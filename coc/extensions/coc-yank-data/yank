8249ed2517d04a984983272ea078e09d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_statistics.rs|1|1|v|rust
	/// Statistics for a differential equation integration
	#[derive(Debug, Clone)]
	pub struct OdeStatistics {
	    /// Number of steps taken
	    pub steps: usize,
	    /// Number of function evaluations
	    pub function_evals: usize,
	    /// Number of jacobian evaluations
	    pub jacobian_evals: usize,
	    /// Number of decompositions performed
	    pub decompositions: usize,
	    /// Number of linear solves performed
	    pub linear_solves: usize,
	    /// Number of accepted steps
	    pub accepts: usize,
	    /// Number of rejected steps
	    pub rejects: usize,
	}
e053062c6bd4a2567eee41407b7d4960|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_status.rs|1|1|v|rust
	#[derive(Debug, PartialEq)]
	pub enum OdeStatus {
	    /// Integration of ODE is not finished.
	    Continue,
	    /// Successful integration of the ODE.
	    Success,
	    /// Integration of ODE haulted due to too many iterations.
	    MaxIters,
	    /// Integration of ODE haulted due to step size being too small.
	    DtLessThanMin,
	    /// Integration of ODE haulted due to unknown/uncatagorized error.
	    Failure,
	}
3c1f98aa386cf7d9a9fc6ef18acb2c75|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_statistics.rs|1|1|v|rust
	/// Statistics for a differential equation integration
	#[derive(Debug, Clone)]
	pub struct OdeStatistics {
	    /// Number of steps taken
	    pub steps: usize,
	    /// Number of function evaluations
	    pub function_evals: usize,
	    /// Number of jacobian evaluations
	    pub jacobian_evals: usize,
	    /// Number of decompositions performed
	    pub decompositions: usize,
	    /// Number of linear solves performed
	    pub linear_solves: usize,
	    /// Number of accepted steps
	    pub accepts: usize,
	    /// Number of rejected steps
	    pub rejects: usize,
	}
	
	impl OdeStatistics {
	    pub fn new() -> Self {
	        OdeStatistics {
	            /// Number of steps taken
	            steps: 0,
	            function_evals: 0,
	            jacobian_evals: 0,
	            decompositions: 0,
	            linear_solves: 0,
	            accepts: 0,
	            rejects: 0,
	        }
	    }
	}
b0f33b06b2fd293291b71e215431f7ba|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_integrator.rs|1|1|v|rust
	//! The `OdeIntegrator` is an object which stores all the information needed
	//! to integrate an ordinary differential equation. This object is created
	//! from the associated `init` method of an `OdeAlgorithm`.
	//!
	//! # Example
	//! Generate an integrator using the DormandPrince5 algorithm.
	//! ```
	//! use cyphus_diffeq::prelude::*;
	//! use ndarray::prelude::*;
	//! let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t:f64|{
	//!     du[0] = u[1];
	//!     du[1] = -u[0];
	//! };
	//! let uinit = array![0.0, 1.0];
	//! let tspan = (0.0, 1.0);
	//! let prob = OdeProblemBuilder::default(dudt, uinit, tspan).build().unwrap();
	//!
	//! let mut integrator = DormandPrince5::init(&prob);
	//! // Step the integrator (returns solution if done, else None)
	//! integrator.step();
	//! // Integrate (returns the solution)
	//! let sol = integrator.integrate();
	//! ```
	
	use crate::ode_algorithm::OdeAlgorithm;
	use crate::ode_solution::OdeSolution;
	use ndarray::prelude::*;
	
	/// Light-weight struct used to keep track of the state of the ODE throughout
	/// integration.
	pub struct OdeIntegrator<F, J, Alg: OdeAlgorithm>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    /// RHS of the ordinary differential equation. Should be of the form:
	    /// dudt = dudt(du, u, t) where `du` is modified in place.
	    pub dudt: F,
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
	    pub dfdu: Option<J>,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// If true, integration is from smaller to larger times.
	    pub forward: bool,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
	
	impl<F, J, Alg> OdeIntegrator<F, J, Alg>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    Alg: OdeAlgorithm,
	{
	    /// Step the ODE to the next state. Returns solution if finished and
	    /// None otherwise.
	    pub fn step(&mut self) -> Option<OdeSolution> {
	        if Alg::step(self) {
	            None
	        } else {
	            Some(self.sol)
	        }
	    }
	    /// Solve the ODE
	    pub fn solve(&mut self) -> OdeSolution {
	        loop {
	            let res = self.step();
	            match res {
	                Some(sol) => return sol,
	                None => {}
	            }
	        }
	    }
	}
	
	/// Common options for differential equations
	#[derive(Clone)]
	pub struct OdeIntegratorOpts {
	    /// Relative tolerance
	    pub reltol: f64,
	    /// Absolute tolerance
	    pub abstol: f64,
	    /// Flag specifying if dense output is requested
	    pub dense: bool,
	    /// Initial step value
	    pub dtstart: f64,
	    /// Maximum allowed step size
	    pub dtmax: f64,
	    /// Maximum number of allowed steps
	    pub max_steps: usize,
	    /// Maximum number of allowed newton iterations.
	    pub max_newt_iter: usize,
	    /// If true, use modern predictive controller (Gustafsson).
	    pub modern_pred: bool,
	    /// Safety factor used in adaptive step selection.
	    pub safe: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
	    pub facr: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
	    pub facl: f64,
	    /// Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot1: f64,
	    /// Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot2: f64,
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
	    /// and Wanner's book.)
	    pub beta: f64,
	    /// The amount to decrease the timestep by if the Newton iterations of an
	    /// implicit method fail.
	    pub fnewt: f64,
	    /// If true, the extrapolated collocation solution is taken as the starting
	    /// value of the Newton iteration.
	    pub use_ext_col: bool,
	    /// If true, the Jacobian will be converted into Hessenberg form.
	    pub hess: bool,
	}
	
	/// Statistics for a differential equation integration
	#[derive(Debug, Clone)]
	pub struct OdeStatistics {
	    /// Number of steps taken
	    pub steps: usize,
	    /// Number of function evaluations
	    pub function_evals: usize,
	    /// Number of jacobian evaluations
	    pub jacobian_evals: usize,
	    /// Number of decompositions performed
	    pub decompositions: usize,
	    /// Number of linear solves performed
	    pub linear_solves: usize,
	    /// Number of accepted steps
	    pub accepts: usize,
	    /// Number of rejected steps
	    pub rejects: usize,
	}
	
	impl OdeStatistics {
	    pub fn new() -> Self {
	        OdeStatistics {
	            /// Number of steps taken
	            steps: 0,
	            function_evals: 0,
	            jacobian_evals: 0,
	            decompositions: 0,
	            linear_solves: 0,
	            accepts: 0,
	            rejects: 0,
	        }
	    }
	}
	
	#[derive(Debug, PartialEq)]
	pub enum OdeStatus {
	    /// Integration of ODE is not finished.
	    Continue,
	    /// Successful integration of the ODE.
	    Success,
	    /// Integration of ODE haulted due to too many iterations.
	    MaxIters,
	    /// Integration of ODE haulted due to step size being too small.
	    DtLessThanMin,
	    /// Integration of ODE haulted due to unknown/uncatagorized error.
	    Failure,
	}
20636d476ba946c286e6dd4cb601aa4e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_solution.rs|5|1|v|rust
	pub struct OdeSolution {
	    pub ts: Vec<f64>,
	    pub us: Vec<Array1<f64>>,
	    pub statistics: OdeStatistics,
	    pub status: OdeStatus,
	    // pub u: F,
	    //pub(crate) cont: Vec<Array1<f64>>,
	}
	
	impl OdeSolution {
	    pub(crate) fn new() -> OdeSolution {
	        OdeSolution {
	            ts: vec![],
	            us: vec![],
	            statistics: OdeStatistics::new(),
	            status: OdeStatus::Continue,
	        }
	    }
	}
85dbb2ab279685403372a94dcf2aef66|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|7|1|V|rust
	    pub status: OdeStatus,
e6a635a953df46a2dae628dc7d571024|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|94|1|v|rust
	/// Common options for differential equations
	#[derive(Clone)]
	pub struct OdeIntegratorOpts {
	    /// Relative tolerance
	    pub reltol: f64,
	    /// Absolute tolerance
	    pub abstol: f64,
	    /// Flag specifying if dense output is requested
	    pub dense: bool,
	    /// Initial step value
	    pub dtstart: f64,
	    /// Maximum allowed step size
	    pub dtmax: f64,
	    /// Maximum number of allowed steps
	    pub max_steps: usize,
	    /// Maximum number of allowed newton iterations.
	    pub max_newt_iter: usize,
	    /// If true, use modern predictive controller (Gustafsson).
	    pub modern_pred: bool,
	    /// Safety factor used in adaptive step selection.
	    pub safe: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
	    pub facr: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
	    pub facl: f64,
	    /// Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot1: f64,
	    /// Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot2: f64,
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
	    /// and Wanner's book.)
	    pub beta: f64,
	    /// The amount to decrease the timestep by if the Newton iterations of an
	    /// implicit method fail.
	    pub fnewt: f64,
	    /// If true, the extrapolated collocation solution is taken as the starting
	    /// value of the Newton iteration.
	    pub use_ext_col: bool,
	    /// If true, the Jacobian will be converted into Hessenberg form.
	    pub hess: bool,
	}
472cab8d148d14b8d05dfd9a723aff91|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|29|1|v|rust
	/// Light-weight struct used to keep track of the state of the ODE throughout
	/// integration.
	pub struct OdeIntegrator<F, J, Alg: OdeAlgorithm>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    /// RHS of the ordinary differential equation. Should be of the form:
	    /// dudt = dudt(du, u, t) where `du` is modified in place.
	    pub dudt: F,
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
	    pub dfdu: Option<J>,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// If true, integration is from smaller to larger times.
	    pub forward: bool,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
	
	impl<F, J, Alg> OdeIntegrator<F, J, Alg>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    Alg: OdeAlgorithm,
	{
	    /// Step the ODE to the next state. Returns solution if finished and
	    /// None otherwise.
	    pub fn step(&mut self) -> Option<OdeSolution> {
	        if Alg::step(self) {
	            None
	        } else {
	            Some(self.sol)
	        }
	    }
	    /// Solve the ODE
	    pub fn solve(&mut self) -> OdeSolution {
	        loop {
	            let res = self.step();
	            match res {
	                Some(sol) => return sol,
	                None => {}
	            }
	        }
	    }
	}
82d055a12d45456ae2fc07668ec0c14d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_integrator.rs|1|1|v|rust
	//! The `OdeIntegrator` is an object which stores all the information needed
	//! to integrate an ordinary differential equation. This object is created
	//! from the associated `init` method of an `OdeAlgorithm`.
	//!
	//! # Example
	//! Generate an integrator using the DormandPrince5 algorithm.
	//! ```
	//! use cyphus_diffeq::prelude::*;
	//! use ndarray::prelude::*;
	//! let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t:f64|{
	//!     du[0] = u[1];
	//!     du[1] = -u[0];
	//! };
	//! let uinit = array![0.0, 1.0];
	//! let tspan = (0.0, 1.0);
	//! let prob = OdeProblemBuilder::default(dudt, uinit, tspan).build().unwrap();
	//!
	//! let mut integrator = DormandPrince5::init(&prob);
	//! // Step the integrator (returns solution if done, else None)
	//! integrator.step();
	//! // Integrate (returns the solution)
	//! let sol = integrator.integrate();
	//! ```
	
	use crate::ode_algorithm::OdeAlgorithm;
	use crate::ode_solution::OdeSolution;
	use ndarray::prelude::*;
	
	
985e80443abe59299bc69d5e194f8aec|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|1|1|v|rust
	//! The `OdeIntegrator` is an object which stores all the information needed
	//! to integrate an ordinary differential equation. This object is created
	//! from the associated `init` method of an `OdeAlgorithm`.
	//!
	//! # Example
	//! Generate an integrator using the DormandPrince5 algorithm.
	//! ```
	//! use cyphus_diffeq::prelude::*;
	//! use ndarray::prelude::*;
	//! let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t:f64|{
	//!     du[0] = u[1];
	//!     du[1] = -u[0];
	//! };
	//! let uinit = array![0.0, 1.0];
	//! let tspan = (0.0, 1.0);
	//! let prob = OdeProblemBuilder::default(dudt, uinit, tspan).build().unwrap();
	//!
	//! let mut integrator = DormandPrince5::init(&prob);
	//! // Step the integrator (returns solution if done, else None)
	//! integrator.step();
	//! // Integrate (returns the solution)
	//! let sol = integrator.integrate();
	//! ```
	
	use crate::ode_algorithm::OdeAlgorithm;
	use crate::ode_solution::OdeSolution;
	use ndarray::prelude::*;
	
	
	
c1b4523bd62dc7098b2d6ddf36cf3112|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_algorithm.rs|1|1|v|rust
	//! The `OdeAlgorithm` trait defines the basic behavior that an algorithm
	//! for solving an ODE must exhibit. Each algorithm must be able to:
	//! - yield default values for all the integrator parameters (`default`),
	//! - yield an associated cache struct used to store specific working variables
	//!   needed for integration of the ODE (`gen_cache`),
	//! - and advance the integrator to the next state (`next`).
	
	use crate::ode_integrator::OdeIntegrator;
	use crate::ode_prob::OdeProblem;
	use ndarray::prelude::*;
	
	pub trait OdeAlgorithm {
	    /// The `Cache` type is the cache struct associated with the algorithm.
	    type Cache;
	    /// Construct an integrator.
	    fn init<F, J>(prob: &OdeProblem<F, J>) -> OdeIntegrator<F, J, Self>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	        Self: Sized;
	    /// Advance the integrator to the next state.
	    fn step<F, J>(integrator: &mut OdeIntegrator<F, J, Self>) -> bool
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	        Self: Sized;
	}
0d261ccbd438f795169440f269e4b156|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode_prob.rs|1|1|v|rust
	use ndarray::prelude::*;
	
	pub enum OdeProblemBuildErr {
	    InvalidIndexPars(usize, usize, usize),
	    Invalid2ndOrderPars(usize, usize),
	    InvlaidMassBw(usize, usize, usize, usize),
	}
	
	impl std::fmt::Debug for OdeProblemBuildErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            OdeProblemBuildErr::InvalidIndexPars(idx1, idx2, idx3) => write!(
	                f,
	                "Invalid index varibles: {}, {}, {}. Sum must be equal to size of the system.",
	                idx1, idx2, idx3
	            ),
	            OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2) => write!(
	                f,
	                "Invalid 2nd order parameters: m1={}, m2={}. Sum must be less that size of system.",
	                m1, m2
	            ),
	            OdeProblemBuildErr::InvlaidMassBw(jl, ju, ml, mu) => write!(
	                f,
	                "Bandwidth of mass matrix cannot be larger than bandwidths of Jacobian: jl = {}, \
	                ju = {}, ml = {}, mu = {}.",
	                jl, ju, ml, mu
	            ),
	        }
	    }
	}
	
	/// Structure for specifying an ordinary differential equation problem of the
	/// form:
	///     ODE:                u'_{i}(t) = f_{i}(u_1,...,u_n, t)
	///     Initial conditions: u'_{i}(t_0) = u_{0,i}
	///     Domain:             t0 <= t <= tf
	#[derive(Clone)]
	pub struct OdeProblem<F, J>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    /// RHS of the ordinary differential equation. Should be of the form:
	    /// dudt = dudt(du, u, t) where `du` is modified in place.
	    pub dudt: F,
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
	    pub dfdu: Option<J>,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Initial conditions.
	    pub uinit: Array1<f64>,
	    /// Initial and final time values.
	    pub tspan: (f64, f64),
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub num_index1_vars: usize,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub num_index2_vars: usize,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub num_index3_vars: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m1: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m2: usize,
	    /// Upper bandwidth of the Jacobian
	    pub jac_ubw: usize,
	    /// Lower bandwidth of the Jacobian
	    pub jac_lbw: usize,
	    /// Upper bandwidth of the mass matrix
	    pub mm_ubw: usize,
	    /// Lower bandwidth of the mass matrix
	    pub mm_lbw: usize,
	}
	
	pub struct OdeProblemBuilder<F, J>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    /// RHS of the ordinary differential equation. Should be of the form:
	    /// dudt = dudt(du, u, t) where `du` is modified in place.
	    pub dudt: F,
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
	    pub dfdu: Option<J>,
	    /// Mass matrix of the system (differential-algebraic system): Mu'(t) = f(u,t).
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Initial conditions.
	    pub uinit: Array1<f64>,
	    /// Initial and final time values.
	    pub tspan: (f64, f64),
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub(crate) num_index1_vars: Option<usize>,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index2_vars: Option<usize>,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index3_vars: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m1: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m2: Option<usize>,
	    /// Upper bandwidth of the Jacobian
	    pub(crate) jac_ubw: Option<usize>,
	    /// Lower bandwidth of the Jacobian
	    pub(crate) jac_lbw: Option<usize>,
	    /// Upper bandwidth of the mass matrix
	    pub(crate) mm_ubw: Option<usize>,
	    /// Lower bandwidth of the mass matrix
	    pub(crate) mm_lbw: Option<usize>,
	}
	
	impl<F, J> OdeProblemBuilder<F, J>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    pub fn default(dudt: F, uinit: Array1<f64>, tspan: (f64, f64)) -> OdeProblemBuilder<F, J> {
	        let n = uinit.shape()[0];
	        OdeProblemBuilder {
	            dudt,
	            dfdu: None,
	            mass_matrix: None,
	            uinit,
	            tspan,
	            num_index1_vars: None,
	            num_index2_vars: None,
	            num_index3_vars: None,
	            m1: None,
	            m2: None,
	            jac_ubw: None,
	            jac_lbw: None,
	            mm_ubw: None,
	            mm_lbw: None,
	        }
	    }
	    /// Add a jacobian to the builder.
	    pub fn with_jac(mut self, dfdu: J) -> OdeProblemBuilder<F, J> {
	        self.dfdu = Some(dfdu);
	        self
	    }
	    /// Add a mass matrix to the builder.
	    pub fn with_mass(mut self, mass_matrix: Array2<f64>) -> OdeProblemBuilder<F, J> {
	        self.mass_matrix = Some(mass_matrix);
	        self
	    }
	    /// Specify the number of index-1 variables of the differential-algebraic
	    /// system. An index-1 problem is one in which the system can be converted
	    /// into an ODE by taking a single derivive of one of the equations.
	    pub fn num_index1_vars(mut self, val: usize) -> OdeProblemBuilder<F, J> {
	        self.num_index1_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-2 variables of the differential-algebraic
	    /// system. An index-2 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of two of the equations.
	    pub fn num_index2_vars(mut self, val: usize) -> OdeProblemBuilder<F, J> {
	        self.num_index2_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-3 variables of the differential-algebraic
	    /// system. An index-3 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of three of the equations.
	    pub fn num_index3_vars(mut self, val: usize) -> OdeProblemBuilder<F, J> {
	        self.num_index3_vars = Some(val);
	        self
	    }
	    /// Specify the second order parameters m1, and m2 of the problem. These
	    /// are defined such that u'[i] = u[i+m2] for i = 1,...,m1 which is a
	    /// structure that often occurs for second-order differential equations.
	    pub fn second_order_params(mut self, val: (usize, usize)) -> OdeProblemBuilder<F, J> {
	        self.m1 = Some(val.0);
	        self.m2 = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the Jacobian.
	    pub fn jac_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<F, J> {
	        self.jac_lbw = Some(val.0);
	        self.jac_ubw = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the mass matrix.
	    pub fn mass_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<F, J> {
	        self.mm_lbw = Some(val.0);
	        self.mm_ubw = Some(val.1);
	        self
	    }
	    /// Try to build the OdeProblem.
	    pub fn build(self) -> Result<OdeProblem<F, J>, OdeProblemBuildErr> {
	        let n = self.uinit.shape()[0];
	
	        let nind1 = self.num_index1_vars.unwrap_or(n);
	        let nind2 = self.num_index2_vars.unwrap_or(0);
	        let nind3 = self.num_index3_vars.unwrap_or(0);
	
	        if nind1 + nind2 + nind3 != n {
	            return Err(OdeProblemBuildErr::InvalidIndexPars(nind1, nind2, nind3));
	        }
	
	        let m1 = self.m1.unwrap_or(0);
	        let mut m2 = self.m1.unwrap_or(0);
	        if m1 == 0 {
	            m2 = n;
	        } else if m2 == 0 {
	            m2 = m1;
	        }
	        if m1 + m2 > n {
	            return Err(OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2));
	        }
	
	        let mut jac_ubw = self.jac_ubw.unwrap_or(n);
	        let mut jac_lbw = self.jac_lbw.unwrap_or(n);
	
	        let mm_ubw = self.mm_ubw.unwrap_or(n);
	        let mm_lbw = self.mm_lbw.unwrap_or(n);
	
	        let nm1 = n - m1;
	        let jband = jac_lbw < nm1;
	
	        if !jband {
	            jac_ubw = nm1;
	            jac_lbw = nm1;
	        }
	
	        if !self.mass_matrix.is_none() {
	            if mm_lbw > jac_lbw || mm_ubw > jac_ubw {
	                return Err(OdeProblemBuildErr::InvlaidMassBw(
	                    jac_lbw, jac_ubw, mm_lbw, mm_ubw,
	                ));
	            }
	        }
	
	        Ok(OdeProblem {
	            dudt: self.dudt,
	            dfdu: self.dfdu,
	            mass_matrix: self.mass_matrix,
	            uinit: self.uinit,
	            tspan: self.tspan,
	            num_index1_vars: nind1,
	            num_index2_vars: nind2,
	            num_index3_vars: nind3,
	            m1,
	            m2,
	            jac_ubw,
	            jac_lbw,
	            mm_ubw,
	            mm_lbw,
	        })
	    }
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_construction() {
	        let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64| {
	            du[0] = u[1];
	            du[1] = -u[0];
	        };
	        let dfdu = |mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64| {
	            df[[0, 0]] = 0.0;
	            df[[0, 1]] = 0.0;
	            df[[1, 0]] = -1.0;
	            df[[1, 1]] = 0.0;
	        };
	
	        let uinit = array![0.0, 1.0];
	        let tspan = (0.0, 1.0);
	        let mass_matrix = Array2::<f64>::zeros((2, 2));
	
	        let prob = OdeProblemBuilder::default(dudt, uinit.clone(), tspan)
	            .with_jac(dfdu)
	            .with_mass(mass_matrix)
	            .build()
	            .unwrap();
	
	        let mut u = array![0.0, 1.0];
	        let mut du = Array1::<f64>::zeros(2);
	        let mut df = Array2::<f64>::zeros((2, 2));
	
	        (prob.dudt)(du.view_mut(), u.view(), 1.0);
	        (prob.dfdu.unwrap())(df.view_mut(), u.view(), 1.0);
	
	        println!("du = {:?}", &du);
	        println!("df = {:?}", &df);
	    }
	}
8c62a605855d72e1b93217055d24d1aa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|9|1|V|rust
	pub mod ode_status;
429c1f7450eee9216303b9d575f4e6b5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|8|1|V|rust
	pub mod ode_statistics;
84c8817a0b4bf34eadae7b3e09816c37|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|7|1|V|rust
	pub mod ode_solution;
a066b3af3db17f36263da66e0c221141|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|6|1|V|rust
	pub mod ode_prob;
cc2ae2d06ecaba9330c6411b3694e70c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|5|1|V|rust
	//pub mod ode_options;
f1621ac77853ddce3fef435ae4507219|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|4|1|V|rust
	pub mod ode_integrator;
4f2e98300348eb0260865c0977ef2a1c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|3|1|V|rust
	pub mod ode_algorithm;
e9b0e8b9e56b23cd20bea5beec0a8846|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|8|5|v|rust
	crate::ode_
7dcec40b5a2935f0bf616895eb462748|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|9|5|v|rust
	crate::ode_prob
b51a04be1ec1fab910038cfe19f8ae45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|6|1|V|rust
	    pub statistics: OdeStatistics,
6ed9111257ebe90828d02c5e1f3a728c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|15|13|V|rust
	            statistics: OdeStatistics::new(),
d16fab919ce9d67d43e7de3ed837bb1c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|15|13|V|rust
	            status: OdeStatus::Continue,
2def0aaa8a9eb4e7fb63982e430016f4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|7|5|V|rust
	    //pub(crate) cont: Vec<Array1<f64>>,
82900d7a0f52cef1da9039f71e99377f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|9|1|v|rust
	impl OdeSolution {
	    pub(crate) fn new() -> OdeSolution {
	        OdeSolution {
	            ts: vec![],
	            us: vec![],
	        }
	    }
	}
b1ac69daaf9fb0dd6f6f5d8cb258d380|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|6|5|V|rust
	    pub u: F,
64605c688421eac33245d87e2ab8ec63|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|6|1|V|rust
	use crate::ode_algorithm::OdeAlgorithm;
fedbe0f42f9f43165029d1b7098ba0cc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|6|1|V|rust
	use crate::ode_integrator::{OdeIntegrator, OdeIntegratorOpts};
3c80ec71e639abbe8857c5e98579b781|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|6|1|V|rust
	use crate::ode_prob::OdeProblem;
205e6bc36eda84e7b6d8f978f6b0942d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|6|12|v|rust
	ode_solution::OdeSolution
20b8257fb71bcc536dfc938d86437e21|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|57|19|v|rust
	&self, 
752b0b7950233c722956687894575e30|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|136|29|v|rust
	alg: &DormandPrince5, 
e91da4b5a144d40a567c5882d6a7cb13|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|63|46|v|rust
	&self,
30451820e2dddad9524ae7b41312d47f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|63|9|V|rust
	        let cache = DormandPrince5Cache::new( &prob);
bfe99481f74f177961ef5c860823c772|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|83|9|V|rust
	        let sol = OdeSolution{
4e1ddba1c31545ee09fb38ae1fd79346|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|83|9|V|rust
	        }
b0f6ff57ec874c2e589acff3c1ed3b1a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/dense.rs|3|12|v|rust
	ode_integrator
0b8e04bb61ccb774094e5e95bccb0f70|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/dense.rs|2|1|V|rust
	use super::DormandPrince5Cache;
af63ce0c38f5ac029ebb444ffabc0cbd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|2|15|v|rust
	_integrator
cc8cc36dd973b53835a6016b9ad40413|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/step.rs|10|1|v|rust
	impl DormandPrince5 {
	    /// Prepare the integrator and integrator.cache for the next DormandPrince5 step.
	    #[allow(dead_code)]
	    pub(super) fn prepare_next_step<F, J>(
	        &self,
	        t_err: f64,
	        integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>,
	    ) where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = integrator.u.len();
	        // computation of hnew
	        let fac11 = t_err.powf(self.alpha);
	        // Lund-stabilization
	        let mut fac = fac11 / integrator.cache.facold.powf(self.beta);
	        // we require minNextPrevStepRatio <= hnew/h <= m_maxNextPrevStepRatio
	        fac = self.fac2.max(self.fac2.min(fac / self.safe));
	        let mut dtnew = integrator.dt / fac;
	
	        if t_err <= 1.0 {
	            /* step accepted */
	
	            integrator.cache.facold = t_err.max(1e-4);
	            integrator.sol.statistics.accepts += 1;
	
	            /* stiffness detection */
	            if integrator.sol.statistics.accepts % self.max_stiff == 0
	                || integrator.cache.n_stiff > 0
	            {
	                let mut stnum = 0.0;
	                let mut stden = 0.0;
	                for i in 0..n {
	                    let mut sqr = integrator.cache.k2[i] - integrator.cache.k6[i];
	                    stnum += sqr * sqr;
	                    sqr = integrator.cache.unew[i] - integrator.cache.ustiff[i];
	                    stden += sqr * sqr;
	                }
	                if stden > 0.0 {
	                    integrator.cache.dtlamb = integrator.dt * (stnum / stden).sqrt();
	                }
	                if integrator.cache.dtlamb > 3.25 {
	                    integrator.cache.n_nonstiff = 0;
	                    integrator.cache.n_stiff += 1;
	                    if integrator.cache.n_stiff == 15 {
	                        //throw DormandPrince5Stiff(integrator.t);
	                    }
	                } else {
	                    integrator.cache.n_nonstiff += 1;
	                    if integrator.cache.n_nonstiff == 6 {
	                        integrator.cache.n_stiff = 0;
	                    }
	                }
	            }
	            if self.dense {
	                self.prepare_dense(integrator);
	            }
	
	            integrator.cache.du.assign(&integrator.cache.dunew);
	            integrator.u.assign(&integrator.cache.unew);
	            integrator.tprev = integrator.t;
	            integrator.t += integrator.dt;
	
	            if dtnew.abs() > self.dtmax {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 }) * self.dtmax;
	            }
	            if integrator.cache.reject {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 })
	                    * dtnew.abs().min(integrator.dt.abs());
	            }
	
	            integrator.cache.reject = false;
	        } else {
	            /* step rejected */
	            dtnew = integrator.dt / self.fac1.min(fac11 / self.safe);
	            integrator.cache.reject = true;
	            if integrator.sol.statistics.accepts >= 1 {
	                integrator.sol.statistics.rejects += 1;
	            }
	            integrator.cache.last = false;
	        }
	
	        integrator.dtprev = integrator.dt;
	        integrator.dt = dtnew;
	    }
	    #[allow(dead_code)]
	    pub fn init<F, J>(&self, prob: OdeProblem<F, J>) -> OdeIntegrator<F, J, DormandPrince5Cache>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut cache = DormandPrince5Cache::new(&self, &prob);
	
	        if self.dtmax != 0.0 {
	            cache.dtmax = self.dtmax;
	        }
	        let forward = prob.tspan.1 > prob.tspan.0;
	        let u = prob.uinit.clone();
	        let t = prob.tspan.0;
	        let dt = self.dtstart;
	        let uprev = prob.uinit.clone();
	        let tprev = prob.tspan.1;
	
	        OdeIntegrator::<F, J, DormandPrince5Cache> {
	            prob,
	            u,
	            t,
	            dt,
	            uprev,
	            tprev,
	            dtprev: self.dtstart,
	            forward,
	            cache,
	            sol: OdeSolution::new(),
	        }
	    }
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
	    pub fn step<F, J>(&self, integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>)
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        loop {
	            self.compute_stages(integrator);
	            let err = self.error(integrator);
	            self.prepare_next_step(err, integrator);
	            if !integrator.cache.reject {
	                break;
	            }
	            if integrator.dt.abs() <= integrator.t.abs() * f64::EPSILON {
	                integrator.sol.status = OdeStatus::DtLessThanMin;
	                return;
	            }
	        }
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	        integrator.sol.statistics.steps += 1;
	    }
	    /// Solve an ODE problem using the DormandPrince5 algorithm
	    pub fn solve<F, J>(&self, prob: OdeProblem<F, J>) -> OdeSolution
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut integrator = self.init(prob);
	
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	
	        (integrator.prob.dudt)(
	            integrator.cache.du.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	
	        let tdir = if integrator.forward { 1.0 } else { -1.0 };
	
	        while !integrator.cache.last {
	            if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
	            self.step(&mut integrator);
	            if integrator.sol.statistics.steps > self.max_steps {
	                integrator.sol.status = OdeStatus::MaxIters;
	                return integrator.sol;
	                //throw std::runtime_error("too many steps..");
	            }
	            if integrator.sol.status != OdeStatus::Continue {
	                return integrator.sol;
	            }
	        }
	        integrator.sol
	    }
	}
73e6ccd951d69dd8f26c7cabd017d09f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|196|5|v|rust
	#[allow(dead_code)]
	    pub fn init<F, J>(&self, prob: OdeProblem<F, J>) -> OdeIntegrator<F, J, DormandPrince5Cache>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut cache = DormandPrince5Cache::new(&self, &prob);
	
	        if self.dtmax != 0.0 {
	            cache.dtmax = self.dtmax;
	        }
	        let forward = prob.tspan.1 > prob.tspan.0;
	        let u = prob.uinit.clone();
	        let t = prob.tspan.0;
	        let dt = self.dtstart;
	        let uprev = prob.uinit.clone();
	        let tprev = prob.tspan.1;
	
	        OdeIntegrator::<F, J, DormandPrince5Cache> {
	            prob,
	            u,
	            t,
	            dt,
	            uprev,
	            tprev,
	            dtprev: self.dtstart,
	            forward,
	            cache,
	            sol: OdeSolution::new(),
	        }
	    }
2542b7b2fdd20f65ba0e142f022e742e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|258|1|v|rust
	pub(crate) struct DormandPrince5Cache {
	    n_stiff: usize,
	    n_nonstiff: usize,
	    reject: bool,
	    last: bool,
	    facold: f64, // previous ratio of dtnew/dt
	    dtlamb: f64,
	    k2: Array1<f64>,
	    k3: Array1<f64>,
	    k4: Array1<f64>,
	    k5: Array1<f64>,
	    k6: Array1<f64>,
	    rcont1: Array1<f64>,
	    rcont2: Array1<f64>,
	    rcont3: Array1<f64>,
	    rcont4: Array1<f64>,
	    rcont5: Array1<f64>,
	    unew: Array1<f64>,
	    du: Array1<f64>,
	    dunew: Array1<f64>,
	    uerr: Array1<f64>,
	    ustiff: Array1<f64>,
	}
	
	impl DormandPrince5Cache {
	    pub(crate) fn new<F, J>(prob: &OdeProblem<F, J>) -> DormandPrince5Cache
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = prob.uinit.len();
	
	        DormandPrince5Cache {
	            n_stiff: 0,
	            n_nonstiff: 0,
	            reject: false,
	            last: false,
	            facold: 0.0, // previous ratio of dtnew/dt
	            dtlamb: 0.0,
	            k2: Array1::<f64>::zeros(n),
	            k3: Array1::<f64>::zeros(n),
	            k4: Array1::<f64>::zeros(n),
	            k5: Array1::<f64>::zeros(n),
	            k6: Array1::<f64>::zeros(n),
	            rcont1: Array1::<f64>::zeros(n),
	            rcont2: Array1::<f64>::zeros(n),
	            rcont3: Array1::<f64>::zeros(n),
	            rcont4: Array1::<f64>::zeros(n),
	            rcont5: Array1::<f64>::zeros(n),
	            unew: Array1::<f64>::zeros(n),
	            du: Array1::<f64>::zeros(n),
	            dunew: Array1::<f64>::zeros(n),
	            uerr: Array1::<f64>::zeros(n),
	            ustiff: Array1::<f64>::zeros(n),
	        }
	    }
	}
4e994c6270d026fe548750a62c8cedc1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|10|1|v|rust
	pub struct DormandPrince5;
	
	impl DormandPrince5 {
	    // Butcher c_i's
	    pub(crate) const C2: f64 = 0.2;
	    pub(crate) const C3: f64 = 0.3;
	    pub(crate) const C4: f64 = 0.8;
	    pub(crate) const C5: f64 = 8.0 / 9.0;
	    // But_ij's
	    pub(crate) const A21: f64 = 0.2;
	    pub(crate) const A31: f64 = 3.0 / 40.0;
	    pub(crate) const A32: f64 = 9.0 / 40.0;
	    pub(crate) const A41: f64 = 44.0 / 45.0;
	    pub(crate) const A42: f64 = -56.0 / 15.0;
	    pub(crate) const A43: f64 = 32.0 / 9.0;
	    pub(crate) const A51: f64 = 19372.0 / 6561.0;
	    pub(crate) const A52: f64 = -25360.0 / 2187.0;
	    pub(crate) const A53: f64 = 64448.0 / 6561.0;
	    pub(crate) const A54: f64 = -212.0 / 729.0;
	    pub(crate) const A61: f64 = 9017.0 / 3168.0;
	    pub(crate) const A62: f64 = -355.0 / 33.0;
	    pub(crate) const A63: f64 = 46732.0 / 5247.0;
	    pub(crate) const A64: f64 = 49.0 / 176.0;
	    pub(crate) const A65: f64 = -5103.0 / 18656.0;
	    // But_i's: y1 = y0 + h * (b1 * k1 + ... + bs * ks)
	    pub(crate) const A71: f64 = 35.0 / 384.0;
	    pub(crate) const A73: f64 = 500.0 / 1113.0;
	    pub(crate) const A74: f64 = 125.0 / 192.0;
	    pub(crate) const A75: f64 = -2187.0 / 6784.0;
	    pub(crate) const A76: f64 = 11.0 / 84.0;
	    // Errimation constants: b_i^* - b_i
	    pub(crate) const E1: f64 = 71.0 / 57600.0;
	    pub(crate) const E3: f64 = -71.0 / 16695.0;
	    pub(crate) const E4: f64 = 71.0 / 1920.0;
	    pub(crate) const E5: f64 = -17253.0 / 339200.0;
	    pub(crate) const E6: f64 = 22.0 / 525.0;
	    pub(crate) const E7: f64 = -1.0 / 40.0;
	    // Cons output parameters
	    pub(crate) const D1: f64 = -12715105075.0 / 11282082432.0;
	    pub(crate) const D3: f64 = 87487479700.0 / 32700410799.0;
	    pub(crate) const D4: f64 = -10690763975.0 / 1880347072.0;
	    pub(crate) const D5: f64 = 701980252875.0 / 199316789632.0;
	    pub(crate) const D6: f64 = -1453857185.0 / 822651844.0;
	    pub(crate) const D7: f64 = 69997945.0 / 29380423.0;
	}
	
	impl OdeAlgorithm for DormandPrince5 {
	    type Cache = DormandPrince5Cache;
	    fn init<F, J>(prob: &OdeProblem<F, J>) -> OdeIntegrator<F, J, Self>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	        Self: Sized,
	    {
	        let cache = DormandPrince5Cache::new(&prob);
	        let opts = OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: prob.tspan.1 - prob.tspan.0,
	            max_steps: 100000,
	            beta: 0.04,
	            max_newt_iter: 0,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 0.2,
	            facl: 10.0,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	        };
	
	        OdeIntegrator {
	            dudt: prob.dudt,
	            dfdu: prob.dfdu,
	            mass_matrix: prob.mass_matrix,
	            u: prob.uinit.clone(),
	            t: prob.tspan.0,
	            dt: 1e-6,
	            uprev: prob.uinit.clone(),
	            tprev: prob.tspan.0,
	            dtprev: 1e-6,
	            forward: prob.tspan.1 > prob.tspan.0,
	            sol: OdeSolution::new(),
	            opts,
	            cache,
	        }
	    }
	    /// Advance the integrator to the next state.
	    fn step<F, J>(integrator: &mut OdeIntegrator<F, J, Self>) -> bool
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	        Self: Sized,
	    {
	        false
	    }
	}
	
	impl DormandPrince5 {
	    /// Prepare the integrator and integrator.cache for the next DormandPrince5 step.
	    #[allow(dead_code)]
	    pub(super) fn prepare_next_step<F, J>(
	        &self,
	        t_err: f64,
	        integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>,
	    ) where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = integrator.u.len();
	        // computation of hnew
	        let fac11 = t_err.powf(self.alpha);
	        // Lund-stabilization
	        let mut fac = fac11 / integrator.cache.facold.powf(self.beta);
	        // we require minNextPrevStepRatio <= hnew/h <= m_maxNextPrevStepRatio
	        fac = self.fac2.max(self.fac2.min(fac / self.safe));
	        let mut dtnew = integrator.dt / fac;
	
	        if t_err <= 1.0 {
	            /* step accepted */
	
	            integrator.cache.facold = t_err.max(1e-4);
	            integrator.sol.statistics.accepts += 1;
	
	            /* stiffness detection */
	            if integrator.sol.statistics.accepts % self.max_stiff == 0
	                || integrator.cache.n_stiff > 0
	            {
	                let mut stnum = 0.0;
	                let mut stden = 0.0;
	                for i in 0..n {
	                    let mut sqr = integrator.cache.k2[i] - integrator.cache.k6[i];
	                    stnum += sqr * sqr;
	                    sqr = integrator.cache.unew[i] - integrator.cache.ustiff[i];
	                    stden += sqr * sqr;
	                }
	                if stden > 0.0 {
	                    integrator.cache.dtlamb = integrator.dt * (stnum / stden).sqrt();
	                }
	                if integrator.cache.dtlamb > 3.25 {
	                    integrator.cache.n_nonstiff = 0;
	                    integrator.cache.n_stiff += 1;
	                    if integrator.cache.n_stiff == 15 {
	                        //throw DormandPrince5Stiff(integrator.t);
	                    }
	                } else {
	                    integrator.cache.n_nonstiff += 1;
	                    if integrator.cache.n_nonstiff == 6 {
	                        integrator.cache.n_stiff = 0;
	                    }
	                }
	            }
	            if self.dense {
	                self.prepare_dense(integrator);
	            }
	
	            integrator.cache.du.assign(&integrator.cache.dunew);
	            integrator.u.assign(&integrator.cache.unew);
	            integrator.tprev = integrator.t;
	            integrator.t += integrator.dt;
	
	            if dtnew.abs() > self.dtmax {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 }) * self.dtmax;
	            }
	            if integrator.cache.reject {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 })
	                    * dtnew.abs().min(integrator.dt.abs());
	            }
	
	            integrator.cache.reject = false;
	        } else {
	            /* step rejected */
	            dtnew = integrator.dt / self.fac1.min(fac11 / self.safe);
	            integrator.cache.reject = true;
	            if integrator.sol.statistics.accepts >= 1 {
	                integrator.sol.statistics.rejects += 1;
	            }
	            integrator.cache.last = false;
	        }
	
	        integrator.dtprev = integrator.dt;
	        integrator.dt = dtnew;
	    }
	    
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
	    pub fn step<F, J>(&self, integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>)
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        loop {
	            self.compute_stages(integrator);
	            let err = self.error(integrator);
	            self.prepare_next_step(err, integrator);
	            if !integrator.cache.reject {
	                break;
	            }
	            if integrator.dt.abs() <= integrator.t.abs() * f64::EPSILON {
	                integrator.sol.status = OdeStatus::DtLessThanMin;
	                return;
	            }
	        }
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	        integrator.sol.statistics.steps += 1;
	    }
	    /// Solve an ODE problem using the DormandPrince5 algorithm
	    pub fn solve<F, J>(&self, prob: OdeProblem<F, J>) -> OdeSolution
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut integrator = self.init(prob);
	
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	
	        (integrator.prob.dudt)(
	            integrator.cache.du.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	
	        let tdir = if integrator.forward { 1.0 } else { -1.0 };
	
	        while !integrator.cache.last {
	            if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
	            self.step(&mut integrator);
	            if integrator.sol.statistics.steps > self.max_steps {
	                integrator.sol.status = OdeStatus::MaxIters;
	                return integrator.sol;
	                //throw std::runtime_error("too many steps..");
	            }
	            if integrator.sol.status != OdeStatus::Continue {
	                return integrator.sol;
	            }
	        }
	        integrator.sol
	    }
	}
e298a0dfa345648cd1d7724c3997db6f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|7|1|v|rust
	use crate::ode::*;
	use ndarray::prelude::*;
	
	
1d0abc1eab1fdd58f70ec33ecc62afbd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|117|9|v|rust
	let n = integrator.u.len();
c711ca3218372c8a41d7a38e25871d02|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|117|1|V|rust
	        let n = integrator.u.len();
	        // computation of hnew
	        let fac11 = t_err.powf(self.alpha);
	        // Lund-stabilization
	        let mut fac = fac11 / integrator.cache.facold.powf(self.beta);
	        // we require minNextPrevStepRatio <= hnew/h <= m_maxNextPrevStepRatio
	        fac = self.fac2.max(self.fac2.min(fac / self.safe));
	        let mut dtnew = integrator.dt / fac;
	
	        if t_err <= 1.0 {
	            /* step accepted */
	
	            integrator.cache.facold = t_err.max(1e-4);
	            integrator.sol.statistics.accepts += 1;
	
	            /* stiffness detection */
	            if integrator.sol.statistics.accepts % self.max_stiff == 0
	                || integrator.cache.n_stiff > 0
	            {
	                let mut stnum = 0.0;
	                let mut stden = 0.0;
	                for i in 0..n {
	                    let mut sqr = integrator.cache.k2[i] - integrator.cache.k6[i];
	                    stnum += sqr * sqr;
	                    sqr = integrator.cache.unew[i] - integrator.cache.ustiff[i];
	                    stden += sqr * sqr;
	                }
	                if stden > 0.0 {
	                    integrator.cache.dtlamb = integrator.dt * (stnum / stden).sqrt();
	                }
	                if integrator.cache.dtlamb > 3.25 {
	                    integrator.cache.n_nonstiff = 0;
	                    integrator.cache.n_stiff += 1;
	                    if integrator.cache.n_stiff == 15 {
	                        //throw DormandPrince5Stiff(integrator.t);
	                    }
	                } else {
	                    integrator.cache.n_nonstiff += 1;
	                    if integrator.cache.n_nonstiff == 6 {
	                        integrator.cache.n_stiff = 0;
	                    }
	                }
	            }
	            if self.dense {
	                self.prepare_dense(integrator);
	            }
	
	            integrator.cache.du.assign(&integrator.cache.dunew);
	            integrator.u.assign(&integrator.cache.unew);
	            integrator.tprev = integrator.t;
	            integrator.t += integrator.dt;
	
	            if dtnew.abs() > self.dtmax {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 }) * self.dtmax;
	            }
	            if integrator.cache.reject {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 })
	                    * dtnew.abs().min(integrator.dt.abs());
	            }
	
	            integrator.cache.reject = false;
	        } else {
	            /* step rejected */
	            dtnew = integrator.dt / self.fac1.min(fac11 / self.safe);
	            integrator.cache.reject = true;
	            if integrator.sol.statistics.accepts >= 1 {
	                integrator.sol.statistics.rejects += 1;
	            }
	            integrator.cache.last = false;
	        }
	
	        integrator.dtprev = integrator.dt;
	        integrator.dt = dtnew;
1e12eb92624ede16d96ba74b410688fa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|175|9|V|rust
	        false
a15f8c535a677e68ee5a5f9fe258a9aa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|106|1|v|rust
	impl DormandPrince5 {
	    /// Prepare the integrator and integrator.cache for the next DormandPrince5 step.
	    #[allow(dead_code)]
	    pub(super) fn prepare_next_step<F, J>(
	        &self,
	        t_err: f64,
	        integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>,
	    ) where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = integrator.u.len();
	        // computation of hnew
	        let fac11 = t_err.powf(self.alpha);
	        // Lund-stabilization
	        let mut fac = fac11 / integrator.cache.facold.powf(self.beta);
	        // we require minNextPrevStepRatio <= hnew/h <= m_maxNextPrevStepRatio
	        fac = self.fac2.max(self.fac2.min(fac / self.safe));
	        let mut dtnew = integrator.dt / fac;
	
	        if t_err <= 1.0 {
	            /* step accepted */
	
	            integrator.cache.facold = t_err.max(1e-4);
	            integrator.sol.statistics.accepts += 1;
	
	            /* stiffness detection */
	            if integrator.sol.statistics.accepts % self.max_stiff == 0
	                || integrator.cache.n_stiff > 0
	            {
	                let mut stnum = 0.0;
	                let mut stden = 0.0;
	                for i in 0..n {
	                    let mut sqr = integrator.cache.k2[i] - integrator.cache.k6[i];
	                    stnum += sqr * sqr;
	                    sqr = integrator.cache.unew[i] - integrator.cache.ustiff[i];
	                    stden += sqr * sqr;
	                }
	                if stden > 0.0 {
	                    integrator.cache.dtlamb = integrator.dt * (stnum / stden).sqrt();
	                }
	                if integrator.cache.dtlamb > 3.25 {
	                    integrator.cache.n_nonstiff = 0;
	                    integrator.cache.n_stiff += 1;
	                    if integrator.cache.n_stiff == 15 {
	                        //throw DormandPrince5Stiff(integrator.t);
	                    }
	                } else {
	                    integrator.cache.n_nonstiff += 1;
	                    if integrator.cache.n_nonstiff == 6 {
	                        integrator.cache.n_stiff = 0;
	                    }
	                }
	            }
	            if self.dense {
	                self.prepare_dense(integrator);
	            }
	
	            integrator.cache.du.assign(&integrator.cache.dunew);
	            integrator.u.assign(&integrator.cache.unew);
	            integrator.tprev = integrator.t;
	            integrator.t += integrator.dt;
	
	            if dtnew.abs() > self.dtmax {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 }) * self.dtmax;
	            }
	            if integrator.cache.reject {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 })
	                    * dtnew.abs().min(integrator.dt.abs());
	            }
	
	            integrator.cache.reject = false;
	        } else {
	            /* step rejected */
	            dtnew = integrator.dt / self.fac1.min(fac11 / self.safe);
	            integrator.cache.reject = true;
	            if integrator.sol.statistics.accepts >= 1 {
	                integrator.sol.statistics.rejects += 1;
	            }
	            integrator.cache.last = false;
	        }
	
	        integrator.dtprev = integrator.dt;
	        integrator.dt = dtnew;
	    }
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
	    pub fn step<F, J>(&self, integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>)
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        loop {
	            self.compute_stages(integrator);
	            let err = self.error(integrator);
	            self.prepare_next_step(err, integrator);
	            if !integrator.cache.reject {
	                break;
	            }
	            if integrator.dt.abs() <= integrator.t.abs() * f64::EPSILON {
	                integrator.sol.status = OdeStatus::DtLessThanMin;
	                return;
	            }
	        }
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	        integrator.sol.statistics.steps += 1;
	    }
	    /// Solve an ODE problem using the DormandPrince5 algorithm
	    pub fn solve<F, J>(&self, prob: OdeProblem<F, J>) -> OdeSolution
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut integrator = self.init(prob);
	
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	
	        (integrator.prob.dudt)(
	            integrator.cache.du.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	
	        let tdir = if integrator.forward { 1.0 } else { -1.0 };
	
	        while !integrator.cache.last {
	            if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
	            self.step(&mut integrator);
	            if integrator.sol.statistics.steps > self.max_steps {
	                integrator.sol.status = OdeStatus::MaxIters;
	                return integrator.sol;
	                //throw std::runtime_error("too many steps..");
	            }
	            if integrator.sol.status != OdeStatus::Continue {
	                return integrator.sol;
	            }
	        }
	        integrator.sol
	    }
	}
3b03917ce41f31869fd37df52df3ba85|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|109|1|v|rust
	    pub(super) fn prepare_next_step<F, J>(
34fa728176985e6579519319d0b52f08|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|107|1|V|rust
	    /// Prepare the integrator and integrator.cache for the next DormandPrince5 step.
	    #[allow(dead_code)]
	
	        &self,
	        t_err: f64,
	        integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>,
	    ) where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = integrator.u.len();
	        // computation of hnew
	        let fac11 = t_err.powf(self.alpha);
	        // Lund-stabilization
	        let mut fac = fac11 / integrator.cache.facold.powf(self.beta);
	        // we require minNextPrevStepRatio <= hnew/h <= m_maxNextPrevStepRatio
	        fac = self.fac2.max(self.fac2.min(fac / self.safe));
	        let mut dtnew = integrator.dt / fac;
	
	        if t_err <= 1.0 {
	            /* step accepted */
	
	            integrator.cache.facold = t_err.max(1e-4);
	            integrator.sol.statistics.accepts += 1;
	
	            /* stiffness detection */
	            if integrator.sol.statistics.accepts % self.max_stiff == 0
	                || integrator.cache.n_stiff > 0
	            {
	                let mut stnum = 0.0;
	                let mut stden = 0.0;
	                for i in 0..n {
	                    let mut sqr = integrator.cache.k2[i] - integrator.cache.k6[i];
	                    stnum += sqr * sqr;
	                    sqr = integrator.cache.unew[i] - integrator.cache.ustiff[i];
	                    stden += sqr * sqr;
	                }
	                if stden > 0.0 {
	                    integrator.cache.dtlamb = integrator.dt * (stnum / stden).sqrt();
	                }
	                if integrator.cache.dtlamb > 3.25 {
	                    integrator.cache.n_nonstiff = 0;
	                    integrator.cache.n_stiff += 1;
	                    if integrator.cache.n_stiff == 15 {
	                        //throw DormandPrince5Stiff(integrator.t);
	                    }
	                } else {
	                    integrator.cache.n_nonstiff += 1;
	                    if integrator.cache.n_nonstiff == 6 {
	                        integrator.cache.n_stiff = 0;
	                    }
	                }
	            }
	            if self.dense {
	                self.prepare_dense(integrator);
	            }
	
	            integrator.cache.du.assign(&integrator.cache.dunew);
	            integrator.u.assign(&integrator.cache.unew);
	            integrator.tprev = integrator.t;
	            integrator.t += integrator.dt;
	
	            if dtnew.abs() > self.dtmax {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 }) * self.dtmax;
	            }
	            if integrator.cache.reject {
	                dtnew = (if integrator.forward { 1.0 } else { -1.0 })
	                    * dtnew.abs().min(integrator.dt.abs());
	            }
	
	            integrator.cache.reject = false;
	        } else {
	            /* step rejected */
	            dtnew = integrator.dt / self.fac1.min(fac11 / self.safe);
	            integrator.cache.reject = true;
	            if integrator.sol.statistics.accepts >= 1 {
	                integrator.sol.statistics.rejects += 1;
	            }
	            integrator.cache.last = false;
	        }
	
	        integrator.dtprev = integrator.dt;
	        integrator.dt = dtnew;
	    }
ef83afaf42789be126ab7e34dd774de3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|10|46|v|rust
	DormandPrince5Cache
3e4669d9382d2b4919d5f8c178aa73c5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|90|1|V|rust
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
	    pub fn step<F, J>(&self, integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>)
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        loop {
	            self.compute_stages(integrator);
	            let err = self.error(integrator);
	            self.prepare_next_step(err, integrator);
	            if !integrator.cache.reject {
	                break;
	            }
	            if integrator.dt.abs() <= integrator.t.abs() * f64::EPSILON {
	                integrator.sol.status = OdeStatus::DtLessThanMin;
	                return;
	            }
	        }
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	        integrator.sol.statistics.steps += 1;
	    }
	    /// Solve an ODE problem using the DormandPrince5 algorithm
	    pub fn solve<F, J>(&self, prob: OdeProblem<F, J>) -> OdeSolution
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut integrator = self.init(prob);
	
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	
	        (integrator.prob.dudt)(
	            integrator.cache.du.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	
	        let tdir = if integrator.forward { 1.0 } else { -1.0 };
	
	        while !integrator.cache.last {
	            if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
	            self.step(&mut integrator);
	            if integrator.sol.statistics.steps > self.max_steps {
	                integrator.sol.status = OdeStatus::MaxIters;
	                return integrator.sol;
	                //throw std::runtime_error("too many steps..");
	            }
	            if integrator.sol.status != OdeStatus::Continue {
	                return integrator.sol;
	            }
	        }
	        integrator.sol
	    }
71a0476fa721dfff1e6b0e033313f449|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|114|9|v|rust
	loop {
	            self.compute_stages(integrator);
	            let err = self.error(integrator);
	            self.prepare_next_step(err, integrator);
	            if !integrator.cache.reject {
	                break;
	            }
	            if integrator.dt.abs() <= integrator.t.abs() * f64::EPSILON {
	                integrator.sol.status = OdeStatus::DtLessThanMin;
	                return;
	            }
	        }
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	        integrator.sol.statistics.steps += 1;
c5774d31bd3410c6b74f082b98a0d5b6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|125|1|V|rust
	    #[allow(dead_code)]
cc2de9c33ab5bd8b073263e1237e01c6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|124|1|V|rust
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
66389a498ac7c20ba9d7b463ed8f9b22|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|95|1|V|rust
	    /// Advance the integrator to the next state.
0b753e2c36226f3851dc5c83bdba06c9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|125|1|V|rust
	    /// Step the integrator using the DormandPrince5 algorithm.
	    #[allow(dead_code)]
	    pub fn step<F, J>(&self, integrator: &mut OdeIntegrator<F, J, DormandPrince5Cache>)
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        
ea5a1cbe764918679997181a3ea281d3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|125|5|V|rust
	    }
1626448b74e74298a964ea1ffd25f2e3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|4|1|V|rust
	pub struct DormandPrince5;
772c0eb3a01e8fc90687e65bbe4d0d96|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|5|1|v|rust
	impl DormandPrince5 {
	    // Butcher c_i's
	    pub(crate) const C2: f64 = 0.2;
	    pub(crate) const C3: f64 = 0.3;
	    pub(crate) const C4: f64 = 0.8;
	    pub(crate) const C5: f64 = 8.0 / 9.0;
	    // But_ij's
	    pub(crate) const A21: f64 = 0.2;
	    pub(crate) const A31: f64 = 3.0 / 40.0;
	    pub(crate) const A32: f64 = 9.0 / 40.0;
	    pub(crate) const A41: f64 = 44.0 / 45.0;
	    pub(crate) const A42: f64 = -56.0 / 15.0;
	    pub(crate) const A43: f64 = 32.0 / 9.0;
	    pub(crate) const A51: f64 = 19372.0 / 6561.0;
	    pub(crate) const A52: f64 = -25360.0 / 2187.0;
	    pub(crate) const A53: f64 = 64448.0 / 6561.0;
	    pub(crate) const A54: f64 = -212.0 / 729.0;
	    pub(crate) const A61: f64 = 9017.0 / 3168.0;
	    pub(crate) const A62: f64 = -355.0 / 33.0;
	    pub(crate) const A63: f64 = 46732.0 / 5247.0;
	    pub(crate) const A64: f64 = 49.0 / 176.0;
	    pub(crate) const A65: f64 = -5103.0 / 18656.0;
	    // But_i's: y1 = y0 + h * (b1 * k1 + ... + bs * ks)
	    pub(crate) const A71: f64 = 35.0 / 384.0;
	    pub(crate) const A73: f64 = 500.0 / 1113.0;
	    pub(crate) const A74: f64 = 125.0 / 192.0;
	    pub(crate) const A75: f64 = -2187.0 / 6784.0;
	    pub(crate) const A76: f64 = 11.0 / 84.0;
	    // Errimation constants: b_i^* - b_i
	    pub(crate) const E1: f64 = 71.0 / 57600.0;
	    pub(crate) const E3: f64 = -71.0 / 16695.0;
	    pub(crate) const E4: f64 = 71.0 / 1920.0;
	    pub(crate) const E5: f64 = -17253.0 / 339200.0;
	    pub(crate) const E6: f64 = 22.0 / 525.0;
	    pub(crate) const E7: f64 = -1.0 / 40.0;
	    // Cons output parameters
	    pub(crate) const D1: f64 = -12715105075.0 / 11282082432.0;
	    pub(crate) const D3: f64 = 87487479700.0 / 32700410799.0;
	    pub(crate) const D4: f64 = -10690763975.0 / 1880347072.0;
	    pub(crate) const D5: f64 = 701980252875.0 / 199316789632.0;
	    pub(crate) const D6: f64 = -1453857185.0 / 822651844.0;
	    pub(crate) const D7: f64 = 69997945.0 / 29380423.0;
	}
e2a7f28f5f4651110143333bbcc784bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|8|1|V|rust
	pub(crate) mod step;
a1cfdac02713621d94effb5cc96ce6f0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|5|5|v|rust
	pub(crate) 
dd4827af87b26de9ed92e6fb08efc5ab|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|5|9|v|rust
	crate
bffe68c3a142034e90ae959c66512327|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|1|10|v|rust
	::algorithm:
a912a94d79b5124d876951f96ebb256f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|105|20|v|rust
	statistics
26f3be1839164900baf57f6eb3fc2f0f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|9|9|V|rust
	        &self,
946922b258d486fa96254d7886e27b32|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|16|27|v|rust
	integrator
bcc09e5322d13942cf47008114e6947a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|19|32|v|rust
	self.alpha
590f53e8699817c6fa498cc11a4cbe63|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|21|60|v|rust
	self
eb4220eb2dfdc25ce785bf68bddfbbbd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|18|1|V|rust
	        let fac1 = 1.0 / integrator.opts.facl;
ad6e7652b1bdfb38783486c2c3d5e806|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|66|17|v|rust
	Self
1a2c7fbd5da6df13c763689154655a76|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|62|23|v|rust
	self.
441e1361ef664a03cea724b186065cfb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|74|25|v|rust
	tics
1813e7a120c3d0b3627e86bbcbec7648|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|68|32|v|rust
	status 
a5f6fc57680d9615c6b54be49b6ac8c4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|68|42|v|rust
	OdeStatus
eaac10843edd67842478d1c65d01e2cb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|69|24|v|rust
	Some(integrator.sol
d92a29ddfaa03390850f693f28eff54f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|101|13|v|rust
	if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
11eb7d93a0324d2c4818837694080822|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|105|1|V|rust
	            if (integrator.t + 1.01 * integrator.dt - integrator.prob.tspan.1) * tdir > 0.0 {
	                integrator.dt = integrator.prob.tspan.1 - integrator.t;
	                integrator.cache.last = true;
	            }
56e031a6d2a43bc7799306e6a6c1e93f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|106|1|V|rust
	            if integrator.sol.statistics.steps > self.max_steps {
	                integrator.sol.status = OdeStatus::MaxIters;
	                return integrator.sol;
	                //throw std::runtime_error("too many steps..");
	            }
	            if integrator.sol.status != OdeStatus::Continue {
	                return integrator.sol;
	            }
99a3c567a60974f4f293f1f5186033b2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|87|1|V|rust
	        integrator.stats.steps += 1;
9acb44549b41563697bb490144ec6258|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|80|28|v|rust
	status
c13b4778cee23eb182a2932e58f06348|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|81|20|v|rust
	integrator.sol
5654414c04d3f8b80cae0d7e316bfc86|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|82|13|V|rust
	            //throw std::runtime_error("too many steps..");
4ce7365d7d6c0f6848fe7ec4ecf0da56|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|83|9|v|rust
	if integrator.sol.retcode != OdeStatus::Continue {
	            return integrator.sol;
	        }
4e7033196670aecca8521c1d461683f6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|84|1|V|rust
	        integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
7bb0edd98f22430a03b67f853e83c2ca|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|85|8|V|rust
	        
269b3f18d885f92a5058b8ce2525513c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|61|40|v|rust
	prob.tspan.1
4aed4c04f2c8cbac98e3b3499b4861a9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|59|9|v|rust
	If true, integration is from smaller to larger times.
965dbaac085fc891bfbbd4f9d145bbc8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|60|9|v|rust
	forward
c506ff134babdd6e68ab3e6350e95305|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|60|15|v|rust
	bool
260477cbd63a0339fb565a1aad73ebcb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|74|25|v|rust
	(if integrator.forward { 1.0 } else { -1.0 })
c859e08a6ab8c8f5daf9dee2f32307c1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|74|25|v|rust
	integrator.tdir
949d5c9319f3f02e41ff87672b82dc96|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|104|9|v|rust
	integrator.sol.ts.push(integrator.t);
	        integrator.sol.us.push(integrator.u.clone());
	
	        (integrator.prob.dudt)(
	            integrator.cache.du.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
9ebd39b6dbd5b9ddb5f89b9d99bbeba8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|60|13|v|rust
	sol: OdeSolution::new()
52e4d7e27447c8d4b70301d58dfbe8a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|62|13|V|rust
	            sol: OdeSolution::new(),
e6bb2786594c19f7efc8dfdb612e4a25|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|101|1|V|rust
	impl DormandPrince5 {
	    /// Solve an ODE problem using the DormandPrince5 algorithm
	    pub fn solve<F, J>(&self, prob: OdeProblem<F, J>) -> OdeSolution
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let mut integrator = self.init(prob);
	
	        let tdir = if integrator.forward { 1.0 } else { -1.0 };
	
	        while !integrator.cache.last {
	            self.step(&mut integrator);
	        }
	        integrator.sol
	    }
	}
d6f67f4384e4a7ae9e2222fcb8d37171|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|81|38|v|rust
	OdeSolution
6adf97f83acf6453d4a6a4b1070f3754|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|83|13|v|rust
	None
38112da6bac44bf839a2baa5d536d510|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|85|13|V|rust
	            Some(self.sol)
a4dc15553e6b89970d8e61080ec71a0e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|86|9|v|rust
	if Alg::step(self) {
	           Some(self.stats.steps)
	        } else {
	            None
	        }
1caf2172db8df160246f77a9f788fde4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|91|1|V|rust
	        if Alg::step(self) {
	           Some(self.stats.steps)
	        } else {
	            None
	        }
dbef7466ab8050e8c9db874b95cce0df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|96|9|v|rust
	loop {
	            let res = self.step();
	            match res {
	                Some(sol) => return sol,
	                None => {}
	            }
	        }
6b574107a5606e3be0a7e380061f5d17|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|93|28|v|rust
	 -> OdeSolution
b9534471a3c6339fee9709d98908a964|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|95|9|V|rust
	        self.sol.clone()
1c0a06758a5fe6c42a00b11db4bf3e07|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|21|17|v|rust
	 (returns the solution)
31717c427d6e24fd02ed5587c644e71f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|22|5|v|rust
	let sol = i
385e54735cbf7e164d5ca45c7419d3a9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|43|19|v|rust
	prob
e078d114e7bf45d6aa1de79c48ad4067|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|13|5|V|rust
	        let p = &*prob.clone();
b62e9edea151f090b3837ba1b561b0fa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|4|4|v|rust
	(crate)
ada74a7bbf7a1adbef4d6a0550e5880b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|172|1|V|rust
	        let prob = OdeProblemBuilder::default(dudt, uinit.clone(), tspan)
	            .with_jac(dfdu)
	            .build()
	            .unwrap();
c7d64a66e255de32a8fe88fec04cc051|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|24|9|V|rust
	        let prob = OdeProblemBuilder::default(dudt, uinit.clone(), tspan)
cac3e24e0eb423452b7df248808acaeb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|25|9|V|rust
	            .with_jac(dfdu)
cf23bfddff5ac219b99dd02c95bbce65|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|33|15|v|rust
	Some(i) =
505a83f220c02df2f85c3810cd9ceb38|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|16|34|v|rust
	Success
bc1cc04dec2cbafaacecd91185142b46|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|82|57|v|rust
	Success {
b04959f344974fc1c982bf2c53634fc8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|83|13|V|rust
	            None
7dd039107c01f1329a9d5ac0372589c2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|83|9|V|rust
	        } else {
f058b36a0d08c09db28c937cb99b76c1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|122|9|V|rust
	        let n = uinit.shape()[0];
e98533e20c373de40752d276aac9614f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|38|22|v|rust
	<F, J>
567904efe9e64d9faf3e41ef402cb568|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|39|1|V|rust
	where
f54f8c77ad1427279b643ede78f1e238|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|39|5|V|rust
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
aebfd107a9a444895dac45ec935be291|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|39|5|V|rust
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
9afc4c951a9c2461e0ebcb0cc1d89346|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|42|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>,f64)
4b125120e610724cf3bfb17d09883dd6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|78|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>,f64),
185dbd3e351bab68701ba337029bc684|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|82|22|v|rust
	fn(ArrayViewMut2<f64>, ArrayView1<f64>,f64)
8c76882a91dbe45b1c8cccc742a0ca26|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|255|9|v|rust
	let dudt =
3839f5cd5315039f1c393923ac62eea2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|4|13|v|rust
	mut 
e9a915602a4e309681fe81ec64e3e0e6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|4|1|V|rust
	    fn dudt(du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t:f64);
b7dccc7d9373cd4717256318909fcebe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|3|23|v|rust
	Param
4092c6c9606afb4e1eb89655f37d0cac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|38|22|v|rust
	<F: Fn, J: Fn>
24c92e516a9ab79ccd107c886e91bd05|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|41|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64)
5f4d936a83a9ea6ca12be073d5f36b6c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|45|22|v|rust
	fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64)
a40eb750868aaef814051589da28cd17|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|74|1|V|rust
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
5c2a049a768658afe5c232910fa829e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|126|26|v|rust
	<F,J>
c29745a7cbc950ad3e4aad7c995ad255|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|122|15|v|rust
	&fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
06b96f19c3503ab7292dcf11140c04a5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|142|15|v|rust
	&fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
e57eae1863dafee679f8196f25424b0e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|144|30|v|rust
	.clone()
3d84d573ef0c19880fe9b4cad09c3678|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|12|1|V|rust
	    fn dfdu(&mut self, df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64);
5d2cf1ce7cdedb86aa1195be1e9934cd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|14|1|V|rust
	    fn dudt(&mut self, du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64);
0881dc200b59ea52ec7f8f1dee06f142|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|11|1|v|rust
	fn dudt
c95755b7c1bcd89d5d406118d84c028c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|22|26|v|rust
	::<f64>
578a99f865bbafe1bcf44ca4dbf6804e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|22|1|V|rust
	       let mut du = Array::zeros(u.raw_dim());
9bd55170322a87640b6a1934ba28ac2e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|20|1|v|rust
	let mut du0 = 
d61dbd7cb2ce3c45888f3b30348c35da|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|19|1|V|rust
	       let mut du0 = Array::zeros(u.raw_dim());
051a238a3d80858cb78c6242bfe4c309|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|20|23|v|rust
	Array::zeros(u.raw_dim())
c7e541a9e03346ff571bc1f24d3beb68|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|19|23|v|rust
	= u.clone()
5af64d05bda6e31f5a863aee10bc2ab1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|42|9|v|rust
	dudt
0700865f9eb9ff1e7801f0628b3ca2a4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|44|5|V|rust
	    fn mass_matrix
21452ee3b8684edb93d0a10f7f76f1fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|43|1|V|rust
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
df7a23bb4a216686c8dd0c7ade968d0f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|40|1|V|rust
	    /// RHS of the ordinary differential equation. Should be of the form:
	    /// dudt = dudt(du, u, t) where `du` is modified in place.
0cc87bb6eda417c46f3ff689c3992095|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|20|1|V|rust
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
72bfbc489b9e58abc894a9cfc0abe5d5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|43|1|V|rust
	    /// Jacobian of the RHS of the ordinary differential equation. Should be of
	    /// the form: dfdu = dfdu(df, u, t) where the jacobian `df` is modified in
	    /// place.
	    pub dfdu: Option<J>,
fea1be02a05c373c53f9795ab94e6afa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|73|9|v|rust
	dudt: F,
1f6e274d1fc475930654eaeae45bb0f0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|40|1|V|rust
	    /// Function structure representing the RHS of the ODE.
a02b38baf6b9d59a79a049349cff931b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|100|6|v|rust
	F, J
96b85cc559d553ecc0ced72ef4b58987|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|105|13|V|rust
	            dfdu: None,
2f1b1a35c03d846759e72455784a2218|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|104|13|v|rust
	dudt: dudt,
834dd0886e07a889ad10ea50fbb094a8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|119|1|V|rust
	    /// Add a jacobian to the builder.
	    pub fn with_jac(mut self, dfdu: J) -> OdeProblemBuilder<F, J> {
	        self.dfdu = Some(dfdu);
	        self
	    }
623cc6bde9d4bca07460083f0dfee804|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|211|13|v|rust
	dudt: self.dudt,
78d522f1a5776f093142a627216abb77|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|212|13|V|rust
	            dfdu: self.dfdu,
3e068e3f4ab6da9008b3fa8d8d59c124|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|241|9|v|rust
	let dfdu = |mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64| {
	            df[[0, 0]] = 0.0;
	            df[[0, 1]] = 0.0;
	            df[[1, 0]] = -1.0;
	            df[[1, 1]] = 0.0;
	        };
deff967d81e9a262834dc7583a14c5c8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|253|9|v|rust
	prob.func.dudt
66e273ace5d7d25a9c8ef68eba52207a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|17|5|V|rust
	    where
111911b08532a07dc0f9bc5c3f3409e1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|17|9|V|rust
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
3bcd6868be56d6d642c7e1aafe035838|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|17|9|V|rust
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
c869f7b10ef237bb0061ed658d2fd5b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|11|1|V|rust
	use ndarray::prelude::*;
4b7abdd003039514fd2d6d72ce234598|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|67|5|V|rust
	    Alg: OdeAlgorithm,
60026a41046fa5bc85d993a5c79016db|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|37|9|v|rust
	prob.dudt
6632037d399ac9266e8f6fe09a8c92b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|40|13|v|rust
	dudt: prob.dudt,
84b80e6f756c69765c57ebf4f7380d91|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|41|13|V|rust
	            dfdu: prob.dfdu,
68147e9f602f84636df74af9380b1442|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|15|9|v|rust
	integrator.dudt
9d8826e6d10bb99c3d8167e05d58f47b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|21|12|v|rust
	mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t: f64
5be7e589d5144a6f3b8d5bb04e03d753|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|26|9|V|rust
	        let dfdu = |mut _df: ArrayViewMut2<f64>, _u: ArrayView1<f64>, _t: f64| {};
466b3e48e2cae7bc4352afac7779fabc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|41|17|v|rust
	: prob.func,
d8f63452b225d236289b03020ae51e79|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|81|13|v|rust
	if integrator.cache.last {
	                integrator.sol.retcode = OdeRetCode::Success;
	                return true;
	            }
43a1437f7f656cd8be7c996c58719e0a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|24|19|v|rust
	10.0
876409ee5c4e3b5666feb64ccefa527c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|36|1|V|rust
	            assert!((integrator.u[0] - integrator.t.sin()).abs() < integrator.opts.reltol * integrator.u[0]);
db8cff76991f6a294cad1d7d23d3b7a0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|13|V|rust
	            println!("t, u = ({}, {})", integrator.t, integrator.u);
f100415a0874fa6a631aeb420cfb92fe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|13|V|rust
	            println!(
18e499202dd7170c9a4850227387d875|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|17|V|rust
	                "       (    {}, {})",
b64017c61c3415461f4fdafa343aec6a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|17|V|rust
	                integrator.t.sin(),
9f59633b4b74352d915eb1ad6b47df1e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|17|V|rust
	                integrator.t.cos()
5504f3d947f441840d83f67615cde096|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|13|V|rust
	            );
35ef4cf32806765dab9e3a01ccabaa92|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|13|V|rust
	            println!("");
3635fa5e62e6828b59638e4f7225beee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|37|104|v|rust
	u[1]
91637b65060488581bc4c7ef537849cc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|18|v|rust
	integrator.u[0] - integrator.t.sin()
dfa2ed38e1966bcdc380bf521c8446b9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|36|1|V|rust
	            let dx = integrator.u[0] - integrator.t.sin();
a44d223aa2aed4aed1519772b085776c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|43|18|v|rust
	integrator.u[1] - integrator.t.cos()
6cb369d4a6e6add94d01041ec4c21532|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|36|22|v|rust
	dbg!
0de09f919df8dc324f0d9642e3df4a3e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|45|9|V|rust
	        assert!(false);
bc6de9b4d3a6c76b20a7edf89cd04df7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|39|17|v|rust
	dx.abs()
eae356c4f5dd37176437f3fdf1cfa728|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|42|17|v|rust
	dy.abs()
60393231d057026b4f5751f3849aa16c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|39|28|v|rust
	integrator.opts.reltol * integrator.t.sin().abs() * 10.0
fc1132d957a55212b1fdfa3b7275ec40|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|42|28|v|rust
	integrator.opts.reltol * integrator.t.cos().abs() * 10.0
9321a509dd6d6423bb6faf199cfad243|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|12|1|V|rust
	#[derive(Clone)]
03531b035037c43457543be44c50c001|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|12|19|v|rust
	{
	    /// Relative tolerance
	    pub(crate) reltol: f64,
	    ///(crate) Absolute tolerance
	    pub(crate) abstol: f64,
	    ///(crate) Flag specifying if dense output is requested
	    pub(crate) dense: bool,
	    ///(crate) Initial step value
	    pub(crate) dtstart: f64,
	    ///(crate) Maximum allowed step size
	    pub(crate) dtmax: f64,
	    ///(crate) Maximum number of allowed steps
	    pub(crate) max_steps: usize,
	    ///(crate) Maximum number of allowed newton iterations.
	    pub(crate) max_newt: usize,
	    ///(crate) If true, use modern predictive controller (Gustafsson).
	    pub(crate) modern_pred: bool,
	    ///(crate) Safety factor used in adaptive step selection.
	    pub(crate) safe: f64,
	    ///(crate) Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
	    pub(crate) facr: f64,
	    ///(crate) Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
	    pub(crate) facl: f64,
	    ///(crate) Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub(crate) quot1: f64,
	    ///(crate) Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub(crate) quot2: f64,
	    /// Parameter to determine if Jacobian needs to be recomputed.
	    pub(crate) thet: f64,
	    ///(crate) The amount to decrease the timestep by if the Newton iterations of an
	    ///(crate) implicit method fail.
	    pub(crate) fnewt: f64,
	    ///(crate) If true, the extrapolated collocation solution is taken as the starting
	    ///(crate) value of the Newton iteration.
	    pub(crate) use_ext_col: bool,
	    ///(crate) If true, the Jacobian will be converted into Hessenberg form.
	    pub(crate) hess: bool,
	}
	
c698e618853f7e16037b77f3f4ee1784|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|13|1|v|rust
	// Declare all the constants needed for Radau5
	impl Radau5 {
	    pub(crate) const T11: f64 = 9.1232394870892942792e-02;
	    pub(crate) const T12: f64 = -0.14125529502095420843;
	    pub(crate) const T13: f64 = -3.0029194105147424492e-02;
	    pub(crate) const T21: f64 = 0.24171793270710701896;
	    pub(crate) const T22: f64 = 0.20412935229379993199;
	    pub(crate) const T23: f64 = 0.38294211275726193779;
	    pub(crate) const T31: f64 = 0.96604818261509293619;
	    pub(crate) const TI11: f64 = 4.3255798900631553510;
	    pub(crate) const TI12: f64 = 0.33919925181580986954;
	    pub(crate) const TI13: f64 = 0.54177053993587487119;
	    pub(crate) const TI21: f64 = -4.1787185915519047273;
	    pub(crate) const TI22: f64 = -0.32768282076106238708;
	    pub(crate) const TI23: f64 = 0.47662355450055045196;
	    pub(crate) const TI31: f64 = -0.50287263494578687595;
	    pub(crate) const TI32: f64 = 2.5719269498556054292;
	    pub(crate) const TI33: f64 = -0.59603920482822492497;
	}
14a7d6f1c92918c4c67890db1c2082af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|16|1|V|rust
	    fn default() -> Self {
	        Radau5 {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: 0.0,
	            max_steps: 100_000,
	            max_newt: 7,
	            modern_pred: true,
	            safe: 0.9,
	            facr: 1.0 / 8.0,
	            facl: 5.0,
	            quot1: 1.0,
	            quot2: 1.2,
	            thet: 0.001,
	            fnewt: 0.001,
	            use_ext_col: true,
	            hess: false,
	        }
	    }
	    fn reltol(&mut self, val: f64) {
	        self.reltol = val;
	    }
	    fn abstol(&mut self, val: f64) {
	        self.abstol = val
	    }
	    fn dense(&mut self, val: bool) {
	        self.dense = val
	    }
	    fn dtstart(&mut self, val: f64) {
	        self.dtstart = val
	    }
	    fn dtmax(&mut self, val: f64) {
	        self.dtmax = val;
	    }
	    fn max_steps(&mut self, val: usize) {
	        self.max_steps = val;
	    }
a412806c826f5b5bfa6b5c166e90c522|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|18|1|v|rust
	impl Radau5 {
	    pub fn max_newt(&mut self, val: usize) {
	        self.max_newt = val;
	    }
	    pub fn modern_pred(&mut self, val: bool) {
	        self.modern_pred = val;
	    }
	    pub fn safe(&mut self, val: f64) {
	        self.safe = val;
	    }
	    pub fn facr(&mut self, val: f64) {
	        self.facr = val;
	    }
	    pub fn facl(&mut self, val: f64) {
	        self.facl = val;
	    }
	    pub fn quot1(&mut self, val: f64) {
	        self.quot1 = val;
	    }
	    pub fn quot2(&mut self, val: f64) {
	        self.quot2 = val;
	    }
	    pub fn thet(&mut self, val: f64) {
	        self.thet = val;
	    }
	    pub fn fnewt(&mut self, val: f64) {
	        self.fnewt = val;
	    }
	    pub fn use_ext_col(&mut self, val: bool) {
	        self.use_ext_col = val;
	    }
	    pub fn hess(&mut self, val: bool) {
	        self.hess = val;
	    }
	}
b7b530e169f45c731ed327198d8b690b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|34|9|v|rust
	let 
223acd8dcf203f00ede5ddc3d2118948|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|32|9|V|rust
	        let mu = 1e-6;
436e9af590c53db872eb8d95a3140e45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|48|9|V|rust
	        let mut rad = Radau5::default();
120a83027d7649f2d1fa74e773e0610d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|48|9|V|rust
	        rad.reltol(1e-7);
86bb806575853fc2f97dc6f26857a72b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|48|9|V|rust
	        rad.abstol(1e-7);
ed3c7f154b116b9adbf29a77cc8f58cf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|49|9|V|rust
	        let sol = rad.integrate(prob);
249c775d78126f78847b878ac918d749|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|49|9|V|rust
	        for (t, u) in sol.ts.iter().zip(sol.us.iter()) {
e5c4acc6d4cd9f33ca711c77d341f857|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|49|13|V|rust
	            println!("t, u = {:?}, {:?}", t, &u)
510709e105bd0f1ec7cf4de10299c876|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|49|9|V|rust
	        println!("{:?}", sol.status);
691d0492064a3ebc5c3998f31d75871e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|15|1|V|rust
	impl OdeAlgorithm for Radau5 {}
0d12bf92670e725094e19718da95b6e6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|11|1|V|rust
	use crate::ode::algorithm::OdeAlgorithm;
a4afd56113cbfb7a805a8eef44cbca9e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|7|9|V|rust
	        where 
1c423471b60b1e7922f699b02004de00|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|7|13|V|rust
	            T
ff58464b8bf6dacf6f3396bbe86fb3d9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|2|15|v|rust
	_prob
cf586632532513c89667b108759caa8c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|76|9|V|rust
	        alg: &Radau5,
56bab9145bf0494f004a7da4cc3b57ab|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/continuous_output.rs|10|41|v|rust
	, J,
4ea9b2b4f16fca4e48a9d3b40b936ad9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/continuous_output.rs|10|43|v|rust
	Radau5Cache
b65d402e1466ad44f46639f807fa6f36|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/continuous_output.rs|1|1|V|rust
	use super::cache::Radau5Cache;
ab0cf104f39708eabd07b8cb67e149ba|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|11|49|v|rust
	Cache
c3b64a40830bf594feca91552408e3fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|345|13|v|rust
	integrator.prob.dudt
aef7f0b198600ee3cf9dcef7b3dc48f6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|350|23|v|rust
	.sol
45fa23a18cd8fc171a4e344412884bf3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|8|8|v|rust
	Fn(f64) -> f64
5375d6bdcfbd90abce646a49c0c9e27f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|22|17|v|rust
	Struct{
	            f: |x:f64| -> 
	        }
	
2c32634ef7b5d5fe6523072a5a122333|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|8|1|V|rust
	where
	    F: Fn(f64) -> f64,
	    J: Fn(f64, f64) -> f64,
0212c63463ac3a8a2a3195b5f96b0aee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|32|29|v|rust
	|x:f64| -> {x}
9d313205d235758f33f25870b63fa1f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|7|1|v|rust
	pub struct Struct<F, J>
	where
	    F: Fn(f64) -> f64,
	    J: Fn(f64, f64) -> f64,
	{
	    pub f: F,
	    pub j: Option<J>,
	    phantom: std::marker::PhantomData<J>,
	}
a7614aae926845c8ab9f6d33f760d80b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|30|21|v|rust
	-> f64
2496be231a824cdf58eadb2f91d34ce8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|20|20|v|rust
	 -> f64
f9aec29db8ab1577ca4aa732ce9aeb0b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|9|5|V|rust
	    F: Fn(f64) -> f64,
f9fcd4785970651e1b9dfbd04cb2ff93|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|11|12|v|rust
	dyn Fn(f64) -> f64
b577755b410309ee9f866f87b7f95f11|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|12|12|v|rust
	Option<J>
560b7ee113dd5be96a8e75119b5295d2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|13|5|V|rust
	    phantom: std::marker::PhantomData<J>,
1d0074745dfe4a5de41abaa37f1de213|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|8|5|V|rust
	    J: Fn(f64, f64),
8e8edc4948b599dfbcf5c0ed83559537|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|13|1|v|rust
	pub struct StructBuilder<F, J>
	where
	    F: Fn(f64) -> f64,
	    J: Fn(f64, f64),
	{
	    pub f: F,
	    pub j: Option<J>,
	    phantom: std::marker::PhantomData<J>,
	}
6928c815cf1004d6da0d2b60e01fdcfc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|15|1|V|rust
	impl<F, J> StructBuilder<F, J>
	where
	    F: Fn(f64) -> f64,
	    J: Fn(f64, f64),
	{
	    fn default(f: F) -> StructBuilder<F, J> {
	        StructBuilder {
	            f,
	            j: None,
	            phantom: std::marker::PhantomData,
	        }
	    }
	    fn build(self) -> Struct<F, J> {
	        Struct {
	            f: self.f,
	            j: self.j,
	            phantom: std::marker::PhantomData,
	        }
	    }
	}
74915cb67b4efd6f97e5dcd7683f9df3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|21|23|v|rust
	Builder::<Fn(f64) -> f64, Fn(f64, f64)>
ec5a691adec85b59fc511a3fc7b7735b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|7|1|v|rust
	pub struct Struct
	{
	    pub f: dyn Fn(f64) -> f64,
	    pub j: Option<dyn Fn(f64, f64)>,
	}
	
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_it() {
	        let f = |xx: f64| xx;
	        let x = Struct::default(f).build();
	    }
	}
c92875255a8e3b460da756e4ea78be5f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|3|15|v|rust
	_integrator::OdeIntegrator
a1236286d2adeee6644180e116444237|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|4|1|V|rust
	use crate::ode_solution::OdeSolution;
d4673f0c17c03c471a9683adaf75cade|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|4|1|V|rust
	use crate::ode_statistics::OdeStatistics;
87618464ad6d5ab2cf7c78e82743d2eb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|4|1|V|rust
	use crate::ode_status::OdeStatus;
16d225268731d290d8af4b1dd7628fef|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|8|86|v|rust
	Cach
818994b948c57f67845461d11096c825|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|13|9|v|rust
	let mut cache = Radau5Cache::new(&self, &prob).unwrap();
	
	        if self.dtmax != 0.0 {
	            cache.dtmax = self.dtmax;
	        }
	        let forward = prob.tspan.1 > prob.tspan.0;
	        let u = prob.uinit.clone();
	        let t = prob.tspan.0;
	        let dt = dbg!(self.dtstart);
	        let uprev = prob.uinit.clone();
	        let tprev = prob.tspan.1;
	
	        OdeIntegrator::<F, J, Radau5Cache> {
	            prob,
	            u,
	            t,
	            dt,
	            uprev,
	            tprev,
	            dtprev: self.dtstart,
	            forward,
	            sol: OdeSolution::new(),
	            cache,
	        }
73310baa7c2c842d97f36eb796646101|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|8|1|V|rust
	        unimplemented!()
b3713f7a0b03cf49e7c3a156c3ba1ab1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|170|1|V|rust
	            fnewt: opts.fnewt,
f3f778cc9542f459ceb94831ea53d188|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|166|13|V|rust
	            dtmax: prob.tspan.1 - prob.tspan.0,
100baadf0f8d9fc42b0bbd6bd4feae0e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|164|13|V|rust
	            reltol: opts.reltol,
5e23163231bdb117a353976d6939a81c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|164|13|V|rust
	            abstol: opts.abstol,
b1740b193a37e75e38d2c3fa8a931b5d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|38|5|V|rust
	    pub(crate) fnewt: f64,
2d4200d4cff0f6bdf1af5d2ff37d678e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|34|5|V|rust
	    pub(crate) dtmax: f64,
b0255e6970cc9af2ed634aec826d5545|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|33|5|V|rust
	    pub(crate) abstol: f64,
232e992a2d81353b959f19360e2d8fb2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|32|5|V|rust
	    pub(crate) reltol: f64,
7245f474b6dab5e95f4b07667da186fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|10|9|V|rust
	        if .dtmax != 0.0 {
be2bb66cff45275fb1a54d8dd7848b3d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|10|13|V|rust
	            cache.dtmax = self.dtmax;
d50e707f7d3a6a2c923b9b4e621e68fa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|11|1|V|rust
	        let opts = OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: prob.tspan.1 - prob.tspan.0,
	            max_steps: 100000,
	            beta: 0.04,
	            max_newt_iter: 0,
	            max_stiff: 1000,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 10.0,
	            facl: 0.2,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	        };
	        let mut func = prob.func;
	        // Initialize the solution
	        let mut sol = OdeSolution::new();
	        sol.ts.push(prob.tspan.0);
	        sol.us.push(prob.uinit.clone());
	        // Initialize the cache
	        func.dudt(cache.du.view_mut(), prob.uinit.view(), prob.tspan.0);
01c1a1e972574e2b8275d7574b758650|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|10|1|V|rust
	        let forward = prob.tspan.1 > prob.tspan.0;
	        let u = prob.uinit.clone();
	        let t = prob.tspan.0;
	        let dt = dbg!(self.dtstart);
	        let uprev = prob.uinit.clone();
	        let tprev = prob.tspan.1;
cf51a5e11140a70f45e173535873eb55|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|73|5|V|rust
	        opts: &OdeIntegratorOpts,
54e9cc3ca8fa9526223d2aeb444d4422|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|3|17|v|rust
	{OdeAlgorithm, OdeFunction, OdeIntegrator, OdeProblem};
cb295bc38c7ca4223fb29ed5f880f1cb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|39|9|v|rust
	OdeIntegrator {
	            func,
	            mass_matrix: prob.mass_matrix,
	            u: prob.uinit.clone(),
	            t: prob.tspan.0,
	            dt: 1e-6,
	            uprev: prob.uinit.clone(),
	            tprev: prob.tspan.0,
	            dtprev: 1e-6,
	            tdir: if prob.tspan.1 > prob.tspan.0 {
	                1.0
	            } else {
	                0.0
	            },
	            tfinal: prob.tspan.1,
	            sol,
	            stats: OdeStatistics::new(),
	            opts,
	            cache,
	        }
3c2cbf6086b34e001a351d8aa9984631|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|38|1|V|rust
	        OdeIntegrator::<T, Radau5> {
	            func: prob.func,
	            u,
	            t,
	            dt,
	            uprev,
	            tprev,
	            dtprev: self.dtstart,
	            forward,
	            sol: OdeSolution::new(),
	            cache,
	        }
49685a9e98000552a339823606550b9a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|35|9|v|rust
	let tfinal = integrator.prob.tspan.1;
	
	        let sq6 = 6f64.sqrt();
	        let c1 = (4.0 - sq6) / 10.0;
	        let c2 = (4.0 + sq6) / 10.0;
	        let c1m1 = c1 - 1.0;
	        let c2m1 = c2 - 1.0;
	        let c1mc2 = c1 - c2;
	        let u1 = 1.0 / ((6.0 + 81f64.powf(1.0 / 3.0) - 9f64.powf(1.0 / 3.0)) / 30.0);
	        let mut alph = (12.0 - 81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) / 60.0;
	        let mut beta = (81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) * 3f64.sqrt() / 60.0;
	        let cno = alph * alph + beta * beta;
	
	        {
	            let quot = self.abstol / self.reltol;
	            integrator.cache.reltol = 0.1 * self.reltol.powf(2.0 / 3.0);
	            integrator.cache.abstol = self.reltol * quot;
	        }
	
	        let n = integrator.u.shape()[0];
	
	        integrator.cache.fnewt = if self.fnewt == 0.0 {
	            (10.0 * f64::EPSILON / self.reltol).max(0.03f64.min(self.reltol.sqrt()))
	        } else {
	            self.fnewt
	        };
	
	        alph = alph / cno;
	        beta = beta / cno;
	
	        let posneg = 1.0f64.copysign(tfinal - integrator.t);
	        let dtmax = (integrator.cache.dtmax)
	            .abs()
	            .min((tfinal - integrator.t).abs());
	        let cfac = self.safe * (1 + 2 * self.max_newt) as f64;
	
	        // compute mass matrix for implicit case
	        integrator.cache.mass_matrix = match &integrator.prob.mass_matrix {
	            Some(mm) => mm.clone(),
	            None => Array2::eye(n),
	        };
	
	        integrator.dt = (integrator.dt).abs().min(dtmax);
	        integrator.dt = integrator.dt.copysign(posneg);
	        integrator.dtprev = integrator.dt;
	
	        let mut last = false;
	        let mut first = true;
	
	        if integrator.t + integrator.dt * 1.0001 - tfinal * posneg >= 0.0 {
	            integrator.dt = tfinal - integrator.t;
	            last = true;
	        }
	
	        let mut dtopt: f64 = integrator.dt;
	        let mut faccon: f64 = 1.0;
	
	        if self.dense {
	            let irtrn = 1;
	            for i in (0)..(n) {
	                integrator.cache.cont[i] = integrator.u[i];
	            }
	            // irtrn = SolutionOutput();
	            if irtrn < 0 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                return integrator.sol;
	            }
	        }
	        solution.ts.push(integrator.t);
	        solution.us.push(integrator.u.clone());
	
	        for i in (0)..(n) {
	            integrator.cache.scal[i] = self.abstol + self.reltol * integrator.u[i].abs();
	        }
	
	        (integrator.prob.dudt)(
	            integrator.cache.u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	        integrator.sol.statistics.function_evals += 1;
	
	        let mut dtfac = integrator.dt;
	        let mut dtacc: f64 = 0.0;
	        let mut erracc: f64 = 0.0;
	        let mut thqold: f64 = 0.0;
	        let mut nsing = 0;
	        let mut ier;
	
	
cc817b49f916e2294393aa40aa40e5cf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|58|8|V|rust
	        let tfinal = integrator.prob.tspan.1;
3e5bcce4583b513b474cf934ffcf3183|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|59|1|V|rust
	        let sq6 = 6f64.sqrt();
	        let c1 = (4.0 - sq6) / 10.0;
	        let c2 = (4.0 + sq6) / 10.0;
	        let c1m1 = c1 - 1.0;
	        let c2m1 = c2 - 1.0;
	        let c1mc2 = c1 - c2;
	        let u1 = 1.0 / ((6.0 + 81f64.powf(1.0 / 3.0) - 9f64.powf(1.0 / 3.0)) / 30.0);
	        let mut alph = (12.0 - 81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) / 60.0;
	        let mut beta = (81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) * 3f64.sqrt() / 60.0;
	        let cno = alph * alph + beta * beta;
3a4c62c6e24b95b45b69b408de1c874b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|60|9|v|rust
	{
	            let quot = self.abstol / self.reltol;
	            integrator.cache.reltol = 0.1 * self.reltol.powf(2.0 / 3.0);
	            integrator.cache.abstol = self.reltol * quot;
	        }
0fea6a13c52b4d4725368f24b045ca84|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|33|13|v|rust
	cache
715424962a9332b9cfaa464d1b50056a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|31|9|V|rust
	        {
706d1ce7ce9f52d3a9d8846c5c4972ea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|33|13|V|rust
	            opts.abstol = opts.reltol * quot;
	        }
6e32bb655e559c0e0d43cb5cdda7aaa2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|1|V|rust
	        let n = integrator.u.shape()[0];
	
	        integrator.cache.fnewt = if self.fnewt == 0.0 {
	            (10.0 * f64::EPSILON / self.reltol).max(0.03f64.min(self.reltol.sqrt()))
	        } else {
	            self.fnewt
	        };
	
	        alph = alph / cno;
	        beta = beta / cno;
	
	        let posneg = 1.0f64.copysign(tfinal - integrator.t);
	        let dtmax = (integrator.cache.dtmax)
	            .abs()
	            .min((tfinal - integrator.t).abs());
	        let cfac = self.safe * (1 + 2 * self.max_newt) as f64;
	
	        // compute mass matrix for implicit case
	        integrator.cache.mass_matrix = match &integrator.prob.mass_matrix {
	            Some(mm) => mm.clone(),
	            None => Array2::eye(n),
	        };
	
	        integrator.dt = (integrator.dt).abs().min(dtmax);
	        integrator.dt = integrator.dt.copysign(posneg);
	        integrator.dtprev = integrator.dt;
	
	        let mut last = false;
	        let mut first = true;
	
	        if integrator.t + integrator.dt * 1.0001 - tfinal * posneg >= 0.0 {
	            integrator.dt = tfinal - integrator.t;
	            last = true;
	        }
	
	        let mut dtopt: f64 = integrator.dt;
	        let mut faccon: f64 = 1.0;
	
	        if self.dense {
	            let irtrn = 1;
	            for i in (0)..(n) {
	                integrator.cache.cont[i] = integrator.u[i];
	            }
	            // irtrn = SolutionOutput();
	            if irtrn < 0 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                return integrator.sol;
	            }
	        }
	        solution.ts.push(integrator.t);
	        solution.us.push(integrator.u.clone());
	
	        for i in (0)..(n) {
	            integrator.cache.scal[i] = self.abstol + self.reltol * integrator.u[i].abs();
	        }
	
	        (integrator.prob.dudt)(
	            integrator.cache.u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	        integrator.sol.statistics.function_evals += 1;
	
101d8542da6e224cdd28cf4031f0ab17|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|47|9|V|rust
	        let posneg = 1.0f64.copysign(tfinal - integrator.t);
213c34f8b285fd8d9f60fd95c0540533|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        alph = alph / cno;
2e26fb4a8de22cfecd624aaf394c9999|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        beta = beta / cno;
86dfea8fa14096c5892445acc97fe520|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|36|1|V|rust
	        let n = integrator.u.shape()[0];
0c682d5ae590eca5f4e68ccffefe2451|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        let dtmax = (integrator.cache.dtmax)
afd83a7c4dc1a23041cc831079dd148b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|13|V|rust
	            .abs()
0ab62ce966a3d545d7159d9e350d3893|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|13|V|rust
	            .min((tfinal - integrator.t).abs());
49d27153d72e590b2882068c3945e795|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        let cfac = self.safe * (1 + 2 * self.max_newt) as f64;
f8bcffc5ff1a73becabe6cfcb22398aa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        // compute mass matrix for implicit case
c07dd5342748b0e5ff6b22ae8ef1b1af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        integrator.cache.mass_matrix = match &integrator.prob.mass_matrix {
6f6faf4e3cfed8c0eb6e4735a269b2fa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|13|V|rust
	            Some(mm) => mm.clone(),
6f9c0390002be081756956c0818e1a8b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|13|V|rust
	            None => Array2::eye(n),
3dfefe60cd3394d01587351caf03bd3f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        };
e6904e6f1a52c6ae2bb8f43b5759c2bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|43|14|v|rust
	integrator.dt
13d3082a65216372f3dd7085684d7531|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|43|41|v|rust
	dtmax
edcbd69ff6efa37ee9d8c4e0deeee7fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        dt = integrator.dt.copysign(posneg);
7c94f9dbc185cd039212cff536727527|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|44|9|V|rust
	        integrator.dtprev = integrator.dt;
b2e61f31a3e64bc4feaf3fa9cdde9bc2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|1|V|rust
	        let mut last = false;
1f8d99b45f3709ae13a23d0b22f52815|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|9|V|rust
	        let mut first = true;
9d93bea37085610d77f32b6654af7ce4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|1|V|rust
	        if integrator.t + integrator.dt * 1.0001 - tfinal * posneg >= 0.0 {
83f1c9a569bf74bece236b7dc65495ee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|13|V|rust
	            integrator.dt = tfinal - integrator.t;
040256c476563efa983cc91ab9d5785e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|13|V|rust
	            last = true;
f6ba44ad696c5ef9ce2cce57bb2c5b04|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|9|V|rust
	        let mut dtopt: f64 = integrator.dt;
16cc4d17132953381d25c1bfddfc7b90|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|9|V|rust
	        let mut faccon: f64 = 1.0;
9cbb58f72ac5e73d362ace918cc98ee3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|45|9|v|rust
	if self.dense {
	            let irtrn = 1;
	            for i in (0)..(n) {
	                integrator.cache.cont[i] = integrator.u[i];
	            }
	            // irtrn = SolutionOutput();
	            if irtrn < 0 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                return integrator.sol;
	            }
	        }
52f5367861c1f028e82f1252bdc220f3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|46|8|V|rust
	        solution.ts.push(integrator.t);
a2251c36242c27b2f88febca261d0487|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|46|9|V|rust
	        solution.us.push(integrator.u.clone());
90521caa3cc15dbc244a9b4f617a0268|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|50|9|v|rust
	func.dudt
34242e1b5c85c129296d8d3e467a1544|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|50|1|V|rust
	        func.dudt(
	            integrator.cache.u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	        integrator.sol.statistics.function_evals += 1;
11f01a234489bea8692d692c92bb1e40|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|59|9|V|rust
	        func.dudt(cache.du.view_mut(), prob.uinit.view(), prob.tspan.0);
2e869d707b556f1f0fa6c594f2242cce|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|82|1|V|rust
	            stats: OdeStatistics::new(),
c1aa29f77386e544a187a9caa953ce4d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|9|v|rust
	integrator.sol.
bf31f81129912b54c726f6d39c6acbbb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|86|18|v|rust
	: OdeStatistics::new(),
b60edb3450b0e381eabe81d6b0d37302|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|94|1|V|rust
	        let mut dtfac = integrator.dt;
	        let mut dtacc: f64 = 0.0;
	        let mut erracc: f64 = 0.0;
	        let mut thqold: f64 = 0.0;
	        let mut nsing = 0;
	        let mut ier;
e0ef6cd2102743326e0c4d1be226d9d5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|90|1|V|rust
	
	
	        
	
	
	
13734204b6887ac0830321867ec58e45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|32|1|v|rust
	/// Light-weight struct used to keep track of the state of the ODE throughout
	/// integration.
	pub struct OdeIntegrator<T: OdeFunction, Alg: OdeAlgorithm> {
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
f4de98d95d4135e2b5d7797c161f26ac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|66|1|v|rust
	/// Light-weight struct used to keep track of the state of the ODE throughout
	/// integration.
	pub struct OdeIntegrator<T: OdeFunction, Alg: OdeAlgorithm> {
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
	
	impl<T: OdeFunction, Alg: OdeAlgorithm> OdeIntegrator<T, Alg> {
	    /// Step the ODE to the next state. Returns solution if finished and
	    /// None otherwise.
	    pub fn step(&mut self) -> Option<usize> {
	        if self.sol.retcode == super::code::OdeRetCode::Continue {
	            if !Alg::step(self) {
	                Some(self.stats.steps)
	            } else {
	                None
	            }
	        } else {
	            None
	        }
	    }
	    /// Solve the ODE
	    pub fn solve(&mut self) {
	        while let Some(_i) = self.step() {}
	    }
	}
9909ec500e751e07cb5d49e6d6142471|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|119|50|v|rust
	OdeIntegratorBuilder<T, Alg>
6bd66f21f9b55cea23582500ee8cb723|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|122|5|v|rust
	fn reltol(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.reltol = val;
	        self
	    }
5df6f9378eaf9d942c9cc9290410e6a8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|127|19|v|rust
	reltol = val;
423ccadc9c2e0be089739537007ed2c6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|127|19|v|rust
	reltol
168bc269b9f849cdf6230e7c806b254b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|126|1|V|rust
	    fn abstol(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.abstol = val;
	        self
	    }
f0e327b389e6a1a87b6597ceeaa84b30|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|130|8|v|rust
	abstol
a11706f69a7d4558574bd1101180027f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|130|1|V|rust
	    fn dense(mut self, val: bool) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.dense = val;
	        self
	    }
0eccef1fe0100f85b12e6eabe08eaff6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|134|8|v|rust
	dense
955bd1465ed54d7a6a726cf360b1e80e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|134|1|V|rust
	    fn dtstart(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.dtstart = val;
	        self
	    }
ea2b2676c28c0db26d39331a336c6b92|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|138|10|v|rust
	start
ec94c7a928eb01095fb3783627b2b308|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|138|1|V|rust
	    fn dtmax(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.dtmax = val;
	        self
	    }
48b2270e819547bffb8a81a58d3ececd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|142|1|V|rust
	    fn max_steps(mut self, val: usize) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.max_steps = val;
	        self
	    }
fca3ffea6534176432f58b5a22ed22e1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|146|12|v|rust
	steps
44f112de69dacf3bfd8ef8b20a7b1332|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|147|19|v|rust
	max_steps
717929132c663179d925231dea004ac1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|146|1|V|rust
	    fn max_newt_iter(mut self, val: usize) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.max_newt_iter = val;
	        self
	    }
3c8965540970bca4e33d6cc122b13bb7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|150|8|v|rust
	max_newt_iter
3319d6c7740f79ad4dcddd45e731ce18|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|150|35|v|rust
	usize
00aa5eaece810f0c3c9034d31a32010c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|150|1|V|rust
	    fn modern_pred(mut self, val: bool) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.modern_pred = val;
	        self
	    }
31688b177164ee94c2e0600c2ba3d787|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|154|8|v|rust
	modern_pred
415b104f86b2264f3d168f10fc555fc5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|150|12|v|rust
	newt_iter
19015d4f0dbcee34e9a9730597af4350|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|158|1|V|rust
	    fn safe(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.safe = val;
	        self
	    }
9dfc8dce7280fd49fc6e7bf0436ed325|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|162|8|v|rust
	safe
58e944c417b0447f42e9e3a3d603ba07|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|162|1|V|rust
	    fn facr(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.facr = val;
	        self
	    }
cc5c2c9b620ccc0124d9e46df503dccb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|166|1|V|rust
	    fn facl(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.facl = val;
	        self
	    }
8c4ae2f07542ea6e918cdfb50b7f51b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|170|8|v|rust
	facl
e4d35e46a54367314b2fce854b81bea3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|170|1|V|rust
	    fn quot1(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.quot1 = val;
	        self
	    }
e74ad7a55546e2086c7598828f02a501|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|178|8|v|rust
	quot1
93a43993ebf191b919958a9e8c52b380|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|178|1|V|rust
	    fn beta(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.beta = val;
	        self
	    }
987bcab01b929eb2c07877b224215c92|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|182|8|v|rust
	beta
0bb43761f36e55413a55476b4142f99f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|182|1|V|rust
	    fn fnewt(mut self, val: f64) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.fnewt = val;
	        self
	    }
7b1a6c4c9d9219c2502ad84e079fd397|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|186|8|v|rust
	fnewt
1d029a8ca190731184aabec06b44d799|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|186|8|v|rust
	use_ext_col
923f1507229f7f568b0f4314b6224a31|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|186|1|V|rust
	    fn use_ext_col(mut self, val: bool) -> OdeIntegratorBuilder<T, Alg> {
	        self.opts.use_ext_col = val;
	        self
	    }
e4f1ac7a4e8a8e78adc8320f8779c7ab|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|114|1|V|rust
	    /// Cache associated with the algorithm
fd31360d777231eed868f1c85dd59b41|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|114|5|V|rust
	    pub(crate) cache: Alg::Cache,
41855e679d54051e92604b2f6e02ffbd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|112|1|V|rust
	    /// Solution object
78f973086722b2d828e90202549e1193|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|112|5|V|rust
	    pub sol: OdeSolution,
6f38749387f4c3c6543d98dc1b4462be|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|110|1|V|rust
	    /// Statistics
7a35bb1c9bb115620bf836f12b3ead6f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|110|5|V|rust
	    pub stats: OdeStatistics,
03bc68156072d7e6b5a9ca79edaa6649|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|35|5|v|rust
	/// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
34ec7e16b85043505b65e8a29b6d7323|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|190|12|V|rust
	            /// Function structure representing the RHS of the ODE.
c1b91e47b726e1db9ea1a0f25a85ee84|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|191|13|V|rust
	            /// Mass matrix for DAE.
0a356e5a358aad384d97a5d6f7987aa2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|192|13|V|rust
	            /// Current solution vector
70733ee0a433c596d2b58de8b0e73b3b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|193|13|V|rust
	            /// Current time
3dc119b02b4011b25008d6d21401902c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|194|13|V|rust
	            /// Current step size
33e187771fa20d518853b13c33ee2d53|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|195|13|V|rust
	            /// Previous solution vector
d8c8e3cc0ac202dd3cd3cc8bae7e8d8f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|196|13|V|rust
	            /// Previous time
cde7d0e449b0ab0eb89a4abb67a7bcb9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|197|13|V|rust
	            /// Previous step size
60e2b8e43dbcdf508455c434f5b49000|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|198|13|V|rust
	            /// Direction of integration.
babd4e4110c59dd9d6a0975d9442b9c8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|199|13|V|rust
	            /// Final time value
571e3605960480073c5720afb0418443|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|200|13|V|rust
	            /// Options
81dd1298dcd4ceb45464c8c05da7a8e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|201|13|V|rust
	            /// Statistics
624b28f76574d5ffffba8f96241dba72|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|202|13|V|rust
	            /// Solution object
d94a525d85fefadb2e7c3d32ab9c9e52|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|203|13|V|rust
	            /// Cache associated with the algorithm
59e358dee6970c8bf4d57fbb66df2f45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|190|13|v|rust
	pub 
2ed5fbc00c5496eb6e658e3898cdb6b1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|191|26|v|rust
	Option<Array2<f64>>
76de63165fa08a3ca7ce440e78756cf5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|192|16|v|rust
	Array1<f64>
d906600cd39348b997294e2e33f02c2f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|195|25|v|rust
	uprev
6221ceabef98e686c3b0dd6f3209d9d3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|200|19|v|rust
	OdeIntegratorOpts
5dba3bc566188e0ff94c7f6f4cdad00e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|204|18|v|rust
	: Alg::new_cache(),
7c3e6a21965d0265ecd0bb13d2395c3d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    /// Previous solution vector
be3c067dd79c480f7d7b5905a9b46869|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    pub uprev: Array1<f64>,
4800f3341220595505d18004c24ff58a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    /// Previous time
7e267cf52b3deb0c4fdb37306123e54e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    pub tprev: f64,
357f587e1fa5431c5dcf976f6cbe3652|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    /// Previous step size
cdbcd4fd93b6ba1097d6c7b4ae4401cd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|98|5|V|rust
	    pub dtprev: f64,
112ee35848b9b00afbc113ae2bbf9958|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|108|9|v|rust
	Alg::init(prob)
0ff917db248a2d971f8fce4186e0e70d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|20|5|V|rust
	    /// Construct an integrator.
a34257bb71a73062174ec850aef08384|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|20|5|V|rust
	    fn init<T: OdeFunction>(prob: OdeProblem<T>) -> OdeIntegrator<T, Self>
21b7e098483df42ef6ac4767cdf95641|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|20|9|V|rust
	        Self: Sized;
708e7efe97e8424cdc9b56f69e11acac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|9|25|v|rust
	OdeIntegratorBuilder
2bd4a59bb5a32ded63b98eea556ca87a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|9|38|v|rust
	Builder
1881923c9565993f366d0e0fe53b3bd5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|11|1|V|rust
	use super::problem::OdeProblem;
ada6f2a06a5527a64de5fe4355876f89|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|11|9|v|rust
	let opts = OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: prob.tspan.1 - prob.tspan.0,
	            max_steps: 100000,
	            beta: 0.04,
	            max_newt_iter: 0,
	            max_stiff: 1000,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 10.0,
	            facl: 0.2,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	        };
a909c9bf46f2fa27ae5ccbfe8f262bd5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|7|9|v|rust
	let opts = 
52b6e73572e406a1e31fbfa0cca5eb32|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|12|20|v|rust
	.tspan.1 - prob.tspan.0,
e37f0136aa3ffaf149b351f6a4c948e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|28|8|v|rust
	init
b23a8e511b57c233cf670a1bfe33b8ff|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|29|9|V|rust
	        Self: Sized,
54e6948c5050b58c76f2479d51ebd65f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|28|58|v|rust
	OdeIntegrator<T, Self>
441bcdf6a5ee7e1c4fa51baf27e5a330|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        let mut func = prob.func;
3f84f4110c079a27904f76793c3b8647|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        // Initialize the solution
cba5161504cbcdfba9d2d0615aefadee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        let mut sol = OdeSolution::new();
174f07f09050b8c12b516841b44a0750|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        sol.ts.push(prob.tspan.0);
3ca93a89179c9577cef3cda8927ece62|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        sol.us.push(prob.uinit.clone());
79bba27e155693436a6a69bd7575dbfe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|31|9|V|rust
	        // Initialize the cache
3e2f3e7ebd4f79da2c57281305efb7e1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|30|9|v|rust
	let n = prob.uinit.len();
	
	        DormandPrince5Cache {
	            n_stiff: 0,
	            n_nonstiff: 0,
	            reject: false,
	            last: false,
	            facold: 0.0, // previous ratio of dtnew/dt
	            dtlamb: 0.0,
	            k2: Array1::<f64>::zeros(n),
	            k3: Array1::<f64>::zeros(n),
	            k4: Array1::<f64>::zeros(n),
	            k5: Array1::<f64>::zeros(n),
	            k6: Array1::<f64>::zeros(n),
	            rcont1: Array1::<f64>::zeros(n),
	            rcont2: Array1::<f64>::zeros(n),
	            rcont3: Array1::<f64>::zeros(n),
	            rcont4: Array1::<f64>::zeros(n),
	            rcont5: Array1::<f64>::zeros(n),
	            unew: Array1::<f64>::zeros(n),
	            du: Array1::<f64>::zeros(n),
	            dunew: Array1::<f64>::zeros(n),
	            uerr: Array1::<f64>::zeros(n),
	            ustiff: Array1::<f64>::zeros(n),
	        }
4c4164a5c90f3b690d92514d6605e242|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|30|8|V|rust
	        let mut cache = super::cache::DormandPrince5Cache::new(&prob);
abc4537aef0ed1a4a363d18c77adae60|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|28|46|v|rust
	OdeProblem
b5c841bb14184e91dfed355f9b444cd9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|30|28|v|rust
	uinit
3cc98edc8bb5c73c76277db8ec3447e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|28|1|V|rust
	impl DormandPrince5Cache {
d457ec84474c315076d10530dd2fa805|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|28|5|V|rust
	    pub(crate) fn new<T: OdeFunction>(prob: &OdeProblem<T>) -> DormandPrince5Cache {
69515621a2ff5692b85a8f2e2c542017|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/cache.rs|1|1|V|rust
	use crate::ode::{OdeFunction, OdeProblem};
f03f1ee7db4e757e8bdcb26920a215a7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|33|30|v|rust
	DormandPrince5::init(prob);
a7914f86af79b3a14e0bc8132cb98e4c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|88|47|v|rust
	, Alg: OdeAlgorithm
d4f633e84ad5a9c913284f26a384b3f0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|108|64|v|rust
	OdeAlgorithm
8f1d1a303d6b7cd2f3d034add31e8a8c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|107|44|v|rust
	c Alg
402f3e7583053fdd5003a0b01f70c07c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|111|32|v|rust
	, Alg
9908ab48f4c98632f93eaf0547863ddc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|110|19|v|rust
	<Alg: OdeAlgorithm>
ff6dea5b8ceb0c3805c46e49a084caa4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|112|9|V|rust
	        alg: Alg,
9d051fbd93c697ecf2ade3ad6a12573c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|19|1|V|rust
	        where
	            Self:Sized;
2fa8b313824973dd3fa5bb9575468e64|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|197|9|V|rust
	        let u = 
dbca2f9a58d514ccc7c01ffc123372b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|34|9|V|rust
	        prob.uinit;
874ddec47f3eed0c0b0997a8f327d0d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|109|20|v|rust
	 + Clone
e617c4b47615798b4757bd048396cb47|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|112|28|v|rust
	.clone(
d154adcacce92bccbb1aba2b7e9b8b88|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|18|1|V|rust
	//! let mut integrator = DormandPrince5::init(&prob);
e590b6c602e81cfced41d844b0a0a857|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|121|17|v|rust
	: Alg::default_opts()
b79549d36af3cd0543d2b01b446dc10e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|39|35|v|rust
	dbg!(
cbc0fc2cc96241bd0cb6bb9bd25f9770|term://.//62126%3A/bin/zsh|10023|88|v|floaterm
	0.000000009999999999998334
c08ccb3bd58cfbe2170eb83f87dedd30|term://.//62126%3A/bin/zsh|10022|40|v|floaterm
	0.00000009114583333328819
a92afecfed7e8173f913665a61883109|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|212|18|v|rust
	OdeSolution::new()
f4c74256ff91138c2520241ede1c2788|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|52|1|V|rust
	            du: Array1::<f64>::zeros(n),
3fbe116bbfbe9f9267d1b05c6ca6bede|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|57|17|v|rust
	Array1::<f64>::zeros(n)
657597bcc622d4068cae808d7468c866|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|36|22|v|rust
	integrator.u[0]
784ed8acda938eab30ad65aa64714c9a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|36|40|v|rust
	integrator.t.sin()
c6b72fdb6d6f7ded8f8be20d62eb085b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|11|9|v|rust
	let mut opts = OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: prob.tspan.1 - prob.tspan.0,
	            max_steps: 100000,
	            beta: 0.04,
	            max_newt_iter: 0,
	            max_stiff: 1000,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 10.0,
	            facl: 0.2,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	        };
ad90ec51a6af20e868551cab03c57c36|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|8|9|v|rust
	let mut opts = 
bc956eee84370b9608057131d534b3b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|13|20|v|rust
	prob.tspan.1 - prob.tspan.0,
5bc0656bcb60c055cd748f0f2790729e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|35|9|v|rust
	let quot = opts.abstol / opts.reltol;
	        opts.reltol = 0.1 * opts.reltol.powf(2.0 / 3.0);
	        opts.abstol = opts.reltol * quot;
	
	        opts.fnewt = if opts.fnewt == 0.0 {
	            (10.0 * f64::EPSILON / opts.reltol).max(0.03f64.min(opts.reltol.sqrt()))
	        } else {
	            opts.fnewt
	        };
	
	        let dt = opts
	            .dtstart
	            .abs()
	            .min(opts.dtmax)
	            .copysign(prob.tspan.1 - prob.tspan.0);
	
	        for i in (0)..prob.uinit.len() {
	            cache.scal[i] = opts.abstol + opts.reltol * prob.uinit[i].abs();
	        }
	
	        let mut func = prob.func;
	        // Initialize the solution
	        let mut sol = OdeSolution::new();
	        sol.ts.push(prob.tspan.0);
	        sol.us.push(prob.uinit.clone());
	
	        let mut stats = OdeStatistics::new();
	
	        // Initialize the cache
	        func.dudt(cache.u0.view_mut(), prob.uinit.view(), prob.tspan.0);
	        stats.function_evals += 1;
	
	
949138456aa6994f886acf67e0882c06|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|39|9|V|rust
	        integrator.stats.function_evals += 1;
3af6af5f58445e814d0ba0cd211dc084|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|64|5|v|rust
	fn init<T: OdeFunction>(prob: OdeProblem<T>) -> OdeIntegrator<T, Self> {
	        let mut cache = Radau5Cache::new(&prob).unwrap();
	
	        let quot = opts.abstol / opts.reltol;
	        opts.reltol = 0.1 * opts.reltol.powf(2.0 / 3.0);
	        opts.abstol = opts.reltol * quot;
	
	        opts.fnewt = if opts.fnewt == 0.0 {
	            (10.0 * f64::EPSILON / opts.reltol).max(0.03f64.min(opts.reltol.sqrt()))
	        } else {
	            opts.fnewt
	        };
	
	        let dt = opts
	            .dtstart
	            .abs()
	            .min(opts.dtmax)
	            .copysign(prob.tspan.1 - prob.tspan.0);
	
	        for i in (0)..prob.uinit.len() {
	            cache.scal[i] = opts.abstol + opts.reltol * prob.uinit[i].abs();
	        }
	
	        let mut func = prob.func;
	        // Initialize the solution
	        let mut sol = OdeSolution::new();
	        sol.ts.push(prob.tspan.0);
	        sol.us.push(prob.uinit.clone());
	
	        let mut stats = OdeStatistics::new();
	
	        // Initialize the cache
	        func.dudt(cache.u0.view_mut(), prob.uinit.view(), prob.tspan.0);
	        stats.function_evals += 1;
	
	        OdeIntegrator {
	            func,
	            mass_matrix: prob.mass_matrix,
	            u: prob.uinit.clone(),
	            t: prob.tspan.0,
	            dt: 1e-6,
	            uprev: prob.uinit.clone(),
	            tprev: prob.tspan.0,
	            dtprev: 1e-6,
	            tdir: if prob.tspan.1 > prob.tspan.0 {
	                1.0
	            } else {
	                0.0
	            },
	            tfinal: prob.tspan.1,
	            sol,
	            stats,
	            opts,
	            cache,
	        }
	    }
e38502749f773d33ee02de5c2f61d6f3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|15|19|v|rust
	0.04
f7ca00579f7aa800ec37e1eb7f1f60df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|4|1|V|rust
	    /// Relative tolerance
	    pub reltol: f64,
	    /// Absolute tolerance
	    pub abstol: f64,
	    /// Flag specifying if dense output is requested
	    pub dense: bool,
	    /// Initial step value
	    pub dtstart: f64,
	    /// Maximum allowed step size
	    pub dtmax: f64,
	    /// Maximum number of allowed steps
	    pub max_steps: usize,
	    /// Maximum number of allowed newton iterations.
	    pub max_newt_iter: usize,
	    /// Maximum number of stiff detections allowed
	    pub max_stiff: usize,
	    /// If true, use modern predictive controller (Gustafsson).
	    pub modern_pred: bool,
	    /// Safety factor used in adaptive step selection.
	    pub safe: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
	    pub facr: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
	    pub facl: f64,
	    /// Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot1: f64,
	    /// Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot2: f64,
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
	    /// and Wanner's book.)
	    pub beta: f64,
	    /// The amount to decrease the timestep by if the Newton iterations of an
	    /// implicit method fail.
	    pub fnewt: f64,
	    /// If true, the extrapolated collocation solution is taken as the starting
	    /// value of the Newton iteration.
	    pub use_ext_col: bool,
	    /// If true, the Jacobian will be converted into Hessenberg form.
	    pub hess: bool,
	    /// Decides whether the Jacobian should be recomputed.
	    pub theta: f64,
dbd07650ddfcf8eea1986f893b8fbe30|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|50|5|V|rust
	    /// Relative tolerance
cb0ef341bfe1f98b2470571d810f15f4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|51|5|V|rust
	    /// Absolute tolerance
908d1217cb0a01edcc7868feaf9a4195|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|52|5|V|rust
	    /// Flag specifying if dense output is requested
aa36dd3a340a0dc74ee5c4af3c230605|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|53|5|V|rust
	    /// Initial step value
0f1524841b651592a259221347a02d78|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|54|5|V|rust
	    /// Maximum allowed step size
22760c8ca1850cefe5ef308e5c0b3fa4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|55|5|V|rust
	    /// Maximum number of allowed steps
a06c4f6c32ab7ec1783310db3f035672|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|56|5|V|rust
	    /// Maximum number of allowed newton iterations.
0489c744110b49d8554b2da1d2904227|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|57|5|V|rust
	    /// Maximum number of stiff detections allowed
141c19312ceeed323159e2943d27527f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|58|5|V|rust
	    /// If true, use modern predictive controller (Gustafsson).
ab7ff29241fbcb3d2c9d11f15c6d2131|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|59|5|V|rust
	    /// Safety factor used in adaptive step selection.
2e150767c658eed9d7e539c58adf7f13|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|60|5|V|rust
	    /// Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
e4bdbc27a270c3c12ed1639c40f7094e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|61|5|V|rust
	    /// Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
52d3fa54014854148ecebfa5a44ec22c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|62|5|V|rust
	    /// Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
fe1ac558e0811c726d6f18657f1df170|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|63|5|V|rust
	    /// Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
0cd39938d0747eddaf4ff01c99f1dab2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|64|5|V|rust
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
681b19399e32e14c461fc1f41a61852e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|64|5|V|rust
	    /// and Wanner's book.)
718e3f7f8d487ad245e83dc55bcf9b2e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|65|5|V|rust
	    /// The amount to decrease the timestep by if the Newton iterations of an
afe7f75294218b4176e8f754a690600d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|65|5|V|rust
	    /// implicit method fail.
42fec0372bbeba3642ef0b1aa85757af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|66|5|V|rust
	    /// If true, the extrapolated collocation solution is taken as the starting
8e36d87916cdb9a3314ed1c98eedfdeb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|66|5|V|rust
	    /// value of the Newton iteration.
4d7e4148aaaa6b8df14884ae7e91fc6a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|67|5|V|rust
	    /// If true, the Jacobian will be converted into Hessenberg form.
aaceb38ee3360adcc68a67f3b43dfcd5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|68|5|V|rust
	    /// Decides whether the Jacobian should be recomputed.
fb655b4365c4c502949405eacb4fe047|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|50|20|v|rust
	f64,
b537f1404cc47d665a8a876a3ae9ad3d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|52|19|v|rust
	bool,
43bfe46c21abf57a149388ccda6c741f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|55|23|v|rust
	usize,
89bee242d567d0bed0dcc83cedf9a73f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|53|12|V|rust
	           dtstart: 0.0,
68934a3e9455fa72420237eb05902327|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|66|25|v|rust
	false
22c125ce2146dd15b660a12945c2ae5c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|18|1|V|rust
	        OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-6,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: f64::INFINITY,
	            max_steps: 100000,
	            beta: 0.04,
	            max_newt_iter: 0,
	            max_stiff: 1000,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 10.0,
	            facl: 0.2,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	            theta: 0.0,
	        }
9910aeb54a86e168909e425d53d96be9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|11|1|V|rust
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.beta = 0.04;
	        opts.facr = 10.0;
	        opts.facl = 0.2;
	        opts.max_stiff = 1000;
	        opts.max_steps = 100000;
	        opts
94369891d9464e5d5da8e300651c0589|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|9|V|rust
	        OdeIntegratorOpts {
24712dcc20fe2d8f1d411490aeb130c0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|V|rust
	            reltol: 1e-3,
97857f3b5a6f24502864f7bafe891933|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|V|rust
	            abstol: 1e-6,
7befbbbc467326ced26b6b222b134358|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|V|rust
	            dense: false,
1115ce16f7ced8a7274d446099ea3840|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|V|rust
	            dtstart: 1e-6,
242b951d349c76a00b0d6bd45ee17093|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|V|rust
	            dtmax: f64::INFINITY,
7f7245c2ca7591ca42bf1f12ea3eed0f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|13|v|rust
	max_steps: 100000,
	            beta: 0.0,
	            max_newt_iter: 7,
	            max_stiff: 1000,
	            modern_pred: false,
	            safe: 0.9,
	            facr: 10.0,
	            facl: 0.2,
	            quot1: 0.0,
	            quot2: 0.0,
	            fnewt: 0.0,
	            use_ext_col: false,
	            hess: false,
	        }
	
1399264e87cb52b6f45954458f16f38d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|17|9|V|rust
	        opts.max_stiff = 1000;
e4816d92d89d8b4a075f4b9dd4e4fe1a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|9|V|rust
	        opts.fnewt = if opts.fnewt == 0.0 {
6806004021f34a04e9bdad07ae8a5e86|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|13|V|rust
	            (10.0 * f64::EPSILON / opts.reltol).max(0.03f64.min(opts.reltol.sqrt()))
7e7a769bd66e87d92cd8aefb0fa968f9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|13|V|rust
	            opts.fnewt
8ccca0da322848d90eb99a43f41505dc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|1|V|rust
	        let dt = opts
4aaba83254c41f042c0884be64019a8a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|13|V|rust
	            .dtstart
cbb4b1af7ef911548cd3c7a3f475bab5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|13|V|rust
	            .min(opts.dtmax)
4be4ff815da75f73a1e35ad4ddabfdb9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|13|V|rust
	            .copysign(prob.tspan.1 - prob.tspan.0);
d259af498a3a73107cb4500e6536bc39|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|48|5|v|rust
	/// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub num_index1_vars: usize,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub num_index2_vars: usize,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub num_index3_vars: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m1: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m2: usize,
	    /// Upper bandwidth of the Jacobian
	    pub jac_ubw: usize,
	    /// Lower bandwidth of the Jacobian
	    pub jac_lbw: usize,
	    /// Upper bandwidth of the mass matrix
	    pub mm_ubw: usize,
	    /// Lower bandwidth of the mass matrix
	    pub mm_lbw: usize,
9a1e53953b0ae0eca02f9d3bc3941aea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|88|1|V|rust
	/// Number of index 1 variables. For ODEs, this is equal to the size of the
9f10da938992118aa52b4229304c8ef5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|88|5|V|rust
	    /// system
f20a3587a47a96727121519fe2a9c1df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|89|5|V|rust
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
0d107ff30417cc7a7ddde139f2dc2c8d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|90|5|V|rust
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
c7b7175f54689bf5da186902f40d999c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|91|5|V|rust
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
63f75ca2c67887fd8d9127324b609782|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|93|5|V|rust
	    /// Upper bandwidth of the Jacobian
ffec78ca37061a7eefced65d888dcc3a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|94|5|V|rust
	    /// Lower bandwidth of the Jacobian
de0767549773459d70b2c777a16b0110|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|95|5|V|rust
	    /// Upper bandwidth of the mass matrix
2707c0abc4d9120ad665938ec935b73d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|96|5|V|rust
	    /// Lower bandwidth of the mass matrix
eb4112b6a6b76c8a84808a40baa94769|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|114|32|v|rust
	opts
5acad1c03824fd04272a5854f401175d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|114|1|V|rust
	        opts.num_index1_vars = prob.num_index1_vars;
f244ece894925a9d835f1b40ee4894a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|117|1|V|rust
	        opts.jac_ubw = prob.jac_ubw;
978007c78a0a1a102837001994fa7388|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|117|1|V|rust
	        opts.jac_ubw = prob.jac_ubw;
	        opts.jac_lbw = prob.jac_lbw;
a3d2c697bcfc9fe8e85f4d4962d3fd24|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|72|9|v|rust
	let n = prob.uinit.shape()[0];
	        let nm1 = n - prob.m1;
	        let implct = prob.mass_matrix.is_none();
	        let jband = prob.jac_lbw < nm1;
	
	        let mut prob_type = 1;
	
	        let (mljac, mujac, ldjac, lde1) = if jband {
	            (
	                prob.jac_lbw,
	                prob.jac_ubw,
	                prob.jac_lbw + prob.jac_ubw + 1,
	                2 * prob.jac_lbw + prob.jac_ubw + 1,
	            )
	        } else {
	            (nm1, nm1, nm1, nm1)
	        };
	        let mut mlmas = prob.mm_lbw;
	        let mut mumas = prob.mm_ubw;
	        let mut ldmas = 1;
	        if implct {
	            if prob.mm_lbw != nm1 {
	                ldmas = mlmas + mumas + 1;
	                prob_type = if jband { 4 } else { 3 };
	            } else {
	                mumas = nm1;
	                mlmas = nm1;
	                prob_type = 5;
	            }
	        } else {
	            ldmas = 0;
	            if jband {
	                prob_type = 2;
	            } else {
	                prob_type = 1;
	                //TODO: Should fix this to allow for hess
	                //if n > 2 && opts.hess {
	                //    prob_type = 7;
	                //}
	            }
	        }
	        ldmas = ldmas.max(1);
	
	        if (implct || jband) && prob_type == 7 {
	            return Err(Radau5CacheErr::HessErr);
	        }
	
	        if prob.m1 > 0 {
	            prob_type += 10;
	        }
	
	        let mle = mljac;
	        let mue = mujac;
	        let mbjac = mljac + mujac + 1;
	        let mbb = mlmas + mumas + 1;
	        let mdiag = mle + mue;
	        let mdiff = mle + mue - mumas;
	        let mbdiag = mumas + 1;
	
	        Ok(Radau5Cache {
	            prob_type,
	            implct,
	            jband,
	            caljac: false,
	            calhes: false,
	            first: true,
	            reject: false,
	            mujac,
	            mljac,
	            mumas,
	            mlmas,
	            m1: prob.m1,
	            m2: prob.m2,
	            nind1: prob.num_index1_vars,
	            nind2: prob.num_index2_vars,
	            nind3: prob.num_index3_vars,
	            mle,
	            mue,
	            mbjac,
	            mbb,
	            mdiag,
	            mdiff,
	            mbdiag,
	            ldmas,
	            ldjac,
	            lde1,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            u0: Array1::<f64>::zeros(n),
	            scal: Array1::<f64>::zeros(n),
	            /// Coninuous output vectors
	            cont: Array1::<f64>::zeros(4 * n),
	            z1: Array1::<f64>::zeros(n),
	            z2: Array1::<f64>::zeros(n),
	            z3: Array1::<f64>::zeros(n),
	            f1: Array1::<f64>::zeros(n),
	            f2: Array1::<f64>::zeros(n),
	            f3: Array1::<f64>::zeros(n),
	            ip1: Array1::<i32>::zeros(nm1),
	            ip2: Array1::<i32>::zeros(nm1),
	            iphes: Array1::<i32>::zeros(nm1),
	            e1: Array2::<f64>::zeros((lde1, nm1)),
	            e2r: Array2::<f64>::zeros((lde1, nm1)),
	            e2i: Array2::<f64>::zeros((lde1, nm1)),
	            dfdu: Array2::<f64>::zeros((ldjac, n)),
	            mass_matrix: Array2::<f64>::zeros((ldmas, nm1)),
	        })
c880470e50cce2e0c8d69365b1044cff|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|25|29|v|rust
	.uinit
7df4935f4a5a2865191ef74f64df8754|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|90|9|v|rust
	func
fcea0e29ca9dfa4d4359f32dc969c44a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|89|9|v|rust
	Function structure representing the RHS of the ODE.
aa7df1f28138982b360fbb13917f0ea2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|101|5|V|rust
	    /// Final time value
cd553646cf2dc5c366effac730de6f0a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|101|5|V|rust
	    pub tfinal: f64,
eeb2f0e9faf52d825d116ed2958c5831|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|108|9|v|rust
	opts.m1 = prob.m1;
	        opts.m2 = prob.m2;
	        opts.num_index1_vars = prob.num_index1_vars;
	        opts.num_index2_vars = prob.num_index2_vars;
	        opts.num_index3_vars = prob.num_index3_vars;
	        opts.jac_ubw = prob.jac_ubw;
	        opts.jac_lbw = prob.jac_lbw;
	        opts.mm_ubw = prob.mm_ubw;
	        opts.mm_lbw = prob.mm_lbw;
639ecd8ddbee4e0ae4e3f0276d7d3a39|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|111|14|v|rust
	prob.func
bee335985f22c37da6a9dd31543c335f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|119|13|V|rust
	            tfinal: prob.tspan.1,
fc956eef299a066df2d5cb4020850399|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|113|1|V|rust
	            prob,
ec07052a2ba68f4100020e78ce8b8b88|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|110|9|V|rust
	        let u = prob.uinit.clone();
c960d56a536af9b9205583c96e0e9844|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|201|13|v|rust
	func: self.func,
3525d9eb4544744fd10d8962b3bd6f1c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|210|13|V|rust
	            tfinal: self.tfinal,
fd50675c7836a77f8d6699e977434c99|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|88|1|V|rust
	            num_index1_vars: 0,
	            num_index2_vars: 0,
	            num_index3_vars: 0,
	            m1: 0,
	            m2: 0,
	            jac_ubw: 0,
	            jac_lbw: 0,
	            mm_ubw: 0,
	            mm_lbw: 0,
3e975e05fde918dbefd9ed4e877322e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|45|9|V|rust
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub num_index1_vars: usize,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub num_index2_vars: usize,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub num_index3_vars: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m1: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m2: usize,
	    /// Upper bandwidth of the Jacobian
	    pub jac_ubw: usize,
	    /// Lower bandwidth of the Jacobian
	    pub jac_lbw: usize,
	    /// Upper bandwidth of the mass matrix
	    pub mm_ubw: usize,
	    /// Lower bandwidth of the mass matrix
	    pub mm_lbw: usize,
16bc95634a3134b39ce073faf7c4c1f6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|59|62|v|rust
	tfinal
28e6f3e248148e93abdca3e4d4ca9fb0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|135|9|v|rust
	for i in (0)..integrator.u.len() {
	            cache.scal[i] = opts.abstol + opts.reltol * prob.uinit[i].abs();
	        }
	
	        let mut func = prob.func;
	        // Initialize the solution
	        let mut sol = OdeSolution::new();
	        sol.ts.push(prob.tspan.0);
	        sol.us.push(prob.uinit.clone());
	
	        let mut stats = OdeStatistics::new();
	
	        // Initialize the cache
	        func.dudt(cache.u0.view_mut(), prob.uinit.view(), prob.tspan.0);
	        stats.function_evals += 1;
cd7f75fcf2e360f3a9857a337816ad98|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|153|8|V|rust
	        cache
13ee9e0dd423b66b2625ffe17b1fa710|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|89|1|V|rust
	        let mut stats = OdeStatistics::new();
a6ca8b3564046069e9b5e65c21e4cb22|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|106|1|V|rust
	            m1: integrator.prob.m1,
	            m2: integrator.prob.m2,
	            nind1: integrator.prob.num_index1_vars,
	            nind2: integrator.prob.num_index2_vars,
	            nind3: integrator.prob.num_index3_vars,
b37995c8526bc3ce8f39d35449929174|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|120|1|V|rust
	            u0: Array1::<f64>::zeros(n),
a7d5da6c309128b65c01d156515a6300|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|94|34|v|rust
	prob.uinit
b2da110f349bba3d66aa0585cf413eea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|94|67|v|rust
	prob.tspan.0
e5704d57208418780896ebbcb43fae28|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|70|1|V|rust
	impl Radau5Cache {
	    pub(crate) fn new<T: OdeFunction>(prob: &OdeProblem<T>) -> Result<Radau5Cache, Radau5CacheErr> {
	        let n = prob.uinit.shape()[0];
	        let nm1 = n - prob.m1;
	        let implct = prob.mass_matrix.is_none();
	        let jband = prob.jac_lbw < nm1;
	
	        let mut prob_type = 1;
	
	        let (mljac, mujac, ldjac, lde1) = if jband {
	            (
	                prob.jac_lbw,
	                prob.jac_ubw,
	                prob.jac_lbw + prob.jac_ubw + 1,
	                2 * prob.jac_lbw + prob.jac_ubw + 1,
	            )
	        } else {
	            (nm1, nm1, nm1, nm1)
	        };
	        let mut mlmas = prob.mm_lbw;
	        let mut mumas = prob.mm_ubw;
	        let mut ldmas = 1;
	        if implct {
	            if prob.mm_lbw != nm1 {
	                ldmas = mlmas + mumas + 1;
	                prob_type = if jband { 4 } else { 3 };
	            } else {
	                mumas = nm1;
	                mlmas = nm1;
	                prob_type = 5;
	            }
	        } else {
	            ldmas = 0;
	            if jband {
	                prob_type = 2;
	            } else {
	                prob_type = 1;
	                //TODO: Should fix this to allow for hess
	                //if n > 2 && opts.hess {
	                //    prob_type = 7;
	                //}
	            }
	        }
	        ldmas = ldmas.max(1);
	
	        if (implct || jband) && prob_type == 7 {
	            return Err(Radau5CacheErr::HessErr);
	        }
	
	        if prob.m1 > 0 {
	            prob_type += 10;
	        }
	
	        let mle = mljac;
	        let mue = mujac;
	        let mbjac = mljac + mujac + 1;
	        let mbb = mlmas + mumas + 1;
	        let mdiag = mle + mue;
	        let mdiff = mle + mue - mumas;
	        let mbdiag = mumas + 1;
	
	        Ok(Radau5Cache {
	            prob_type,
	            implct,
	            jband,
	            caljac: false,
	            calhes: false,
	            first: true,
	            reject: false,
	            mujac,
	            mljac,
	            mumas,
	            mlmas,
	            m1: prob.m1,
	            m2: prob.m2,
	            nind1: prob.num_index1_vars,
	            nind2: prob.num_index2_vars,
	            nind3: prob.num_index3_vars,
	            mle,
	            mue,
	            mbjac,
	            mbb,
	            mdiag,
	            mdiff,
	            mbdiag,
	            ldmas,
	            ldjac,
	            lde1,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            u0: Array1::<f64>::zeros(n),
	            scal: Array1::<f64>::zeros(n),
	            /// Coninuous output vectors
	            cont: Array1::<f64>::zeros(4 * n),
	            z1: Array1::<f64>::zeros(n),
	            z2: Array1::<f64>::zeros(n),
	            z3: Array1::<f64>::zeros(n),
	            f1: Array1::<f64>::zeros(n),
	            f2: Array1::<f64>::zeros(n),
	            f3: Array1::<f64>::zeros(n),
	            ip1: Array1::<i32>::zeros(nm1),
	            ip2: Array1::<i32>::zeros(nm1),
	            iphes: Array1::<i32>::zeros(nm1),
	            e1: Array2::<f64>::zeros((lde1, nm1)),
	            e2r: Array2::<f64>::zeros((lde1, nm1)),
	            e2i: Array2::<f64>::zeros((lde1, nm1)),
	            dfdu: Array2::<f64>::zeros((ldjac, n)),
	            mass_matrix: Array2::<f64>::zeros((ldmas, nm1)),
	        })
	    }
	}
dfd1749653d1c4e49b87e03e3985d8d9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|55|1|V|rust
	pub(crate) enum Radau5CacheErr {
	    HessErr,
	}
	
	impl std::fmt::Debug for Radau5CacheErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            Radau5CacheErr::HessErr => write!(
	                f,
	                "Hessenberg option only for explicit equations with full Jacobian.",
	            ),
	        }
	    }
	}
	
0442d8114a0f466b8abc4d7efd68155f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|1|v|rust
	    pub(crate) m1: usize,
66b304dea022bcca51dff6d978b2fb23|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|1|V|rust
	j
	    pub(crate) m2: usize,
	    pub(crate) nind1: usize,
	    pub(crate) nind2: usize,
	    pub(crate) nind3: usize,
895012bfacfb2b8fdf09ffdd17fd93d9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|1|1|V|rust
	use super::Radau5;
7fcc01b870a0dddbf3678c9389563d54|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|1|1|V|rust
	use crate::ode::{OdeFunction, OdeIntegratorOpts, OdeProblem};
06a47323788330cbf3f8ba36090346d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|123|1|V|rust
	            scal: Array1::<f64>::zeros(n),
83d8a5b480ea93420fa594662efcbc4a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|85|1|V|rust
	        for i in (0)..integrator.u.len() {
	            cache.scal[i] = opts.abstol + opts.reltol * prob.uinit[i].abs();
	        }
64fcf4e8a269a000e43f4d646ccb689e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|61|10|V|rust
	                //TODO: Should fix this to allow for hess
1f90f5b9f4d11f802bc9645e2d5f0d50|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|69|12|V|rust
	            return Err(Radau5CacheErr::HessErr);
bd3d6529da02c1fb8eca200efe9d8a82|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|8|38|v|rust
	cache: &mut Radau5Cache
576309daa99cb7166ad476efa94a8df0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|420|1|V|rust
	                    integrator.cache.ip2.view_mut(),
0c03e6a11a546095231e65c122dab25d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|183|34|v|rust
	&self, integrator.cache: &mut Radau5Cache
157143db2745ba7ba0dc2f05af31e1a9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|1|1|V|rust
	use super::integrator.cache::Radau5Cache;
0d52db1be3e76a2e50a45831d689f1f9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|421|1|V|rust
	                        integrator.cache.e2i[[i + integrator.cache.mle, j]] -= sumi;
658b75b8f3f0d117801fe453248f7353|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|408|1|V|rust
	                let abno = integrator.cache.alphn * integrator.cache.alphn + integrator.cache.betan * cache.betan;
	                let alp = integrator.cache.alphn / abno;
	                let bet = integrator.cache.betan / abno;
	                for j in 0..integrator.cache.m2 {
	                    for i in 0..integrator.cache.mbjac {
	                        let mut sumr = 0.0;
	                        let mut sumi = 0.0;
	                        for k in 0..mm {
	                            let sums = sumr + integrator.cache.dfdu[[i, j + k * integrator.cache.m2]];
	                            sumr = sums * alp + sumi * bet;
	                            sumi = sumi * alp - sums * bet;
	                        }
	                        integrator.cache.e2r[[i + integrator.cache.mle, j]] -= sumr;
d1f6b6ae6899bc36e5bac5fb0e54d90d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|408|1|V|rust
	                let abno = integrator.cache.alphn * integrator.cache.alphn + integrator.cache.betan * cache.betan;
9e04e16431da7fa170b651e88e88d883|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|408|1|V|rust
	                let abno = integrator.cache.alphn * integrator.cache.alphn + integrator.cache.betan * integrator.cache.betan;
bd24b8c1c32060cc7ef9743ab88a0710|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|356|1|V|rust
	                        integrator.cache.e2r[[i + integrator.cache.mle, j]] = -integrator.cache.dfdu[[i, j + integrator.cache.m1]];
985fbeec1fbc0e98288ff845494ce441|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|335|1|V|rust
	                    integrator.cache.e2i[[integrator.cache.mdiag, j]] += integrator.cache.betan;
1c7393c1d158168c2d5dcfafa286b4f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|463|1|V|rust
	                let mm = integrator.c[prob.m1 / integrator.cache.m2;
a18cb6b97399d83c45a284e4323bd392|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|474|1|V|rust
	                                sumr + integrator.cache.dfdu[[i, j + k * integrator.c[prob.m2]];
cf80fd5d14a785b6120a09f215fa1112|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|42|5|V|rust
	    /// Mass matrix for DAE.
beeff074ca88eaf4ea6e5a66bfdc043d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|42|5|V|rust
	    pub mass_matrix: Option<Array2<f64>>,
66cd5adbb1d132a1400906a65eb9f374|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|10|1|V|rust
	impl std::fmt::Debug for OdeProblemBuildErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            OdeProblemBuildErr::InvalidIndexPars(idx1, idx2, idx3) => write!(
	                f,
	                "Invalid index varibles: {}, {}, {}. Sum must be equal to size of the system.",
	                idx1, idx2, idx3
	            ),
	            OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2) => write!(
	                f,
	                "Invalid 2nd order parameters: m1={}, m2={}. Sum must be less that size of system.",
	                m1, m2
	            ),
	            OdeProblemBuildErr::InvlaidMassBw(jl, ju, ml, mu) => write!(
	                f,
	                "Bandwidth of mass matrix cannot be larger than bandwidths of Jacobian: jl = {}, \
	                ju = {}, ml = {}, mu = {}.",
	                jl, ju, ml, mu
	            ),
	        }
	    }
	}
117165d7e4e1022e36626269f73d187d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|4|1|V|rust
	pub enum OdeProblemBuildErr {
	    InvalidIndexPars(usize, usize, usize),
	    Invalid2ndOrderPars(usize, usize),
	    InvlaidMassBw(usize, usize, usize, usize),
	}
39f6ca76d6b4f55cc99a2f2254292dc9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|20|1|V|rust
	pub struct OdeProblemBuilder<T: OdeFunction> {
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix of the system (differential-algebraic system): Mu'(t) = f(u,t).
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Initial conditions.
	    pub uinit: Array1<f64>,
	    /// Initial and final time values.
	    pub tspan: (f64, f64),
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub(crate) num_index1_vars: Option<usize>,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index2_vars: Option<usize>,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index3_vars: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m1: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m2: Option<usize>,
	    /// Upper bandwidth of the Jacobian
	    pub(crate) jac_ubw: Option<usize>,
	    /// Lower bandwidth of the Jacobian
	    pub(crate) jac_lbw: Option<usize>,
	    /// Upper bandwidth of the mass matrix
	    pub(crate) mm_ubw: Option<usize>,
	    /// Lower bandwidth of the mass matrix
	    pub(crate) mm_lbw: Option<usize>,
	}
c21f969b5f03d33d43e04f8f136e7682|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|22|12|v|rust
	default
9920ac095b34e40a8066eb83ad167fc1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|28|1|V|rust
	            num_index1_vars: None,
	            num_index2_vars: None,
	            num_index3_vars: None,
	            m1: None,
	            m2: None,
	            jac_ubw: None,
	            jac_lbw: None,
	            mm_ubw: None,
	            mm_lbw: None,
c58db1265ab195b2f8a6b3e1b7250990|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|30|1|V|rust
	    /// Add a mass matrix to the builder.
	    pub fn with_mass(mut self, mass_matrix: Array2<f64>) -> OdeProblemBuilder<T> {
	        self.mass_matrix = Some(mass_matrix);
	        self
	    }
	    /// Specify the number of index-1 variables of the differential-algebraic
	    /// system. An index-1 problem is one in which the system can be converted
	    /// into an ODE by taking a single derivive of one of the equations.
	    pub fn num_index1_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index1_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-2 variables of the differential-algebraic
	    /// system. An index-2 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of two of the equations.
	    pub fn num_index2_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index2_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-3 variables of the differential-algebraic
	    /// system. An index-3 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of three of the equations.
	    pub fn num_index3_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index3_vars = Some(val);
	        self
	    }
	    /// Specify the second order parameters m1, and m2 of the problem. These
	    /// are defined such that u'[i] = u[i+m2] for i = 1,...,m1 which is a
	    /// structure that often occurs for second-order differential equations.
	    pub fn second_order_params(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.m1 = Some(val.0);
	        self.m2 = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the Jacobian.
	    pub fn jac_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.jac_lbw = Some(val.0);
	        self.jac_ubw = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the mass matrix.
	    pub fn mass_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.mm_lbw = Some(val.0);
	        self.mm_ubw = Some(val.1);
	        self
	    }
	    /// Try to build the OdeProblem.
	    pub fn build(self) -> Result<OdeProblem<T>, OdeProblemBuildErr> {
	        let n = self.uinit.shape()[0];
	
	        let nind1 = self.num_index1_vars.unwrap_or(n);
	        let nind2 = self.num_index2_vars.unwrap_or(0);
	        let nind3 = self.num_index3_vars.unwrap_or(0);
	
	        if nind1 + nind2 + nind3 != n {
	            return Err(OdeProblemBuildErr::InvalidIndexPars(nind1, nind2, nind3));
	        }
	
	        let m1 = self.m1.unwrap_or(0);
	        let mut m2 = self.m1.unwrap_or(0);
	        if m1 == 0 {
	            m2 = n;
	        } else if m2 == 0 {
	            m2 = m1;
	        }
	        if m1 + m2 > n {
	            return Err(OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2));
	        }
	
	        let mut jac_ubw = self.jac_ubw.unwrap_or(n);
	        let mut jac_lbw = self.jac_lbw.unwrap_or(n);
	
	        let mm_ubw = self.mm_ubw.unwrap_or(n);
	        let mm_lbw = self.mm_lbw.unwrap_or(n);
	
	        let nm1 = n - m1;
	        let jband = jac_lbw < nm1;
	
	        if !jband {
	            jac_ubw = nm1;
	            jac_lbw = nm1;
	        }
	
	        if !self.mass_matrix.is_none() {
	            if mm_lbw > jac_lbw || mm_ubw > jac_ubw {
	                return Err(OdeProblemBuildErr::InvlaidMassBw(
	                    jac_lbw, jac_ubw, mm_lbw, mm_ubw,
	                ));
	            }
	        }
	
	        Ok(OdeProblem {
	            func: self.func,
	            mass_matrix: self.mass_matrix,
	            uinit: self.uinit,
	            tspan: self.tspan,
	            num_index1_vars: nind1,
	            num_index2_vars: nind2,
	            num_index3_vars: nind3,
	            m1,
	            m2,
	            jac_ubw,
	            jac_lbw,
	            mm_ubw,
	            mm_lbw,
	        })
	    }
90f2261518341fde1a0725d98e445008|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|1|1|V|rust
	use super::function::OdeFunction;
	use ndarray::prelude::*;
	
	pub enum OdeProblemBuildErr {
	    InvalidIndexPars(usize, usize, usize),
	    Invalid2ndOrderPars(usize, usize),
	    InvlaidMassBw(usize, usize, usize, usize),
	}
	
	impl std::fmt::Debug for OdeProblemBuildErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            OdeProblemBuildErr::InvalidIndexPars(idx1, idx2, idx3) => write!(
	                f,
	                "Invalid index varibles: {}, {}, {}. Sum must be equal to size of the system.",
	                idx1, idx2, idx3
	            ),
	            OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2) => write!(
	                f,
	                "Invalid 2nd order parameters: m1={}, m2={}. Sum must be less that size of system.",
	                m1, m2
	            ),
	            OdeProblemBuildErr::InvlaidMassBw(jl, ju, ml, mu) => write!(
	                f,
	                "Bandwidth of mass matrix cannot be larger than bandwidths of Jacobian: jl = {}, \
	                ju = {}, ml = {}, mu = {}.",
	                jl, ju, ml, mu
	            ),
	        }
	    }
	}
	
	/// Structure for specifying an ordinary differential equation problem of the
	/// form:
	///     ODE:                u'_{i}(t) = f_{i}(u_1,...,u_n, t)
	///     Initial conditions: u'_{i}(t_0) = u_{0,i}
	///     Domain:             t0 <= t <= tf
	#[derive(Clone)]
	pub struct OdeProblem<T: OdeFunction> {
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix for DAE.
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Initial conditions.
	    pub uinit: Array1<f64>,
	    /// Initial and final time values.
	    pub tspan: (f64, f64),
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub num_index1_vars: usize,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub num_index2_vars: usize,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub num_index3_vars: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m1: usize,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub m2: usize,
	    /// Upper bandwidth of the Jacobian
	    pub jac_ubw: usize,
	    /// Lower bandwidth of the Jacobian
	    pub jac_lbw: usize,
	    /// Upper bandwidth of the mass matrix
	    pub mm_ubw: usize,
	    /// Lower bandwidth of the mass matrix
	    pub mm_lbw: usize,
	}
	
	pub struct OdeProblemBuilder<T: OdeFunction> {
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Mass matrix of the system (differential-algebraic system): Mu'(t) = f(u,t).
	    pub mass_matrix: Option<Array2<f64>>,
	    /// Initial conditions.
	    pub uinit: Array1<f64>,
	    /// Initial and final time values.
	    pub tspan: (f64, f64),
	    /// Number of index 1 variables. For ODEs, this is equal to the size of the
	    /// system
	    pub(crate) num_index1_vars: Option<usize>,
	    /// Number of index 2 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index2_vars: Option<usize>,
	    /// Number of index 3 variables. For ODEs, this is equal to zero.
	    pub(crate) num_index3_vars: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m1: Option<usize>,
	    /// Second order ODE structure constant: u[i]' = u[i+m2] for i = 1,...,m1.
	    pub(crate) m2: Option<usize>,
	    /// Upper bandwidth of the Jacobian
	    pub(crate) jac_ubw: Option<usize>,
	    /// Lower bandwidth of the Jacobian
	    pub(crate) jac_lbw: Option<usize>,
	    /// Upper bandwidth of the mass matrix
	    pub(crate) mm_ubw: Option<usize>,
	    /// Lower bandwidth of the mass matrix
	    pub(crate) mm_lbw: Option<usize>,
	}
	
	impl<T: OdeFunction> OdeProblemBuilder<T> {
	    pub fn default(func: T, uinit: Array1<f64>, tspan: (f64, f64)) -> OdeProblemBuilder<T> {
	        OdeProblemBuilder {
	            func,
	            mass_matrix: None,
	            uinit,
	            tspan,
	            num_index1_vars: None,
	            num_index2_vars: None,
	            num_index3_vars: None,
	            m1: None,
	            m2: None,
	            jac_ubw: None,
	            jac_lbw: None,
	            mm_ubw: None,
	            mm_lbw: None,
	        }
	    }
	    /// Add a mass matrix to the builder.
	    pub fn with_mass(mut self, mass_matrix: Array2<f64>) -> OdeProblemBuilder<T> {
	        self.mass_matrix = Some(mass_matrix);
	        self
	    }
	    /// Specify the number of index-1 variables of the differential-algebraic
	    /// system. An index-1 problem is one in which the system can be converted
	    /// into an ODE by taking a single derivive of one of the equations.
	    pub fn num_index1_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index1_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-2 variables of the differential-algebraic
	    /// system. An index-2 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of two of the equations.
	    pub fn num_index2_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index2_vars = Some(val);
	        self
	    }
	    /// Specify the number of index-3 variables of the differential-algebraic
	    /// system. An index-3 problem is one in which the system can be converted
	    /// into an ODE by taking derivatives of three of the equations.
	    pub fn num_index3_vars(mut self, val: usize) -> OdeProblemBuilder<T> {
	        self.num_index3_vars = Some(val);
	        self
	    }
	    /// Specify the second order parameters m1, and m2 of the problem. These
	    /// are defined such that u'[i] = u[i+m2] for i = 1,...,m1 which is a
	    /// structure that often occurs for second-order differential equations.
	    pub fn second_order_params(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.m1 = Some(val.0);
	        self.m2 = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the Jacobian.
	    pub fn jac_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.jac_lbw = Some(val.0);
	        self.jac_ubw = Some(val.1);
	        self
	    }
	    /// Specify the lower and upper bandwidths of the mass matrix.
	    pub fn mass_bandwidths(mut self, val: (usize, usize)) -> OdeProblemBuilder<T> {
	        self.mm_lbw = Some(val.0);
	        self.mm_ubw = Some(val.1);
	        self
	    }
	    /// Try to build the OdeProblem.
	    pub fn build(self) -> Result<OdeProblem<T>, OdeProblemBuildErr> {
	        let n = self.uinit.shape()[0];
	
	        let nind1 = self.num_index1_vars.unwrap_or(n);
	        let nind2 = self.num_index2_vars.unwrap_or(0);
	        let nind3 = self.num_index3_vars.unwrap_or(0);
	
	        if nind1 + nind2 + nind3 != n {
	            return Err(OdeProblemBuildErr::InvalidIndexPars(nind1, nind2, nind3));
	        }
	
	        let m1 = self.m1.unwrap_or(0);
	        let mut m2 = self.m1.unwrap_or(0);
	        if m1 == 0 {
	            m2 = n;
	        } else if m2 == 0 {
	            m2 = m1;
	        }
	        if m1 + m2 > n {
	            return Err(OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2));
	        }
	
	        let mut jac_ubw = self.jac_ubw.unwrap_or(n);
	        let mut jac_lbw = self.jac_lbw.unwrap_or(n);
	
	        let mm_ubw = self.mm_ubw.unwrap_or(n);
	        let mm_lbw = self.mm_lbw.unwrap_or(n);
	
	        let nm1 = n - m1;
	        let jband = jac_lbw < nm1;
	
	        if !jband {
	            jac_ubw = nm1;
	            jac_lbw = nm1;
	        }
	
	        if !self.mass_matrix.is_none() {
	            if mm_lbw > jac_lbw || mm_ubw > jac_ubw {
	                return Err(OdeProblemBuildErr::InvlaidMassBw(
	                    jac_lbw, jac_ubw, mm_lbw, mm_ubw,
	                ));
	            }
	        }
	
	        Ok(OdeProblem {
	            func: self.func,
	            mass_matrix: self.mass_matrix,
	            uinit: self.uinit,
	            tspan: self.tspan,
	            num_index1_vars: nind1,
	            num_index2_vars: nind2,
	            num_index3_vars: nind3,
	            m1,
	            m2,
	            jac_ubw,
	            jac_lbw,
	            mm_ubw,
	            mm_lbw,
	        })
	    }
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_construction() {
	        struct HO;
	        impl OdeFunction for HO {
	            fn dudt(&mut self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	                du[0] = u[1];
	                du[1] = -u[0];
	            }
	        }
	
	        let uinit = array![0.0, 1.0];
	        let tspan = (0.0, 1.0);
	        let mass_matrix = Array2::<f64>::zeros((2, 2));
	
	        let prob = OdeProblemBuilder::default(HO, uinit.clone(), tspan)
	            .with_mass(mass_matrix)
	            .build()
	            .unwrap();
	
	        let mut u = array![0.0, 1.0];
	        let mut du = Array1::<f64>::zeros(2);
	        let mut df = Array2::<f64>::zeros((2, 2));
	
	        //prob.func.dudt(du.view_mut(), u.view(), 1.0);
	        //(prob.dfdu.unwrap())(df.view_mut(), u.view(), 1.0);
	
	        println!("du = {:?}", &du);
	        println!("df = {:?}", &df);
	    }
	}
2089324589283d2a057071e2cbdf2dc2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|3|1|v|rust
	
	pub enum OdeProblemBuildErr {
	    InvalidIndexPars(usize, usize, usize),
	    Invalid2ndOrderPars(usize, usize),
	    InvlaidMassBw(usize, usize, usize, usize),
	}
	
	impl std::fmt::Debug for OdeProblemBuildErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            OdeProblemBuildErr::InvalidIndexPars(idx1, idx2, idx3) => write!(
	                f,
	                "Invalid index varibles: {}, {}, {}. Sum must be equal to size of the system.",
	                idx1, idx2, idx3
	            ),
	            OdeProblemBuildErr::Invalid2ndOrderPars(m1, m2) => write!(
	                f,
	                "Invalid 2nd order parameters: m1={}, m2={}. Sum must be less that size of system.",
	                m1, m2
	            ),
	            OdeProblemBuildErr::InvlaidMassBw(jl, ju, ml, mu) => write!(
	                f,
	                "Bandwidth of mass matrix cannot be larger than bandwidths of Jacobian: jl = {}, \
	                ju = {}, ml = {}, mu = {}.",
	                jl, ju, ml, mu
	            ),
	        }
	    }
	}
581fcf2d9554276d8a19ed839540e8e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|52|13|V|rust
	            .with_mass(mass_matrix)
9a171a648ada2ec869486c4388ec9f3e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|52|13|V|rust
	            .build()
2c6b57981fa80e038f33fe59a14392ff|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|52|13|V|rust
	            .unwrap();
591e952cfe38a99fd2ad403bab6efaa8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|201|13|v|rust
	prob: self.prob,
a5110a36fde5ea3ee0ccdea0fbf264db|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|202|13|V|rust
	            mass_matrix: self.mass_matrix,
6fe62d05991568b56026886e91b669bb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|37|9|v|rust
	prob: OdeProblem<T>,
6e09ec480fbfc9e99f3413bdbae0c9aa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|85|9|v|rust
	The ODE problem we wish to solve.
1d86afbfa2938e560a701bf4149a0ed2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|107|13|v|rust
	prob,
e5cb45b2aeb4878dec8561a664d08be0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|108|13|V|rust
	            mass_matrix: None,
ca7596d92f84f0932dbca4ba4c86932e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/problem.rs|23|19|v|rust
	Builder 
7ac34e72cea997f6fc3c3956cefb43fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|25|13|V|rust
	            .prob
5e6dee97a6d5b58acb9f05c3c2673e99|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|27|1|V|rust
	        let nm1 = n - integrator.prob.m1;
79dc5b988f226ba019de18b6bfd108b0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|27|9|V|rust
	        let implct = integrator.mass_matrix.is_none();
d8d5826dc2a4ba7b07c281891f772e39|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|27|9|V|rust
	        let jband = integrator.prob.jac_lbw < nm1;
b6f91182f001c84f5cf64edf15eef769|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|27|9|V|rust
	        let mut prob_type = 1;
8d70c5e5d79390df5d1f61ff40eb9466|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|28|1|v|rust
	        let (mljac, mujac, ldjac, lde1) = if jband {
	            (
	                integrator.prob.jac_lbw,
	                integrator.prob.jac_ubw,
	                integrator.prob.jac_lbw + integrator.prob.jac_ubw + 1,
	                2 * integrator.prob.jac_lbw + integrator.prob.jac_ubw + 1,
	            )
	        } else {
	            (nm1, nm1, nm1, nm1)
	        };
	        let mut mlmas = integrator.prob.mm_lbw;
	        let mut mumas = integrator.prob.mm_ubw;
	        let mut ldmas = 1;
	        if implct {
	            if integrator.prob.mm_lbw != nm1 {
	                ldmas = mlmas + mumas + 1;
	                prob_type = if jband { 4 } else { 3 };
	            } else {
	                mumas = nm1;
	                mlmas = nm1;
	                prob_type = 5;
	            }
	        } else {
	            ldmas = 0;
	            if jband {
	                prob_type = 2;
	            } else {
	                prob_type = 1;
	                if n > 2 && integrator.opts.hess {
	                    prob_type = 7;
	                }
	            }
	        }
	        ldmas = ldmas.max(1);
	
	
e26a4a1efa82bcec9ee2e2fca7e894e6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|28|1|v|rust
	        //if (implct || jband) && prob_type == 7 {
	        //    prob_type = 1;
	        //}
	
	
7b021c3f8378e488d2df09ffdfb3b68e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|28|1|v|rust
	        if integrator.prob.m1 > 0 {
	            prob_type += 10;
	        }
	
	
d9e25121de86034981511c5e9ec6f3b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|28|1|v|rust
	        let mle = mljac;
	        let mue = mujac;
	        let mbjac = mljac + mujac + 1;
	        let mbb = mlmas + mumas + 1;
	        let mdiag = mle + mue;
	        let mdiff = mle + mue - mumas;
	        let mbdiag = mumas + 1;
	
	
ea0dbf1a1838694af253eb2dbc83a375|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|80|39|v|rust
	lde1
d43d164aa57c56fc64e05ad87f0b4d91|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|83|41|v|rust
	ldjac
7b38a35523eaf5c88d94329ba37e668f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|15|17|v|rust
	for j in 0..n {
	                    for i in 0..n {
	                        integrator.cache.e1[[i, j]] = -integrator.cache.dfdu[[i, j]];
	                    }
	                    integrator.cache.e1[[j, j]] += integrator.cache.fac1;
	                }
	                ier = dec(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.ip1.view_mut(),
	                );
5bb276c4a94d63ab7245c55f2d44aaf4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|24|1|v|rust
	
	        match integrator.cache.prob_type {
	            1 => {
	                
	            }
	            2 => {
	                for j in 0..n {
	                    for i in 0..integrator.cache.mbjac {
	                        integrator.cache.e1[[i + integrator.cache.mle, j]] =
	                            -integrator.cache.dfdu[[i, j]];
	                    }
	                    integrator.cache.e1[[integrator.cache.mdiag, j]] += integrator.cache.fac1;
	                }
	                ier = decb(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.mle,
	                    integrator.cache.mue,
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            3 => {
	                for j in 0..n {
	                    for i in 0..n {
	                        integrator.cache.e1[[i, j]] = -integrator.cache.dfdu[[i, j]];
	                    }
	                    for i in
	                        0.max(j - integrator.cache.mumas)..n.min(j + integrator.cache.mlmas + 1)
	                    {
	                        integrator.cache.e1[[i, j]] += integrator.cache.fac1
	                            * integrator.cache.mass_matrix
	                                [[i - j + integrator.cache.mbdiag - 1, j]];
	                    }
	                }
	                ier = dec(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            4 => {
	                for j in 0..n {
	                    for i in 0..integrator.cache.mbjac {
	                        integrator.cache.e1[[i + integrator.cache.mle, j]] =
	                            -integrator.cache.dfdu[[i, j]];
	                    }
	                    for i in 0..integrator.cache.mbb {
	                        integrator.cache.e1[[i + integrator.cache.mdiff, j]] +=
	                            integrator.cache.fac1 * integrator.cache.mass_matrix[[i, j]];
	                    }
	                }
	                ier = decb(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.mle,
	                    integrator.cache.mue,
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            5 => {
	                // mass is a full matrix, Jacobian a full matrix
	                for j in 0..n {
	                    for i in 0..n {
	                        integrator.cache.e1[[i, j]] = integrator.cache.mass_matrix[[i, j]]
	                            * integrator.cache.fac1
	                            - integrator.cache.dfdu[[i, j]];
	                    }
	                }
	                ier = dec(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            7 => {
	                // mass = identity, Jacobian a full matrix, Hessenberg-option
	                if integrator.cache.calhes {
	                    elmhes(
	                        n,
	                        0,
	                        n,
	                        integrator.cache.dfdu.view_mut(),
	                        integrator.cache.iphes.view_mut(),
	                    );
	                }
	                integrator.cache.calhes = false;
	                for j in 0..(n - 1) {
	                    integrator.cache.e1[[j + 1, j]] = -integrator.cache.dfdu[[j + 1, j]];
	                }
	                for j in 0..n {
	                    for i in 0..(j + 1) {
	                        integrator.cache.e1[[i, j]] = -integrator.cache.dfdu[[i, j]];
	                    }
	                    integrator.cache.e1[[j, j]] += integrator.cache.fac1;
	                }
	                ier = dech(
	                    n,
	                    integrator.cache.e1.view_mut(),
	                    1,
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            11 => {
	                for j in 0..nm1 {
	                    for i in 0..nm1 {
	                        integrator.cache.e1[[i, j]] =
	                            -integrator.cache.dfdu[[i, j + integrator.prob.m1]];
	                    }
	                    integrator.cache.e1[[j, j]] += integrator.cache.fac1;
	                }
	            }
	            12 => {
	                for j in 0..nm1 {
	                    for i in 0..integrator.cache.mbjac {
	                        integrator.cache.e1[[i + integrator.cache.mle, j]] =
	                            -integrator.cache.dfdu[[i, j + integrator.c[prob.m1]];
	                    }
	                    integrator.cache.e1[[integrator.cache.mdiag, j]] += integrator.cache.fac1;
	                }
	            }
	            13 => {
	                for j in 0..nm1 {
	                    for i in 0..nm1 {
	                        integrator.cache.e1[[i, j]] =
	                            -integrator.cache.dfdu[[i, j + integrator.c[prob.m1]];
	                    }
	                    for i in
	                        0.max(j - integrator.cache.mumas)..n.min(j + integrator.cache.mlmas + 1)
	                    {
	                        integrator.cache.e1[[i, j]] += integrator.cache.fac1
	                            * integrator.cache.mass_matrix
	                                [[i - j + integrator.cache.mbdiag - 1, j]];
	                    }
	                }
	            }
	            14 => {
	                for j in 0..nm1 {
	                    for i in 0..integrator.cache.mbjac {
	                        integrator.cache.e1[[i + integrator.cache.mle, j]] =
	                            -integrator.cache.dfdu[[i, j + integrator.c[prob.m1]];
	                    }
	                    for i in 0..integrator.cache.mbb {
	                        integrator.cache.e1[[i + integrator.cache.mdiff, j]] +=
	                            integrator.cache.fac1 * integrator.cache.mass_matrix[[i, j]];
	                    }
	                }
	            }
	            15 => {
	                for j in 0..nm1 {
	                    for i in 0..nm1 {
	                        integrator.cache.e1[[i, j]] = integrator.cache.mass_matrix[[i, j]]
	                            * integrator.cache.fac1
	                            - integrator.cache.dfdu[[i, j + integrator.c[prob.m1]];
	                    }
	                }
	            }
	            _ => {}
	        }
	
	        match integrator.cache.prob_type {
	            11 | 13 | 15 => {
	                let mm = integrator.c[prob.m1 / integrator.c[prob.m2;
	                for j in 0..integrator.c[prob.m2 {
	                    for i in 0..nm1 {
	                        let mut sum = 0.0;
	                        for k in 0..mm {
	                            sum = (sum + integrator.cache.dfdu[[i, j + k * integrator.c[prob.m2]])
	                                / integrator.cache.fac1;
	                        }
	                        integrator.cache.e1[[i, j]] -= sum;
	                    }
	                }
	                ier = dec(
	                    nm1,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            12 | 14 => {
	                let mm = integrator.c[prob.m1 / integrator.c[prob.m2;
	                for j in 0..integrator.c[prob.m2 {
	                    for i in 0..integrator.cache.mbjac {
	                        let mut sum = 0.0;
	                        for k in 0..mm {
	                            sum = (sum + integrator.cache.dfdu[[i, j + k * integrator.c[prob.m2]])
	                                / integrator.cache.fac1;
	                        }
	                        integrator.cache.e1[[i + integrator.cache.mle, j]] -= sum;
	                    }
	                }
	                ier = decb(
	                    nm1,
	                    integrator.cache.e1.view_mut(),
	                    integrator.cache.mle,
	                    integrator.cache.mue,
	                    integrator.cache.ip1.view_mut(),
	                );
	            }
	            _ => {}
	        }
cb54ad51702aad68b6dfa859c24efbdb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|19|9|v|rust
	ier = 
7598a95a64c79df59f589de3dd2d1261|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|26|9|V|rust
	        ier
464596e8ae9b1093c5c7bf433934740d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|36|17|v|rust
	for j in 0..n {
	                    for i in 0..n {
	                        integrator.cache.e2r[[i, j]] = -integrator.cache.dfdu[[i, j]];
	                        integrator.cache.e2i[[i, j]] = 0.0;
	                    }
	                    integrator.cache.e2r[[j, j]] += integrator.cache.alphn;
	                    integrator.cache.e2i[[j, j]] = integrator.cache.betan;
	                }
	                ier = decc(
	                    n,
	                    integrator.cache.e2r.view_mut(),
	                    integrator.cache.e2i.view_mut(),
	                    integrator.cache.ip2.view_mut(),
	                );
5e926d1421034549c08a02b34ec458a6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|30|1|V|rust
	        let nm1 = n - integrator.c[prob.m1;
eab9913cd04afe89df2d2aeb4a73f9a6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|30|9|V|rust
	        let mut ier = 0;
fee0834d6d3452c46f0ebad7dd61bff6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|42|1|V|rust
	            prob_type,
173435b6160007410181dc594e818952|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|42|13|V|rust
	            implct,
85b35f01cead7a1c26c911e11940ec1f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|42|13|V|rust
	            jband,
9d77a71231289ff07c6976e7ee1bf9a7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|46|1|V|rust
	            mujac,
	            mljac,
	            mumas,
	            mlmas,
	            mle,
	            mue,
	            mbjac,
	            mbb,
	            mdiag,
	            mdiff,
	            mbdiag,
	            ldmas,
	            ldjac,
	            lde1,
80310d6c0eb9ea1d27ddbcc4d40884df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|66|13|V|rust
	            mass_matrix: Array2::<f64>::zeros((ldmas, nm1)),
7c738d61f61dca21f371bcca7572ffa4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|61|9|V|rust
	            iphes: Array1::<i32>::zeros(n),
382af6729c949cd1b7f15a93cf6ccccc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|4|1|V|rust
	    pub(crate) prob_type: usize,
91716e4f6de0f7e9a79fc758cf6bb88d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|4|5|V|rust
	    pub(crate) implct: bool,
97de9bbe3715dbec980c7442add29f00|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|4|5|V|rust
	    pub(crate) jband: bool,
6eddd62fb1fa7272a9493061c8666b2f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|8|1|V|rust
	    pub(crate) mujac: usize,
	    pub(crate) mljac: usize,
	    pub(crate) mumas: usize,
	    pub(crate) mlmas: usize,
	    pub(crate) mle: usize,
	    pub(crate) mue: usize,
	    pub(crate) mbjac: usize,
	    pub(crate) mbb: usize,
	    pub(crate) mdiag: usize,
	    pub(crate) mdiff: usize,
	    pub(crate) mbdiag: usize,
	    pub(crate) ldmas: usize,
	    pub(crate) ldjac: usize,
	    pub(crate) lde1: usize,
31b34e321cc0c62d9f23e84306a8e381|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|23|5|V|rust
	    pub(crate) iphes: Array1<i32>,
98d8c6ec3482f2a656961d2a033bb8b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|27|5|V|rust
	    pub(crate) mass_matrix: Array2<f64>,
8d78b75b7b88821319fac7e96e703c87|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|22|17|v|rust
	for i in 0..n {
	                    integrator.cache.f2[i] = hee1 * integrator.cache.z1[i]
	                        + hee2 * integrator.cache.z2[i]
	                        + hee3 * integrator.cache.z3[i];
	                    integrator.cache.cont[i] = integrator.cache.f2[i] + integrator.cache.u0[i];
	                }
	                sol(
	                    n,
	                    integrator.cache.e1.view(),
	                    integrator.cache.cont.view_mut(),
	                    integrator.cache.ip1.view(),
	                );
37c700243288bb7058e5f9b699281c9c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|35|1|V|rust
	        match integrator.cache.prob_type {
	            11 | 13 | 15 => {
	                let mm = integrator.cache.m1 / integrator.cache.m2;
	                for j in 0..integrator.cache.m2 {
	                    let mut sum = 0.0;
	                    for k in (0..mm).rev() {
	                        sum = (integrator.cache.cont[j + k * integrator.cache.m2] + sum)
	                            / integrator.cache.fac1;
	                        for i in 0..nm1 {
	                            integrator.cache.cont[i + integrator.cache.m1] +=
	                                integrator.cache.dfdu[[i, j + k * integrator.cache.m2]] * sum;
	                        }
	                    }
	                }
	                sol(
	                    nm1,
	                    integrator.cache.e1.view(),
	                    integrator.cache.cont.slice_mut(s![integrator.cache.m1..]),
	                    integrator.cache.ip1.view(),
	                );
	                for i in (0..integrator.cache.m1).rev() {
	                    integrator.cache.cont[i] = (integrator.cache.cont[i]
	                        + integrator.cache.cont[integrator.cache.m2 + i])
	                        / integrator.cache.fac1;
	                }
	            }
	            12 | 14 => {
	                let mm = integrator.cache.m1 / integrator.cache.m2;
	                for j in 0..integrator.cache.m2 {
	                    let mut sum = 0.0;
	                    for k in (0..mm).rev() {
	                        sum = (integrator.cache.cont[j + k * integrator.cache.m2] + sum)
	                            / integrator.cache.fac1;
	                        for i in
	                            0.max(j - integrator.cache.mujac)..nm1.min(j + integrator.cache.mljac)
	                        {
	                            integrator.cache.cont[i + integrator.cache.m1] += integrator.cache.dfdu
	                                [[i + integrator.cache.mujac - j, j + k * integrator.cache.m2]]
	                                * sum;
	                        }
	                    }
	                }
	                solb(
	                    nm1,
	                    integrator.cache.e1.view(),
	                    integrator.cache.mle,
	                    integrator.cache.mue,
	                    integrator.cache.cont.slice_mut(s![integrator.cache.m1..]),
	                    integrator.cache.ip1.view(),
	                );
	                for i in (0..integrator.cache.m1).rev() {
	                    integrator.cache.cont[i] = (integrator.cache.cont[i]
	                        + integrator.cache.cont[integrator.cache.m2 + i])
	                        / integrator.cache.fac1;
	                }
	            }
	            _ => {}
	        }
	
c5f4767dba279b94c3083535874a9244|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|13|9|V|rust
	        let nm1 = n - integrator.cache.m1;
b573af059672148b04a8e4607910caea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|57|21|v|rust
	sol(
	                        n,
	                        integrator.cache.e1.view(),
	                        integrator.cache.cont.view_mut(),
	                        integrator.cache.ip1.view(),
	                    );
30540b7de7716edeb15d50358c7f8e25|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|61|13|v|rust
	match integrator.cache.prob_type {
	                1 | 3 | 5 => {}
	                2 | 4 => {
	                    solb(
	                        n,
	                        integrator.cache.e1.view(),
	                        integrator.cache.mle,
	                        integrator.cache.mue,
	                        integrator.cache.cont.view_mut(),
	                        integrator.cache.ip1.view(),
	                    );
	                }
	                7 => {
	                    // Hessenberg matrix option
	                    // mass = identity, Jacobian a full matrix, Hessenberg-option
	                    for mm1 in (0..(n - 2)).rev() {
	                        let mp = n - mm1 - 2;
	                        let ii = integrator.cache.iphes[mp] as usize;
	                        if ii != mp {
	                            let zsafe = integrator.cache.cont[mp];
	                            integrator.cache.cont[mp] = integrator.cache.cont[ii];
	                            integrator.cache.cont[ii] = zsafe;
	                        }
	                        for i in mp..n {
	                            integrator.cache.cont[i] -=
	                                integrator.cache.dfdu[[i, mp - 1]] * integrator.cache.cont[mp];
	                        }
	                    }
	                    solh(
	                        n,
	                        integrator.cache.e1.view(),
	                        1,
	                        integrator.cache.cont.view_mut(),
	                        integrator.cache.ip1.view(),
	                    );
	                    for mm1 in 0..(n - 2) {
	                        let mp = n - mm1 - 2;
	                        for i in mp..n {
	                            integrator.cache.cont[i] +=
	                                integrator.cache.dfdu[[i, mp - 1]] * integrator.cache.cont[mp];
	                        }
	                        let ii = integrator.cache.iphes[mp] as usize;
	                        if ii != mp {
	                            let zsafe = integrator.cache.cont[mp];
	                            integrator.cache.cont[mp] = integrator.cache.cont[ii];
	                            integrator.cache.cont[ii] = zsafe;
	                        }
	                    }
	                }
	                11 | 13 | 15 => {
	                    // Full matrix option, second order
	                    for j in 0..integrator.cache.m2 {
	                        let mut sum = 0.0;
	                        let mm = integrator.cache.m1 / integrator.cache.m2;
	                        for k in (0..mm).rev() {
	                            sum = (integrator.cache.cont[j + k * integrator.cache.m2] + sum)
	                                / integrator.cache.fac1;
	                            for i in 0..nm1 {
	                                integrator.cache.cont[i + integrator.cache.m1] +=
	                                    integrator.cache.dfdu[[i, j + k * integrator.cache.m2]] * sum;
	                            }
	                        }
	                    }
	
	                    sol(
	                        nm1,
	                        integrator.cache.e1.view(),
	                        integrator.cache.cont.slice_mut(s![integrator.cache.m1..]),
	                        integrator.cache.ip1.view(),
	                    );
	                    for i in (0..integrator.cache.m1).rev() {
	                        integrator.cache.cont[i] = (integrator.cache.cont[i]
	                            + integrator.cache.cont[integrator.cache.m2 + i])
	                            / integrator.cache.fac1;
	                    }
	                }
	                12 | 14 => {
	                    // Banded matrix option, second order
	                    for j in 0..integrator.cache.m2 {
	                        let mut sum = 0.0;
	                        let mm = integrator.cache.m1 / integrator.cache.m2;
	                        for k in (0..mm).rev() {
	                            sum = (integrator.cache.cont[j + k * integrator.cache.m2] + sum)
	                                / integrator.cache.fac1;
	                            for i in 0.max(j - integrator.cache.mujac)
	                                ..nm1.min(j + integrator.cache.mljac)
	                            {
	                                integrator.cache.cont[i + integrator.cache.m1] += integrator
	                                    .cache
	                                    .dfdu
	                                    [[i + integrator.cache.mujac - j, j + k * integrator.cache.m2]]
	                                    * sum;
	                            }
	                        }
	                    }
	                    solb(
	                        nm1,
	                        integrator.cache.e1.view(),
	                        integrator.cache.mle,
	                        integrator.cache.mue,
	                        integrator.cache.cont.slice_mut(s![integrator.cache.m1..]),
	                        integrator.cache.ip1.view(),
	                    );
	                    for i in (0..integrator.cache.m1).rev() {
	                        integrator.cache.cont[i] = (integrator.cache.cont[i]
	                            + integrator.cache.cont[integrator.cache.m2 + i])
	                            / integrator.cache.fac1;
	                    }
	                }
	                _ => {}
	            }
bc95dfc14146aa23e43f2ea7af04d310|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|61|12|V|rust
	            
b17071825b69e3ffe9ae913b4a713858|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|15|17|v|rust
	for i in 0..n {
	                    let s2 = -cache.f2[i];
	                    let s3 = -cache.f3[i];
	                    cache.z1[i] -= cache.f1[i] * cache.fac1;
	                    cache.z2[i] = cache.z2[i] + s2 * cache.alphn - s3 * cache.betan;
	                    cache.z3[i] = cache.z3[i] + s3 * cache.alphn + s2 * cache.betan;
	                }
	                sol(n, cache.e1.view(), cache.z1.view_mut(), cache.ip1.view());
	                solc(
	                    n,
	                    cache.e2r.view(),
	                    cache.e2i.view(),
	                    cache.z2.view_mut(),
	                    cache.z3.view_mut(),
	                    cache.ip2.view(),
	                );
6c44d3f4eaa4cb1d617e18332e9d6f7c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|30|8|v|rust
	 match cache.prob_type {
	            11 | 13 | 15 => {
	                let abno = cache.alphn * cache.alphn + cache.betan * cache.betan;
	                let mm = cache.m1 / cache.m2;
	                for j in 0..cache.m2 {
	                    let mut sum1 = 0.0;
	                    let mut sum2 = 0.0;
	                    let mut sum3 = 0.0;
	                    for k in (0..mm).rev() {
	                        let jkm = j + k * cache.m2;
	                        sum1 = (cache.z1[jkm] + sum1) / cache.fac1;
	                        let sumh = (cache.z2[jkm] + sum2) / abno;
	                        sum3 = (cache.z3[jkm] + sum3) / abno;
	                        sum2 = sumh * cache.alphn + sum3 * cache.betan;
	                        sum3 = sum3 * cache.alphn - sumh * cache.betan;
	                        for i in 0..nm1 {
	                            cache.z1[i + cache.m1] += cache.dfdu[[i, jkm]] * sum1;
	                            cache.z2[i + cache.m1] += cache.dfdu[[i, jkm]] * sum2;
	                            cache.z3[i + cache.m1] += cache.dfdu[[i, jkm]] * sum3;
	                        }
	                    }
	                }
	
	                sol(
	                    nm1,
	                    cache.e1.view(),
	                    cache.z1.slice_mut(s![cache.m1..]),
	                    cache.ip1.view(),
	                );
	                solc(
	                    nm1,
	                    cache.e2r.view(),
	                    cache.e2i.view(),
	                    cache.z2.slice_mut(s![cache.m1..]),
	                    cache.z3.slice_mut(s![cache.m1..]),
	                    cache.ip2.view(),
	                );
	            }
	            12 | 14 => {
	                let abno = cache.alphn * cache.alphn + cache.betan * cache.betan;
	                let mm = cache.m1 / cache.m2;
	                for j in 0..cache.m2 {
	                    let mut sum1 = 0.0;
	                    let mut sum2 = 0.0;
	                    let mut sum3 = 0.0;
	                    for k in 0..mm {
	                        let jkm = j + k * cache.m2;
	                        sum1 = (cache.z1[jkm] + sum1) / cache.fac1;
	                        let sumh = (cache.z2[jkm] + sum2) / abno;
	                        sum3 = (cache.z3[jkm] + sum3) / abno;
	                        sum2 = sumh * cache.alphn + sum3 * cache.betan;
	                        sum3 = sum3 * cache.alphn - sumh * cache.betan;
	                        for i in 0.max(j - cache.mujac)..nm1.min(j + cache.mljac + 1) {
	                            let ffja = cache.dfdu[[i + cache.mujac - j, jkm]];
	                            cache.z1[i + cache.m1] += ffja * sum1;
	                            cache.z2[i + cache.m1] += ffja * sum2;
	                            cache.z3[i + cache.m1] += ffja * sum3;
	                        }
	                    }
	                }
	                solb(
	                    nm1,
	                    cache.e1.view(),
	                    cache.mle,
	                    cache.mue,
	                    cache.z1.slice_mut(s![cache.m1..]),
	                    cache.ip1.view(),
	                );
	                solbc(
	                    nm1,
	                    cache.e2r.view(),
	                    cache.e2i.view(),
	                    cache.mle,
	                    cache.mue,
	                    cache.z2.slice_mut(s![cache.m1..]),
	                    cache.z3.slice_mut(s![cache.m1..]),
	                    cache.ip2.view(),
	                );
	            }
	            _ => {}
	        }
2c04f98759d784b2d79bd72e8df2457c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|28|7|V|rust
	       
c86de16c134ed072ed39a8429d2f51f2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|10|5|V|rust
	        let nm1 = n - cache.m1;
c0e6a3a11476c34dfd7f5486d47b065a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|7|47|v|rust
	&self, cache: &mut Radau5Cache
4e4aaf3fee165531347b772f66b4f30c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|7|48|v|rust
	integrate
c45c7ab67ca0d15a8dcff2efd3e80346|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|6|9|v|rust
	au5 {
	    #[allow(dead_code)]
	    pub fn init<T: OdeFunction>(&self, prob: OdeProblem<T>) -> OdeIntegrator<T, Radau5>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        
	    }
	}
	
6e0acf109369ec88719b935561804fa8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|6|1|V|rust
	impl Rad
571ba4907da45f9f7a21af9a51b90ff4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/core.rs|13|1|V|rust
	        let mut integrator = self.init(prob);
3a3c0c162ccc3c94019a7a9ede5e7662|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|1|V|rust
	let mut solution = OdeSolution {
4076662f233f24524eea48efba775212|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|13|V|rust
	            ts: Vec::<f64>::with_capacity(200),
c764fa52711254200cdf37acffb620b0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|13|V|rust
	            us: Vec::<Array1<f64>>::with_capacity(200),
5a873a89cfe8cdbd2bf32e1f4004b6c9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|9|V|rust
	        solution.ts.push(integrator.prob.tspan.0);
1bd8d7702fb40d7a189bcbf5e19cb5f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|68|9|V|rust
	        solution.us.push(integrator.prob.uinit.clone());
46273902cd61a8c9f41e5b421717ea84|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|80|1|V|rust
	        {
	            let quot = self.abstol / self.reltol;
	            integrator.cache.reltol = 0.1 * self.reltol.powf(2.0 / 3.0);
	            integrator.cache.abstol = self.reltol * quot;
	        }
	
	        let n = integrator.u.shape()[0];
	
	        integrator.cache.fnewt = if self.fnewt == 0.0 {
	            (10.0 * f64::EPSILON / self.reltol).max(0.03f64.min(self.reltol.sqrt()))
	        } else {
	            self.fnewt
	        };
	
411b457dfaec7e283778a7d434732587|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|83|1|V|rust
	        let posneg = 1.0f64.copysign(tfinal - integrator.t);
	        let dtmax = (integrator.cache.dtmax)
	            .abs()
	            .min((tfinal - integrator.t).abs());
8e14d76baeb30687659b618e33fc8773|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|85|1|V|rust
	        // compute mass matrix for implicit case
	        integrator.cache.mass_matrix = match &integrator.prob.mass_matrix {
	            Some(mm) => mm.clone(),
	            None => Array2::eye(n),
	        };
ee24c8b2fbdb0a96f7f9a39cf76e745d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|86|1|V|rust
	        integrator.dt = (integrator.dt).abs().min(dtmax);
	        integrator.dt = integrator.dt.copysign(posneg);
	        integrator.dtprev = integrator.dt;
59379d8c210fa2313c62d93556d594bf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|97|1|V|rust
	        if self.dense {
	            let irtrn = 1;
	            for i in (0)..(n) {
	                integrator.cache.cont[i] = integrator.u[i];
	            }
	            // irtrn = SolutionOutput();
	            if irtrn < 0 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                return integrator.sol;
	            }
	        }
	        solution.ts.push(integrator.t);
	        solution.us.push(integrator.u.clone());
	
cca24c7c7925aac4da8e75a024d768d9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|97|1|V|rust
	        for i in (0)..(n) {
	            integrator.cache.scal[i] = self.abstol + self.reltol * integrator.u[i].abs();
	        }
	
	        (integrator.prob.dudt)(
	            integrator.cache.u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	        );
	        integrator.sol.statistics.function_evals += 1;
0c86e2c090dfdbe2847d67d5b00e1341|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|89|72|v|rust
	posneg
b7b73cd4a3d2ed785cfba24361b48bf3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|103|9|V|rust
	        self.compute_jacobian(&mut integrator);
16a5d90cb2175f5f03ffe1f60e5ec752|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|29|1|V|rust
	        let mut scal = Array1::<f64>::zeros(n);
ef9c299da4bfd878157f07109d0c9f58|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|30|17|v|rust
	scal
0a4d284bc056a7665e33e5d135314fc3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|67|17|v|rust
	: Array2::<f64>::zeros((n, n)),
459b4109b11e0564d429af17d2799d85|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|141|28|v|rust
	integrator.sol;
3144ecf69969ee3db4eb19983f55080c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|169|32|v|rust
	dex of the problem
f6138149b019d9bd7bbab5a7db0d2988|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|169|1|V|rust
	                // check the injjj
	                if integrator.cache.nind2 != 0 {
	                    // is index 2
	                    for i in
	                        (integrator.cache.nind1)..(integrator.cache.nind1 + integrator.cache.nind2)
	                    {
	                        integrator.cache.scal[i] = integrator.cache.scal[i] / dtfac;
	                    }
	                }
7476a75c5212b6c629c52f3f70124c11|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|170|1|V|rust
	                if integrator.cache.nind3 != 0 {
	                    // is index 3
	                    for i in (integrator.cache.nind1 + integrator.cache.nind2)
	                        ..(integrator.cache.nind1 + integrator.cache.nind2 + integrator.cache.nind3)
	                    {
	                        integrator.cache.scal[i] = integrator.cache.scal[i] / (dtfac * dtfac);
	                    }
	                }
5df83c78ea58fa2f7eb87e8085bea10c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|114|52|v|rust
	.cache
b7078ae362fb898bbe27e42ec9a3bd82|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|153|24|v|rust
	sol.
3552cdd5ae6f6eaa1ac7b604c651153c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|157|31|v|rust
	sol.statistics
db0b0dfad166b56d9929b6708b3c0d9f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|157|46|v|rust
	self.max_steps
54e709419864ef1214f29abb2aaf0ee1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|243|21|v|rust
	integrator.func.dudt
70080738cbb4f991119cb18bb8f9cd84|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/jacobian.rs|12|17|v|rust
	dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
0b4d608e7be41a76423a6603428bcf3b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|132|1|V|rust
	                    self.compute_jacobian(&mut integrator);
4b5e9e7d1230de7aaa57fb02e088be66|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|132|1|V|rust
	                    integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
451cd342f6905e74f51abe25340c2143|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|243|1|V|rust
	                            self.compute_jacobian(&mut integrator);
61b4c67d9b23ce17c6f793994d406e78|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|333|1|V|rust
	                                    self.compute_jacobian(&mut integrator);
e052bf36854d7ee5d0676fb0c5befa89|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|356|1|V|rust
	                                self.compute_jacobian(&mut integrator);
ef54076d16132473e1b532a9e967e49a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|485|1|V|rust
	                        self.compute_jacobian(&mut integrator);
e4f4360983e9feac28de47d41df880f3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|8|1|V|rust
	/pub(crate) mod jacobian;
599b897634810360c3e948d78bc9fc52|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|5|1|V|rust
	pub(crate) mod core;
ae64616f0b738d3bf0dc3e458b4faa29|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|41|30|v|rust
	Radau5::init(prob);
8b0f912d92a6b239cf8f4659cb563cd2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|15|32|v|rust
	OdeAlgorithmBuilder;
b99f43aa77a8ea3905a0a2837cbad9bb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|15|21|v|rust
	algorithm::
8756b1ddd282ca4133d615eb602238d7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|16|5|V|rust
	    use crate::ode::problem::OdeProblem;
b530bd348dc27a7d0e69ec9f35245ee4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|16|5|V|rust
	    use crate::ode::OdeFunction;
640cdeb97197383d1de9f6747a235f7e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|142|40|v|rust
	&mut 
72eacff3580d6d1a336408d1114e69d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|97|9|v|rust
	let mut dtopt: f64 = integrator.dt;
	        let mut faccon: f64 = 1.0;
	
	        let mut dtfac = integrator.dt;
	        let mut dtacc: f64 = 0.0;
	        let mut erracc: f64 = 0.0;
	        let mut thqold: f64 = 0.0;
	        let mut nsing = 0;
	
547511453fb43a073fc432b64817fa68|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|97|9|v|rust
	let mut dtopt: f64 = integrator.dt;
	        let mut faccon: f64 = 1.0;
	
	        let mut dtfac = integrator.dt;
	        let mut dtacc: f64 = 0.0;
	        let mut erracc: f64 = 0.0;
	        let mut thqold: f64 = 0.0;
	        let mut nsing = 0;
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
93a0da176e486b01de604b38f2d863a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|5|v|rust
	let mut 
357e20694463367e0b11ad9e03252daa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|11|26|v|rust
	 = integrator.dt;
5886f622d23d33b5d4b79fa8cbaa5bd7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|12|27|v|rust
	 = 1.0;
fc2c91f6da44e94dd58e73b6d1703c47|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|14|26|v|rust
	 = 0.0;
eec5711aac21e2f7e228aa90435f90f3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|17|21|v|rust
	 = 0;
bc4016ff1a8ebc913ad32bb88f65328e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|47|9|V|rust
	            calhes: false,
4aad1e65f6875fc6d2aa0f875ff412a0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|12|5|v|rust
	pub(crate) dtopt: f64,
507227c37fa6be71be6c09e0fb964210|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|12|1|V|rust
	    pub(crate) dtopt: f64,
	    pub(crate) faccon: f64,
	    pub(crate) dtfac: f64,
	    pub(crate) dtacc: f64,
	    pub(crate) erracc: f64,
	    pub(crate) thqold: f64,
	    pub(crate) nsing: usize,
2f630395126d6a0800e56144da2c3fb7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|104|1|V|rust
	        let mut dtopt: f64 = integrator.dt;
	        let mut faccon: f64 = 1.0;
	
	        let mut dtfac = integrator.dt;
	        let mut dtacc: f64 = 0.0;
	        let mut erracc: f64 = 0.0;
	        let mut thqold: f64 = 0.0;
	        let mut nsing = 0;
	        let mut ier;
68ca470ba48af966589ad40b1ff36aaa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|5|1|V|rust
	    pub(crate) calhes: bool,
a1c3aea0be962a0a12a0def6960625a5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|102|20|v|rust
	 = 0
ae5b44681c555b6efd27d86dcbc1567f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|80|29|V|rust
	        let sq6 = 6f64.sqrt();
	        let c1 = (4.0 - sq6) / 10.0;
	        let c2 = (4.0 + sq6) / 10.0;
	        let c1m1 = c1 - 1.0;
	        let c2m1 = c2 - 1.0;
	        let c1mc2 = c1 - c2;
	        let u1 = 1.0 / ((6.0 + 81f64.powf(1.0 / 3.0) - 9f64.powf(1.0 / 3.0)) / 30.0);
	        let mut alph = (12.0 - 81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) / 60.0;
	        let mut beta = (81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) * 3f64.sqrt() / 60.0;
	        let cno = alph * alph + beta * beta;
	
	        alph = alph / cno;
	        beta = beta / cno;
	
	        let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
9730630ee29cf3ba4babe516ca2ec7f0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|4|1|V|rust
	let sq6 = 6f64.sqrt();
	let c1 = (4.0 - sq6) / 10.0;
	let c2 = (4.0 + sq6) / 10.0;
	let c1m1 = c1 - 1.0;
	let c2m1 = c2 - 1.0;
	let c1mc2 = c1 - c2;
	let u1 = 1.0 / ((6.0 + 81f64.powf(1.0 / 3.0) - 9f64.powf(1.0 / 3.0)) / 30.0);
	let mut alph = (12.0 - 81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) / 60.0;
	let mut beta = (81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) * 3f64.sqrt() / 60.0;
	let cno = alph * alph + beta * beta
	alph = alph / cno;
	beta = beta / cno
	let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
5c57ca3377dc601a92030881a6a300ad|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|37|1|V|rust
	    pub(crate) const C1: f64 = 0.1550510257216822;
aaae412cee63dbdc229ddfbedf7d3bc7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|38|32|v|rust
	0.1550510257216822
6f3ec424a415428639d2196d5dfb0eb5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|3|1|v|rust
	
	let sq6 = 6f64.sqrt();
	let c1 = (4.0 - sq6) / 10.0;
	let c2 = (4.0 + sq6) / 10.0;
	let c1m1 = c1 - 1.0;
	let c2m1 = c2 - 1.0;
	let c1mc2 = c1 - c2;
	let u1 = 1.0 / ((6.0 + 81f64.powf(1.0 / 3.0) - 9f64.powf(1.0 / 3.0)) / 30.0);
	let mut alph = (12.0 - 81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) / 60.0;
	let mut beta = (81f64.powf(1.0 / 3.0) + 9f64.powf(1.0 / 3.0)) * 3f64.sqrt() / 60.0;
	let cno = alph * alph + beta * beta
	alph = alph / cno;
	beta = beta / cno
	let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
	
	
5644182fce84bcbeffdea3ee81b97016|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|21|1|V|rust
	    pub(crate) const C1: f64 = 0.1550510257216822;
	    pub(crate) const C2: f64 = 0.6449489742783178;
0f97f9f4e172b12df0483bb68660a0d7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|24|34|v|rust
	0.6449489742783178;
a14beb4d97cf6c6ee748061339e5af63|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|94|32|v|rust
	Radau5::
cd30fc009040d49722de3e27fd34417b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|95|38|v|rust
	alph
b2818102e8906014ba99a8b5d3665065|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|174|25|v|rust
	Radau5::C1
3874a4bb798b849df77da800f2baeb30|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|175|25|v|rust
	Radau5::C2
89cb1355822663c4f6289e7641c547e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|18|1|V|rust
	    pub(crate) cfac: f64,
b326b5062b2f0e69046810717534cb09|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|91|25|v|rust
	true
20702ce34004b5c6bb3e88c06e05aec4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|93|13|V|rust
	            lloop = false;
9133419d7983e46fbfe167beab2efe10|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|92|9|V|rust
	        while lloop {
5e2bd708bfd9ed026a3eaba9f333b333|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|118|13|v|rust
	continue;
7aa28ed115707345d0274032757e8991|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|142|13|v|rust
	continue
0b7591b0f3f277e028cddb713b50b2a5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|468|17|V|rust
	                lloop = true;
bd1db4febe0aa15fd5221f160076f0e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|141|10|V|rust
	            lloop = true;
e318e2995867d3eba9578314614e9f1d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|198|13|v|rust
	//  lloop for the simplified Newton iteration
	            let mut newt = 0;
	            integrator.cache.faccon = integrator.cache.faccon.max(f64::EPSILON).powf(0.8);
	            let mut theta = integrator.opts.theta.abs();
	            let mut dyno: f64;
	            let mut dynold: f64 = 0.0;
	            loop {
	                if newt >= integrator.opts.max_newt_iter {
	                    if ier != 0 {
	                        integrator.cache.nsing += 1;
	                        if integrator.cache.nsing >= 5 {
	                            println!("exit of RADAU5 at t = {}", integrator.t);
	                            println!("matrix is repeatedly singular");
	                            return true;
	                        }
	                    }
	                    integrator.dt *= 0.5;
	                    integrator.cache.dtfac = 0.5;
	                    integrator.cache.reject = true;
	                    integrator.cache.last = false;
	                    if !integrator.cache.caljac {
	                        integrator.func.dfdu(
	                            integrator.cache.dfdu.view_mut(),
	                            integrator.u.view(),
	                            integrator.t,
	                        );
	                    }
	                    lloop = true;
	                    break;
	                }
	                // compute the right-hand side
	                for i in (0)..(n) {
	                    integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z1[i];
	                }
	                integrator.func.dudt(
	                    integrator.cache.z1.view_mut(),
	                    integrator.cache.cont.view(),
	                    integrator.t + Radau5::C1 * integrator.dt,
	                );
	
	                for i in (0)..(n) {
	                    integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z2[i];
	                }
	                integrator.func.dudt(
	                    integrator.cache.z2.view_mut(),
	                    integrator.cache.cont.view(),
	                    integrator.t + Radau5::C2 * integrator.dt,
	                );
	
	                for i in (0)..(n) {
	                    integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z3[i];
	                }
	                integrator.func.dudt(
	                    integrator.cache.z3.view_mut(),
	                    integrator.cache.cont.view(),
	                    tph,
	                );
	
	                integrator.stats.function_evals += 3;
	
	                // solve the linear systems
	                for i in (0)..(n) {
	                    let a1 = integrator.cache.z1[i];
	                    let a2 = integrator.cache.z2[i];
	                    let a3 = integrator.cache.z3[i];
	                    integrator.cache.z1[i] =
	                        Radau5::TI11 * a1 + Radau5::TI12 * a2 + Radau5::TI13 * a3;
	                    integrator.cache.z2[i] =
	                        Radau5::TI21 * a1 + Radau5::TI22 * a2 + Radau5::TI23 * a3;
	                    integrator.cache.z3[i] =
	                        Radau5::TI31 * a1 + Radau5::TI32 * a2 + Radau5::TI33 * a3;
	                }
	                Self::linear_solve(integrator);
	                integrator.stats.linear_solves += 1;
	                newt += 1;
	                dyno = 0.0;
	                let mut denom: f64;
	                for i in 0..n {
	                    denom = integrator.cache.scal[i];
	                    dyno = dyno
	                        + (integrator.cache.z1[i] / denom).powi(2)
	                        + (integrator.cache.z2[i] / denom).powi(2)
	                        + (integrator.cache.z3[i] / denom).powi(2);
	                }
	                dyno = (dyno / ((3 * n) as f64)).sqrt();
	                // bad convergence or number of iterations to large
	                if newt > 1 && (newt < integrator.opts.max_newt_iter) {
	                    let thq = dyno / dynold;
	                    if newt == 2 {
	                        theta = thq;
	                    } else {
	                        theta = (thq * integrator.cache.thqold).sqrt();
	                    }
	                    integrator.cache.thqold = thq;
	                    if theta < 0.99 {
	                        integrator.cache.faccon = theta / (1.0 - theta);
	                        let dyth = integrator.cache.faccon
	                            * dyno
	                            * theta.powi((integrator.opts.max_newt_iter - 1 - newt) as i32)
	                            / integrator.opts.fnewt;
	                        if dyth >= 1.0 {
	                            let qnewt: f64 = (1.0e-4f64).max((20.0f64).min(dyth));
	                            integrator.cache.dtfac = 0.8
	                                * qnewt.powf(
	                                    -1.0f64 / (4 + integrator.opts.max_newt_iter - 1 - newt) as f64,
	                                );
	                            integrator.dt *= integrator.cache.dtfac;
	                            integrator.cache.reject = true;
	                            integrator.cache.last = false;
	                            if integrator.cache.caljac {
	                                integrator.func.dfdu(
	                                    integrator.cache.dfdu.view_mut(),
	                                    integrator.u.view(),
	                                    integrator.t,
	                                );
	                            }
	                            lloop = true;
	                            break;
	                        }
	                    } else {
	                        if ier != 0 {
	                            integrator.cache.nsing += 1;
	                            if integrator.cache.nsing >= 5 {
	                                println!("exit of RADAU5 at t = {}", integrator.t);
	                                println!("matrix is repeatedly singular");
	                                return true;
	                            }
	                        }
	                        integrator.dt *= 0.5;
	                        integrator.cache.dtfac = 0.5;
	                        integrator.cache.reject = true;
	                        integrator.cache.last = false;
	                        if !integrator.cache.caljac {
	                            integrator.func.dfdu(
	                                integrator.cache.dfdu.view_mut(),
	                                integrator.u.view(),
	                                integrator.t,
	                            );
	                        }
	                        lloop = true;
	                        break;
	                    }
	                }
	                dynold = (dyno).max(f64::EPSILON);
	                for i in (0)..(n) {
	                    integrator.cache.f1[i] = integrator.cache.f1[i] + integrator.cache.z1[i];
	                    integrator.cache.f2[i] = integrator.cache.f2[i] + integrator.cache.z2[i];
	                    integrator.cache.f3[i] = integrator.cache.f3[i] + integrator.cache.z3[i];
	                    integrator.cache.z1[i] = Radau5::T11 * integrator.cache.f1[i]
	                        + Radau5::T12 * integrator.cache.f2[i]
	                        + Radau5::T13 * integrator.cache.f3[i];
	                    integrator.cache.z2[i] = Radau5::T21 * integrator.cache.f1[i]
	                        + Radau5::T22 * integrator.cache.f2[i]
	                        + Radau5::T23 * integrator.cache.f3[i];
	                    integrator.cache.z3[i] =
	                        Radau5::T31 * integrator.cache.f1[i] + integrator.cache.f2[i];
	                }
	                if integrator.cache.faccon * dyno <= integrator.opts.fnewt {
	                    break;
	                }
	            }
2c885e7886282d8d58c259b4c8d0a0b0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|148|22|v|rust
	dyno
947354959bbeca83c6d39a689921e4fd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|5|83|v|rust
	-> bool
bc04b63c8dfb8ea249fbd1a0299b4e2f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|120|17|V|rust
	                        lloop = true;
e5827505cc74a8eb7d9efbc6e6c94739|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|142|21|V|rust
	                    lloop = true;
d8a5f040eebecf11a0b4a457bcf9863f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|142|21|V|rust
	                    break;
9b2e4b5e8d5338cf511a50e45a2cca4b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|11|23|v|rust
	= integrator.opts.theta.abs(
f050e82be8c81f7eaf89fbab7effddb6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|11|1|V|rust
	        let mut theta;
7fd60bd5d6f339901094667327752d57|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|93|21|v|rust
	theta = 
877c23fc4acffc423e77662b4ce34c56|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|67|9|V|rust
	        return ier;
28cbdaaf24a4d60217ded313a82336d6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|9|7|v|rust
	-> usize 
b70249d6bb132fc46c5c673323126231|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|207|13|v|rust
	l = 
9bba4b01217639637c4d190f6fe367c5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|205|13|v|rust
	// error estimation
	            integrator.cache.err = 0.0;
	            Self::error_estimate(integrator);
	
	            // computation of hnew -- require 0.2 <= hnew/integrator.dt <= 8.
	            let fac = (integrator.opts.safe)
	                .min(integrator.cache.cfac / (newt + 2 * integrator.opts.max_newt_iter) as f64);
	            let mut quot = (integrator.opts.facr)
	                .max((integrator.opts.facl).min(integrator.cache.err.powf(0.25) / fac));
	            let mut hnew = integrator.dt / quot;
	
	            //  is the error small enough ?
	            if integrator.cache.err < 1.0 {
	                // step is accepted
	                integrator.cache.first = false;
	                integrator.stats.accepts += 1;
	                if integrator.opts.modern_pred {
	                    // predictive controller of Gustafsson
	                    if integrator.stats.accepts > 1 {
	                        let mut facgus = (integrator.cache.dtacc / (integrator.dt))
	                            * (integrator.cache.err * integrator.cache.err
	                                / integrator.cache.erracc)
	                                .powf(0.25)
	                            / integrator.opts.safe;
	                        facgus = (integrator.opts.facr).max((integrator.opts.facl).min(facgus));
	                        quot = (quot).max(facgus);
	                        hnew = integrator.dt / quot;
	                    }
	                    integrator.cache.dtacc = integrator.dt;
	                    integrator.cache.erracc = (1.0e-2f64).max(integrator.cache.err);
	                }
	                integrator.tprev = integrator.t;
	                integrator.dtprev = integrator.dt;
	                integrator.t = tph;
	                let mut ak: f64;
	                let mut acont3: f64;
	                for i in (0)..(n) {
	                    integrator.u[i] = integrator.u[i] + integrator.cache.z3[i];
	                    integrator.cache.cont[i + n] =
	                        (integrator.cache.z2[i] - integrator.cache.z3[i]) / Radau5::C2M1;
	                    ak = (integrator.cache.z1[i] - integrator.cache.z2[i]) / Radau5::C1MC2;
	                    acont3 = integrator.cache.z1[i] / Radau5::C1;
	                    acont3 = (ak - acont3) / Radau5::C2;
	                    integrator.cache.cont[i + 2 * n] =
	                        (ak - integrator.cache.cont[i + n]) / Radau5::C1M1;
	                    integrator.cache.cont[i + 3 * n] = integrator.cache.cont[i + 2 * n] - acont3;
	                }
	                for i in (0)..(n) {
	                    integrator.cache.scal[i] =
	                        integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	                }
	                if integrator.opts.dense {
	                    for i in (0)..(n) {
	                        integrator.cache.cont[i] = integrator.u[i];
	                    }
	                    let irtrn = 1;
	                    // irtrn = SolutionOutput();
	                    if irtrn < 0 {
	                        println!("exit of RADAU5 at t = {}", integrator.t);
	                        return true;
	                    }
	                }
	                integrator.cache.caljac = false;
	                if integrator.cache.last {
	                    integrator.dt = integrator.cache.dtopt;
	                    return true;
	                }
	                integrator.func.dudt(
	                    integrator.cache.u0.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	                integrator.stats.function_evals += 1;
	                hnew = integrator.tdir * hnew.abs().min(integrator.opts.dtmax);
	                integrator.cache.dtopt = integrator.dt.min(hnew);
	                if integrator.cache.reject {
	                    hnew = integrator.tdir * (hnew).abs().min(integrator.dt.abs());
	                }
	                integrator.cache.reject = false;
	                if integrator.t + hnew / integrator.opts.quot1 - integrator.tfinal * integrator.tdir
	                    >= 0.0
	                {
	                    integrator.dt = integrator.tfinal - integrator.t;
	                    integrator.cache.last = true;
	                } else {
	                    let qt = hnew / (integrator.dt);
	                    integrator.cache.dtfac = integrator.dt;
	                    if integrator.cache.theta <= integrator.opts.theta
	                        && (qt >= integrator.opts.quot1 && (qt <= integrator.opts.quot2))
	                    {
	                        continue;
	                    }
	                    integrator.dt = hnew;
	                }
	                integrator.cache.dtfac = integrator.dt;
	                if integrator.cache.theta > integrator.opts.theta {
	                    integrator.func.dfdu(
	                        integrator.cache.dfdu.view_mut(),
	                        integrator.u.view(),
	                        integrator.t,
	                    );
	                }
	            } else {
	                // step is rejected
	                integrator.cache.reject = true;
	                integrator.cache.last = false;
	                if integrator.cache.first {
	                    integrator.dt *= 0.1;
	                    integrator.cache.dtfac = 0.1;
	                } else {
	                    integrator.cache.dtfac = hnew / (integrator.dt);
	                    integrator.dt = hnew;
	                }
	                if integrator.stats.accepts >= 1 {
	                    integrator.stats.rejects += 1;
	                }
	                if !integrator.cache.caljac {
	                    integrator.func.dfdu(
	                        integrator.cache.dfdu.view_mut(),
	                        integrator.u.view(),
	                        integrator.t,
	                    );
	                }
	            }
2c9840aa8bfe895d623d61021239feb1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|6|12|v|rust
	 // error estimation
	            integrator.cache.err = 0.0;
	            Self::error_estimate(integrator);
90ec3dc933df04afae22e0b721b0b364|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|200|13|v|rust
	let newt = 
657b496cd522af3e7d5ef40c2239bf4e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|167|2|V|rust
	        newt
9e27ff0eaec8ff73ca5a426fcc79ce99|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|5|83|v|rust
	-> usize
ab204abafac09adcb1aca878cae983f1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|161|13|v|rust
	//  starting values for Newton iteration
	            if integrator.cache.first || !integrator.opts.use_ext_col {
	                for i in 0..n {
	                    integrator.cache.z1[i] = 0.0;
	                    integrator.cache.z2[i] = 0.0;
	                    integrator.cache.z3[i] = 0.0;
	                    integrator.cache.f1[i] = 0.0;
	                    integrator.cache.f2[i] = 0.0;
	                    integrator.cache.f3[i] = 0.0;
	                }
	            } else {
	                let c3q = integrator.dt / integrator.dtprev;
	                let c1q = Radau5::C1 * c3q;
	                let c2q = Radau5::C2 * c3q;
	                let mut ak1;
	                let mut ak2;
	                let mut ak3;
	                for i in 0..n {
	                    ak1 = integrator.cache.cont[i + n];
	                    ak2 = integrator.cache.cont[i + 2 * n];
	                    ak3 = integrator.cache.cont[i + 3 * n];
	                    integrator.cache.z1[i] =
	                        c1q * (ak1 + (c1q - Radau5::C2M1) * (ak2 + (c1q - Radau5::C1M1) * ak3));
	                    integrator.cache.z2[i] =
	                        c2q * (ak1 + (c2q - Radau5::C2M1) * (ak2 + (c2q - Radau5::C1M1) * ak3));
	                    integrator.cache.z3[i] =
	                        c3q * (ak1 + (c3q - Radau5::C2M1) * (ak2 + (c3q - Radau5::C1M1) * ak3));
	                    integrator.cache.f1[i] = Radau5::TI11 * integrator.cache.z1[i]
	                        + Radau5::TI12 * integrator.cache.z2[i]
	                        + Radau5::TI13 * integrator.cache.z3[i];
	                    integrator.cache.f2[i] = Radau5::TI21 * integrator.cache.z1[i]
	                        + Radau5::TI22 * integrator.cache.z2[i]
	                        + Radau5::TI23 * integrator.cache.z3[i];
	                    integrator.cache.f3[i] = Radau5::TI31 * integrator.cache.z1[i]
	                        + Radau5::TI32 * integrator.cache.z2[i]
	                        + Radau5::TI33 * integrator.cache.z3[i];
	                }
	            }
e5e243c188a589ebf5b1f2491595a6be|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|5|19|v|rust
	prepare_newton
7a1d7b9cd2a1f849db9325fab4a6898f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|160|12|V|rust
	            let tph = integrator.t + integrator.dt;
f8bbd604d6594236db9e66170664304d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|149|17|V|rust
	                integrator.sol.retcod
12548a0c232cf50abbbca0086625706a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|150|17|V|rust
	                println!("exit of RADAU5 at t = {}", integrator.t);
03986e161d3ec6785275c9212cfc1c61|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|150|17|V|rust
	                println!("More than {} iterations needed.", integrator.opts.max_steps);
20a35b44d5af4de6369ebbfd41237a32|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|154|17|V|rust
	                println!("Step size too small: dt = {}", integrator.dt);
546953fab9160d4ff6e71c1442bc7f55|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|89|9|v|rust
	let n = integrator.u.len();
	        let mut ier;
	
	        // basic integration step
	        let mut lloop = false;
	        // compute the matrices e1 and e2 and their decompositions
	        integrator.cache.fac1 = Radau5::U1 / integrator.dt;
	        integrator.cache.alphn = Radau5::ALPHA / integrator.dt;
	        integrator.cache.betan = Radau5::BETA / integrator.dt;
	
	        ier = Self::decomp_real(integrator);
	
	        if ier != 0 {
	            integrator.cache.nsing += 1;
	            if integrator.cache.nsing >= 5 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                println!("Matrix is repeatedly singular.");
	                return true;
	            }
	            integrator.dt *= 0.5;
	            integrator.cache.dtfac = 0.5;
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if !integrator.cache.caljac {
	                integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	            return false;
	        }
	
	        ier = Self::decomp_complex(integrator);
	
	        if ier != 0 {
	            integrator.cache.nsing += 1;
	            if integrator.cache.nsing >= 5 {
	                println!("exit of RADAU5 at t = {}", integrator.t);
	                println!("Matrix is repeatedly singular.");
	                return true;
	            }
	            integrator.dt *= 0.5;
	            integrator.cache.dtfac = 0.5;
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if !integrator.cache.caljac {
	                integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	            return false;
	        }
	        integrator.stats.decompositions += 1;
	
	
950a3c6fd81ccbc2c8552fb9484e442b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|10|1|V|rust
	pub(crate) mod perform_decompositions;
900ad129e7092bfef9dd13f910317c1b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|113|13|V|rust
	            integrator.cache.err = 0.0;
ffa3ea51b83f054167f3c347091cb7ac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/code.rs|8|5|v|rust
	LinAlgErr
3d17778be6319c9609c1011e576d642b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|83|17|V|rust
	                println!("Matrix is repeatedly singular.");
0d6906b820e1114aad617b1970221ab3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|83|1|V|rust
	                integrator.sol.retcode = OdeRetCode::SingularMatrix;
c94b6df14416f79c1555bf037ae3c8bb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|48|9|V|rust
	        // basic integration step
ff0cdf5268af06e54dee9826b6aa1cbb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|48|9|V|rust
	        let mut lloop = false;
8c2d152eae24bd11ebb322746466c9c1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|101|9|V|rust
	        loop {
c2bef11d43d42a908d638b8e21336173|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|80|17|v|rust
	break;
fe47de5ade04f857ed3772c838087c42|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|119|9|V|rust
	        //if lloop {
4d9e62d7847d5467568fa7abb8fd792d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|119|9|V|rust
	        //   break;
0bf8265e9832338768f1e4899ff9ca15|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|119|9|V|rust
	        //}
793709f315f05acb2c6ccd50c83ce02c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|125|9|V|rust
	        //break;
779c5af1c6532bd2c4966e02c459fffb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|85|13|V|rust
	            return true;
1f8b955bc5e17596bd23c40f12ea6fbc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|71|5|V|rust
	                return true;
0d0e26604ffa3d7a95c120e32793d3ee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|70|13|V|rust
	            if 
fc6b2e4f2010f095bda5309daa2aaede|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|69|13|V|rust
	            Alg::step(self);
ee5c6e109f462a59897c408d50b730b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|70|13|V|rust
	            if !Alg::step(self) {
fa9a6cd29d1928cf154c9c20ff9750c3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|71|13|V|rust
	            } else {
2601f670cf165d33553743ba676b55e1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|71|17|V|rust
	                None
7ddd5a90fd0f28f15e9b9a264dc394f8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|71|13|V|rust
	            }
ef4b166e227c4898475178c4d90a6a7f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|33|28|v|rust
	.iter()
83a68db3a6da25a40cfd638b175aaf77|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|38|1|V|rust
	            let dx = integrator.u[0] - integrator.t.sin();
	            let dy = integrator.u[1] - integrator.t.cos();
	            assert!(dx.abs() <= integrator.opts.reltol * integrator.t.sin().abs() * 10.0);
	            assert!(dy.abs() <= integrator.opts.reltol * integrator.t.cos().abs() * 10.0);
16e1a48d4578e51253ed717647fb6b4d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|40|1|V|rust
	        while let Some(_i) = integrator.step() {
	            let dx = integrator.u[0] - integrator.t.sin();
	            let dy = integrator.u[1] - integrator.t.cos();
	            assert!(dx.abs() <= integrator.opts.reltol * integrator.t.sin().abs() * 10.0);
	            assert!(dy.abs() <= integrator.opts.reltol * integrator.t.cos().abs() * 10.0);
	        }
789df20e1fcc4d1bb26fe7bcb6ab84fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|82|17|v|rust
	usize;
0c97cfee1398bcbd086669c10a0c5be1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|35|22|v|rust
	integrator.
9534928e3441b913dae09bdb56ec147b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|37|33|v|rust
	integrator.opts.
968cedde79b213b4a3c08e28bcb470c6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|89|9|v|rust
	while integrator.cache.reject
505b97969baa28c3f607a38ee02f4f2d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|117|17|v|rust
	return;
72a5538690cddf78b8406ee3d3cf37c1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|67|19|v|rust
	Array1::<f64>::zeros(n),
bdc45383de0ffc6df5d620edc0decae9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|66|15|v|rust
	: Array1::<f64>::zeros(n),
0d7a2eb7fef797c0c9734ca6011e4a94|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|102|5|V|rust
	    fn 
fac1c8c64818f6ae91a829d2e3e04e25|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|95|1|V|rust
	struct OdeAlgorithmIterHelper<'a> {
	    iter: ::std::slice::Iter<'a, &'a (f64, Array1<f64>)>,
	}
	
	impl<T: OdeFunction, Alg: OdeAlgorithm, 'a> IntoIterator for &'a OdeIntegrator<T, Alg> {
	    type Item = &'a (f64, Array1<f64>);
	    type IntoIter = OdeAlgorithmIterHelper<'a>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeAlgorithmIterHelper {
	            iter: self.into_iter(),
	        }
	    }
	}
099a2ffe7001ddff13bbf1ee9bf84a0e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|83|63|v|rust
	, 'a>
37302ccecb8ae11c64170bc6bfa44eaa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|84|5|v|rust
	iter
d8ad48daf74cd5171b081eb751cdfdff|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|106|9|v|rust
	match self.step() {
	            Some(_i) => Some((self.t, self.u.clone())),
	            None => None,
	        }
35c478eeb46dc8de62a86f48b6150604|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|101|15|v|rust
	self.integrator.step()
716571fc570e73f843fe32f83aa2aba1|untitled:6|1|1|v|
	cannot borrow `*self.integrator` as mutable, as it is behind a `&` reference
ae92518967c291ce59caed44a2b379d3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|103|13|v|rust
	None => None,
aa1ed10d61ab3e7288ab7db3213963e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|83|30|v|rust
	'a, 
0c87ba98c66225f43756e6f8535e29cf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|46|34|v|rust
	into_
1d91aaac4638b1e94be16f791e91a4a4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|46|33|v|rust
	.into_iter()
d4e8ef7b0711d8b15baf8069f61114f9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|21|8|v|rust
	test_van_der_pol
b8079a45dc0f87dce115c897a625ecf7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|108|1|v|rust
	impl<T: OdeFunction, Alg: OdeAlgorithm> std::iter::Iterator for OdeIntegrator<T, Alg> {
	    type Item = (f64, Array1<f64>);
	    fn next(&mut self) -> Option<Self::Item> {
	        match self.step() {
	            Some(_i) => Some((self.t, self.u.clone())),
	            None => None,
	        }
	    }
	}
f2b0e27ccf4035c2aa0f0cacdcf8d87b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|93|1|v|rust
	pub struct OdeIntegratorMutIterator<'a, T: OdeFunction, Alg: OdeAlgorithm> {
	    pub integrator: &'a mut OdeIntegrator<T, Alg>,
	}
	
	impl<'a, T: OdeFunction, Alg: OdeAlgorithm> IntoIterator for &'a mut OdeIntegrator<T, Alg> {
	    type Item = (f64, Array1<f64>);
	    type IntoIter = OdeIntegratorMutIterator<'a, T, Alg>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeIntegratorMutIterator { integrator: self }
	    }
	}
	
	impl<'a, T: OdeFunction, Alg: OdeAlgorithm> Iterator for OdeIntegratorMutIterator<'a, T, Alg> {
	    type Item = (f64, Array1<f64>);
	
	    fn next(&mut self) -> Option<(f64, Array1<f64>)> {
	        let res = (*self).integrator.step();
	        match res {
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
	            None => None,
	        }
	    }
	}
254aba280e0a89c2caf04cc94e69d909|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|96|76|v|rust
	lla,
879ff7fc2bab881d8e54a03ec3aec2fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|46|33|v|rust
	.into()
71f085d8088637a020271479f4750ea4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|56|1|v|rust
	            //if integrator.opts.dense {
	            //    for i in (0)..(n) {
	            //        integrator.cache.cont[i] = integrator.u[i];
	            //    }
	            //    let irtrn = 1;
	            //    // irtrn = SolutionOutput();
	            //    if irtrn < 0 {
	            //        println!("exit of RADAU5 at t = {}", integrator.t);
	            //        return true;
	            //    }
	            //}
	 
c1f65930561ebd4a2c57059f3b212ee3|file:///Users/loganmorrison/.config/nvim/init.vim|1|106|v|vim
	
	        _\ \          /\ \         /\ \           / /\                /\ \     _                           
	       /\__ \        /  \ \       /  \ \         / /  \              /  \ \   /\_\                         
	      / /_ \_\      / /\ \ \     / /\ \_\       / / /\ \            / /\ \ \_/ / /                         
	     / / /\/_/     / / /\ \ \   / / /\/_/      / / /\ \ \          / / /\ \___/ /                          
	    / / /         / / /  \ \_\ / / / ______   / / /  \ \ \        / / /  \/____/                           
	   / / /         / / /   / / // / / /\_____\ / / /___/ /\ \      / / /    / / /                            
	  / / / ____    / / /   / / // / /  \/____ // / /_____/ /\ \    / / /    / / /                             
	 / /_/_/ ___/\ / / /___/ / // / /_____/ / // /_________/\ \ \  / / /    / / /                              
	/_______/\__\// / /____\/ // / /______\/ // //_       __\ \_\/ / /    / / /                               
	\_______\/    \/_________/ \/___________/ \_\___\     /____/_/\/_/     \/_/                                
	         _                                                                                                 
	        / /\                                                                                               
	       / /  \                                                                                              
	      / / /\ \                                                                                             
	     / / /\ \ \                                                                                            
	    / / /  \ \ \                                                                                           
	   / / /___/ /\ \                                                                                          
	  / / /_____/ /\ \                                                                                         
	 / /_________/\ \ \  _                                                                                     
	/ / /_       __\ \_\/\_\                                                                                   
	\_\___\     /____/_/\/_/                                                                                   
	        _   _         _            _           _            _         _            _            _          
	       /\_\/\_\ _    /\ \         /\ \        /\ \         /\ \      / /\         /\ \         /\ \     _  
	      / / / / //\_\ /  \ \       /  \ \      /  \ \        \ \ \    / /  \       /  \ \       /  \ \   /\_\
	     /\ \/ \ \/ / // /\ \ \     / /\ \ \    / /\ \ \       /\ \_\  / / /\ \__   / /\ \ \     / /\ \ \_/ / /
	    /  \____\__/ // / /\ \ \   / / /\ \_\  / / /\ \_\     / /\/_/ / / /\ \___\ / / /\ \ \   / / /\ \___/ / 
	   / /\/________// / /  \ \_\ / / /_/ / / / / /_/ / /    / / /    \ \ \ \/___// / /  \ \_\ / / /  \/____/  
	  / / /\/_// / // / /   / / // / /__\/ / / / /__\/ /    / / /      \ \ \     / / /   / / // / /    / / /   
	 / / /    / / // / /   / / // / /_____/ / / /_____/    / / /   _    \ \ \   / / /   / / // / /    / / /    
	/ / /    / / // / /___/ / // / /\ \ \  / / /\ \ \  ___/ / /__ /_/\__/ / /  / / /___/ / // / /    / / /     
	\/_/    / / // / /____\/ // / /  \ \ \/ / /  \ \ \/\__\/_/___\\ \/___/ /  / / /____\/ // / /    / / /      
	        \/_/ \/_________/ \/_/    \_\/\/_/    \_\/\/_________/ \_____\/   \/_________/ \/_/     \/_/       
	                                                                                                            
	
	
	
320bc34b3e8e1b2ec3489400ca9c2949|file:///Users/loganmorrison/.config/nvim/init.vim|1|1|V|vim
	   _             _            _              _                   _                                   
	
5cb1176ca3e9027e7419ba7cc7413174|file:///Users/loganmorrison/.config/nvim/init.vim|1|1|v|vim
	    __                               ___         
	   / /   ____  ____ _____ _____     /   |        
	  / /   / __ \/ __ `/ __ `/ __ \   / /| |        
	 / /___/ /_/ / /_/ / /_/ / / / /  / ___ |_       
	/_____/\____/\__, /\__,_/_/_/_/  /_/  |_(_)      
	   /  |/  /_//__//________(_)________  ____      
	  / /|_/ / __ \/ ___/ ___/ / ___/ __ \/ __ \     
	 / /  / / /_/ / /  / /  / (__  ) /_/ / / / /     
	/_/  /_/\____/_/  /_/  /_/____/\____/_/ /_/
	
	
97c7bcd17242aeadb684e18aa0e1302c|file:///Users/loganmorrison/.config/nvim/init.vim|16|1|V|vim
	                                          
1b5cda5f877043f48c75759f048d6ced|file:///Users/loganmorrison/.config/nvim/init.vim|22|1|V|vim
	" Plugin
1be963371ade41e2b3aff1b26a4d41d8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|14|18|v|rust
	integrator.opts.facl
ae3e2b1195595c985d1cd9d4018ae22c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|26|51|v|rust
	integrator.cache.err
3cfb7b996735e729d20efc50aba4c0bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|29|30|v|rust
	integrator.opts.facr
bbbdf0e0e8228d2df299395c42f8ebdc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|30|28|v|rust
	quot
4dfb60727bee510d1710a9324a1e9fc9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|34|43|v|rust
	1.0e-2f64
d0a40bb6ddd89ad7e733804271c02c38|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|43|36|v|rust
	integrator.u[i] + 
c87ec0e4d2ef4170c30217ad227bf125|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|87|43|v|rust
	dtnew
8cf67bbcb55c40a89cae4edd31c4a423|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|98|20|v|rust
	integrator.cache.theta <= integrator.opts.theta
c3abf930e8f4ba55e53ec2a5f8ea2f0e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|99|24|v|rust
	qt >= integrator.opts.quot1 && (qt <= integrator.opts.quot2)
fed49572e056aa30792e596fe41b3d2c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|9|19|v|rust
	integrator.opts.safe
73573cb58611265f7ed7efa1e8e883b3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|40|1|V|rust
	    pub use_ext_col: bool,
043f7e52460834b5b9cf5ecd7abfdc4a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|21|1|v|rust
	use_
1c42dc87157811406b3617d437bc5f9d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|20|25|v|rust
	: bool,
53a41677e20e1f9b2a3e495d633ec34a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|186|43|v|rust
	integrator.cache.f3[i] + 
c62eba3bef8afd07a5160efa6b9aacd3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|185|43|v|rust
	integrator.cache.f2[i] + 
e109a6b8a1b5236e574251c86e5c81d3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|184|43|v|rust
	integrator.cache.f1[i] + 
fa3baf2daf576715bebea5fd71b7f6ac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|13|28|v|rust
	.diag()
eb3e3dafd5e77db6fd94234cc4206a99|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|15|13|v|rust
	&(integrator.cache.fac1 * Array::eye(integrator.cache.e1.shape()[0])
1f66769e75bdb37468b9fbd7b024fe07|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|16|9|V|rust
	        integrator.cache.e1 +=
cd5118eb61eef89d3fad7ba7345ae492|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|18|1|V|rust
	        for j in 0..n {
	            for i in 0..n {
	                integrator.cache.e1[[i, j]] = -integrator.cache.dfdu[[i, j]];
	            }
	            integrator.cache.e1[[j, j]] += integrator.cache.fac1;
	        }
b485166cd09072295a71b4425427a0e4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|10|9|V|rust
	        let n = integrator.cache.e1.nrows();
b54ba538cf98a8e00ad89c5f2285a001|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|10|17|v|rust
	integrator.cache.e1.nrows();
	
	
f4dab9ba13c55e5901eafa8b7e20c609|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|10|9|v|rust
	integrator.cache.e1.assign(
	            &(&(integrator.cache.fac1 * Array::eye(integrator.cache.e1.shape()[0])
	                - &integrator.cache.dfdu)),
	        );
7874a31cb70449f5854eb3d86cb15dde|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|28|34|v|rust
	fac1
109a53f9859c224a9df8b3045cb6da75|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|27|9|v|rust
	integrator.cache.e2r.assign(
	            &(&(integrator.cache.alphn * Array::eye(integrator.cache.e1.shape()[0])
	                - &integrator.cache.dfdu)),
	        );
48c1a1bc368794599424c243fd21f909|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|33|17|v|rust
	- &integrator.cache.dfdu
fa85172158d66345068f8f58154817c7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|34|24|v|rust
	integrator.cache.alphn * Array::eye(integrator.cache.e1.shape()[0])
a5382791510acdfff2d0b9c1bad7291b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|34|40|v|rust
	alphn
37fb815be786e4d7db3ac246e41d0598|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|35|1|v|rust
	
	        for j in 0..n {
	            for i in 0..n {
	                integrator.cache.e2r[[i, j]] = -integrator.cache.dfdu[[i, j]];
	                integrator.cache.e2i[[i, j]] = 0.0;
	            }
	            integrator.cache.e2r[[j, j]] += integrator.cache.alphn;
	            integrator.cache.e2i[[j, j]] = integrator.cache.betan;
	        }
	
dd31eddf009ba7d156148ed336a08231|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|25|17|v|rust
	integrator.cache.e1.nrows()
7a8d0708d52623b7285598b950ffe3e7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|25|9|V|rust
	        let n = ;
b93b6c1125de813a322f484e1343ebda|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|29|42|v|rust
	Array::eye(integrator.cache.e1.shape()[0])
b10392fccd4f711fc9bf750a67d58b5b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|31|22|v|rust
	&(integrator.cache.alphn * &iden - &integrator.cache.dfdu)
37870093137a35bd2d156f7ac7f389c3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|11|13|v|rust
	&(integrator.cache.fac1 * Array::eye(integrator.cache.e1.shape()[0])
	                - &integrator.cache.dfdu)
750f9106ad07778ca3eecb4e7086f0af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|28|1|V|rust
	        // E2r = alpha * I - dfdu
2c1743a391305fbf367df8e4f069f9f9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|33|18|v|rust
	alpha
2335acb7c8703614e6ba901d18221027|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|33|27|v|rust
	- dfdu
ca8ce869a3425592f366bd60c2391cb3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|84|1|V|rust
	        ier = Self::decomp_complex(integrator);
5224b1b0846487758e2e9d69773e14b2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|91|1|V|rust
	            integrator.cache.nsing += 1;
	            if integrator.cache.nsing >= 5 {
	                integrator.sol.retcode = OdeRetCode::SingularMatrix;
	                return false;
	            }
	            integrator.dt *= 0.5;
	            integrator.cache.dtfac = 0.5;
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if !integrator.cache.caljac {
	                integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	            return false;
8493233076c50d65d80bf227fd39139d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|111|1|V|rust
	        integrator.stats.decompositions += 1;
6dba05f9297406104697c57e7ccbd3d7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|88|1|V|rust
	        if ier != 0 {
	            integrator.cache.nsing += 1;
	            if integrator.cache.nsing >= 5 {
	                integrator.sol.retcode = OdeRetCode::SingularMatrix;
	                return false;
	            }
	            integrator.dt *= 0.5;
	            integrator.cache.dtfac = 0.5;
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if !integrator.cache.caljac {
	                integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	            return false;
	        }
	
	        ier = Self::decomp_complex(integrator);
	
	        if ier != 0 {
	        }
	        integrator.stats.decompositions += 1;
	        true
3f11f1f36641eefc5d2d412ec4dc88cf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|51|5|V|rust
	        let n = integrator.u.len();
9da307619641e2c061b840ac05e243bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|58|9|v|rust
	Self::decomp_real(integrator)
72c03139de2e5ccc1345c3ce0d4f6e76|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|58|9|V|rust
	        Self::decomp_real(integrator);
63426b54080647aca4ed5f66f862e6f8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|59|19|v|rust
	Self::decomp_complex(integrator)
48426faf0d73ee4d6501ec94f78a7397|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|59|13|V|rust
	            ier = Self::decomp_complex(integrator);
e6ffa6382b558184f3328d9a1dc10a7a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|51|9|V|rust
	        let mut ier;
9899665d26dc29747eb4b775fcb8a43a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|23|13|V|rust
	            let mut ak3;
4ccbbacece0e1cde1c1667cb2e4a56b4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|22|13|V|rust
	            let mut ak2;
4b86200aacdebd07a4cce97eb5ce38bc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|21|13|V|rust
	            let mut ak1;
e023bc62968b5656b4b65be9de28e69a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|26|17|V|rust
	                (c1q-Radau5::C1M1).mul_add(ak3, 
dc9a82951e5f2bbdadd8e45dcaae511d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|28|1|V|rust
	                integrator.cache.z1[i] =
598db7dc7a4ddcc3f47ac3ad7d06a262|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|26|17|v|rust
	integrator.cache.z1[i] = ak3
	                    .mul_add(c1q - Radau5::C1M1, ak2)
	                    .mul_add(c1q - Radau5::C2M1, ak1)
	                    * c1q;
7e33fc2cb6a3f37a7ac97bece879db7f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|26|1|V|rust
	                integrator.cache.z1[i] = ak3
	                    .mul_add(c1q - Radau5::C1M1, ak2)
	                    .mul_add(c1q - Radau5::C2M1, ak1)
	                    * c1q;
2943acfae6f8c65ba83bda30aac01c10|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|40|1|V|rust
	                integrator.cache.z1[i] =
	                    c1q * (ak1 + (c1q - Radau5::C2M1) * (ak2 + (c1q - Radau5::C1M1) * ak3));
	                integrator.cache.z2[i] =
	                    c2q * (ak1 + (c2q - Radau5::C2M1) * (ak2 + (c2q - Radau5::C1M1) * ak3));
	                integrator.cache.z3[i] =
	                    c3q * (ak1 + (c3q - Radau5::C2M1) * (ak2 + (c3q - Radau5::C1M1) * ak3));
a9473ded85aa51851deb4859cdd53f98|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|38|16|V|rust
	                
6ed20805e1142d78953d10028b045c46|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|131|16|v|rust
	integrator.cache.newt > 1
946514ae55277e9a6e876b2e0874b3e3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|151|56|v|rust
	20f64
628cccc16e2ebc95d52716e57a49fd14|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|151|42|v|rust
	1e-4f64
e00b600b3304a22e3e979698241bfad5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|69|13|V|rust
	            // integrator.sol.ts.push(integrator.t);
740dd5f9b0432098d91ebd002f6853e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|50|37|v|rust
	10f64.max
541132939f6fcc0e131bf18339037555|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/lib.rs|1|1|V|rust
	#[cfg(test)]
	mod tests {
	    #[test]
	    fn it_works() {
	        assert_eq!(2 + 2, 4);
	    }
	}
9734a87642ae229773c503725f264952|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|7|13|V|rust
	            return 0.0
4670f3aed45988f19e13f8b159a9cb83|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|26|1|V|cpp
	    return (kALPHA_EM * pow(params.eps, 2) * sqrt(-4 * pow(mf, 2) + pow(params.mv, 2)) *
	            (7 * pow(mf, 2) + 17 * pow(params.mv, 2))) /
	            (72. * pow(kCOS_THETA_WEAK, 2) * pow(params.mv, 2));
9c2bc9406868d9b71e21dd8501e3f9aa|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/lib.rs|1|1|V|rust
	pub use constants
0cf50e6c9c9943c5d7e685d1e15bf77e|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/lib.rs|1|1|V|rust
	pub mod couplings;
3f9035fb600854294f4e356dd764d706|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|23|1|v|cpp
	//Masses
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTAU_MASS = 1776.86e-3;
	static constexpr double kUP_QUARK_MASS = 2.16e-3;
	static constexpr double kDOWN_QUARK_MASS = 4.67e-3;
	static constexpr double kSTRANGE_QUARK_MASS = 93e-3;
	static constexpr double kCHARM_QUARK_MASS = 1.27;
	static constexpr double kBOTTOM_QUARK_MASS = 4.18;
	static constexpr double kTOP_QUARK_MASS = 172.9;
	static constexpr double kW_BOSON_MASS = 80.379;
	static constexpr double kZ_BOSON_MASS = 91.1876;
	static constexpr double kHIGGS_MASS = 125.10;
	static constexpr double kNEUTRAL_PION_MASS = 134.9766e-3;
	static constexpr double kCHARGED_PION_MASS = 139.57018e-3;
	static constexpr double kNEUTRAL_KAON_MASS = 497.61e-3;
	static constexpr double kLONG_KAON_MASS = 497.614e-3;
	static constexpr double kCHARGED_KAON_MASS = 493.68e-3;
	
	
02b5f4ef5dd24c17ec356a7bf1a9ca1e|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|1|1|V|rust
	//Masses
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
7ba30fad535d03ad7b58425bcd5c648b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|v|rust
	static constexpr double k
d50bbd1729d1cdf902ac83082c3b057a|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|5|26|v|rust
	:f64
9d6fb6a0125d810b7aa182eb1a8d8331|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|1|1|V|rust
	/// Electron mass in GeV
0df2da9cf88450e6758356da45b4d04f|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|3|5|v|rust
	Electron
579c7649257a5ff2891652cbac8ad106|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|3|1|V|rust
	/// Muon mass in GeV
f6be6a7241de9da99f9a2eef8fca8882|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|5|5|v|rust
	Muon
8c2a4631d03aef060d83383e72c9f4ba|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|5|1|V|rust
	/// Tau mass in GeV
1224fe97a75f814b579acb2349db32fb|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|7|1|V|rust
	/// Up-quark mass in GeV
ad584f9c9138e0c765e933296b3e8ad5|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|9|1|V|rust
	/// Down-quark mass in GeV
08a38277b0309070706f6652eeae9a53|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|11|5|v|rust
	Down
de45cd460b5ca1180945de4a8559220b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|11|1|V|rust
	/// Strange-quark mass in GeV
704c84136858e0f2b3bfa41e06a9b2be|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|13|5|v|rust
	Strange
1adda852a2db596a8827a462f3e752fa|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|13|1|V|rust
	/// Charm-quark mass in GeV
32ce041007058889bd9ccb8b22ade877|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|15|5|v|rust
	Charm
f39a276e0e504d84ad8cd1cd14c2d22f|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|15|1|V|rust
	/// Bottom-quark mass in GeV
2ad9d63b69c4a10a5cc9cad923133bc4|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|5|v|rust
	Bottom
2aa09cfde067512da4e90ba168c29d2c|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|17|1|V|rust
	/// Top-quark mass in GeV
bd931c6aa96ad69f7b49b4fc62ac33f0|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|19|5|v|rust
	-quark
c2ae100d0ae79421438a4423eedaf48d|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|19|1|V|rust
	/// W-boson mass in GeV
2404c4845cb7f738009f309915755b3d|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|21|1|V|rust
	/// Z-boson mass in GeV
dec144c55f5ee9e6c111b0c812ffe36f|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|23|1|V|rust
	/// Higgs-boson mass in GeV
935c24e8c0f2786b1647f5b2e8cf4eeb|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|25|5|v|rust
	Higgs
2d2c6b7c323fc301d419974bc2151a40|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|25|13|v|rust
	boson
2884e1359fa52c4374d05eb47126bbab|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|25|1|V|rust
	/// Neutron-pion mass in GeV
88fac409baf592beb25e285d8663edcb|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|27|5|v|rust
	Neutron
2ad1afbd23efcff7588d5d7f634b8c63|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|27|1|V|rust
	/// Charged-pion mass in GeV
b1c2b9d67c3196aa206d0443269ed775|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|29|5|v|rust
	Charged
655fa8619f87748c616c5b41f1452716|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|29|1|V|rust
	/// Neutral-pion mass in GeV
5d97188d1ec5fba22bf55508c4ac70f6|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|31|5|v|rust
	Neutral-pion
0065d24d17ed237ca0cea5dcbc2dc2c5|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|31|1|V|rust
	/// Long-Kaon mass in GeV
8394f0347c184cf156ac5924dccb773b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|33|5|v|rust
	Long
16e66b4520a0a7230737d37c089a25c1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|42|1|V|cpp
	//Boson widths
	static constexpr double kW_BOSON_WIDTH = 2.085;
	static constexpr double kZ_BOSON_WIDTH = 2.4952;
	static constexpr double kHIGGS_WIDTH = 4.07e-3;
a73b56378ff8b101aca184ba8f0c575a|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	static 
a73b56378ff8b101aca184ba8f0c575a|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	static 
a73b56378ff8b101aca184ba8f0c575a|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	static 
8cbd8517bc3ecc1214220b97586eb37b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	constexpr 
8cbd8517bc3ecc1214220b97586eb37b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	constexpr 
8cbd8517bc3ecc1214220b97586eb37b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	constexpr 
586af9192c0228a6ce6a8d625a68a0cd|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	double 
586af9192c0228a6ce6a8d625a68a0cd|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	double 
586af9192c0228a6ce6a8d625a68a0cd|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|4|1|v|rust
	double 
96969a2a65091f37a598c8692de18613|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|1|1|V|rust
	//Boson widths
c395f94b329bff062a19a78d53cccd97|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|1|1|V|rust
	/// W-boson decay width in GeV
1331c535c8370f99f30103591f051f04|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|10|1|V|cpp
	static constexpr double kG_FERMI = 1.1663787e-5;
	static constexpr double kHIGGS_VEV = 246.21965;
	static constexpr double kALPHA_EM = 1.0 / 137.0; //at p^2 = 0
	static constexpr double kSIN_THETA_WEAK = 0.480853;
	static constexpr double kSIN_THETA_WEAK_SQRD = 0.23122;
	static constexpr double kCOS_THETA_WEAK = 0.876801;
fcf96ae93efd7282d58b8df752ee76ee|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|1|1|V|rust
	/// Fermi constant in GeV^-2
b573877c7f18b2dd15f4cc7dd1d0cd63|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|3|5|v|rust
	Fermi constant in GeV^-2
3b0d5107133a932ea7d636d9778a931f|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|3|1|V|rust
	/// Higgs VEV in GeV
83dc9b2995494ab735bf2815ba09c65d|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|5|5|v|rust
	Higgs VEV in GeV
8c0920f13a6693276868349ef3a9927f|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|5|1|V|rust
	/// Fine-structure constant at p^2 = 0
a910adf9f80976847a01976db5698c7e|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|7|5|v|rust
	Fine-structure constant at p^2 = 0
674ce2d28ae95b8ee1b6c6198b867cd3|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|7|1|V|rust
	/// Sine of the Weinberg angle
46dcdb393a03771d34f9917053a8c3a1|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|9|1|V|rust
	/// Sine squared of the Weinberg angle
eaed38e30899686cdf33620471effd41|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|11|12|v|rust
	squared
36b1b32ddef877903ae939691b96a715|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|16|1|V|cpp
	static constexpr double kM_PLANK = 1.220910e19;
	static constexpr double kRHO_CRIT = 1.05375e-5;
	static constexpr double kS_TODAY = 2891.2;
	static constexpr double kT_CMB = 2.56215e-10;
	static constexpr double kT_BBN = 0.0001; // 0.1 MeV in GeV
	static constexpr double kOMEGA_H2_CDM = 0.1198;
f7adafb6cefd60c45bbefae5f2fe2033|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|1|1|V|rust
	/// Plank mass in GeV
49b1e41cf37c87da06bca474b5f3069c|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|3|5|v|rust
	Plank mass in GeV
8fc9d1a13d9decf41c5ae286cc25206b|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|3|1|V|rust
	/// Critical energy density divided by h^2 in units of GeV/c^2 cm^-3
2f9b81d3a4d9dd93c84c985ce085e6b9|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|7|1|V|rust
	/// Temperature of Universe when the CMB was formed
a87ea0b39a380857815b791b7ff83cd0|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|9|34|v|rust
	the CMB was formed
02f8526e08cb42c846a2c6f729151c27|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|11|31|v|rust
	in units of
569038d7589aa3839c60848980ffb936|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/Cargo.toml|11|1|V|toml
	cyphus-integration = { path = "../cyphus-integration" }
b543b424a533bae3b646ffdab5e3ed05|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/Cargo.toml|12|1|V|toml
	cyphus-interpolation = { path = "../cyphus-interpolation" }
	ndarray = "0.13.1"
d64e052035ac79dd5e39cd935df1cde8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/Cargo.toml|10|1|v|toml
	haliax-constants
141232ac1524c026c0c4c6b6e60bd26b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/Cargo.toml|11|1|v|toml
	cyphus-interpolation =
73cc2cfdd5a00aacf57218724c54b296|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/Cargo.toml|10|1|V|toml
	haliax-constants = ["path" = ".
40100b7b602f58f7c6ae7f15e854ccc2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/Cargo.toml|10|34|v|toml
	cyphus-interpolation
ea1760d97cfc44eb4a68d0c178065b97|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|7|21|v|rust
	kALPHA_EM
36ab06170d3b1784964ef1b6575e32b9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|7|21|v|rust
	haliax_constants::electroweak::
dd1de98e8b0e34d5cf5396e83036f4d5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|9|19|v|rust
	sqrt
85f792d6dd7b45e19dfff7dfca1fe87c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|9|38|v|rust
	pow(
21ffce5b8a6cc8cc6a41448dd69623c9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|8|19|v|rust
	params
2e1944b5e4b4d0941bc31dd092b8d7a5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|5|1|V|rust
	    pub fn width_v_to_ququ(&self, mf: f64) -> f64 {
	        if self.mv > 2.0 * mf {
	            return (ALPHA_EM
	                * self.eps.powi(2)
	                * (-4.0 * mf.powi(2) + self.mv.powi(2)).sqrt()
	                * (7.0 * mf.powi(2) + 17.0 * self.mv.powi(2)))
	                / (72. * COS_THETA_WEAK.powi(2) * self.mv.powi(2));
	        } else {
	            0.0
	        }
	    }
ff6b4a11a6788e61074eaaf029d00821|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|70|1|V|cpp
	    return (kALPHA_EM * pow(params.eps, 2) * params.mv) / (24. * pow(kCOS_THETA_WEAK, 2));
e6bc2a9f5b41e14cf7b0777b4a89e6c7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|28|5|v|rust
	return 
e7c201481fcb883429df493876416979|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|28|55|v|rust
	pow(k
eec6dde90edee16092d6f6c549200ff2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|28|51|v|rust
	24.0 * COS_THETA_WEAK.powi(2)
0383ef71116608f34dd41c0936260120|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|28|9|v|rust
	ALPHA_EM * self.eps.powi(2) * self.mv
4ba6ceb4e388e1942399598b575444c8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|74|4|v|cpp
	Compute the partial width for V -> higgs + z-boson.
ec8344ba621d638457b46adc3603d2a9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|27|5|v|rust
	/// Comput the part
	
c3319bd7cdbc7c2a1083dee621ddfd9b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|27|9|v|rust
	Comput the part
	
554fdf75a9417f087bdee53ddb17cee5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|64|4|v|cpp
	Compute the partial width for V -> neutrinos.
78c173523e14cd35115bfceab0d1d018|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|27|9|v|rust
	/// Comput the part
2e6c608dcb0cc9b25a5080851bcf18bd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|48|4|v|cpp
	Compute the partial width for V -> leptons.
	
8f63a3e9f12b694193c9023dca796d0f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|32|4|v|cpp
	Compute the partial width for V -> down-type quarks.
	
3f4013292c29d58488d547bc3ea6a8ec|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|33|5|V|rust
	    pub fn width_v_to
c5fea93cf134b557e128302545ce189d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|19|9|v|rust
	if self.mv > 2.0 * mf {
	            return (ALPHA_EM
	                * self.eps.powi(2)
	                * (-4.0 * mf.powi(2) + self.mv.powi(2)).sqrt()
	                * (7.0 * mf.powi(2) + 5.0 * self.mv.powi(2)))
	                / (24.0 * COS_THETA_WEAK.powi(2) * self.mv.powi(2));
	        } else {
	            0.0
	        }
af424600ce7e806c336c1912c4a26f01|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|20|20|v|rust
	3.0 * 
b29f9b973feb2dae9eae203172efc5fb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|48|4|v|cpp
	Compute the partial width for V -> leptons.
c8b348b21ef232eb11988dd286b51761|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|83|1|V|cpp
	    return (pow(kALPHA_EM, 2) * pow(params.eps, 2) *
	            sqrt(-pow(kHIGGS_MASS, 2) + pow(pow(kHIGGS_MASS, 2) + pow(params.mv, 2) -
	                                                    pow(kW_BOSON_MASS, 2), 2) /
	                    (4. * pow(params.mv, 2))) * (2 * pow(params.mv, 2) * pow(kW_BOSON_MASS, 2) +
	            pow(-pow(kHIGGS_MASS, 2) + pow(params.mv, 2) + pow(kW_BOSON_MASS, 2), 2) / 4.) * M_PI *
	            pow(kHIGGS_VEV, 2)) /
	            (6. * pow(kCOS_THETA_WEAK, 4) * pow(params.mv, 4) * pow(kW_BOSON_MASS, 2) * pow(kSIN_THETA_WEAK, 2));
03ec33248b91be26e2ff303bc8c950bf|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|48|67|v|rust
	low(
5ea5214c27528b04eb6e97f3e42548c8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|51|12|v|rust
	 xow
e9fe0a376e3f91e71cab262ba55b0df8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|58|19|v|rust
	M_PI
478ee95840e0f5cc4ce8d0c4ede30144|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|74|4|v|cpp
	Compute the partial width for V -> higgs + z-boson.
	
19a88036e9947de529851f3e666fcba6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|102|1|V|cpp
	    return (pow(params.gvxx, 2) * sqrt(-4 * pow(params.mx, 2) + pow(params.mv, 2)) *
	            (2 * pow(params.mx, 2) + pow(params.mv, 2))) /
	            (12. * pow(params.mv, 2) * M_PI);
e70c4df10ef0983b9c8c31bd06b2a2c3|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|72|5|v|rust
	return
5c5827e603f3ca292ddb98b51116e7bb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|72|7|v|rust
	pow(params
c0ad735d087a8d165a9b9a7604fe0f48|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/widths.hpp|109|4|v|cpp
	Compute the total width or parital of the vector meidator.
0b1de22f77c7c31183c7adaf5a905080|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|6|1|V|rust
	enum KineticMixing
685b4b32536416c540aaab1f1ee2ad76|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|5|5|v|rust
	UpQuarkUpQuark
30142b55f2c683f449d5a471bf94c0be|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|5|1|V|rust
	    UUbar,
	    CCbar,
	    TTbar,
bf5d5de975937b2f02a86d8c2758b130|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|14|1|V|rust
	    NueNue,
4356a58740b454a8721ac1c6255b089c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|18|5|V|rust
	    Higgs
f7acf9f4dcc87e79fbdcca55082519b3|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|2|32|v|rust
	{
	    ALPHA_EM, COS_THETA_WEAK, HIGGS_MASS, HIGGS_VEV, SIN_THETA_WEAK, W_BOSON_MASS, Z_BOSON_MASS,
	    UP_QUARK_MASS,DOWN_QUARK_MASS,
	};
	
3615a7688d7cd53afb5f7ab998b45c4f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|82|38|v|rust
	DOWN_QUARK_MASS
23ea9578394da9c4347f0923a777c550|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|82|1|V|rust
	                self.width_v_to_ququ(CHARM_QUARK_MASS) +
f9a394519b66a362f0a54d2c86c67763|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|83|38|v|rust
	CHARM
44f8b322d7f6d520edc33992101a638a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|84|1|V|rust
	                self.width_v_to_qdqd(DOWN_QUARK_MASS) + 
c4e0e4e3118472beeb2ae75827450f1f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|85|38|v|rust
	DOWN
adee1f170ee149d821eebc40e8beeb22|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|85|38|v|rust
	STRANGE_QUARK_MASS_QUARK_MASS
470d8391bbc454cf7470304e0bb03d7c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|86|38|v|rust
	DOWN_QUARK_MASS) + 
fa5cd74ccb4db134e3f4870741ab4c50|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|87|1|V|rust
	                self.width_v_to_ll(ELECTRON_MASS) + 
5be3782adffea724ae251e73e8aaf1b1|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|88|36|v|rust
	ELECTRON_MASS
d9967325b0a7758432772089d0533604|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|90|38|v|rust
	NueNue
4e1b41b3cf3a14aa0c52b558abe410e4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|84|18|v|rust
	KineticMixingFinalStates::All {
	            self.width_v_to_ququ(UP_QUARK_MASS) +
	                self.width_v_to_ququ(CHARM_QUARK_MASS) +
	                self.width_v_to_ququ(TOP_QUARK_MASS) +
	                self.width_v_to_qdqd(DOWN_QUARK_MASS) + 
	                self.width_v_to_qdqd(STRANGE_QUARK_MASS) + 
	                self.width_v_to_qdqd(BOTTOM_QUARK_MASS) +
	                self.width_v_to_ll(ELECTRON_MASS) + 
	                self.width_v_to_ll(MUON_MASS) + 
	                self.width_v_to_ll(TAU_MASS) + 
	                3.0 * self.width_v_to_nunu()+
	                self.width_v_to_hz() +
	                self.width_v_to_xx()
	            }
	
65b6db39a38171feef29d8015f6767d2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|97|1|V|rust
	        if fs == KineticMixingFinalStates::All {
	            self.width_v_to_ququ(UP_QUARK_MASS) +
	                self.width_v_to_ququ(CHARM_QUARK_MASS) +
	                self.width_v_to_ququ(TOP_QUARK_MASS) +
	                self.width_v_to_qdqd(DOWN_QUARK_MASS) + 
	                self.width_v_to_qdqd(STRANGE_QUARK_MASS) + 
	                self.width_v_to_qdqd(BOTTOM_QUARK_MASS) +
	                self.width_v_to_ll(ELECTRON_MASS) + 
	                self.width_v_to_ll(MUON_MASS) + 
	                self.width_v_to_ll(TAU_MASS) + 
	                3.0 * self.width_v_to_nunu()+
	                self.width_v_to_hz() +
	                self.width_v_to_xx()
	            }
b02ec1a25abea7f97f1c3220e6b9718e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|94|1|V|rust
	            KineticMixingFinalStates::UU => self.width_v_to_ququ(UP_QUARK_MASS),
1324aa30694a500cfd0811949f4359a2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|95|82|v|rust
	_QUARK_MASS
86d8d72b507fb64e4e0274c21c851166|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|95|1|V|rust
	            KineticMixingFinalStates::CC => self.width_v_to_ququ(CHARM_QUARK_MASS),
17fe83f667a5ccd901054a614c0cb27f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|94|1|V|rust
	            KineticMixingFinalStates::UU => self.width_v_to_ququ(UP_QUARK_MASS),
	            KineticMixingFinalStates::CC => self.width_v_to_ququ(CHARM_QUARK_MASS),
	            KineticMixingFinalStates::TT => self.width_v_to_ququ(TOP_QUARK_MASS),
38a41b4d9693cd28727e409d0ca260da|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|100|1|V|rust
	            KineticMixingFinalStates::NueNue => self.width_v_to_nunu(),
add00f533a307ef9218db7d2d8439bd5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|101|1|V|rust
	            KineticMixingFinalStates::EE => self.width_v_to_ll(ELECTRON_MASS),
0ab3949d214bf9f6526f1d450d030c0d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|106|1|V|rust
	            KineticMixingFinalStates::NutauNutau => self.width_v_to_nunu(),
fa9b290f91831acdab5ed3f454ce33f0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|107|39|v|rust
	NutauNutau
2f8c3ab806a42e79c774cb09b41a53c8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|107|65|v|rust
	nunu
f2102a28018356517a4b3ae4a8ebd64a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|79|12|v|rust
	vector_mediator_width
976fb64c4c63338bb9b9e1f252f12689|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|79|1|V|rust
	    pub fn vector_mediator_width(&self, fs: KineticMixingFinalStates) -> f64 {
	        match fs {
	            KineticMixingFinalStates::All => {
	                self.width_v_to_ququ(UP_QUARK_MASS)
	                    + self.width_v_to_ququ(CHARM_QUARK_MASS)
	                    + self.width_v_to_ququ(TOP_QUARK_MASS)
	                    + self.width_v_to_qdqd(DOWN_QUARK_MASS)
	                    + self.width_v_to_qdqd(STRANGE_QUARK_MASS)
	                    + self.width_v_to_qdqd(BOTTOM_QUARK_MASS)
	                    + self.width_v_to_ll(ELECTRON_MASS)
	                    + self.width_v_to_ll(MUON_MASS)
	                    + self.width_v_to_ll(TAU_MASS)
	                    + 3.0 * self.width_v_to_nunu()
	                    + self.width_v_to_hz()
	                    + self.width_v_to_xx()
	            }
	            KineticMixingFinalStates::UU => self.width_v_to_ququ(UP_QUARK_MASS),
	            KineticMixingFinalStates::CC => self.width_v_to_ququ(CHARM_QUARK_MASS),
	            KineticMixingFinalStates::TT => self.width_v_to_ququ(TOP_QUARK_MASS),
	            KineticMixingFinalStates::DD => self.width_v_to_ququ(DOWN_QUARK_MASS),
	            KineticMixingFinalStates::SS => self.width_v_to_ququ(STRANGE_QUARK_MASS),
	            KineticMixingFinalStates::BB => self.width_v_to_ququ(BOTTOM_QUARK_MASS),
	            KineticMixingFinalStates::EE => self.width_v_to_ll(ELECTRON_MASS),
	            KineticMixingFinalStates::MuMu => self.width_v_to_ll(MUON_MASS),
	            KineticMixingFinalStates::TauTau => self.width_v_to_ll(TAU_MASS),
	            KineticMixingFinalStates::NueNue => self.width_v_to_nunu(),
	            KineticMixingFinalStates::NumuNumu => self.width_v_to_nunu(),
	            KineticMixingFinalStates::NutauNutau => self.width_v_to_nunu(),
	            KineticMixingFinalStates::HiggsZ => self.width_v_to_hz(),
	            KineticMixingFinalStates::XX => self.width_v_to_xx(),
	        }
	    }
ca893fc5db2204f670779030743124fc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|111|12|v|rust
	vector_mediator_
63e397b27e6a17b4fb029deb68c120a1|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|82|1|V|rust
	                self.width_v_to_ququ(UP_QUARK_MASS)
	                    + self.width_v_to_ququ(CHARM_QUARK_MASS)
	                    + self.width_v_to_ququ(TOP_QUARK_MASS)
	                    + self.width_v_to_qdqd(DOWN_QUARK_MASS)
	                    + self.width_v_to_qdqd(STRANGE_QUARK_MASS)
	                    + self.width_v_to_qdqd(BOTTOM_QUARK_MASS)
	                    + self.width_v_to_ll(ELECTRON_MASS)
	                    + self.width_v_to_ll(MUON_MASS)
	                    + self.width_v_to_ll(TAU_MASS)
	                    + 3.0 * self.width_v_to_nunu()
	                    + self.width_v_to_hz()
	                    + self.width_v_to_xx()
1c0a751e87a60f291d5a325c40e0fab8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|93|1|V|rust
	        match fs {
	            KineticMixingFinalStates::All => {
	                self.width_v_to_ququ(UP_QUARK_MASS)
	                    + self.width_v_to_ququ(CHARM_QUARK_MASS)
	                    + self.width_v_to_ququ(TOP_QUARK_MASS)
	                    + self.width_v_to_qdqd(DOWN_QUARK_MASS)
	                    + self.width_v_to_qdqd(STRANGE_QUARK_MASS)
	                    + self.width_v_to_qdqd(BOTTOM_QUARK_MASS)
	                    + self.width_v_to_ll(ELECTRON_MASS)
	                    + self.width_v_to_ll(MUON_MASS)
	                    + self.width_v_to_ll(TAU_MASS)
	                    + 3.0 * self.width_v_to_nunu()
	                    + self.width_v_to_hz()
	                    + self.width_v_to_xx()
	            }
	            KineticMixingFinalStates::UU => self.width_v_to_ququ(UP_QUARK_MASS),
	            KineticMixingFinalStates::CC => self.width_v_to_ququ(CHARM_QUARK_MASS),
	            KineticMixingFinalStates::TT => self.width_v_to_ququ(TOP_QUARK_MASS),
	            KineticMixingFinalStates::DD => self.width_v_to_ququ(DOWN_QUARK_MASS),
	            KineticMixingFinalStates::SS => self.width_v_to_ququ(STRANGE_QUARK_MASS),
	            KineticMixingFinalStates::BB => self.width_v_to_ququ(BOTTOM_QUARK_MASS),
	            KineticMixingFinalStates::EE => self.width_v_to_ll(ELECTRON_MASS),
	            KineticMixingFinalStates::MuMu => self.width_v_to_ll(MUON_MASS),
	            KineticMixingFinalStates::TauTau => self.width_v_to_ll(TAU_MASS),
	            KineticMixingFinalStates::NueNue => self.width_v_to_nunu(),
	            KineticMixingFinalStates::NumuNumu => self.width_v_to_nunu(),
	            KineticMixingFinalStates::NutauNutau => self.width_v_to_nunu(),
	            KineticMixingFinalStates::HiggsZ => self.width_v_to_hz(),
	            KineticMixingFinalStates::XX => self.width_v_to_xx(),
	        }
ba6959bc1bc370caa56835d5314ef2ea|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|79|39|v|rust
	, fs: KineticMixingFinalStates
df1f15530afec61d7d10185146df88ba|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|79|13|v|rust
	ector_mediator
a173afcfd60e2fb88bee1993eb922e9a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|43|39|v|rust
	KineticMixingFinalStates::All
6e51ef96b5cd4f999151560a3993318d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|4|1|V|rust
	use widths::*;
c4ac5f1d3ace6375a0d6ebe77a17c662|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/widths.rs|1|1|V|rust
	use super::{KineticMixing, KineticMixingFinalStates};
	use haliax_constants::prelude::*;
5c330c3a7cc3a2f954b354a4219916df|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|1|1|V|rust
	use sup
52ea1de24a305357115fefb6765fc6df|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|17|1|V|cpp
	/**
	 * Compute the annihilation cross-section for dark matter to up-type quarks.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param mf Mass of the up-type quark.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> u + ubar
	 */
	double sigma_xx_to_ququ(
	        const Parameters &params,
	        double Q,
	        double mf,
	        const std::string &channel
	) {
	    if ((channel != "s" && channel != "all") || Q <= 2.0 * mf || Q <= 2.0 * params.mx) {
	        return 0.0;
	    }
	    double temp1 = pow(params.mx, 2);
	    double temp2 = pow(Q, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return ((kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (2 * temp1 +
	            temp2) * sqrt(temp2 - 4 * temp3) * (17 * temp2 +
	            7 * temp3)) / (72. * pow(kCOS_THETA_WEAK, 2) *
	            pow(Q, 2) * sqrt(-4 * temp1 + temp2) *
	            (pow(-temp2 + temp4, 2) + temp4 * pow(params.widthv, 2))));
	}
	
	/**
	 * Compute the annihilation cross-section for dark matter to down-type quarks.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param mf Mass of the down-type quark.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> d + dbar
	 */
	double sigma_xx_to_qdqd(
	        const Parameters &params,
	        double Q,
	        double mf,
	        const std::string &channel
	) {
	    if ((channel != "s" && channel != "all") || Q <= 2.0 * mf || Q <= 2.0 * params.mx) {
	        return 0.0;
	    }
	    double temp1 = pow(Q, 2);
	    double temp2 = pow(params.mx, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return ((kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (temp1 +
	            2 * temp2) * (5 * temp1 - 17 * temp3) * sqrt(temp1 - 4 * temp3)) /
	            (72. * pow(kCOS_THETA_WEAK, 2) * pow(Q, 2) * sqrt(temp1 - 4 * temp2) *
	                    (pow(-temp1 + temp4, 2) + temp4 * pow(params.widthv, 2))));
	}
	
	/**
	 * Compute the annihilation cross-section for dark matter to leptons.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param mf Mass of the lepton.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> l + lbar
	 */
	double sigma_xx_to_ll(
	        const Parameters &params,
	        double Q,
	        double mf,
	        const std::string &channel
	) {
	    if ((channel != "s" && channel != "all") || Q <= 2.0 * mf || Q <= 2.0 * params.mx) {
	        return 0.0;
	    }
	    double temp1 = pow(params.mx, 2);
	    double temp2 = pow(Q, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return (kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (2 * temp1 +
	            temp2) * sqrt(temp2 - 4 * temp3) * (5 * temp2 + 7 * temp3)) /
	            (24. * pow(kCOS_THETA_WEAK, 2) * pow(Q, 2) * sqrt(-4 * temp1 + temp2) *
	                    (pow(-temp2 + temp4, 2) + temp4 * pow(params.widthv, 2)));
	}
	
	/**
	 * Compute the annihilation cross-section for dark matter to neutrinos.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> nu + nubar
	 */
	double sigma_xx_to_nunu(
	        const Parameters &params,
	        double Q,
	        const std::string &channel
	) {
	    if ((channel != "s" && channel != "all") || Q <= 2 * params.mx) {
	        return 0.0;
	    }
	    double temp1 = pow(Q, 2);
	    double temp2 = pow(params.mx, 2);
	    double temp3 = pow(params.mv, 2);
	    return (kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * sqrt(temp1) * (temp1 +
	            2 * temp2)) / (24. * pow(kCOS_THETA_WEAK, 2) * sqrt(temp1 - 4 * temp2) *
	            (pow(-temp1 + temp3, 2) + temp3 * pow(params.widthv, 2)));
	}
	
	/**
	 * Compute the annihilation cross-section for dark matter to a higgs and z-boson.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> H + Z.
	 */
	double sigma_xx_to_hz(
	        const Parameters &params,
	        double Q,
	        const std::string &channel
	) {
	    if ((channel != "s" && channel != "all") || Q <= kHIGGS_MASS + kW_BOSON_MASS || Q <= 2.0 * params.mx) {
	        return 0.0;
	    }
	    double temp1 = -Q;
	    double temp2 = -kW_BOSON_MASS;
	    double temp3 = pow(params.mx, 2);
	    double temp4 = pow(Q, 2);
	    double temp5 = pow(kW_BOSON_MASS, 2);
	    double temp6 = pow(params.mv, 2);
	    return (pow(kALPHA_EM, 2) * pow(params.eps, 2) * pow(params.gvxx, 2) * M_PI * sqrt(((
	            kHIGGS_MASS + kW_BOSON_MASS + Q) * (kHIGGS_MASS + kW_BOSON_MASS +
	            temp1) * (kHIGGS_MASS + Q + temp2) * (kHIGGS_MASS + temp1 +
	            temp2)) / (-4 * temp3 + temp4)) * (2 * temp3 + temp4) * (pow(kHIGGS_MASS, 4) +
	            pow(kW_BOSON_MASS, 4) + pow(Q, 4) + 10 * temp4 * temp5 -
	            2 * pow(kHIGGS_MASS, 2) * (temp4 + temp5)) * pow(kHIGGS_VEV, 2)) /
	            (48. * pow(kCOS_THETA_WEAK, 4) * pow(kW_BOSON_MASS, 2) * pow(Q, 5) * pow
	                    (kSIN_THETA_WEAK, 2) * (pow(-temp4 + temp6, 2) +
	                    temp6 * pow(params.widthv, 2)));
	}
	
	/**
	 * Compute the annihilation cross-section for dark matter to a vector mediators.
	 *
	 * @param params Model parameters.
	 * @param Q Center of mass energy.
	 * @param channel String specifying channel: "s" or "tu".
	 * @return Cross section for x + xbar -> v + v.
	 */
	double sigma_xx_to_vv(
	        const Parameters &params,
	        double Q,
	        const std::string &channel
	) {
	    if (channel == "s" || Q <= 2.0 * params.mx || Q <= 2.0 * params.mv) {
	        return 0.0;
	    }
	    double temp1 = pow(params.mx, 2);
	    double temp2 = -4 * temp1;
	    double temp3 = pow(Q, 2);
	    double temp4 = temp2 + temp3;
	    double temp5 = pow(params.mv, 4);
	    double temp6 = pow(params.mv, 2);
	    double temp7 = -4 * temp6;
	    double temp8 = temp3 + temp7;
	    double temp9 = 2 * temp6;
	    double temp10 = -temp3;
	    double temp11 = temp10 + temp9;
	    double temp12 = -2 * temp6;
	    double temp13 = sqrt(temp4);
	    double temp14 = sqrt(temp8);
	    double temp15 = temp13 * temp14;
	    double temp16 = 2 * temp1;
	    double temp17 = temp12 + temp15 + temp3;
	    return (pow(params.gvxx, 4) * ((-48 * temp13 * temp14 * (4 * pow(params.mx, 4) +
	            temp1 * temp3 + 2 * temp5)) / (temp5 + temp1 * temp8) + (48 * (temp1 * (temp12 +
	            temp2 + temp3) * log(2) + temp3 * temp6 * log(4) + (2 * temp1 * (temp16 +
	            temp6) - temp3 * (temp1 + temp9)) * log(-(pow(temp17, 2) / (-pow(Q, 4) +
	            temp13 * temp14 * temp3 - 2 * temp5 + (-2 * temp13 * temp14 + 4 * temp3) * temp6 +
	            2 * temp1 * temp8))) + temp11 * (temp12 + temp16 +
	            temp3) * log(-(temp17 / (temp10 + temp15 +
	            temp9))))) / temp11)) / (384. * M_PI * pow(Q, 2) * temp4);
	}
0c4afa3af3177882888e7169c305247a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|5|1|V|rust
	    pub fn sigma_xx_to_ququ(&self, cme: f64, mf: f64) -> {
	    }
116d44923949ce4187b7454a4bec24f4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|7|1|V|rust
	    pub fn sigma_xx_to_qdqd(&self, cme: f64, mf: f64) -> {
	    }
5604961c22dfa9d85aa444b3b3667dc9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|9|24|v|rust
	qdqd
d1a8a100f678c520341a564caea98009|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|9|1|V|rust
	    pub fn sigma_xx_to_ll(&self, cme: f64, mf: f64) -> {
	    }
c94751b42c6748e93cb921c3e3461291|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|11|1|V|rust
	    pub fn sigma_xx_to_vv(&self, cme: f64, mf: f64) -> {
	    }
c29f7ac45833e08880786d2227e08a60|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|13|1|V|rust
	    pub fn sigma_xx_to_nunu(&self, cme: f64, mf: f64) -> {
	    }
1218edcfecc165b9b10a4318d6d325ad|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|8|1|V|rust
	            0.0
8a5f96f3bbbc28a6c23f0ad229ffff68|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|6|1|V|rust
	        if cme > 2.0 * self.mx && cme > 2.0 * mf{
	            0.0
	        }else{
	            0.0
	        }
885565b5952dd795ac6951954ca894b4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|40|42|v|rust
	, mf: f64
f63b60e08cac90fcc194f6b9290d9504|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|33|44|v|rust
	, mf: f6
6b84fa38ab6884848b1f5e47b7096ebe|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|26|42|v|rust
	l mf: f64
777dc0ce1d95d9cff50db539b3a69eb5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|34|32|v|rust
	&& cme > 2.0 * mf
36fcd45d8ae482854eda0ed7670d7bea|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|41|41|v|rust
	2.0 * mf
3b9d1d0240c3e2d28bba238eacc29fc1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|35|1|V|cpp
	    double temp1 = pow(params.mx, 2);
	    double temp2 = pow(Q, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return ((kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (2 * temp1 +
	            temp2) * sqrt(temp2 - 4 * temp3) * (17 * temp2 +
	            7 * temp3)) / (72. * pow(kCOS_THETA_WEAK, 2) *
	            pow(Q, 2) * sqrt(-4 * temp1 + temp2) *
	            (pow(-temp2 + temp4, 2) + temp4 * pow(params.widthv, 2))));
eee28a1513e35ec20e781846b6817f54|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|64|1|V|cpp
	    double temp1 = pow(Q, 2);
	    double temp2 = pow(params.mx, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return ((kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (temp1 +
	            2 * temp2) * (5 * temp1 - 17 * temp3) * sqrt(temp1 - 4 * temp3)) /
	            (72. * pow(kCOS_THETA_WEAK, 2) * pow(Q, 2) * sqrt(temp1 - 4 * temp2) *
	                    (pow(-temp1 + temp4, 2) + temp4 * pow(params.widthv, 2))));
3fdb1904702e2a84404259c31e9ff9c0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|92|1|V|cpp
	    double temp1 = pow(params.mx, 2);
	    double temp2 = pow(Q, 2);
	    double temp3 = pow(mf, 2);
	    double temp4 = pow(params.mv, 2);
	    return (kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * (2 * temp1 +
	            temp2) * sqrt(temp2 - 4 * temp3) * (5 * temp2 + 7 * temp3)) /
	            (24. * pow(kCOS_THETA_WEAK, 2) * pow(Q, 2) * sqrt(-4 * temp1 + temp2) *
	                    (pow(-temp2 + temp4, 2) + temp4 * pow(params.widthv, 2)));
bf5052ff1d20ee12a9f56b390207db15|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|118|1|V|cpp
	    double temp1 = pow(Q, 2);
	    double temp2 = pow(params.mx, 2);
	    double temp3 = pow(params.mv, 2);
	    return (kALPHA_EM * pow(params.eps, 2) * pow(params.gvxx, 2) * sqrt(temp1) * (temp1 +
	            2 * temp2)) / (24. * pow(kCOS_THETA_WEAK, 2) * sqrt(temp1 - 4 * temp2) *
	            (pow(-temp1 + temp3, 2) + temp3 * pow(params.widthv, 2)));
e8cd7da078a86726031ad64f35f5a6c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|67|5|v|rust
	double
e8cd7da078a86726031ad64f35f5a6c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|67|5|v|rust
	double
e8cd7da078a86726031ad64f35f5a6c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|67|5|v|rust
	double
4fcff2ff67cde4b9f9d476d8b872fb76|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|70|1|V|rust
	            let temp1: f64 = pow(Q, 2);
	            let temp2: f64 = pow(params.mx, 2);
	            let temp3: f64 = pow(params.mv, 2);
	            (kALPHA_EM
	                * pow(params.eps, 2)
	                * pow(params.gvxx, 2)
	                * sqrt(temp1)
	                * (temp1 + 2 * temp2))
	                / (24.
	                    * pow(kCOS_THETA_WEAK, 2)
	                    * sqrt(temp1 - 4 * temp2)
	                    * (pow(-temp1 + temp3, 2) + temp3 * pow(params.widthv, 2)))
8d2608d852bf862a0246cb4c2196bb51|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|142|1|V|cpp
	    double temp1 = -Q;
	    double temp2 = -kW_BOSON_MASS;
	    double temp3 = pow(params.mx, 2);
	    double temp4 = pow(Q, 2);
	    double temp5 = pow(kW_BOSON_MASS, 2);
	    double temp6 = pow(params.mv, 2);
	    return (pow(kALPHA_EM, 2) * pow(params.eps, 2) * pow(params.gvxx, 2) * M_PI * sqrt(((
	            kHIGGS_MASS + kW_BOSON_MASS + Q) * (kHIGGS_MASS + kW_BOSON_MASS +
	            temp1) * (kHIGGS_MASS + Q + temp2) * (kHIGGS_MASS + temp1 +
	            temp2)) / (-4 * temp3 + temp4)) * (2 * temp3 + temp4) * (pow(kHIGGS_MASS, 4) +
	            pow(kW_BOSON_MASS, 4) + pow(Q, 4) + 10 * temp4 * temp5 -
	            2 * pow(kHIGGS_MASS, 2) * (temp4 + temp5)) * pow(kHIGGS_VEV, 2)) /
	            (48. * pow(kCOS_THETA_WEAK, 4) * pow(kW_BOSON_MASS, 2) * pow(Q, 5) * pow
	                    (kSIN_THETA_WEAK, 2) * (pow(-temp4 + temp6, 2) +
	                    temp6 * pow(params.widthv, 2)));
5a64edd237aa392e901328e0cf992d9c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|175|1|V|cpp
	    double temp1 = pow(params.mx, 2);
	    double temp2 = -4 * temp1;
	    double temp3 = pow(Q, 2);
	    double temp4 = temp2 + temp3;
	    double temp5 = pow(params.mv, 4);
	    double temp6 = pow(params.mv, 2);
	    double temp7 = -4 * temp6;
	    double temp8 = temp3 + temp7;
	    double temp9 = 2 * temp6;
	    double temp10 = -temp3;
	    double temp11 = temp10 + temp9;
	    double temp12 = -2 * temp6;
	    double temp13 = sqrt(temp4);
	    double temp14 = sqrt(temp8);
	    double temp15 = temp13 * temp14;
	    double temp16 = 2 * temp1;
	    double temp17 = temp12 + temp15 + temp3;
	    return (pow(params.gvxx, 4) * ((-48 * temp13 * temp14 * (4 * pow(params.mx, 4) +
	            temp1 * temp3 + 2 * temp5)) / (temp5 + temp1 * temp8) + (48 * (temp1 * (temp12 +
	            temp2 + temp3) * log(2) + temp3 * temp6 * log(4) + (2 * temp1 * (temp16 +
	            temp6) - temp3 * (temp1 + temp9)) * log(-(pow(temp17, 2) / (-pow(Q, 4) +
	            temp13 * temp14 * temp3 - 2 * temp5 + (-2 * temp13 * temp14 + 4 * temp3) * temp6 +
	            2 * temp1 * temp8))) + temp11 * (temp12 + temp16 +
	            temp3) * log(-(temp17 / (temp10 + temp15 +
	            temp9))))) / temp11)) / (384. * M_PI * pow(Q, 2) * temp4);
188ddaacf9c9dd71f5ff42b25ae1beec|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|11|13|v|rust
	(ALPHA_EM
	                * self.eps.powi(2)
	                * self.gvxx.powi(2)
	                * (2 * temp1 + temp2)
	                * (temp2 - 4 * temp3).sqrt()
	                * (17 * temp2 + 7 * temp3))
	                / (72.
	                    * COS_THETA_WEAK.powi(2)
	                    * cme.powi(2)
	                    * (-4 * temp1 + temp2).sqrt()
	                    * ((-temp2 + temp4).powi(2) + temp4 * self.widthv.powi(2)))
b7beef6a267ecb609e32692536a90603|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|32|13|v|rust
	(ALPHA_EM
	                * pow(self.eps, 2)
	                * pow(self.gvxx, 2)
	                * (temp1 + 2 * temp2)
	                * (5 * temp1 - 17 * temp3)
	                * sqrt(temp1 - 4 * temp3))
	                / (72.
	                    * pow(COS_THETA_WEAK, 2)
	                    * pow(cme, 2)
	                    * sqrt(temp1 - 4 * temp2)
	                    * (pow(-temp1 + temp4, 2) + temp4 * pow(self.widthv, 2)))
65f98998360abe002301373a0acad4cc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|40|23|v|rust
	pow(cme, 2)
4bcf7e68ce148c9257761943bc3f20db|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|83|31|v|rust
	temp4
6f5da13b596ee2fb5e3e9da4c83e45d0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|84|31|v|rust
	temp8
cfbb373a5f4aa811994adb5a26f02fa4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|92|63|v|rust
	log(2)
5a6e1c45de18185f6f674cad97aff68e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|93|47|v|rust
	log(4)
91a1cc4407660e1c185af164abe26d31|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|103|28|v|rust
	M_PI 
eabeadebff8b4a2a125ac69d28b51dfb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|71|1|V|rust
	            let temp1: f64 = self.mx.powi(2);
	            let temp2: f64 = -4.0 * temp1;
	            let temp3: f64 = cme.powi(2);
	            let temp4: f64 = temp2 + temp3;
	            let temp5: f64 = self.mv.powi(4);
	            let temp6: f64 = self.mv.powi(2);
	            let temp7: f64 = -4.0 * temp6;
	            let temp8: f64 = temp3 + temp7;
	            let temp9: f64 = 2.0 * temp6;
	            let temp10: f64 = -temp3;
	            let temp11: f64 = temp10 + temp9;
	            let temp12: f64 = -2.0 * temp6;
	            let temp13: f64 = temp4.sqrt();
	            let temp14: f64 = temp8.sqrt();
	            let temp15: f64 = temp13 * temp14;
	            let temp16: f64 = 2.0 * temp1;
	            let temp17: f64 = temp12 + temp15 + temp3;
	            (self.gvxx.powi(4)
	                * ((-48.0
	                    * temp13
	                    * temp14
	                    * (4.0 * self.mx.powi(4) + temp1 * temp3 + 2.0 * temp5))
	                    / (temp5 + temp1 * temp8)
	                    + (48.0
	                        * (temp1 * (temp12 + temp2 + temp3) * std::f64::consts::LN_2
	                            + temp3 * temp6 * 2.0 * std::f64::consts::LN_2
	                            + (2.0 * temp1 * (temp16 + temp6) - temp3 * (temp1 + temp9))
	                                * (-(temp17.powi(2)
	                                    / (-(cme.powi(4)) + temp13 * temp14 * temp3 - 2.0 * temp5
	                                        + (-2.0 * temp13 * temp14 + 4.0 * temp3) * temp6
	                                        + 2.0 * temp1 * temp8)))
	                                    .ln()
	                            + temp11
	                                * (temp12 + temp16 + temp3)
	                                * (-(temp17 / (temp10 + temp15 + temp9))).ln()))
	                        / temp11))
	                / (384.0 * std::f64::consts::PI * cme.powi(2) * temp4)
dedd9bd368543e138c5426e028ad2477|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|116|64|v|rust
	sqrt(
9c5cf990e5f12e49ae64889e61dc3693|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|152|23|v|rust
	SIN_THETA_WEAK, 2)
216c58023caa07a953a3869fd014cfdb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|18|4|v|cpp
	Compute the annihilation cross-section for dark matter to up-type quarks.
d59046229eb339b64320cd02a78a2270|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|47|4|v|cpp
	Compute the annihilation cross-section for dark matter to down-type quarks.
b7f26bd7c48ac4d23013b40d6d899894|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|49|66|v|rust
	 down-type quarks
c155189c06dd79cab352f9d674ff4edb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|160|4|v|cpp
	Compute the annihilation cross-section for dark matter to a vector mediators.
113e830faa8ca4c57f158ec83dc7e7e4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|103|4|v|cpp
	Compute the annihilation cross-section for dark matter to neutrinos.
de9ebd8664120fec2d25d7b6f11d695b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/cross_sections.hpp|127|4|v|cpp
	Compute the annihilation cross-section for dark matter to a higgs and z-boson.
0e51923fd55bbb687ee1cc4e0f5ebbc7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|7|1|V|rust
	        self.sigma_xx_to_ququ(UP_QUARK_MASS) + 
669338428ccedd23851bb121a344ec3d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|10|1|V|rust
	        self.sigma_xx_to_qdqd(DOWN_QUARK_MASS) + 
7a54bc62b300dba13ec03b086da4cb5f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|13|1|V|rust
	        self.sigma_xx_to_ll(ELECTRON_MASS) + 
43fa0b0f0e567d054cf5cc788e0c72f6|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|181|5|V|rust
	    /// 
fc3248d6c43131fd759d9f841266568e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/thermal_cross_section.rs|1|77|v|rust
	AnnihilationCrossSection2To2
2b2d9c16e231a0c20a5d9a1f12163c29|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/thermal_cross_section.rs|1|1|V|rust
	pub fn thermal_cross_section<T: AnnihilationCrossSection2To2>(x: f64, model: T) -> f64 {}
38840894c696904d4e0754d27c3f78f7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/traits.rs|13|1|v|rust
	pub trait AnnihilationCrossSection2To2 {
	    fn annihilation_cross_section(&self, cme: f64) -> f64;
	    fn thermal_cross_section(&self, x: f64) -> f64;
	}
b4a7cb107b59ab9d38b92d8f65efc29a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/lib.rs|3|9|v|rust
	traits
7fe44b5258b1194575ede2f47b0b899a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/lib.rs|4|1|V|rust
	pub mod thermal_cross_section;
24f509bb19b8373b3bbb0df41e0e3514|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/Cargo.toml|14|5|v|toml
	_static = "1.4.0"
775b09c602e0cd98df25c4a1fdbc8c6c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|17|5|V|rust
	    ///
d08c78ce0508c8e415485cd88157204d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|5|1|V|rust
	lazy_static! {}
15823ad5b11227380bfa5f9f8a8062c5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|3|1|V|rust
	use lazy_static::lazy_static;
79fe6189525f86fc446fc943d809efe5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|15|1|V|rust
	    /// Compute the thermalized annihilation cross section for
	    /// chi + chibar -> anything for a given `x=mass/temperature`.
	    fn dm_thermal_cross_section(&self, x: f64) -> f64;
c6725dd2fbd6a44d7fb9bf3a51a0256a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|3|1|V|rust
	use hali
fd6b1ef6efc0df40b937a0bd818e7883|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|3|1|V|rust
	use haliax-ther
aa3415b403b9fa2b8273025004685bcc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|21|9|V|rust
	        0.0
26a27f04d02b653b4b5b77b5d11d7bb9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|33|35|v|rust
	thermal
b4a88417b3d0170d754c647c30b7216a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|36|53|v|rust
	result
70620cbbf98ce28024b57970490c5f2b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|6|1|V|rust
	    fn annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.sigma_xx_to_ququ(cme, UP_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, CHARM_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, TOP_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, DOWN_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, STRANGE_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, BOTTOM_QUARK_MASS)
	            + self.sigma_xx_to_ll(cme, ELECTRON_MASS)
	            + self.sigma_xx_to_ll(cme, MUON_MASS)
	            + self.sigma_xx_to_ll(cme, TAU_MASS)
	            + 3.0 * self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_vv(cme)
	    }
295e32732251b55cba9efdab632f6da0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|6|5|v|rust
	fn annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.sigma_xx_to_ququ(cme, UP_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, CHARM_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, TOP_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, DOWN_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, STRANGE_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, BOTTOM_QUARK_MASS)
	            + self.sigma_xx_to_ll(cme, ELECTRON_MASS)
	            + self.sigma_xx_to_ll(cme, MUON_MASS)
	            + self.sigma_xx_to_ll(cme, TAU_MASS)
	            + 3.0 * self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_vv(cme)
	    }
cfae3efe5d933ee4c7bfd6c4d7e195ea|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|5|1|V|rust
	impl AnnihilationCrossSection2To2 for KineticMixing {}
73e87c41d2a43dd115943a8aa06321de|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|2|1|V|rust
	use crate::standard_dm_model::StandardDmModel;
ee925d816b38ab89f8970d9bd96c3fdc|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/thermal_cross_section.hpp|55|1|V|cpp
	    // Resonance: sqrt(s) = mv = z * mx => z = mv / mx > 2 => mv > 2mx > mx
	    // Threshold: sqrt(s) = 2mv = z * mx => z = 2mv / mx > 2 => mv > mx
c9837135107b3a694da1b3ee88a42dd8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|56|1|V|rust
	
	        // Resonance: sqrt(s) = mv = z * mx => z = mv / mx > 2 => mv > 2mx > mx
824c6d07f29dc142d957e67da1a615a7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|62|12|v|rust
	self.mx < self.mv
c0777caf33f13e1cd39dbb2fcdd482f3|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|63|16|v|rust
	2.0 * self.mx < self.mv
b18cf515cdcde80fb53ffc86cb3bf5be|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|66|22|v|rust
	self.mv / self.mx
72e8540b6f9bf47feb6b03e970524eeb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|82|9|V|rust
	        let x = 1.0;
21de7b38591cd1fd7d842974d3ddea38|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|36|9|V|rust
	        print!
d2d3017f75397c00e52b14db089b72b7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|80|27|v|rust
	dm_annihilation_cross_section
b7366a94af8e214726eaca6d7e425933|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|77|1|V|rust
	    #[test]
	    fn test_tcs() {
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-3);
	        println!("{}", km.dm_thermal_cross_section(1.0));
	    }
024c6898cfb88273e0d774ea39a80b42|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|80|27|v|rust
	dm_thermal_cross_section
9b4ce78d413253f8d909f39e6d0f328e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|36|20|v|rust
	singular_points(self.dm_thermal_cross_section_singular_pts())
c7d58f09975f1acdf6c2c05d4b325fee|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|36|14|v|rust
	(dbg!(
85f80138bcfb86999ee8b2b593f64036|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|31|9|V|rust
	        let sp = singular_points(self.dm_thermal_cross_section_singular_pts());
64aa3cae2fb418ce53d7eeef9b71698d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|29|13|V|rust
	            (sig * kernal).classify()
1b3e5eb1fea10d9873a13f21e079470f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|29|1|V|rust
	            if res.classify() == std::num::FpCategory::Normal {
	                res
	            } else {
	                0.0
	            }
c42c575fe511248e3007894cf21805d9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/qagp.rs|363|1|V|rust
	    #[test]
	    fn test() {
	        let f = |x| f454(x);
	
	        let exp_result = 5.274080611672716401E+01;
	        let exp_abserr = 1.755703848687062418E-04;
	        let points = vec![0.0, 1.0, 2f64.sqrt(), 3.0];
	
	        let result = qagp(f, &points, 0.0, 1e-3, 1000, 2);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
f7079e8f786bb825c5c5186b5cdfef98|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|252|1|V|rust
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(1e-7)
	            .epsrel(0.0)
	            .key(1)
	            .build();
77f718e52abb7ba5d00428e7825f4393|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|281|9|V|rust
	        let result = qagp(f, &points, 0.0, 1e-3, 1000, 2);
e68470b0176ef031177577f4a644990b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|272|27|v|rust
	0.0, 
9e0a125c71efa6811a59f01df4db1e4f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|272|43|v|rust
	, 3.0
d3fdfbd125634aa1f1c37f801dd19431|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|278|21|v|rust
	1e-7
30ece05394459cdf5bcce2a22ab7cd45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|274|5|V|rust
	        //let result = qagp(f, &points, 0.0, 1e-3, 1000, 2);
900c2ad0968c249e700772fd24cdc564|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|34|46|v|rust
	is_infinite()
9ff836de6459a98f6b6c54989b725cf9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|28|13|v|rust
	let res = 
d889e6b1191e1e686189f5f8dbe3bc59|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|37|14|v|rust
	pf * 
1d540b0d56c980e26b4a6440f5f5fc1e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|58|1|V|rust
	                        *singular_points.last().unwrap(),
cf40e84b6b8e9d765b35310d3b9fb510|term://.//9197%3A/bin/zsh|831|10|v|floaterm
	0.00000000000019443863883485052
0382cdd173b76ab1ae31e392e78872c2|term://.//9197%3A/bin/zsh|1081|1|v|floaterm
	0.000000000000000027750614936183422
95a5ea70d18b0206cbf8311976e22c9c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|37|13|v|rust
	 dbg!
7aaec5e2e0ee143ef0d0e9ebf260f422|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|37|13|v|rust
	gk.integrate(integrand, 2.0, f64::INFINITY)
561b52cfca345e6cfd0018bce40e55ff|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|59|1|V|rust
	        let resonance = self.mv / self.mx;
	        let threshold = 2.0 * self.mv / self.mx;
d01da7c0bdf70163cd9d7f13ee207998|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|66|27|v|rust
	lf.mv / self.mx;
4dea68aa551f8a6d7458128579a7016f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|66|1|V|rust
	        let resonance = self.mv / self.mx;
	        let threshold = 2.0 * self.mv / self.mx;
	
	        if threshold > 2.0 {
	            if resonance > 2.0 {
	                vec![resonance, threshold]
	            } else {
	                vec![threshold]
	            }
	        } else {
	            vec![]
	        }
f4fb4aa8aaf2f2ab1c12154cf08c812f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|50|1|V|rust
	        if resonance > 2.0{
	
	        }
9202fe69f8f2bcfbcaa065619be8c59e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|71|1|V|rust
	        // Resonance: sqrt(s) = mv = z * mx => z = mv / mx > 2 => mv > 2mx > mx
	        // Threshold: sqrt(s) = 2mv = z * mx => z = 2mv / mx > 2 => mv > mx
	        let resonance = self.mv / self.mx;
	        let threshold = 2.0 * self.mv / self.mx;
	
	        if threshold > 2.0 {
	            if resonance > 2.0 {
	                vec![resonance, threshold]
	            } else {
	                vec![threshold]
	            }
	        } else {
	            vec![]
	        }
7e794cc252be8df0e65a3647eedeb5d6|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|21|1|V|rust
	        let m = self.dm_mass();
	        let denom = dbg!(2.0 * x.cyl_bessel_kn_scaled(2));
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.dm_annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-8)
	            .singular_points(self.dm_thermal_cross_section_singular_pts())
	            .build();
	
	        pf * gk.integrate(integrand, 2.0, f64::INFINITY).val
c1ace5c309909971ded2bf85895f670d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|18|1|V|rust
	    /// Compute the thermalized annihilation cross section for
	    /// chi + chibar -> anything for a given `x=mass/temperature`.
	    fn dm_thermal_cross_section(&self, x: f64) -> f64 {
	        let m = self.dm_mass();
	        let denom = dbg!(2.0 * x.cyl_bessel_kn_scaled(2));
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.dm_annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-8)
	            .singular_points(self.dm_thermal_cross_section_singular_pts())
	            .build();
	
	        pf * gk.integrate(integrand, 2.0, f64::INFINITY).val
	    }
cc531a55ccb2a96286bbed687bb47d40|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|2|1|V|rust
	use cyphus_integration::GaussKronrodIntegratorBuilder;
	use cyphus_specfun::bessel::CylBesselK;
9d8c4366889f38bed56fe8c3745c0c56|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|33|5|V|rust
	    singular_points: Vec<f64>,
feaabc0dfb2a8a6b49e5101b037c8e26|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|65|13|v|rust
	singular_points
56dba570d47222b5097b8848fc7fc4ff|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|80|9|V|rust
	        self.singular_points.clone()
2c0a925391adf2f7d71a86bf78b0537a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|80|9|V|rust
	        unsized
09682c6376c1ea672394e24e31955666|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|95|1|V|rust
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-8)
	            .singular_points(self.dm_thermal_cross_section_singular_pts())
	            .build();
4e5290e0851e68bd3c772b663d769325|term://.//12937%3A/bin/zsh|488|1|v|floaterm
	0.000000000000002491798969842802
884466eede05caac59dfadb578d526cb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|93|1|V|rust
	            let z2 = z * z;
	            let sig = self.dm_annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
24bca07d59bc6b99d09f59a5c9c12425|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|72|1|V|rust
	impl KineticMixing {
	    fn thermal_cs_integrand(&self, z: f64, x: f64) -> f64 {
	        let z2 = z * z;
	        let sig = self.dm_annihilation_cross_section(self.mx * z);
	        let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	        sig * kernal
	    }
	}
73e96ee63e4babc8eedef27a33617ec3|file:///Users/loganmorrison/.config/nvim/init.vim|29|1|V|vim
	Plug 'justinmk/vim-sneak'
40464a3974a5b7d4f8445ae9cce42bc7|file:///Users/loganmorrison/.config/nvim/init.vim|218|1|V|vim
	let g:sneak#s_next = 1
6178700739f4e884f26a1ca47b922766|file:///Users/loganmorrison/.config/nvim/init.vim|75|1|V|vim
	Plug 'metakirby5/codi.vim'
82ca1e5907ee8d22e8545f4c6ed10763|file:///Users/loganmorrison/.config/nvim/init.vim|74|1|V|vim
	" Interactive code
c535d33ac9a6dfcd74e4a5db55f40e37|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|8|1|V|rust
	pub trait 
a952eb56c1671205cdc96df8a8bc95e7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|42|1|V|rust
	    /// Compute the relic density of the dark matter particle.
	    fn relic_density(&self, method: BoltzmannMethod) -> f64 {
	        unimplemented!()
	    }
	    /// Solve the Boltzmann equation and return the solution containing the
	    /// comoving number density.
	    fn solve_boltzmann(&self, method: BoltzmannMethod) -> ODESolution {}
6364299b2e4554e2117217b00580405a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|44|7|v|rust
	: StandardDmModel
fc7f86f1a4293eac1769c4110228c3d6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/boltzmann.hpp|29|1|V|cpp
	        double x = exp(logx);
	        double T = params.mx / x;
	        double s = cosmology::sm_entropy_density(T);
	
	        double weq = log(cosmology::neq(T, params.mx, 2.0, 1) / s);
	        double ww = w(0);
	
	        double pf = -sqrt(M_PI / 45) * kM_PLANK * cosmology::sm_sqrt_gstar(T) * T;
	        double sigmav = thermal_cross_section(params, x, "all", "all");
	
	        // dW_e / dlogx
	        dw(0) = pf * sigmav * (exp(ww) - exp(2.0 * weq - ww));
7821e8ed4185ae954a8c20d86970b72b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|57|56|v|rust
	params, x, "all", "all"
b0bf4f989f517698bd74d72768bac671|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|49|22|v|rust
	exp(logx
9ac4e982c77d961d910fc121610b10c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|51|22|v|rust
	cosmology::
e8add20a7c14a4de661c1bfbcb2d6302|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|53|38|v|rust
	params.mx
0039148e41136767ef68a4f6257e597e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|60|32|v|rust
	exp(
08c8d7d9d9c0648f981be77f9f011371|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|49|1|V|rust
	    fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
b9d7277d3eddcce38485026f97b5b40a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|49|13|v|rust
	&mut self
022bd34ec1e09a625cf825cb1f7ae41d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|49|1|V|rust
	    fn dudt(self: &mut T, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
3322d597f8abd0926db8ba84c01d6d11|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|80|13|v|rust
	self: &mut T
c65c208af86537b7fdf8574a99c42294|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|115|9|V|rust
	        let mut 
70a2fac9611872e501f206281454f52b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|115|9|V|rust
	        let mut integrator = ODEIntegratorBuilder::default()
b9fe4c6780bf64f162b6ca890d9470ae|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|114|56|v|rust
	-> ODESolution
e0609fa6e565c882c39ba89360195bba|terminal:12|238|1|V|
	   |      ^ type parameter `T` must be used as the type parameter for some local type
6044a05712f0ddcdd769ef7e4860904a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|80|1|V|rust
	    fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
5c8c4bbca1689144b4eed7757ed773f1|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|79|37|v|rust
	 + OdeFunction
b3e42af023e5817e65bd1f6d770c7535|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|46|5|V|rust
	    T: StandardDmModel,
58a52f0edf2f81a9156a681123d0b8af|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|13|29|v|rust
	: AnnihilationCrossSection2To2
7c4f7d3f023f8311b31a9e2e6907c67b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|100|1|V|rust
	    /// Compute the relic density of the dark matter particle.
	    fn relic_density(&self, method: BoltzmannMethod) -> f64 {
	        unimplemented!()
	    }
	    /// Solve the Boltzmann equation and return the solution containing the
	    /// comoving number density.
	    fn solve_boltzmann(&self, method: BoltzmannMethod) {}
6bfd23270068d245c37520465693cb09|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|16|1|V|rust
	    fn relic_density(&self, method: BoltzmannMethod) -> f64 {
	        unimplemented!()
	    }
	    /// Solve the Boltzmann equation and return the solution containing the
	    /// comoving number density.
	    fn solve_boltzmann(&self, method: BoltzmannMethod) {}
bf8d25e293dc18f3412919482927676d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|43|5|V|rust
	    /// Solve the Boltzmann equation and return the solution containing the
6424e8151fb13774eb529b7f09f1d70d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|43|5|V|rust
	    /// comoving number density.
39072352292e8490f3d8653257e6532c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|19|59|v|rust
	ODESolution
9f199391b5e3082508730be79d06dce4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|48|9|V|rust
	        let gk = GaussKronrodIntegratorBuilder::default()
e42188344beeae9b51b562575ff92957|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|48|13|V|rust
	            .epsabs(0.0)
9cf78727e070c9b174d07dc7d842d9cd|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|48|13|V|rust
	            .epsrel(1e-8)
278b9e28c9cdc4aa871bf716cea2ec88|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|48|13|V|rust
	            .singular_points(self.dm_thermal_cross_section_singular_pts())
f7f3abb6d40255248c420d2ccf86db07|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|48|13|V|rust
	            .build();
966fe2442b3a8f033652a530ef79a270|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|38|22|v|rust
	dm_mass()
5134ac84f8f7eddc8b04643c87538fff|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|38|1|V|rust
	    fn dudt(&mut self, mut dw
cc76f7619fc857002d0dd06d782d6140|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|93|1|V|rust
	/// Trait for a standard dark matter model in which the dominant annihilation
	/// proceed through 2 -> n interactions.
	pub trait StandardDmModel2: OdeFunction {
	    fn dudt(&mut self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {}
	    /// Returns the mass of the dark matter particle.
	    fn dm_mass(&self) -> f64;
	    /// Compute the annihilation cross section for chi + chibar -> anything.
	    fn dm_annihilation_cross_section(&self, cme: f64) -> f64;
	    /// Return a vector containing the singular points of the thermal cross
	    /// section integration (i.e. resonances and thresholds.)
	    fn dm_thermal_cross_section_singular_pts(&self) -> Vec<f64> {
	        vec![]
	    }
	    /// Compute the thermalized annihilation cross section for
	    /// chi + chibar -> anything for a given `x=mass/temperature`.
	    fn dm_thermal_cross_section(&self, x: f64) -> f64 {
	        let m = self.dm_mass();
	        let denom = dbg!(2.0 * x.cyl_bessel_kn_scaled(2));
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.dm_annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-8)
	            .singular_points(self.dm_thermal_cross_section_singular_pts())
	            .build();
	
	        pf * gk.integrate(integrand, 2.0, f64::INFINITY).val
	    }
	}
	
	impl<T: StandardDmModel> OdeFunction for T {
	    fn dudt(self: &mut T, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.dm_mass() / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.dm_mass(), 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
	}
	
	pub trait Boltzmann: StandardDmModel {
	    /// Compute the relic density of the dark matter particle.
	    fn relic_density(&self, method: BoltzmannMethod) -> f64 {
	        unimplemented!()
	    }
	    /// Solve the Boltzmann equation and return the solution containing the
	    /// comoving number density.
	    fn solve_boltzmann(&self, method: BoltzmannMethod) {}
	}
cd4bb296c778d3b40d8d58bd24b3f14f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|72|37|v|rust
	for KineticMixing
e5873da9a9d7a661a9d7f03fbbf420c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|72|1|V|rust
	impl AnnihilationCrossSection2To2 for KineticMixing{
	
	}
82de668c0e3f27dfc28c152017a4d8ff|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|168|1|V|rust
	    pub fn annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.sigma_xx_to_ququ(cme, UP_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, CHARM_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, TOP_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, DOWN_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, STRANGE_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, BOTTOM_QUARK_MASS)
	            + self.sigma_xx_to_ll(cme, ELECTRON_MASS)
	            + self.sigma_xx_to_ll(cme, MUON_MASS)
	            + self.sigma_xx_to_ll(cme, TAU_MASS)
	            + 3.0 * self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_vv(cme)
	    }
c13b38ff696cda06a39b17f976ce693a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|32|5|V|rust
	    integrator: OdeIntegrator<, Radau5>,
bc766d9becd5da0f6d3ed94718b2c7fe|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|40|30|v|rust
	dm_mass
757bf403ebb17bdf68b069ae651afee8|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|89|9|V|rust
	        let sol 
4839a7958ca6e56f1fc162d206e159f0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|89|9|V|rust
	        let prob
8c3a11ca0d5dbdd35b15b66dbb4f52e5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|6|1|V|rust
	    fn dm_annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.sigma_xx_to_ququ(cme, UP_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, CHARM_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, TOP_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, DOWN_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, STRANGE_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, BOTTOM_QUARK_MASS)
	            + self.sigma_xx_to_ll(cme, ELECTRON_MASS)
	            + self.sigma_xx_to_ll(cme, MUON_MASS)
	            + self.sigma_xx_to_ll(cme, TAU_MASS)
	            + 3.0 * self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_vv(cme)
	    }
eaee1717b06f2bf2f8c0075cf7d7cafb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|2|1|V|rust
	use crate::standard_dm_model::AnnihilationCrossSection2To2;
9064dc1aad64ae580eeee3b5c4650054|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/cross_sections.rs|4|1|V|rust
	impl AnnihilationCrossSection2To2 for KineticMixing {
	    fn dm_annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.sigma_xx_to_ququ(cme, UP_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, CHARM_QUARK_MASS)
	            + self.sigma_xx_to_ququ(cme, TOP_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, DOWN_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, STRANGE_QUARK_MASS)
	            + self.sigma_xx_to_qdqd(cme, BOTTOM_QUARK_MASS)
	            + self.sigma_xx_to_ll(cme, ELECTRON_MASS)
	            + self.sigma_xx_to_ll(cme, MUON_MASS)
	            + self.sigma_xx_to_ll(cme, TAU_MASS)
	            + 3.0 * self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_hz(cme)
	            + self.sigma_xx_to_vv(cme)
	    }
	}
f12dc08414e4c4bd918916b90c374ca9|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|71|1|V|rust
	impl 
3cd26af629db22e07055ba5260f0a93e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|83|1|V|rust
	    /// Compute the thermalized annihilation cross section for
	    /// chi + chibar -> anything for a given `x=mass/temperature`.
	    fn dm_thermal_cross_section(&self, x: f64) -> f64 {
	        let m = self.dm_mass();
	        let denom = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.dm_annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        pf * self.gk.integrate(integrand, 2.0, f64::INFINITY).val
	    }
0cf31b2c283ce3431794586df7b0996d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/thermal_cross_section.rs|4|4|V|rust
	    
a17468eaadf878385fe2665e64dee672|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/thermal_cross_section.rs|2|1|V|rust
	use super::cross_sections
eaf597a8d92a9e8f5a99ea887d0158b0|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|4|1|V|rust
	use cyphus_specfun::bessel::CylBesselK;
4001dcdbd2d48997c73dcdda62e48787|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/thermal_cross_section.rs|8|21|v|rust
	.dm_mass()
38f5fce8644e871f6c79fea7c8e78f2d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|38|1|V|rust
	    fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mdm / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mdm, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mdm / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mdm, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.dm_thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
c9541335dfe5d0e302a9d44fef1ce370|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/standard_dm_model.rs|2|1|V|rust
	use cyphus_diffeq::prelude::*;
a0b090ed1dc451ff80127eaf9fabc861|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|72|1|V|rust
	impl StandardDmModel<KineticMixing> {
	    fn dm_mass(&self) -> f64 {
	        self.mx
	    }
	    fn dm_annihilation_cross_section(&self, cme: f64) -> f64 {
	        self.annihilation_cross_section(cme)
	    }
	    fn dm_thermal_cross_section_singular_pts(&self) -> Vec<f64> {
	        vec![]
	    }
	}
2ab89621cd7bbf268a56cfaf9431321c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|39|12|v|rust
	relic_density
84ded8b6e11ec9b64149de55ad7d6fa5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|41|32|v|rust
	self.mx
d49681851423bf244d7e4d64250df5ed|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/lib.rs|14|1|V|rust
	use qagi::qagi;
	use qagp::qagp;
	use qags::qags;
	use result::{IntegrationResult, IntegrationRetCode};
	
	pub struct GaussKronrodIntegrator {
	    pub epsabs: f64,
	    pub epsrel: f64,
	    pub limit: usize,
	    pub key: u8,
	    pub singular_points: Vec<f64>,
	}
	
	impl GaussKronrodIntegrator {
	    pub fn integrate<F>(&self, f: F, a: f64, b: f64) -> IntegrationResult
	    where
	        F: Fn(f64) -> f64,
	    {
	        // Check if we have infinite endpoints
	        if a.is_infinite() || b.is_infinite() {
	            if !self.singular_points.is_empty() {
	                let mut singular_points = self.singular_points.clone();
	                singular_points.retain(|x| x.is_finite());
	                let res1 = qagp(
	                    &f,
	                    &singular_points,
	                    self.epsabs,
	                    self.epsrel,
	                    self.limit,
	                    self.key,
	                );
	                let mut res2 = IntegrationResult::new();
	                let mut res3 = IntegrationResult::new();
	                if a.is_infinite() && b.is_infinite() {
	                    res2 = qagi(
	                        &f,
	                        a,
	                        singular_points[0],
	                        self.epsabs,
	                        self.epsrel,
	                        self.limit,
	                        self.key,
	                    );
	                    res3 = qagi(
	                        &f,
	                        *singular_points.last().unwrap(),
	                        b,
	                        self.epsabs,
	                        self.epsrel,
	                        self.limit,
	                        self.key,
	                    );
	                } else if a.is_infinite() {
	                    res2 = qagi(
	                        f,
	                        a,
	                        singular_points[0],
	                        self.epsabs,
	                        self.epsrel,
	                        self.limit,
	                        self.key,
	                    );
	                } else {
	                    res3 = qagi(
	                        f,
	                        *singular_points.last().unwrap(),
	                        b,
	                        self.epsabs,
	                        self.epsrel,
	                        self.limit,
	                        self.key,
	                    );
	                }
	                IntegrationResult {
	                    val: res1.val + res2.val + res3.val,
	                    err: res1.err + res2.err + res3.err,
	                    code: IntegrationRetCode::Success,
	                    nevals: res1.nevals + res2.nevals + res3.nevals,
	                }
	            } else {
	                qagi(f, a, b, self.epsabs, self.epsrel, self.limit, self.key)
	            }
	        } else if self.singular_points.is_empty() {
	            qags(f, a, b, self.epsabs, self.epsrel, self.limit, self.key)
	        } else {
	            let mut singular_points = vec![a];
	            singular_points.reserve(self.singular_points.len() + 1);
	            for pt in self.singular_points.iter() {
	                singular_points.push(*pt);
	            }
	            singular_points.push(b);
	
	            qagp(
	                f,
	                &singular_points,
	                self.epsabs,
	                self.epsrel,
	                self.limit,
	                self.key,
	            )
	        }
	    }
	}
	
	pub struct GaussKronrodIntegratorBuilder {
	    pub epsabs: f64,
	    pub epsrel: f64,
	    pub limit: usize,
	    pub key: u8,
	    pub singular_points: Vec<f64>,
	}
	
	impl GaussKronrodIntegratorBuilder {
	    pub fn default() -> Self {
	        GaussKronrodIntegratorBuilder {
	            epsabs: 1e-8,
	            epsrel: 1e-8,
	            limit: 1000,
	            key: 2,
	            singular_points: vec![],
	        }
	    }
	    pub fn epsabs(mut self, epsabs: f64) -> Self {
	        self.epsabs = epsabs;
	        self
	    }
	    pub fn epsrel(mut self, epsrel: f64) -> Self {
	        self.epsrel = epsrel;
	        self
	    }
	    pub fn limit(mut self, limit: usize) -> Self {
	        self.limit = limit;
	        self
	    }
	    pub fn key(mut self, key: u8) -> Self {
	        self.key = key;
	        self
	    }
	    pub fn singular_points(mut self, singular_points: Vec<f64>) -> Self {
	        self.singular_points = singular_points;
	        // Sort break-points and delete duplicates
	        self.singular_points
	            .sort_by(|a, b| a.partial_cmp(b).unwrap());
	        self.singular_points.dedup_by(|a, b| (*a).eq(b));
	
	        self
	    }
	    pub fn build(&self) -> GaussKronrodIntegrator {
	        GaussKronrodIntegrator {
	            epsabs: self.epsabs,
	            epsrel: self.epsrel,
	            limit: self.limit,
	            key: self.key,
	            singular_points: self.singular_points.clone(),
	        }
	    }
	}
	
	#[cfg(test)]
	mod tests {
	    use super::*;
	    use crate::test_utils::*;
	
	    #[test]
	    fn test_0_inf_f455() {
	        let exp_result = -3.616892186127022568E-01;
	        let exp_abserr = 3.016716913328831851E-06;
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-3)
	            .key(1)
	            .build();
	        let result = gk.integrate(f455, 0.0, f64::INFINITY);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	
	    #[test]
	    fn test_0_inf_f15() {
	        let exp_result = 6.553600000000024738E+04;
	        let exp_abserr = 7.121667111456009280E-04;
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-7)
	            .key(1)
	            .build();
	
	        let f = |x| f15(x, 5.0);
	        let result = gk.integrate(f, 0.0, f64::INFINITY);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	
	    #[test]
	    fn test_0_inf_f16() {
	        let exp_result = 1.000000000006713292E-04;
	        let exp_abserr = 3.084062020905636316E-09;
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(1e-7)
	            .epsrel(0.0)
	            .key(1)
	            .build();
	
	        let alpha = 1.0;
	        let f = |x| f16(x, alpha);
	        let result = gk.integrate(f, 99.9, f64::INFINITY);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	
	    #[test]
	    fn test_inf_inf() {
	        let exp_result = 2.275875794468747770E+00;
	        let exp_abserr = 7.436490118267390744E-09;
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(1e-3)
	            .epsrel(0.0)
	            .key(1)
	            .build();
	
	        let f = |x: f64| (-x - x * x).exp();
	
	        let result = gk.integrate(f, f64::NEG_INFINITY, f64::INFINITY);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	
	    #[test]
	    fn test_inf_0() {
	        let exp_result = 2.718281828459044647E+00;
	        let exp_abserr = 1.588185109253204805E-10;
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(1e-7)
	            .epsrel(0.0)
	            .key(1)
	            .build();
	
	        let f = |x: f64| (1.0 * x).exp();
	
	        let result = gk.integrate(f, f64::NEG_INFINITY, 1.0);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	
	    #[test]
	    fn test_454() {
	        let f = |x| f454(x);
	
	        let exp_result = 5.274080611672716401E+01;
	        let exp_abserr = 1.755703848687062418E-04;
	        let points = vec![1.0, 2f64.sqrt()];
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-3)
	            .singular_points(points)
	            .key(2)
	            .limit(1000)
	            .build();
	        let result = gk.integrate(f, 0.0, 3.0);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
	}
5fb63579fc981698f97d55bfecb213ea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|6|17|v|rust
	Copy
f5f576dd4c5225d04c2d86e7b7a3b050|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|22|21|v|rust
	1e-8
8b0157c9549e0c43c6c961b4f785fb8b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|23|1|V|rust
	    /// let gk = GaussKronrodIntegratorBuilder::default()
	    ///     .reltol(1e-8)
	    ///     .abstol(1e-8)
	    ///     .build();
	    /// let f = |x:f64| x * x;
	    /// let res = gk.integrate(f, 0.0, 1.0);
	    /// assert!((res.val - 1.0 / 3.0).abs() < 1e-8);
96e9301e8d9b15b47d9d59c62e576ea2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|32|1|V|rust
	    /// ```
	    /// ```
8a3de6a51d20c693674789d2adc1bbc5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|38|35|v|rust
	0.0, 1.0
5effcfae247ad1cb79a7f243d03474fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|39|32|v|rust
	/ 3.0
8fca1b010387fb80dfdc4acb90481402|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|22|9|v|rust
	Finite interval:
8499ddd00d69bbf860915a93ebf60042|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|33|9|v|rust
	Infinite interval:
1c618074431fd40602066c682921e753|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|283|1|V|rust
	    #[test]
	    fn test_454() {
	        let f = |x| f454(x);
	
	        let exp_result = 5.274080611672716401E+01;
	        let exp_abserr = 1.755703848687062418E-04;
	        let points = vec![1.0, 2f64.sqrt()];
	
	        let gk = GaussKronrodIntegratorBuilder::default()
	            .epsabs(0.0)
	            .epsrel(1e-3)
	            .singular_points(points)
	            .key(2)
	            .limit(1000)
	            .build();
	        let result = gk.integrate(f, 0.0, 3.0);
	
	        test_rel(result.val, exp_result, 1e-14);
	        test_rel(result.err, exp_abserr, 1e-5);
	    }
297f2ada3107af289758465df93e9584|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|306|21|v|rust
	f454(x)
d88f1f8bcfcacc171ac7a144bcc7466d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|308|9|V|rust
	        let exp_result = 5.274080611672716401E+01;
6a435eac3f4fc589668f28cbc1b3b0b0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|308|9|V|rust
	        let exp_abserr = 1.755703848687062418E-04;
f3440948a4ce1397bacb762f9ec4a59b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|308|9|V|rust
	        let points = vec![1.0, 2f64.sqrt()];
3afdb6155a4e959a5ab1f00df6e20627|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|311|1|V|rust
	            .singular_points(points)
a2e11b9d06e900de32188b9f8e9d910d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|311|13|V|rust
	            .key(2)
d77becea144cb35c6f13fcb493ce2f84|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|311|13|V|rust
	            .limit(1000)
514bdc3e162c89d676458b2f5e929471|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|314|9|V|rust
	        test_rel(result.val, exp_result, 1e-14);
612d6c1f89c9f4c9012cc167fb009613|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|314|9|V|rust
	        test_rel(result.err, exp_abserr, 1e-5);
2329907d27e32780672c1bfdead50bf3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/quad.rs|313|30|v|rust
	.val
7a4368bfda0ab78ca77aafc6989162ea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/prelude.rs|3|1|V|rust
	pub use
066d73bb28be00b49423c3e03dbc2996|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/README.md|10|34|v|vimwiki
	GaussKronrodIntegratorBuilder
cb3f1269924a5f07092abb1d5194b3f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/README.md|10|1|V|vimwiki
	use cyphus_integration::prelude::*;
b4c31507054f4c9043654ab8bb0a0890|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/README.md|25|1|V|vimwiki
	use cyphus::integration::GaussKronrodIntegratorBuilder;
fce3e91d1543ab481574961b415fb651|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/README.md|41|1|V|vimwiki
	use cyphus::integration::GaussKronrodIntegrator;
12a3f9a2a62621f81340e0c52804ef6c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/problems.rs|3|1|V|rust
	pub struct OdeProb {
293675648b4be1f10eeda3c2ecadbf54|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/problems.rs|16|21|v|rust
	dyn 
69c215fe24728f226b885fa1feca8543|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/problems.rs|8|5|V|rust
	    J: Fn(ArrayViewMut2<f64>,
eb41f7c889357160606e5d968e2fff99|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|5|1|V|rust
	pub mod problems;
a6d7ccb276ae142a8814d71751908bce|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|76|12|v|rust
	solve
b9b9f918245cee2dced6508956675b3e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|133|1|V|rust
	// Non-consuming iterator
3d69d4d8b2f0d07aa4f64c49b5385326|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|6|25|v|rust
	{GaussKronrodIntegrator, GaussKronrodIntegratorBuilder};
cbbce0d9a48c3131adc7ae5f7709d191|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|1|25|v|rust
	GaussKronrodIntegrator;
1679bf5c76bb788b8a97b8ee40675bec|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|85|1|V|rust
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-3);
875c012128d81e8e5e12b0d7bfdadb9e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|39|12|v|rust
	solve_boltzmann
f651f4eaaab6a3a8ee961e4425697751|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|90|8|v|rust
	test_boltz
836c12d5dae8a88db4d860aa62e88dec|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|94|18|v|rust
	0..sol.ts.len()
9dee91622aedec6f0b555ec236dfb572|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|95|32|v|rust
	sol.ts[i], sol.us[i]
3d801aa532c1cec3ee82d87a99fdf63f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|44|22|v|rust
	temp
3007ecc4383870e0ba69e4a5f8e47f99|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|44|31|v|rust
	lllll000f64
ecffd0adfadc810de856b3a73c11a2fd|term://.//58262%3A/bin/zsh|222|1|V|floaterm
	0, [0.003277120183723837]
	0.000000000824566393902871, [-0.06319489786581947]
	0.000000001649132787805742, [-0.125522418523968]
	0.0000000042736673951573, [-0.30143526756788264]
	0.000000007854894277820188, [-0.5003686733133336]
	0.000000012865594995894915, [-0.725428270848883]
	0.000000019864888551894478, [-0.9734648939266664]
	0.00000002961663348624412, [-1.240465087681986]
	0.00000004322200352963795, [-1.523312871446008]
	0.0000000622848204573505, [-1.819812399039024]
	0.00000008913779455534383, [-2.12828588877151]
	0.00000012718600649070234, [-2.4473977966134983]
	0.00000018142011393790484, [-2.7760146047700096]
	0.00000025918697568019844, [-3.1130749277721432]
	0.0000003713507358135122, [-3.457415945478185]
	0.0000005340499371458247, [-3.8074735509999766]
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5.973691233463541]
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6.299796619504697]
	1.2112527778467417, [-6.310721949999949]
	1.4990972765618311, [-6.31076490605416]
	2.328027509234393, [-6.3107659771203926]
	6.907755278982137, [-6.310767488782483]
c0543d7c15bd7ba1e959625cb6d24020|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000000000824566393902871, [-0.06319489786581947]
	0
d08c980ef5349449a3713618f4f48fc8|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0, [0.003277120183723837]
	0
e8e23f7cd4af19410874cbbb300c9a95|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000000042736673951573, [-0.30143526756788264]
	0
c8a65a31f2d8dfdb3e97901d485ab46c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000000622848204573505, [-1.819812399039024]
	0.00000008913779455534383, [-2.12828588877151]
	0.00000012718600649070234, [-2.4473977966134983]
	0.00000018142011393790484, [-2.7760146047700096]
	0.00000025918697568019844, [-3.1130749277721432]
	0.0000003713507358135122, [-3.457415945478185]
	0.0000005340499371458247, [-3.8074735509999766]
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5.973691233463541]
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6.299796619504697]
	1
e99e921fd0519d404fe4ba7a0f4f889c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000000001649132787805742, [-0.125522418523968]
	0
db61ecf3b4e836825b87aabb21ece932|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000002961663348624412, [-1.240465087681986]
	0.00000004322200352963795, [-1
9f603ddfbef6ea91126a5d85e75e97a7|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000025918697568019844, [-3.1130749277721432]
	0.0000003713507358135122, [-3
4ca86553a68ef165adda7ba7b46444fa|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000005340499371458247, [-3.8074735509999766]
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5.973691233463541]
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6.299796619504697]
	1.2112527778467417, [-6.310721949999949]
	1.4990972765618311, [-6.31076490605416]
	2.328027509234393, [-6.3107659771203926]
	6.907755278982137, [-6.310767488782483]
	test kinetic_mixing::test::test_boltz ... ok
	
	test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
	
	 haliax-dm-models (master)  ipython
	Python 3
300377b10b1cac176ffbfbd595620559|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000000019864888551894478, [-0.9734648939266664]
	0
076ea927c5bfa3b7edeeced7e9f63f66|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000012718600649070234, [-2.4473977966134983]
	0.00000018142011393790484, [-2
393f65402c8f099d3f51e9ffc5883d48|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000000007854894277820188, [-0.5003686733133336]
	0
6db41d3280d9d197ff21ad2331ea545e|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000000012865594995894915, [-0.725428270848883]
	0
2a35f6cb97abb1db3f7ed1ceb2bb0fae|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000018142011393790484, [-2.7760146047700096]
	0.00000025918697568019844, [-3.1130749277721432]
	0.0000003713507358135122, [-3.457415945478185]
	0.0000005340499371458247, [-3.8074735509999766]
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5.973691233463541]
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6.299796619504697]
	1.2112527778467417, [-6.310721949999949]
	1.4990972765618311, [-6.31076490605416]
	2
d6c3b7af1bee87a781ac27ef801446f1|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5
0aef546e4e72c3a4b5d198d8b6734b1f|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4
b208de7240b630b71a1bbb6bb804987c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000003713507358135122, [-3.457415945478185]
	0.0000005340499371458247, [-3
c01e51686bc08f160d3a9c242223ddbe|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000004322200352963795, [-1.523312871446008]
	0.0000000622848204573505, [-1
15cd72574e471bef1b5e7bfab475c350|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5
89d74739e371304b3a010d69933ac758|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5
8a5ad3ce3714ae4b6465070a18a81fc1|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5
c08697a974c7f368f75b06c0f1bd119b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5
4c25cd09d3714a0ce9cd6c6eaa1163bf|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000008913779455534383, [-2.12828588877151]
	0.00000012718600649070234, [-2
674505ea568e5be28b2cc04ef41073bd|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5
fd2cb99c19e4c0967a7e552744cb4f4b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5
78ab5b1f1edf73a7cb323537e0deb389|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5
f63f28a8669424885fe6027fbece555b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5
daa09acc22db16999f20b08ff93b44a7|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4
57d497ba44c571dbf3ffbf2e9f773361|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5
16ef526cc32e157088ad4b584ecf1e3c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5
1f3d265aa6a4c0500291d73ff67eb58c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5
7bd5b5bb201b64deb8f2a205c104c542|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5.973691233463541]
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6.299796619504697]
	1.2112527778467417, [-6.310721949999949]
	1.4990972765618311, [-6.31076490605416]
	2.328027509234393, [-6.3107659771203926]
	6.907755278982137, [-6.310767488782483]
	test kinetic_mixing::test::test_boltz ... ok
	
	test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
	
	 haliax-dm-models (master)  ipython
	Python 3.6.2 (default, Mar 22 2018, 00:57:55)
	Type 'copyright', 'credits' or 'license' for more information
	IPython 6.4
b50951644b37faf97520d5fa7355a730|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5
b8c83625515963a0c6e66099d397033a|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.9515668621317296, [-6.299796619504697]
	1.2112527778467417, [-6
c0a2ac7352c700a736cfde0d722816c6|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.8495535082473165, [-6.265341171007107]
	0.9515668621317296, [-6
33982ae45d7fd6054b05ac79d5bfb856|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5
ef29a02e2158514b8f25c91c74d37d6d|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5
06b01fd39ec8a5dd22d931c0a9e55837|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.7475401543629033, [-6.192078415200615]
	0.8495535082473165, [-6
96e8ce46fd680bd7a158a8677fb5a5c8|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.594433815733613, [-6.055845954469688]
	0.6428899683527872, [-6
c017e5e8344b2f0cd3e6e43bcbad5712|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	1.2112527778467417, [-6.310721949999949]
	1.4990972765618311, [-6
ef7b7cc544bd87b1ae960b5d0afe961b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.44171619414870583, [-5.935859895525308]
	0.49384692863157226, [-5
e1a55f85632d310c2ae0a7bec0692f36|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5
314df43ff90fec69eaa0673a1adfe80b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.6952150613578453, [-6.145796552733616]
	0.7475401543629033, [-6
3f10dffc10fa21f0c224ed1ad06acfbd|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5
bd9e6011fb3e7aae001930e8f0a9673a|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5
9b6229ff4c159f0c26ad384d62939b6c|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.6428899683527872, [-6.0983659371906365]
	0.6952150613578453, [-6
e51588c5bd1796753e159b91d7821d34|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	5
	  |
	9 |     mut d: ArrayViewMut1<f64>,
	  |     ----^
	  |     |
	  |     help: remove this `mut`
	
	warning: unused import: `ndarray::prelude::*`
	 --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs:4:5
	  |
	4 | use ndarray::prelude::*;
	  |     ^^^^^^^^^^^^^^^^^^^
	  |
	  = note: `#[warn(unused_imports)]` on by default
	
	warning: function is never used: `spalde`
	 --> /Users/loganmorrison/Documents/coding/rust/cyphus-interpolation/src/dierckx/spalde.rs:3:15
	  |
	3 | pub(super) fn spalde(
	  |               ^^^^^^
	  |
	  = note: `#[warn(dead_code)]` on by default
	
	warning: function is never used: `dech`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs:65:15
	   |
	65 | pub(crate) fn dech(
	   |               ^^^^
	   |
	   = note: `#[warn(dead_code)]` on by default
	
	warning: 3 warnings emitted
	
	warning: function is never used: `dechc`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs:215:15
	    |
	215 | pub(crate) fn dechc(
	    |               ^^^^^
	
	warning: function is never used: `decb`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs:306:15
	    |
	306 | pub(crate) fn decb(
	    |               ^^^^
	
	warning: function is never used: `decbc`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs:389:15
	    |
	389 | pub(crate) fn decbc(
	    |               ^^^^^
	
	warning: function is never used: `elmhes`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs:500:15
	    |
	500 | pub(crate) fn elmhes(
	    |               ^^^^^^
	
	warning: function is never used: `solh`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/sol.rs:32:15
	   |
	32 | pub(crate) fn solh(
	   |               ^^^^
	
	warning: function is never used: `solhc`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/sol.rs:116:15
	    |
	116 | pub(crate) fn solhc(
	    |               ^^^^^
	
	warning: function is never used: `solb`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/sol.rs:169:15
	    |
	169 | pub(crate) fn solb(
	    |               ^^^^
	
	warning: function is never used: `solbc`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/sol.rs:210:15
	    |
	210 | pub(crate) fn solbc(
	    |               ^^^^^
	
	warning: method is never used: `dense_output`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/continuous_output.rs:6:5
	   |
	6  | /     pub(crate) fn dense_output<T: OdeFunction>(
	7  | |         &self,
	8  | |         t: f64,
	9  | |         integrator: &mut OdeIntegrator<T, Radau5>,
	...  |
	25 | |         res + &integrator.cache.cont.slice(s![0..n])
	26 | |     }
	   | |_____^
	
	warning: 11 warnings emitted
	
	warning: function is never used: `test_rel`
	 --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:1:15
	  |
	1 | pub(crate) fn test_rel(result: f64, expected: f64, relative_error: f64) {
	  |               ^^^^^^^^
	  |
	  = note: `#[warn(dead_code)]` on by default
	
	warning: function is never used: `f1`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:36:15
	   |
	36 | pub(crate) fn f1(x: f64, alpha: f64) -> f64 {
	   |               ^^
	
	warning: function is never used: `f3`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:41:15
	   |
	41 | pub(crate) fn f3(x: f64, alpha: f64) -> f64 {
	   |               ^^
	
	warning: function is never used: `f11`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:46:15
	   |
	46 | pub(crate) fn f11(x: f64, alpha: f64) -> f64 {
	   |               ^^^
	
	warning: function is never used: `f15`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:51:15
	   |
	51 | pub(crate) fn f15(x: f64, alpha: f64) -> f64 {
	   |               ^^^
	
	warning: function is never used: `f16`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:56:15
	   |
	56 | pub(crate) fn f16(x: f64, alpha: f64) -> f64 {
	   |               ^^^
	
	warning: function is never used: `f454`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:66:15
	   |
	66 | pub(crate) fn f454(x: f64) -> f64 {
	   |               ^^^^
	
	warning: function is never used: `f455`
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/test_utils.rs:72:15
	   |
	72 | pub(crate) fn f455(x: f64) -> f64 {
	   |               ^^^^
	
	warning: struct is never constructed: `IntegrationQawsTable`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/workspace.rs:224:8
	    |
	224 | struct IntegrationQawsTable<T> {
	    |        ^^^^^^^^^^^^^^^^^^^^
	
	warning: enum is never used: `IntegrationQawoEnum`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/workspace.rs:235:6
	    |
	235 | enum IntegrationQawoEnum {
	    |      ^^^^^^^^^^^^^^^^^^^
	
	warning: struct is never constructed: `IntegrationQawoTable`
	   --> /Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/workspace.rs:241:8
	    |
	241 | struct IntegrationQawoTable<T> {
	    |        ^^^^^^^^^^^^^^^^^^^^
	
	warning: 11 warnings emitted
	
	warning: value assigned to `tol` is never read
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/lambert_w.rs:43:13
	   |
	43 |         let mut tol = 0.0;
	   |             ^^^^^^^
	   |
	   = note: `#[warn(unused_assignments)]` on by default
	   = help: maybe it is overwritten before being read?
	
	warning: variable does not need to be mutable
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/lambert_w.rs:44:13
	   |
	44 |         let mut e = w.exp();
	   |             ----^
	   |             |
	   |             help: remove this `mut`
	   |
	   = note: `#[warn(unused_mut)]` on by default
	
	warning: variable does not need to be mutable
	  --> /Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/lambert_w.rs:45:13
	   |
	45 |         let mut p = w + 1.0;
	   |             ----^
	   |             |
	   |             help: remove this `mut`
	
	warning: 3 warnings emitted
	
	   Compiling haliax-dm-models v0.1.0 (/Users/loganmorrison/Documents/coding/rust/haliax-dm-models)
	warning: unused import: `KineticMixingFinalStates`
	 --> src/kinetic_mixing/cross_sections.rs:1:28
	  |
	1 | use super::{KineticMixing, KineticMixingFinalStates};
	  |                            ^^^^^^^^^^^^^^^^^^^^^^^^
	  |
	  = note: `#[warn(unused_imports)]` on by default
	
	warning: 1 warning emitted
	
	    Finished test [unoptimized + debuginfo] target(s) in 0.69s
	     Running target/debug/deps/haliax_dm_models-68259415d69c7bd1
	
	running 1 test
	0, [0.003277120183723837]
	0.000000000824566393902871, [-0.06319489786581947]
	0.000000001649132787805742, [-0.125522418523968]
	0.0000000042736673951573, [-0.30143526756788264]
	0.000000007854894277820188, [-0.5003686733133336]
	0.000000012865594995894915, [-0.725428270848883]
	0.000000019864888551894478, [-0.9734648939266664]
	0.00000002961663348624412, [-1.240465087681986]
	0.00000004322200352963795, [-1.523312871446008]
	0.0000000622848204573505, [-1.819812399039024]
	0.00000008913779455534383, [-2.12828588877151]
	0.00000012718600649070234, [-2.4473977966134983]
	0.00000018142011393790484, [-2.7760146047700096]
	0.00000025918697568019844, [-3.1130749277721432]
	0.0000003713507358135122, [-3.457415945478185]
	0.0000005340499371458247, [-3.8074735509999766]
	0.0000007713713635436061, [-4.160699244477295]
	0.0000011194532644326652, [-4.512406281073792]
	0.00000163288084347219, [-4.8536270486057]
	0.000002394925165500956, [-5.167856165006243]
	0.00000353382221047641, [-5.428682756840426]
	0.000005239457984758133, [-5.606072116113889]
	0.0000077443493297292, [-5.691469870643939]
	0.000011384811640942628, [-5.716729051359283]
	0.00001751887138349895, [-5.7206251434180615]
	0.00002910117957308224, [-5.720807341776568]
	0.00006769491755202257, [-5.72083537980357]
	0.0002731314428664378, [-5.720865605371856]
	0.0010222223266937531, [-5.721117689801974]
	0.003964550545189364, [-5.7224590443822505]
	0.020625567814878006, [-5.727750645661986]
	0.044210854619834594, [-5.735314203926123]
	0.08095060277925414, [-5.748816164886438]
	0.1176903509386737, [-5.763586389641379]
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5.805805205588503]
	0.2733940823027829, [-5.834360108147002]
	0.3306582066314239, [-5.866463541597869]
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5.935859895525308]
	0
3cd824e8ecf09090045ce7a3c64c982f|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	2.328027509234393, [-6.3107659771203926]
	6
db6049d13db421341fcdc1fc4d2a4f29|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.5459776631144387, [-6.015128604625275]
	0.594433815733613, [-6
70341719f2f14de8a0300e837678ec62|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.3861872003900649, [-5.900104648876906]
	0.44171619414870583, [-5
f6087b822c5dd9451229d186055a935f|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	6.907755278982137, [-6.310767488782483]
	test kinetic_mixing::test::test_boltz ... ok
	
	test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
	
	 haliax-dm-models (master)  ipython
	Python 3.6
c9b050e878babe6e3de179abe09fb53b|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	1.4990972765618311, [-6.31076490605416]
	2.328027509234393, [-6
51ee4cb7d4f191cceeea05b32adb5b11|term://.//58262%3A/bin/zsh|273|1|v|floaterm
	0.16691015445640778, [-5.784058843493309]
	0.21612995797414186, [-5
611a8bdfc3659a89a6d2a9c512fb249d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|94|1|V|rust
	        for (t, u) in sol.ts.iter().zip(sol.us.iter()) {
	            println!("{}, {}", t, u);
	        }
779a8ba8d10f1905adc51c3729e6ba2c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|94|13|v|rust
	(t, u)
4f386314f5206931809c84d855668bba|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|94|31|v|rust
	.zip(sol.us.iter())
1185809a0ff98cbbd9a03d1d92b22a7e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|95|25|v|rust
	, {}
b2d10e20a6f9cf865295f37c6eb2250b|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|97|13|v|rust
	t, u
d04a8c12fde023cf25e309d7daadf644|term://.//58262%3A/bin/zsh|954|1|V|floaterm
	-0.06319489786581947
	-0.125522418523968
	-0.30143526756788264
	-0.5003686733133336
	-0.725428270848883
	-0.9734648939266664
	-1.240465087681986
	-1.523312871446008
	-1.819812399039024
	-2.12828588877151
	-2.4473977966134983
	-2.7760146047700096
	-3.1130749277721432
	-3.457415945478185
	-3.8074735509999766
	-4.160699244477295
	-4.512406281073792
	-4.8536270486057
	-5.167856165006243
	-5.428682756840426
	-5.606072116113889
	-5.691469870643939
	-5.716729051359283
	-5.7206251434180615
	-5.720807341776568
	-5.72083537980357
	-5.720865605371856
	-5.721117689801974
	-5.7224590443822505
	-5.727750645661986
	-5.735314203926123
	-5.748816164886438
	-5.763586389641379
	-5.784058843493309
	-5.805805205588503
	-5.834360108147002
	-5.866463541597869
	-5.900104648876906
	-5.935859895525308
	-5.973691233463541
	-6.015128604625275
	-6.055845954469688
	-6.0983659371906365
	-6.145796552733616
	-6.192078415200615
	-6.265341171007107
	-6.299796619504697
	-6.310721949999949
	-6.31076490605416
	-6.3107659771203926
	-6.310767488782483
a516a785869f1c77901aefa6fc8f9d1a|term://.//58262%3A/bin/zsh|1283|1|V|floaterm
	-0.06319489786581947,
	-0.125522418523968,
	-0.30143526756788264,
	-0.5003686733133336,
	-0.725428270848883,
	-0.9734648939266664,
	-1.240465087681986,
	-1.523312871446008,
	-1.819812399039024,
	-2.12828588877151,
	-2.4473977966134983,
	-2.7760146047700096,
	-3.1130749277721432,
	-3.457415945478185,
	-3.8074735509999766,
	-4.160699244477295,
	-4.512406281073792,
	-4.8536270486057,
	-5.167856165006243,
	-5.428682756840426,
	-5.606072116113889,
	-5.691469870643939,
	-5.716729051359283,
	-5.7206251434180615,
	-5.720807341776568,
	-5.72083537980357,
	-5.720865605371856,
	-5.721117689801974,
	-5.7224590443822505,
	-5.727750645661986,
	-5.735314203926123,
	-5.748816164886438,
	-5.763586389641379,
	-5.784058843493309,
	-5.805805205588503,
	-5.834360108147002,
	-5.866463541597869,
	-5.900104648876906,
	-5.935859895525308,
	-5.973691233463541,
	-6.015128604625275,
	-6.055845954469688,
	-6.0983659371906365,
	-6.145796552733616,
	-6.192078415200615,
	-6.265341171007107,
	-6.299796619504697,
	-6.310721949999949,
	-6.31076490605416,
	-6.3107659771203926,
	-6.310767488782483,
f3d538e959b657a42bb37b149b4082c3|term://.//58262%3A/bin/zsh|1559|1|V|floaterm
	0,
	0.000000000824566393902871,
	0.000000001649132787805742,
	0.0000000042736673951573,
	0.000000007854894277820188,
	0.000000012865594995894915,
	0.000000019864888551894478,
	0.00000002961663348624412,
	0.00000004322200352963795,
	0.0000000622848204573505,
	0.00000008913779455534383,
	0.00000012718600649070234,
	0.00000018142011393790484,
	0.00000025918697568019844,
	0.0000003713507358135122,
	0.0000005340499371458247,
	0.0000007713713635436061,
	0.0000011194532644326652,
	0.00000163288084347219,
	0.000002394925165500956,
	0.00000353382221047641,
	0.000005239457984758133,
	0.0000077443493297292,
	0.000011384811640942628,
	0.00001751887138349895,
	0.00002910117957308224,
	0.00006769491755202257,
	0.0002731314428664378,
	0.0010222223266937531,
	0.003964550545189364,
	0.020625567814878006,
	0.044210854619834594,
	0.08095060277925414,
	0.1176903509386737,
	0.16691015445640778,
	0.21612995797414186,
	0.2733940823027829,
	0.3306582066314239,
	0.3861872003900649,
	0.44171619414870583,
	0.49384692863157226,
	0.5459776631144387,
	0.594433815733613,
	0.6428899683527872,
	0.6952150613578453,
	0.7475401543629033,
	0.8495535082473165,
	0.9515668621317296,
	1.2112527778467417,
	1.4990972765618311,
	2.328027509234393,
	6.907755278982137,
	0.003277120183723837,
ec2724fe1e777bfe0de1b01854fd58bf|term://.//58262%3A/bin/zsh|1914|1|V|floaterm
	-5.720790235014612,
	-5.720790309239479,
	-5.7207925666500286,
	-5.7208129965721914,
	-5.720979388251086,
	-5.722413912456401,
	-5.73089645059965,
	-5.739450235660581,
	-5.753473419772813,
	-5.775796390865955,
	-5.800859324662404,
	-5.835494686818008,
	-5.874502897463853,
	-5.929079948337355,
	-5.972520855709395,
	-6.019105644707142,
	-6.063910530054915,
	-6.111078033930878,
	-6.176742906815431,
	-6.235686651548977,
	-6.299829517499393,
	-6.310151381851329,
	-6.310759334070878,
	-6.3107596596009845,
	-6.310759664110255,
	-6.310759664110569,
fdeaf6192dd1fc78fbe106512570507b|term://.//58262%3A/bin/zsh|1888|1|V|floaterm
	0,
	0.000001,
	0.000009,
	0.000073,
	0.000585,
	0.004680999999999999,
	0.02961561988089656,
	0.054550239761793115,
	0.09316964407133711,
	0.1490548581144307,
	0.20494007215752427,
	0.2744299913217305,
	0.3439199104859368,
	0.4322353338802642,
	0.4921907392198097,
	0.550994507116782,
	0.6037558198656746,
	0.6565171326145672,
	0.7293480476088583,
	0.8021789626031494,
	0.9519032190553288,
	1.1016274755075082,
	1.3693360800639338,
	1.8294843535729464,
	5.051212717793022,
f267f540fe04655a06eb9fcefb0f9b0e|term://.//58262%3A/bin/zsh|1913|1|V|floaterm
	6.907755278982137,
d9b306a294dd5896baded92f24448cb3|term://.//58262%3A/bin/zsh|2483|1|V|floaterm
	-5.720790235014612,
	-5.720790559052508,
	-5.720793153049703,
	-5.7208139069432296,
	-5.720980023145342,
	-5.722314380644454,
	-5.7333538258662795,
	-5.789083303603683,
	-5.83821247886966,
	-5.87475420800818,
	-5.914929386435037,
	-5.958197337292561,
	-6.005247003739693,
	-6.058894822100714,
	-6.1038814085598325,
	-6.153798202431732,
	-6.197788537554528,
	-6.244397743653925,
	-6.29148008445473,
	-6.341884884060294,
	-6.392597932065047,
	-6.446234951203785,
	-6.518487717746647,
	-6.571245978018453,
	-6.626622538921473,
	-6.684505579647227,
	-6.742742216155483,
	-6.8069447173946145,
	-6.864418812387787,
	-6.948090535562213,
	-6.968730722181635,
	-6.971394942616228,
	-6.971400791869934,
	-6.97140092420042,
	-6.971400932520976,
8226835982ef4f3c7138adf776d0fed2|term://.//58262%3A/bin/zsh|2448|1|V|floaterm
	0,
	0.000001,
	0.000009,
	0.000073,
	0.000585,
	0.004680999999999999,
	0.037448999999999996,
	0.17775712980171315,
	0.27874790396441407,
	0.3461129742296368,
	0.41016202727961615,
	0.4714818980218511,
	0.532801768764086,
	0.5966403904616963,
	0.6451020796257174,
	0.6935637687897386,
	0.7346336768342696,
	0.7757035848788006,
	0.8143441294531324,
	0.852984674027464,
	0.8896848259620853,
	0.9263849778967066,
	0.9740585516321433,
	1.006369308900057,
	1.0386800661679705,
	1.0717281213895709,
	1.1047761766111712,
	1.1418339539485969,
	1.1788917312860225,
	1.2670967626715495,
	1.3553017940570764,
	1.542282972818533,
	1.79161857155459,
	2.9420057098565,
	6.907755278982137,
a4b811fd849d5609a17dac3a1b092225|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|40|1|V|rust
	        let temp = self.mx;
a4bfb251e2444b58f18b33159bd0ddbe|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|89|1|V|rust
	    #[test]
	    fn test_boltz() {
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-1);
	        let sol = km.solve_boltzmann();
	
	        for t in sol.ts.iter() {
	            println!("{},", t);
	        }
	        for u in sol.us.iter() {
	            println!("{},", u[0]);
	        }
	    }
3eb7f090db74056eeed0f83aba0590d2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|102|13|v|rust
	boltz
9e00a9204b55ae0fff756660b136d858|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|106|1|V|rust
	        for t in sol.ts.iter() {
	            println!("{},", t);
	        }
	        for u in sol.us.iter() {
	            println!("{},", u[0]);
	        }
5db9f1376abb3e0a2f33030848faddc5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|104|8|V|rust
	        let sol = km.solve_boltzmann();
af91d7ea0dd5686bb4728fd5b5987866|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|103|1|V|rust
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-4);
	        println!("{}", km.relic_density());
fa61244cd51e28ed9163fc50e583eafc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|103|1|V|rust
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-2);
	        println!("{}", km.relic_density());
11298f60e869687f9a44717e00e4287e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|113|1|V|rust
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-5);
	        println!("{}", km.relic_density());
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-6);
	        println!("{}", km.relic_density());
	        let km = KineticMixing::new(1e3, 1e4, 1.0, 1e-7);
	        println!("{}", km.relic_density());
51f2c9c88344d11977396f539cf7d517|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|1|V|rust
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
4c5b394453e45d920568f9658b8ad1f3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|10|14|v|rust
	Option<
f31ad64a41ffe289ed7ede19fee486e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|13|12|v|rust
	<F, J = Jac>
f430a1f151629b57a63874ff4a2bc614|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|13|29|v|rust
	 = Jac
e6aa5a1e115df781a0f9bd210789026b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|7|11|v|rust
	ArrayViewMut1<f64>, ArrayView1<f64>, f64
a1a40fe751b23b7ad14542a74f9296ca|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|20|v|rust
	, J = Jac
3120d80904f4e74e4a80fd0f76db2f55|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|8|1|V|rust
	    pub jac: Option<J>,
a3ed2a4c75bd8d940cbef7a6f0ffc7e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|1|v|rust
	pub struct OdeInt<F>
	{
	    pub f: F,
	}
c67dacfb91ce5efa332428e4d2c75a5a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|9|1|V|rust
	    pub f: F,
4e2242f221531924f77b7250660af487|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|22|v|rust
	Params
6dbd9baa644f47b43a5ac0835c708e6f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|3|1|V|rust
	type Jac = fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64);
	
	pub struct OdeInt<F, Params>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	{
	    pub f: F,
	    phantom: std::marker::PhantomData<Params>,
	}
	pub struct OdeIntWithJac<F, J>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	    J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	{
	    pub f: F,
	    pub j: J,
	}
	
	pub struct OdeIntBuilder<F>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	{
	    pub f: F,
	}
	
	impl<F, J> OdeInt<F, J>
	where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	{
	    pub fn new(f: F) -> OdeInt<F, J> {
	        OdeInt { f, jac: None }
	    }
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test() {
	        let f = |_du: ArrayViewMut1<f64>, u_: ArrayView1<f64>, _t: f64| {};
	        let int = OdeInt::new(f);
	    }
	}
600f4b64d8f8a70439a6e5053a05da28|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|1|V|rust
	    pub f: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Box<T>),
0d329d2c0fe730af2b6f2f8ff40e09f4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|8|12|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Box<T>)
c8da36edd7e1436f5e4e558b173a4400|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|6|v|rust
	DeFunction<T>
7985d2dee0dfd445b6eef53b67094b26|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|1|V|rust
	type DeFunction<T> = fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Box<T>);
86408593c34af77fdd90df932f8b5261|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|8|v|rust
	Function
0cac7026cc6a03a1a32607e3fd0baa34|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|10|12|v|rust
	fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Box<T>),
5b638e9f2feff315ad99b1222a1b0c40|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|17|31|v|rust
	::new_uninit()
265effb57fb98806077f7c0e3c74aea7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|20|v|rust
	ArrayViewMut2<f64>, ArrayView1<f64>, f64, Box<T>
12292013ebd56286c0ae20e3db22524f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|15|9|v|rust
	DeIntegrator {
	            f,
	            j: Box::<DeJac<T>>::new(
	                |_du: ArrayViewMut2<f64>, _u: ArrayView1<f64>, _t: f64, _p: Box<T>| {},
	            ),
	        }
059b18da0695157d34b398f806ed948b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|25|16|v|rust
	Box::<DeJac<T>>::new(
	                |_du: ArrayViewMut2<f64>, _u: ArrayView1<f64>, _t: f64, _p: Box<T>| {},
	            ),
	
78f6acb06f6e890698914d418350f887|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|19|1|V|rust
	                |_du: ArrayViewMut2<f64>, _u: ArrayView1<f64>, _t: f64, _p: Box<T>| {},
318f8bddac1279b6a2779ad4ae5ef1b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|39|1|V|rust
	        let f = |_du: ArrayViewMut1<f64>, _u: ArrayView1<f64>, _t: f64, _p: Box<MyType>| {};
33fc3acbd1e6c2c434c6a63024b9a790|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|22|16|v|rust
	Box::new(j)
243cc4c5ef7653ca9e3456fdf342ee01|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|11|17|v|rust
	Box<T>
d1d8e0657c8eb8e83fdc92c4155973a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|35|40|v|rust
	Box::new(MyType)
3f56d50f933621450d4423df47296825|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|33|77|v|rust
	Box<
379162eede6757f1456dabc58b45d795|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|35|47|v|rust
	.with_jac(j)
a305ed530e0732b34c200d603779a841|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|38|1|V|rust
	        (int.f)(du.view_mut(), u.view(), 0.0, MyType);
94cae22156b9cbad95eb82e952812dda|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|14|1|V|rust
	impl<T> DeIntegrator<T> {
	    pub fn new(f: DeFunction<T>, params: T) -> DeIntegrator<T> {
	        DeIntegrator { f, j: None, params }
	    }
	    pub fn with_jac(self, j: DeJac<T>) -> DeIntegrator<T> {
	        DeIntegrator {
	            f: self.f,
	            params: self.params,
	            j: Some(j),
	        }
	    }
	}
fe78c0473773d384e22517ab52d37a58|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|20|1|V|rust
	        struct MyType;
	        let f = |_du: ArrayViewMut1<f64>, _u: ArrayView1<f64>, _t: f64, _p: MyType| {};
	        let j = |_du: ArrayViewMut2<f64>, _u: ArrayView1<f64>, _t: f64, _p: MyType| {};
	        let int = DeIntegrator::new(f, MyType);
	        let mut du = Array::zeros(1);
	        let u = Array::zeros(1);
	        (int.f)(du.view_mut(), u.view(), 0.0, MyType);
	        println!("{}", int.j.is_none());
2b2ac8cd0aed32a34a58c93a27042a48|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|10|1|V|rust
	    pub dfdu: Option<DeJacobian<T>>,
9dbd42827d0370862507660476ddd406|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|6|v|rust
	DeJacobian<T> = fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, T);
d980d77bad50918c9a0e85cf372caadc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|6|v|rust
	DeJacobian
d1259b7679594083344d5e7e4a4a2b27|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|1|V|rust
	type OdeDfdu<T> = fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, T);
9759721b2ef3fa4428a8075330c0d2f6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|10|15|v|rust
	DeFunction
ec29f155fde24646d5c55fbc1beb67e6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|14|1|V|rust
	    pub u: Array1<f64>,
	    pub t: f64,
6ff81241edabb17a4497604f91f8b199|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|35|1|V|rust
	//pub struct OdeIntegrator<T: OdeFunction, Alg: OdeAlgorithm> {
	//    /// Function structure representing the RHS of the ODE.
	//    pub func: T,
	//    /// Current solution vector
	//    pub u: Array1<f64>,
	//    /// Current time
	//    pub t: f64,
	//    /// Current step size
	//    pub dt: f64,
	//    /// Previous solution vector
	//    pub uprev: Array1<f64>,
	//    /// Previous time
	//    pub tprev: f64,
	//    /// Previous step size
	//    pub dtprev: f64,
	//    /// Direction of integration.
	//    pub tdir: f64,
	//    /// Final time value
	//    pub tfinal: f64,
	//    /// Options
	//    pub opts: OdeIntegratorOpts,
	//    /// Statistics
	//    pub stats: OdeStatistics,
	//    /// Solution object
	//    pub sol: OdeSolution,
	//    /// Cache associated with the algorithm
	//    pub(crate) cache: Alg::Cache,
	//}
2435a5b323e8c970f729d1c25144f06d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|64|26|v|rust
	T: OdeFunction, 
f0aaeaa9d7b8bb2f31cacd0295bf4900|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|66|58|v|rust
	, Box<T>
1e36378bb8904ae8591584febe1611c9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|65|1|V|rust
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
e2ae4b556a526f896344fa51dada775f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|67|1|V|rust
	    /// Jacobian of the RHS of the ODE
	    pub dfdu: fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
1861fe510fd196469300dcec5503a8b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|68|60|v|rust
	OptioParams
b8cc0eb96b95932e2b48392cacec15e3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|70|58|v|rust
	, Option<Params>
0b313ffd4eb5103bf07fc6ecd07aa9e0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|66|58|v|rust
	, Params
bbb93ef26e3c101ff11cdd21cab08a94|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|63|1|V|rust
	Null
2b7cbc78bf108072f59c4f98ff54b64e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|68|67|v|rust
	Option<Params>
75cf96efb858ef6e415d46ac17eb4e2f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|64|54|V|rust
	pub struct OdeIntegrator<Alg: OdeAlgorithm, Params> {
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    /// Jacobian of the RHS of the ODE (w.r.t. u)
	    pub dfdu: fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params),
	    /// Jacobian of the RHS of the ODE (w.r.t. time)
	    pub dfdt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    /// Parameters
	    pub params: Params,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
35f75cb6627b2a546df6ed41d5c23f26|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|5|1|V|rust
	type OdeDudt<T> = fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, T);
	type OdeDfdu<T> = fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, T);
	type OdeDfdt<T> = fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, T);
	
	pub struct DeIntegrator<T> {
	    pub dudt: OdeDudt<T>,
	    pub dfdu: Option<OdeDfdu<T>>,
	    pub dfdt: Option<OdeDfdt<T>>,
	    pub params: T,
	    pub u: Array1<f64>,
	    pub t: f64,
	    pub uprev: Array1<f64>,
	    pub tprev: f64,
	}
e807bdfa595800d0bf589ee4cdcbe7eb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|9|1|V|rust
	    u: Array<f64>,
	    t: f64,
	
d1b02da9fedbc7e79e2b59b57dadd5b3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|36|1|V|rust
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
52b74151117abd8be3cfe468fa881293|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|7|1|V|rust
	    dudt: Dudt,
	    dfdu: Option<Dfdu>,
	    dfdt: Option<Dfdt>,
	    u: Array1<f64>,
	    t: f64,
	    uprev: Array1<f64>,
	    tprev: f64,
	    cach: Alg::Cache,
b73367a5238a69f463bb439056f92eed|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|9|1|V|rust
	    /// Jacobian of the RHS of ODE w.r.t u.
a5e3193320ecfa5e307230e03c453bda|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|8|1|V|rust
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
9b0b3ebf25d30a45a686fd6d3adb844a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|46|v|rust
	: OdeAlgorithm
9bbf3609617f5366a9852bb0180ee90e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|6|1|V|rust
	pub struct DeIntegrator<Dudt, Dfdu, Dfdt, Params, Alg>
	where
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    Dfdt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    Dfdu: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params),
	    Alg: OdeAlgorithm,
	{
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: Dudt,
	    /// Jacobian of the RHS of ODE w.r.t u.
	    pub dfdu: Dfdu,
	    /// Jacobian of the RHS of ODE w.r.t t.
	    pub dfdt: Dfdt,
	    /// Parameters for the ODE.
	    pub params: Params,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
8eefc699b805faf4906e11c8f0187e82|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|68|5|V|rust
	    /// Direction of integration.
3452340fb42312d6981e0e96d356a367|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|68|5|V|rust
	    pub tdir: f64,
ea9895aac92932dafa57b72afc5e6058|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|68|5|V|rust
	    /// Options
80c31df7f114943117803c42512e50e2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|48|1|V|rust
	where
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    Dfdt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    Dfdu: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params),
	    Alg: OdeAlgorithm,
05e4e3d188531f7a51c55c2d0345b866|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|78|14|v|rust
	ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params)
4d0e0d5ae46510cf37dfec80b680835f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|88|29|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, ())
0d43ed35af2bf91e1fd96a4af2db96f4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|90|9|v|rust
	fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, ())
cd580fe5fcdcfb1c984199ef5d2f8b16|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|83|15|v|rust
	<Ju, Jt>
2ec087756b75c319b96d626a9bdeed9d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|78|14|v|rust
	ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params
ae465fe080b8d2839d3399621b9c320d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|90|14|v|rust
	: Dfdu
2ed0cc49a7b0a6505b61fcb9b991df88|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|88|42|v|rust
	(), ()
8ae3c92107bfb3b270ca30e284c2b557|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|89|9|V|rust
	        let f = |df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, ()| {};
6052a36433e4189f7237c31a05b3e6ac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|92|19|v|rust
	Some(f)
d68e33b06bc360539f6f814423955be9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|88|36|v|rust
	Dfdu
62f144632a26f0c815dbe4503625afda|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|49|11|v|rust
	Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
2f1b665b2ab89e00214e8e7d740bc9a1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|55|15|v|rust
	Dudt
315e633d99e5e71c0d94629273f93bc0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|55|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params)
fc63b5fe2bc6c74946fa75d7fbae257a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|59|22|v|rust
	Dfdt
6d776e5801308c6475ca80d838c80b22|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|47|32|v|rust
	Dudt, Dfdu, Dfdt, 
50a5b74f865a4c6b888e34fb54c7ca09|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|49|5|V|rust
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
0c45e34e01646a9e886cb877df564e00|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|49|5|V|rust
	    Dfdt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
8c7a31ef4047280164f38f8f1788d95a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|49|5|V|rust
	    Dfdu: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params),
567c0c2f3c14f0bfa8a083fc85076573|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|52|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
f1925d61f9415c7ab6bfe1268ce4f1e4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|78|15|v|rust
	Dudt,
438b4a46ec73a7e5b9ace08d560d06c7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|77|1|V|rust
	    pub fn new(
	        dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, ()),
	        uinit: Array1<f64>,
	        tspan: (f64, f64),
	        alg: Alg,
	    ) -> DeIntegratorBuilder<(), Alg> {
	        DeIntegratorBuilder {
	            dudt,
	            dfdu: None,
	            dfdt: None,
	            params: None,
	            u: uinit,
	            t: tspan.0,
	            tfinal: tspan.1,
	            dt: 0.0,
	            opts: OdeIntegratorOpts::new(),
	            alg,
	        }
	    }
c4629fa5a23df517c09563d97b2c857b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|96|5|v|rust
	pub fn with_params(
	        dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	        uinit: Array1<f64>,
	        tspan: (f64, f64),
	        alg: Alg,
	        params: Params,
	    ) -> DeIntegratorBuilder<Params, Alg> {
	        DeIntegratorBuilder {
	            dudt,
	            dfdu: None,
	            dfdt: None,
	            params: Some(params),
	            u: uinit,
	            t: tspan.0,
	            tfinal: tspan.1,
	            dt: 0.0,
	            opts: OdeIntegratorOpts::new(),
	            alg,
	        }
	    }
12de6432db37494ffcb74ec23bf55498|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|116|12|v|rust
	with_params
ba57869a009a1d64178526ca16b138ce|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|116|12|v|rust
	dfdu
d2168954df855fc115c8f69e0974c841|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|117|9|V|rust
	        dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
cc5cc49c893bb0bd771d585fe35d2216|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|117|9|V|rust
	        uinit: Array1<f64>,
92941dd62f6b067755538650fc2d5821|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|117|9|V|rust
	        tspan: (f64, f64),
1c9fe158b4b131660e3bbe46c9a5d77b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|117|9|V|rust
	        params: Params,
23a58bf9274bedb19375e527a0744fa9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|116|12|v|rust
	with
56eb6b74e8cd684ec01771cbcdcdea65|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|118|10|v|rust
	DeIntegratorBuilder<Params, Alg>
edb21ccd0c0f643d50029458ebc909a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|117|1|V|rust
	        DeIntegratorBuilder {
	            dudt,
	            dfdu: None,
	            dfdt: None,
	            params: Some(params),
	            u: uinit,
	            t: tspan.0,
	            tfinal: tspan.1,
	            dt: 0.0,
	            opts: OdeIntegratorOpts::new(),
	            alg,
	        }
1a58ae608b2290eace6b013cc49a1c01|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|96|17|V|rust
	    pub fn with_params(
	        dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	        uinit: Array1<f64>,
	        tspan: (f64, f64),
	        alg: Alg,
	        params: Params,
	    ) -> DeIntegratorBuilder<Params, Alg> {
	        DeIntegratorBuilder {
	            dudt,
	            dfdu: None,
	            dfdt: None,
	            params: Some(params),
	            u: uinit,
	            t: tspan.0,
	            tfinal: tspan.1,
	            dt: 0.0,
	            opts: OdeIntegratorOpts::new(),
	            alg,
	        }
	    }
a2e0b6a63b568f6ce5c271448e723701|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|88|19|v|rust
	: params
20bcb8e0ed5d0ad74c962e56579297e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|97|1|V|rust
	    pub fn add_jacu(mut self, j: fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params)) -> Self {
	        self.dfdu = Some(j);
	        self
	    }
be1a0c6c997585d801eda1a8b4ba5a97|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|105|5|V|rust
	    pub fn build(self) -> DeIntegrator<Params, Alg>{
4887cbe838a25985da35db9b89e2c581|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|78|15|v|rust
	fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	
d7fbc1bb26cb36377e6844dc2eaf6658|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|114|59|v|rust
	crate::radau::Radau5,
fbbffdb78db220fa3f36c55def4fef45|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/integrator.rs|112|16|v|rust
	MyType
54ceb168b59107392bd82e0a5cb6af93|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|37|9|v|rust
	func: T,
578c01b64e757f58c5c2ae70af2d647b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|37|1|V|rust
	    pub dfdt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
2b84196c8bd5fe100b6c62b4eba50f1b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|38|1|V|rust
	    /// Jacobian w.r.t. u of RHS of ODE
10b3f9299588f1a3a8882b29c7876e7c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|33|1|V|rust
	/// Light-weight struct used to keep track of the state of the ODE throughout
fe01f384e1cfc42eb6fd1f390af0c18c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|33|1|V|rust
	/// integration.
2d86147f53c9a28b13b2548f07f4376d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|69|6|v|rust
	T: OdeFunction
b67a87b52042f99c020df7687d0d193d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|35|1|V|rust
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    /// Jacobian w.r.t. t of RHS of ODE
	    pub dfdt: fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, Params),
	    /// Jacobian w.r.t. u of RHS of ODE
	    pub dfdu: fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, Params),
	    /// Parameters of the ODE
	    pub params: Params,
02877c4dcf39b4b1469b4e1854615355|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|142|1|V|rust
	    /// Function structure representing the RHS of the ODE.
	    pub func: T,
de21930a3766bd252e4eda968b3f4171|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|167|20|v|rust
	prob: OdeProblem<T>
cece5eed7b3baf4ba51e1318d0cb0b80|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|178|13|v|rust
	func: prob.func,
4b6d55e030ce54ff1c0338bd9b5a2d0d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|179|16|v|rust
	prob.
5dae59e821c1623f64f7524c23d67342|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|181|17|v|rust
	opts.dtstart
b1314b90f6704c1657d39f454856d793|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|182|13|V|rust
	            tdir: 1f64.copysign(tspan.1 - tspan.0),
e246be8d9daf9066ae5024a9ef1a3166|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|175|29|v|rust
	::<T, Alg>
ff1aa627b9e7af66d3e4eb63e3527090|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|173|9|V|rust
	        opts.dtmax = prob.tspan.1 - prob.tspan.0;
ad8b2c0d05e8442f8eb608e7e43165bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|187|42|v|rust
	OdeIntegratorBuilder<Params, Alg>
78d69ddeb2c032de5cd2ca83b143eec4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|199|5|V|rust
	    pub fn dtstart(mut self, val: f64) ->  {
0363ba712627d39d0fc9a5d6a82f3715|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|267|13|V|rust
	            func: self.func,
8598b8b6e40fdadaa21e433b37ac4565|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|267|1|V|rust
	            dudt: self.dudt,
df1b8d3416296368dafda2b5299fc577|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|277|19|v|rust
	self.tdir
39c336d84baaab293e59812cf494c534|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|266|1|V|rust
	        let dfdt = match self.dfdt {
	            Some(f) => f,
	            None => |du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: Params| {},
	        };
a4fe65bc239e3bbc33ef2079a37222ea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/algorithm.rs|8|1|V|rust
	use super::function::OdeFunction;
e56195323331fc5a7f011fe00b0ba28a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|24|1|V|rust
	        let mut utemp = Array::zeros(u.raw_dim());
	        let mut du0 = Array::zeros(u.raw_dim());
	        let mut du1 = Array::zeros(u.raw_dim());
	
	        utemp.assign(&u);
	        self.dudt(du0.view_mut(), u.view(), t);
	
	        for i in 0..u.len() {
	            let usafe = utemp[i];
	            let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	            utemp[i] = usafe + del;
	            self.dudt(du1.view_mut(), utemp.view(), t);
	            for j in 0..u.len() {
	                df[[j, i]] = (du1[j] - du0[j]) / del;
	            }
	            utemp[i] = usafe;
	        }
a3545912b84f506455b1c9e061c3f722|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|266|21|v|rust
	move 
8be1cec5b05e2cdb1fd203a9fd7d5efc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|287|13|V|rust
	            },
1b0d280ca55e63f6d64cb6566d9d2656|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|266|21|v|rust
	Box::new(
012c51ae58210756e2bc07b9a0a759de|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|286|13|V|rust
	            ),
128be525a1430d91ca24b86eeea46b4d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|139|58|v|rust
	, 'a
8be72b9a1d940bdea2c2e00a61c6d340|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|141|15|v|rust
	&'a dyn Fn
3e5feed4cf593010bb7a27cd6b8dedeb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|265|13|v|rust
	Some(f) => f,
	            None
8d0f225ce72820abcfd51a767e08b0dd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/function.rs|46|1|V|rust
	        let mut du = Array::zeros(u.raw_dim());
	        self.dudt(du.view_mut(), u.view(), t);
	        self.dudt(df.view_mut(), u.view(), t);
	        let dt = f64::EPSILON * t.max(1e-5);
	        df.assign(&((&df - &du) / dt));
f173cad190af8262352aac499d13273b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|288|1|v|rust
	|du: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: Params| {},
04c734e4ecebde56d5fcb1704773f207|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|286|13|V|rust
	            Some(f) => f,
e7be6b045b2bb60553d9ed45eee2604d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|32|43|v|rust
	&'a 
96ebb39485cb374bfcd9d4c0e93d1372|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|25|13|V|rust
	            .func
0cb2c91aa7f13372582db934fe739121|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|15|19|v|rust
	.func
7bdb919592fecf7192e5be07bc03bbf8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|17|1|V|rust
	            &mut integrator.params,
85f3db42135219c7499cdcd00e01e16c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|2|18|v|rust
	OdeFunction, 
af23189c299e51bc1105f2dd780827d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/prepare.rs|7|37|v|rust
	: OdeFunction>
fc8b480f65bf0e2f3043fc0f2e62ffd6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|20|9|V|rust
	        impl OdeFunction for HO {
0559a48f5861617cddb85e3207be00e6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|20|21|v|rust
	&mut self, 
d163e2ef9607084d38c6b0f5191c8fa9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|84|23|v|rust
	.func.
d0fdaf0ad9e1ddb191f449c574b7fa97|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|168|1|V|rust
	                            (integrator.dfdu)(
	                                integrator.cache.dfdu.view_mut(),
	                                integrator.u.view(),
	                                integrator.t,
	                                &mut integrator.params
	                            );
53d8a8f263a09b7cdffade79dacb851b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|183|1|V|rust
	                        integrator.func.dfdu(
	                            integrator.cache.dfdu.view_mut(),
	                            integrator.u.view(),
	                            integrator.t,
	                        );
6f2053e5448bf83b60af4578493c733b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|111|1|V|rust
	                (integrator.dfdu)(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                    &mut integrator.params,
	                );
5350173ae329b72bbad217315e9f48b6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|133|1|V|rust
	                integrator.func.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
3325ce4ea813d8c79dda87716ba637c2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|276|21|v|rust
	(self.
3245c13885424606607a53175da121d2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|297|21|v|rust
	llself.
96d277485e7cd9eb301aee85ea5a817c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|265|1|V|rust
	        let dudt = self.dudt.clone();
bbe44d10c7a1e48ec06e6cba980231d2|untitled:5|8|1|v|
	returns a value referencing data owned by the current function
75ad11244dce88e5ffac5d7886a98cc5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|297|1|V|rust
	                &(move |mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params| {
	                    let mut du = Array::zeros(u.raw_dim());
	                    dudt(du.view_mut(), u.view(), t, p);
	                    dudt(df.view_mut(), u.view(), t, p);
	                    let dt = f64::EPSILON * t.max(1e-5);
	                    df.assign(&((&df - &du) / dt));
	                })
f43aacf4644f92f58edbcce92f4801cf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|292|1|v|rust
	default: T
e8d45b0668f1fc0c235d13b30cbfe172|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|304|1|V|rust
	                let dudt = self.dudt.clone();
04099f267365427dd9abcf2f2b554730|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|302|1|V|rust
	        let dfdt = match self.dfdt {
	            Some(f) => f,
	            _ => {
	                let dudt = self.dudt.clone();
	                &(move |mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params| {
	                    let mut du = Array::zeros(u.raw_dim());
	                    dudt(du.view_mut(), u.view(), t, p);
	                    dudt(df.view_mut(), u.view(), t, p);
	                    let dt = f64::EPSILON * t.max(1e-5);
	                    df.assign(&((&df - &du) / dt));
	                })
	            }
	        };
399f3e995c33ce9e8dd2d79c47d14af8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|265|35|v|rust
	 {
	            Some(f) => f,
	            _ => 
deebca7f7f376c1339e8a08a0e7e3bff|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|265|20|v|rust
	match 
3734a903022249b3010be1897042568e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|290|15|v|rust
	move
46200a45a912f6fcdf91c86e0983afee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|301|23|v|rust
	.to_owned()
e58d7a78590deb89846690455bdab2d1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|27|9|V|rust
	        impl OdeFunction for VanDerPol {
f6edf7098044ebc1f40d236f372ee75e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|171|20|v|rust
	Alg::default_opts()
83587501f5bc56c1f40611539feea68f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|171|9|V|rust
	        let opts = Alg::default_opts();
0223f9dc65598c1c0bb09948c76e5a9c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|165|15|v|rust
	&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
7dfeb1f38cadc579aa0b9c49855b3ef6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|184|1|V|rust
	    pub fn jac_dfdu(
	        mut self,
	        jac: &'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &mut Params),
	    ) -> Self {
	        self.dfdu = Some(jac);
	        self
	    }
8a48014b68fb658e8b2d1298664a4f00|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|40|14|v|rust
	with_jacu
2072f77bc0810c8b8e1cfb85cb002078|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|313|19|v|rust
	dfdt
33b629bd9788b2a2b605e9d96b1532d0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|184|15|v|rust
	_dfd
5647363970144ffbd670ae3d1b1ddfa7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|280|1|V|rust
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                f(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    f(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
4aaed575108395b1ed301426a7efee92|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|336|17|v|rust
	&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t:f64, &mut p: Params)
2869ec127d50cd84f659d88f22b77ace|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|337|1|V|rust
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, &mut p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
a5ac5028531db02fc64733657bf93ef4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|303|1|V|rust
	                let mut du = Array::zeros(u.raw_dim());
	                f(du.view_mut(), u.view(), t, p);
	                f(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
9e3d2636f3f95629467809e53df8f9ae|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|365|1|V|rust
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
68e2d0ab9c2d606f10fabe49a7bd3314|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|277|1|V|rust
	        let dfdu = self.dfdu.unwrap_or({
	            let f = self.dudt.clone();
	            &(move |mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params| {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                f(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    f(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            })
	        });
	
	        let dfdt = self.dfdt.unwrap_or({
	            let f = self.dudt.clone();
	            &(move |mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params| {
	                let mut du = Array::zeros(u.raw_dim());
	                f(du.view_mut(), u.view(), t, p);
	                f(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            })
5bd9a3cf4b209fdcdc9bc0473e565e16|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|277|9|V|rust
	        );
013df95772fd2a6f25f137477b4a2d8b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/algorithm.rs|24|9|v|rust
	*integrator
adbb09d79823952e9a98c9cb25a564b0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|299|1|V|rust
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegrator<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        (self.func)(du.view_mut(), u.view(), t, &mut p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, &mut p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jact {
	            Some(f) => f(df, u, t, &mut p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
b6cfa69846465c88b63669743107abcd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|300|78|v|rust
	, p: &mut Params
dd2d5292c01e531c816d4a8ebc27366d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|332|53|v|rust
	, self.params
4d8d4ffae9e0530f0efe2ff902ac864c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|300|1|V|rust
	    pub fn dudt(&mut self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	        (self.func)(du.view_mut(), u.view(), t, &mut self.params)
	    }
	    pub fn dfdu(&mut self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64) {
	        match self.jacu {
	            Some(f) => f(df, u, t, &mut self.params),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&mut self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	        match self.jact {
	            Some(f) => f(df, u, t, &mut self.params),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t);
	                self.dudt(df.view_mut(), u.view(), t);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
02b92212db3197ca935161b6a2bbc98c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|342|1|V|rust
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        (self.func)(du.view_mut(), u.view(), t, &mut p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, &mut p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jact {
	            Some(f) => f(df, u, t, &mut p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
f625c1d70e2f568365af833d73cff676|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5/stages.rs|14|9|V|rust
	            integrator.t + DormandPrince5::C2 * integrator.dt,
	            &mut integrator.params,
84d2abb067495d6aba106d08ba7469d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|9|v|rust
	integrator.dfdu.unwrap()
847b15a01b31de0fa6d01826d1f27905|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|41|9|v|rust
	integrator.func
20af9d8aa4389c41fd8671c03d4073af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|47|24|v|rust
	.unwrap()
681a5cbd97e4676a2c200d3df5eae07b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|73|13|v|rust
	integrator.dfdu
0c2bc05d56554c628c3d5039b655f131|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|77|13|V|rust
	                &mut integrator.params,
bdb0bc6a7f6c3473498b7ec91e164345|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|3|18|v|rust
	OdeFunction
e576b96164a1a9932e00cd600764edd2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|187|25|V|rust
	                            &mut integrator.params,
506248bf277ee222d321be420d14d5a6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|172|25|V|rust
	                                &mut integrator.params,
50621917e1a21cd7d0d7b524f387d98c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|75|21|V|rust
	                        &mut integrator.params,
c7037432b7736154e68edd743d6f993d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|115|17|V|rust
	                    &mut integrator.params,
27d46e061f0c07d9b457b74483e17982|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|343|54|v|rust
	self.param
1ac7b4304cfa7dda992347cc36541586|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|342|80|v|rust
	p: &mut Params
984b7a9d2078037a2af269c1dbcd5291|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|347|36|v|rust
	&mut self.params
728829ae3112c06cddbc6f6139a2c3dc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|342|1|V|rust
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jact {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
322b105f93f635806195df7317e689f0|terminal:32|22|14|v|
	 cannot borrow `integrator.cache.k2` as mutable because it is also borrowed as immutable
0b188e1a1be4c5608f370939a3a01563|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|302|24|v|rust
	mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params)
89be693ce3aa4d51384d9eaf29721845|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|186|1|V|rust
	        jac: &'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &mut Params),
fe4495d3997a6b381f5c6061447a5f52|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|299|1|V|rust
	pub(crate) fn dfdu<F, Params>(
	    dudt: F,
	    mut df: ArrayViewMut2<f64>,
	    u: ArrayView1<f64>,
	    t: f64,
	    p: &mut Params,
	) where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
	{
	    let mut utemp = Array::zeros(u.raw_dim());
	    let mut du0 = Array::zeros(u.raw_dim());
	    let mut du1 = Array::zeros(u.raw_dim());
	
	    utemp.assign(&u);
	    dudt(du0.view_mut(), u.view(), t, p);
	
	    for i in 0..u.len() {
	        let usafe = utemp[i];
	        let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	        utemp[i] = usafe + del;
	        dudt(du1.view_mut(), utemp.view(), t, p);
	        for j in 0..u.len() {
	            df[[j, i]] = (du1[j] - du0[j]) / del;
	        }
	        utemp[i] = usafe;
	    }
	}
04dbd1f2b83acb11cf99cebe334ea45c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|386|1|V|rust
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
ae8489bda1b800d3b95726e1d61c11e4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|335|1|V|rust
	    let mut utemp = Array::zeros(u.raw_dim());
	    let mut du0 = Array::zeros(u.raw_dim());
	    let mut du1 = Array::zeros(u.raw_dim());
	
	    utemp.assign(&u);
	    dudt(du0.view_mut(), u.view(), t, p);
	
	    for i in 0..u.len() {
	        let usafe = utemp[i];
	        let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	        utemp[i] = usafe + del;
	        dudt(du1.view_mut(), utemp.view(), t, p);
	        for j in 0..u.len() {
	            df[[j, i]] = (du1[j] - du0[j]) / del;
	        }
	        utemp[i] = usafe;
	    }
cd0a624b0338c3104c88ba90093ab8dc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|342|1|V|rust
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegratorBuilder<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jact {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegrator<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jacu {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &mut Params) {
	        match self.jact {
	            Some(f) => f(df, u, t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
7890543dcc52351aec6ea8eace76bb00|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|34|8|v|rust
	(crate) func
dcab08d1541af55b706568a068565695|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|14|v|rust
	integrator.dudt,
e35de005ef1ba1e9444141bc63f7867c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|9|V|rust
	        dfdu(, 
1159386a50d0a60780fea35a5df8fe55|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|1|V|rust
	        crate::ode::integrator::dfdu(
	            integrator.dudt,
97c4606e3fe569ac7b1ab1ee92a6cff7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|73|1|V|rust
	            integrator.dfdu(
729785539170a67d2afe3bed99d352d5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|303|1|V|rust
	pub(crate) fn dfdu<F, Params>(
	    dudt: F,
	    mut df: ArrayViewMut2<f64>,
	    u: ArrayView1<f64>,
	    t: f64,
	    p: &mut Params,
	) where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
	{
	    let mut utemp = Array::zeros(u.raw_dim());
	    let mut du0 = Array::zeros(u.raw_dim());
	    let mut du1 = Array::zeros(u.raw_dim());
	
	    utemp.assign(&u);
	    dudt(du0.view_mut(), u.view(), t, p);
	
	    for i in 0..u.len() {
	        let usafe = utemp[i];
	        let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	        utemp[i] = usafe + del;
	        dudt(du1.view_mut(), utemp.view(), t, p);
	        for j in 0..u.len() {
	            df[[j, i]] = (du1[j] - du0[j]) / del;
	        }
	        utemp[i] = usafe;
	    }
	}
	pub(crate) fn dfdt<F, Params>(
	    dudt: F,
	    mut df: ArrayViewMut1<f64>,
	    u: ArrayView1<f64>,
	    t: f64,
	    p: &mut Params,
	) where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
	{
	    let mut du = Array::zeros(u.raw_dim());
	    dudt(du.view_mut(), u.view(), t, p);
	    dudt(df.view_mut(), u.view(), t, p);
	    let dt = f64::EPSILON * t.max(1e-5);
	    df.assign(&((&df - &du) / dt));
	}
7d0b56ce13dd3767b5afdb977faf4270|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|11|1|V|rust
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
a418f758e541b1c9bfc068304a2b897f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|3|1|V|rust
	pub(crate) fn jacobian_u<Dudt, Dfdu, Params>(
	    dudt: Dudt,
	    dfdu: Option<Dfdu>,
	    mut df: ArrayViewMut2<f64>,
	    u: ArrayView1<f64>,
	    t: f64,
	    p: &mut Params,
	) where
	    Dudt: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
	    Dfdu: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &mut Params),
	{
	    match dfdu {
	        Some(f) => f(df.view_mut(), u.view(), t, p),
	        None => {
	            let mut utemp = Array::zeros(u.raw_dim());
	            let mut du0 = Array::zeros(u.raw_dim());
	            let mut du1 = Array::zeros(u.raw_dim());
	            utemp.assign(&u);
	            dudt(du0.view_mut(), u.view(), t, p);
	            for i in 0..u.len() {
	                let usafe = utemp[i];
	                let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                utemp[i] = usafe + del;
	                dudt(du1.view_mut(), utemp.view(), t, p);
	                for j in 0..u.len() {
	                    df[[j, i]] = (du1[j] - du0[j]) / del;
	                }
	                utemp[i] = usafe;
	            }
	        }
	    }
	}
8121a7e36e9c089cea9215cbaf1c46c8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|79|1|V|rust
	    let mut du = Array::zeros(u.raw_dim());
	    dudt(du.view_mut(), u.view(), t, p);
	    dudt(df.view_mut(), u.view(), t, p);
	    let dt = f64::EPSILON * t.max(1e-5);
	    df.assign(&((&df - &du) / dt));
63699bae7db0bc5398265e6f545af4fa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|52|1|v|rust
	let mut utemp = Array::zeros(u.raw_dim());
	            let mut du0 = Array::zeros(u.raw_dim());
	            let mut du1 = Array::zeros(u.raw_dim());
	            utemp.assign(&u);
	            dudt(du0.view_mut(), u.view(), t, p);
	            for i in 0..u.len() {
	                let usafe = utemp[i];
	                let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                utemp[i] = usafe + del;
	                dudt(du1.view_mut(), utemp.view(), t, p);
	                for j in 0..u.len() {
	                    df[[j, i]] = (du1[j] - du0[j]) / del;
	                }
	                utemp[i] = usafe;
	            }
978ce602af021d7c62068a0843ea8571|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|59|1|V|rust
	pub(crate) fn dfdt<F, Params>(
	    dudt: F,
	    mut df: ArrayViewMut1<f64>,
	    u: ArrayView1<f64>,
	    t: f64,
	    p: &mut Params,
	) where
	    F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &mut Params),
	{
	    let mut du = Array::zeros(u.raw_dim());
	    dudt(du.view_mut(), u.view(), t, p);
	    dudt(df.view_mut(), u.view(), t, p);
	    let dt = f64::EPSILON * t.max(1e-5);
	    df.assign(&((&df - &du) / dt));
	}
ca93e0450e6911ce1f2477f82ad0bea5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|5|1|V|rust
	pub mod jacobian;
84f2ffd4b4f20b5118dcc20bdf99a4ee|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|9|v|rust
	crate::ode::integrator::dfdu
d3d7f04a0e14466bfed636fc794bc6b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|36|16|v|rust
	jact
d2d86ab8222765a7b2a63b0982305125|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|38|16|v|rust
	jacu
dd0d1577622a18e32d5fe98a769f8ba7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|42|13|v|rust
	.dudt
9746a51117e33f73f0f5784dccdec9c1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|71|1|V|rust
	                    jacobian_u(
	                        integrator.dudt,
	                        integrator.dfdu,
f618525e04dd1fc432b739ff7a5ab503|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|170|1|V|rust
	                            integrator.dfdu(
cb0a63dbd7ebea9a84621899ed503188|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|170|1|V|rust
	                            jacobian_u(
	                                integrator.dudt,
	                                integrator.dfdu,
5699ff453ddfddaca39e11f76ae8eca9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|187|1|V|rust
	                        integrator.dfdu(
871e9e682f641279ca26c1920d6b4a5e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|78|1|V|rust
	            integrator.dudt(
ba758fad8bb7f02a83f635091e90e649|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|111|1|V|rust
	                jacobian_u(
	                    integrator.dudt,
	                    integrator.dfdu,
5142ca75debaad0bdd218585b5bf2269|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|135|1|V|rust
	                integrator.dfdu(
38deab49951deafc329cd98842f8da36|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|40|14|v|rust
	jac_
88d8aaa8bcea46b8f4cce992ea6fb9e3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|45|1|V|rust
	        //for (t, u) in (&mut integrator).into_iter() {
	        //    println!("{}, {}", t, u);
	        //}
3a61998ae6c121b0e77894294c2d3c22|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|50|9|v|rust
	//    
b31a4f317dd6ce7272cb260e6a3b14be|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|49|23|v|rust
	(&mut integrator).into_iter()
5d7667416f77268d5d6dac1095e08031|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|300|24|v|rust
	mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params)
0cd35e527e8d767e2ee5f394f4fd0c0c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|14|1|V|rust
	    match dfdu {
	        Some(f) => f(df.view_mut(), u.view(), t, p),
	        None => {
	            let mut utemp = Array::zeros(u.raw_dim());
	            let mut du0 = Array::zeros(u.raw_dim());
	            let mut du1 = Array::zeros(u.raw_dim());
	            utemp.assign(&u);
	            dudt(du0.view_mut(), u.view(), t, p);
	            for i in 0..u.len() {
	                let usafe = utemp[i];
	                let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                utemp[i] = usafe + del;
	                dudt(du1.view_mut(), utemp.view(), t, p);
	                for j in 0..u.len() {
	                    df[[j, i]] = (du1[j] - du0[j]) / del;
	                }
	                utemp[i] = usafe;
	            }
	        }
	    }
5c4341b349089f69fe48154ea2fd6609|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|303|1|V|rust
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
c7cf05552612d1b028b1172789fb3454|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/jacobian.rs|47|1|V|rust
	    match dfdt {
	        Some(f) => f(df.view_mut(), u.view(), t, p),
	        None => {
	            let mut du = Array::zeros(u.raw_dim());
	            dudt(du.view_mut(), u.view(), t, p);
	            dudt(df.view_mut(), u.view(), t, p);
	            let dt = f64::EPSILON * t.max(1e-5);
	            df.assign(&((&df - &du) / dt));
	        }
	    }
99f36936b400ae0fabc30dd9e7b6ed60|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|299|1|V|rust
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegrator<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jacu {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jact {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
cb4f75eedc17d68574ca7ef4e0d9a3cb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|48|9|v|rust
	jacobian_u
28cfe378ad0c3adeffabb8b3491234aa|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|49|13|V|rust
	            integrator.dudt,
7bd7fd1bade0f650ef9ce3a790e7e421|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|49|13|V|rust
	            integrator.dfdu,
80c05976cae2e1c2ab850fc62120802e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|74|9|V|rust
	                integrator.dudt,
f3e752f1b478a3581fc6305d46e79ea6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|74|17|V|rust
	                integrator.dfdu,
c72642ecbe7e16c9364de7ff29d30593|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|188|1|V|rust
	                            integrator.dudt,
af1a6aff4e3f190c29c885b1fbbaae36|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|188|29|V|rust
	                            integrator.dfdu,
65bb50a879179cd0c9f944d60f7e6526|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|171|30|V|rust
	                                integrator.dudt,
	                                integrator.dfdu,
0bf4b91c79efef7d0fe5a6cdef21d640|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|72|13|V|rust
	                        integrator.dudt,
0fc30e32c0e4c30852de862c6bbe0185|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|72|25|V|rust
	                        integrator.dfdu,
3de7e7559779c24f6a10659495b47668|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|136|17|V|rust
	                    integrator.dudt,
	                    integrator.dfdu,
5cc4b5e0acd00b1135701c748ec316fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|299|1|V|rust
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegratorBuilder<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jacu {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jact {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegrator<'a, Params, Alg> {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        (self.func)(du.view_mut(), u.view(), t, p)
	    }
	    pub fn dfdu(&self, mut df: ArrayViewMut2<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jacu {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut utemp = Array::zeros(u.raw_dim());
	                let mut du0 = Array::zeros(u.raw_dim());
	                let mut du1 = Array::zeros(u.raw_dim());
	                utemp.assign(&u);
	                self.dudt(du0.view_mut(), u.view(), t, p);
	                for i in 0..u.len() {
	                    let usafe = utemp[i];
	                    let del = (f64::EPSILON * usafe.max(1e-5)).sqrt();
	                    utemp[i] = usafe + del;
	                    self.dudt(du1.view_mut(), utemp.view(), t, p);
	                    for j in 0..u.len() {
	                        df[[j, i]] = (du1[j] - du0[j]) / del;
	                    }
	                    utemp[i] = usafe;
	                }
	            }
	        }
	    }
	    pub fn dfdt(&self, mut df: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &Params) {
	        match self.jact {
	            Some(f) => f(df.view_mut(), u.view(), t, p),
	            None => {
	                let mut du = Array::zeros(u.raw_dim());
	                self.dudt(du.view_mut(), u.view(), t, p);
	                self.dudt(df.view_mut(), u.view(), t, p);
	                let dt = f64::EPSILON * t.max(1e-5);
	                df.assign(&((&df - &du) / dt));
	            }
	        }
	    }
	}
4eede53ae46cd06046f40dc577af3fc7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|3|1|V|rust
	pub mod function;
83280c61779839cb438792a5d4a5199b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|6|1|V|rust
	pub mod problem;
1c57aa12fa0d0fba142b147b1ff47930|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|11|1|V|rust
	pub use function::*;
4097e8a5523d46b7e63b6b4834df5f4c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|14|1|V|rust
	pub use problem::*;
821fbf59cdc1e9624f887976d2df3c16|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|164|1|V|rust
	    pub fn default(
	        dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
	        uinit: Array1<f64>,
	        tspan: (f64, f64),
	        alg: Alg,
	        params: Params,
	    ) -> OdeIntegratorBuilder<'a, Params, Alg> {
	        OdeIntegratorBuilder {
	            dudt,
	            dfdt: None,
	            dfdu: None,
	            params,
	            u: uinit.clone(),
	            t: tspan.0,
	            dt: -1.0,
	            tfinal: tspan.1,
	            opts: Alg::default_opts(),
	            alg,
	        }
	    }
4065ed5e724922c40487fa992d9b4ab8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|164|1|V|rust
	    pub fn default(
	        dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        uinit: Array1<f64>,
	        tspan: (f64, f64),
	        alg: Alg,
	    ) -> OdeIntegratorBuilder<'a, (), Alg> {
	        let func = move |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, _p: &()| {
	            dudt(du.view_mut(), u.view(), t)
	        };
	        OdeIntegratorBuilder {
	            dudt: &func,
	            dfdt: None,
	            dfdu: None,
	            params: (),
	            u: uinit.clone(),
	            t: tspan.0,
	            dt: -1.0,
	            tfinal: tspan.1,
	            opts: Alg::default_opts(),
	            alg,
	        }
	    }
1c3dc242b1e1b7f0c8bfac2537e2ccf1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|35|9|V|rust
	        /    println!("{}, {}", t, u);
	        /    let dx = u[0] - t.sin();
dbe388f5c3dc55ab6da8636d37fa5dd4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|32|9|V|rust
	        let sol = integrator.integrate();
a99666f8517ef4287c6dd827520d64fd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|19|9|V|rust
	        struct HO;
21a1b60911b5bb2496522775c17e6a3f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|18|8|v|rust
	test_ho
c54490d3480079138c8c027a87a366e3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|178|17|v|rust
	-1.0
78e77c176382bb46141087f5e4626bbd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/lib.rs|2|1|V|rust
	pub mod integrator;
7de4dae0b2a264622b682aaf49075f9f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|29|5|V|rust
	        //let prob = OdeProblem::new(HO, uinit.clone(), tspan);
dfeb10c4bfc9e9aada4db8e515c759dd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|38|1|V|rust
	        //let prob = OdeProblem::new(func, uinit.clone(), tspan);
500108dbbbf134dcd65836544a132e0f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|85|1|V|rust
	// Consuming iterator
	
	pub struct OdeIntegratorIterator<'a, Params, Alg: OdeAlgorithm> {
	    pub integrator: OdeIntegrator<'a, Params, Alg>,
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> IntoIterator for OdeIntegrator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	    type IntoIter = OdeIntegratorIterator<'a, Params, Alg>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeIntegratorIterator { integrator: self }
	    }
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> Iterator for OdeIntegratorIterator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	
	    fn next(&mut self) -> Option<(f64, Array1<f64>)> {
	        let res = self.integrator.step();
	        match res {
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
	            None => None,
	        }
	    }
	}
	
	// Non-consuming iterator
	
	pub struct OdeIntegratorMutIterator<'a, Params, Alg: OdeAlgorithm> {
	    pub integrator: &'a mut OdeIntegrator<'a, Params, Alg>,
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> IntoIterator for &'a mut OdeIntegrator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	    type IntoIter = OdeIntegratorMutIterator<'a, Params, Alg>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeIntegratorMutIterator { integrator: self }
	    }
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> Iterator for OdeIntegratorMutIterator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	
	    fn next(&mut self) -> Option<(f64, Array1<f64>)> {
	        let res = (*self).integrator.step();
	        match res {
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
	            None => None,
	        }
	    }
	}
6e85a90538dca609f0c77eb0ca0e494f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|68|1|V|rust
	impl<'a, Params, Alg: OdeAlgorithm> OdeIntegrator<'a, Params, Alg> {
	    /// Step the ODE to the next state. Returns solution if finished and
	    /// None otherwise.
	    pub fn step(&mut self) -> Option<usize> {
	        Alg::step(self);
	        if self.sol.retcode == super::code::OdeRetCode::Continue {
	            Some(self.stats.steps)
	        } else {
	            None
	        }
	    }
	    /// Solve the ODE
	    pub fn integrate(&mut self) {
	        while let Some(_i) = self.step() {}
	    }
	}
8dbf41938d168642ebca7a95cb1315d8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|245|1|V|rust
	// Consuming iterator
09778ad38dc4d223eea18fc9292d9add|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|267|1|V|rust
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
d4f04c3af3f9f5389598c4d404d16876|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|245|1|V|rust
	/// Consuming iterator for OdeIntegrator.
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in integrator {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
8e15693d4f96f17c397443f0dfe5c26d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|284|40|V|rust
	/// Non-consuming, mutable iterator for OdeIntegrator.
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let mut integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in (&mut integrator).into_iter() {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
b3c63b69edc27a0344f218dacebcaf35|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|245|1|V|rust
	/// Consuming iterator for OdeIntegrator.
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in integrator.into_iter() {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
	pub struct OdeIntegratorIterator<'a, Params, Alg: OdeAlgorithm> {
	    pub integrator: OdeIntegrator<'a, Params, Alg>,
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> IntoIterator for OdeIntegrator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	    type IntoIter = OdeIntegratorIterator<'a, Params, Alg>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeIntegratorIterator { integrator: self }
	    }
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> Iterator for OdeIntegratorIterator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	
	    fn next(&mut self) -> Option<(f64, Array1<f64>)> {
	        let res = self.integrator.step();
	        match res {
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
	            None => None,
	        }
	    }
	}
	
	/// Non-consuming, mutable iterator for OdeIntegrator.
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let mut integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in (&mut integrator).into_iter() {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
	pub struct OdeIntegratorMutIterator<'a, Params, Alg: OdeAlgorithm> {
	    pub integrator: &'a mut OdeIntegrator<'a, Params, Alg>,
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> IntoIterator for &'a mut OdeIntegrator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	    type IntoIter = OdeIntegratorMutIterator<'a, Params, Alg>;
	
	    fn into_iter(self) -> Self::IntoIter {
	        OdeIntegratorMutIterator { integrator: self }
	    }
	}
	
	impl<'a, Params, Alg: OdeAlgorithm> Iterator for OdeIntegratorMutIterator<'a, Params, Alg> {
	    type Item = (f64, Array1<f64>);
	
	    fn next(&mut self) -> Option<(f64, Array1<f64>)> {
	        let res = (*self).integrator.step();
	        match res {
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
	            None => None,
	        }
	    }
	}
96872eea65f454a78dc3bea3f7b7b952|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|1|V|rust
	/// Consuming iterator for OdeIntegrator.
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in integrator.into_iter() {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
30ba23d596a5058f614549f97127cd5b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|47|1|v|rust
	// Non-consuming, mutable iterator for OdeIntegrator.
20db95044423878039495a564e947648|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|47|1|V|rust
	j
	///
	/// # Examples
	/// ```
	/// struct HO(w: f64);
	/// let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64, p: &HO|{
	///     du[0] = u[1];
	///     du[1] = -p.w * u[0];
	/// }
	/// let uinit = array![0.0, 1.0];
	/// let tspan = (0.0, 1.0);
	/// let mut integrator = OdeIntegratorBuilder::default(
	///     &dudt,
	///     uinit,
	///     tspan,
	///     DormandPrince5,
	///     HO{w:1.0}
	/// ).reltol(1e-7)
	///     .abstol(1e-7)
	///     .build();
	/// // Iterate
	/// for (t, u) in (&mut integrator).into_iter() {
	///     assert!((u[0] - t.sin()).abs() < 1e-6);
	///     assert!((u[1] - t.cos()).abs() < 1e-6);
	/// }
	/// ```
64f9fe562204b4692d78a6f9c2e93270|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|12|v|rust
	OdeIntegratorIterator
ae24f3442fa0e9600968dc48cfc81f89|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|26|v|rust
	, Params, Alg: OdeAlgorithm
0a87da0cdf18194d15203eb088c00a6d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|23|v|rust
	<'a>
7dc43aca81621023e044d87b6ccd38fd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|23|21|v|rust
	OdeIntegrator
e3717d28856167a2a8f2c73f04b720a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|23|32|v|rust
	<'a, Params, Alg>
a77bf92d318c9f3e4c899ac4e4b8cff3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|26|5|v|rust
	<'a, Params, Alg: OdeAlgorithm>
cb7f0bf3b3e4931b51e74cefe1f96bd8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|12|v|rust
	OdeSolutionIterator
d18836c36760087d93a03a9a0c0e619a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|26|23|v|rust
	OdeSolutionIterator 
99b4d854136e293f43631d168e3925bd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|28|21|v|rust
	OdeIntegratorIterator<
44a99fd1dc683b7981ce719b420dc39b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|28|40|v|rust
	 'a, Params, Alg>
ef8c310b674f57ddd19cee887bba779a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|31|10|v|rust
	'a, Params, Alg>
268bb91dfa0342236f9c6d7bea04bfd3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|34|20|v|rust
	deIntegratorIterator
b070c7b5b5b0a6ec379f5bc03d9fc35f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|38|9|V|rust
	        let res = self.integrator.step();
d01b83c5b2a0b964527727b64e4f7fbc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|21|1|V|rust
	pub struct OdeSolutionIterator {
ca417f2e817ee3c4e4af9ccb9a7f8b5f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|9|v|rust
	sol: OdeSolution,
2a29178a57901ddb90f15e2026465103|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|25|38|v|rust
	Iterator
f7f3b36126155d5a6a588ab39e7da873|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|39|34|v|rust
	(f64, Array1<f64>)
0a520c8294413a8b174c24879f3d07f2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|41|13|V|rust
	            Some(_i) => Some((self.integrator.t, self.integrator.u.clone())),
635925e7b9421b10df0e20ea6940287e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|41|13|V|rust
	            None => None,
28bd4c136775bbb665af94cef7dc91cd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|40|9|V|rust
	        match res {
49b8434df753209f78520cc59e764569|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|44|15|v|rust
	Integrator
672645d2edee426d97bb0f66e1432af1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|45|5|V|rust
	    pub integrator: &'a mut OdeIntegrator<'a, Params, Alg>,
8e36768222fe071d89b13b8398b98e7a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|48|46|v|rust
	<'a, Params, Alg> 
7da02791382ae33a41e4146ab4a61031|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|50|21|v|rust
	OdeIntegratorMutIterator
60c077aa1030a43cbad3eee1fadf2fc7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|50|46|v|rust
	, Params, Alg
1488524022e4fb012c0f03913012c4e0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|53|47|v|rust
	iter()
84f60ecd6401886492d3dc0c5fc6c127|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|63|9|V|rust
	        let res = (*self).integrator.step();
3d2d8ef2e300228fbb6c56cc2f41fdbe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|31|1|V|rust
	            iter_t: self.ts.into_iter().zip(self.us.into_iter()),
30a08b1c0f3084748e069c303e49a0c2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|32|40|v|rust
	.zip(self.us.into_iter()),
83827b77a946736c35c96efe870a64a5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|1|V|rust
	    pub iter: std::vec::IntoIter<(f64, Array1<f64>)>,
6152f2d4f165c34370dee7987dceaf7a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|23|36|v|rust
	(f64, 
7c91c8d9127a1e6f866078a72fc74915|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|22|40|v|rust
	 Array1<f64>)
cfa6726a0c2c5c9f46e099125681f19e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|44|9|V|rust
	        (self.iter_t.next(), self.iter_u.next())
efde821df331438bcfa0b3cf1e508559|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|53|1|V|rust
	    iter: std::slice::Iter<'a, (f64, Array1<f64>)>,
23ce5ad9bc8d3ce11b8e588c0c999803|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|53|34|v|rust
	f64, Array1<f64>
60f33caca90e47b809f7ead9b0f16e8a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|53|37|v|rust
	, Array1<f64>
ba40eddef5b85eea2a3b15103807240f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|54|34|v|rust
	f64, 
6f4aa734fe0c12efc59add82ea1ae3a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|63|1|V|rust
	            iter: self.ts.iter().zip(self.us.iter()),
94475ffc506108fbb99a9b578df13fd3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|63|35|v|rust
	.zip(self.us.iter()),
48fc5206ef9d9c23c47ac6ce2ff3bc77|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|42|1|V|rust
	        let t = self.iter_t.next();
	        let u = self.iter_u.next();
	        if t.is_some() && u.is_some() {
	            Some((t.unwrap(), u.unwrap()))
	        } else {
	            None
	        }
b30d55de620181328e079eb0333dbfbc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|73|1|V|rust
	        self.iter.next()
4ea0e05db111625ce4180235cea4ab21|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/solution.rs|73|17|v|rust
	self.iter_t.next()
ad919fdbc4a568ea40d0341cc9b38644|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|48|23|v|rust
	integrator.sol.ts.iter().zip(integrator.sol.us.iter())
29751fc21a03bbd306e3ba9dcb903a35|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|44|9|V|rust
	        //for (t, u) in (&mut integrator).into_iter() {
c67ca355c9b390204d6394243050c440|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau.rs|44|9|V|rust
	        //    println!("{}, {}", t, u);
7d12bf6f2af6b019f72831deaef5eb4c|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|8|1|V|rust
	    fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
c649702c858ceb3c3e868489a91b49f2|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|79|9|V|rust
	        let prob = OdeProblem::new(self.clone(), uinit, tspan);
28515d0766c90ddf0ea585e1d2c58823|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|7|1|V|rust
	impl OdeFunction for KineticMixing {
	    fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
	}
e53cafedf728e4ea3437b5a6028aea5f|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|7|1|V|rust
	impl K
f8db5124bf8d2b1e40fed87fd9b449f7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|34|14|v|rust
	mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64
b9d1212fba1220369bcf93da2aee61fc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|75|1|V|rust
	            |mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64, p: &KineticMixing| {
	                let x: f64 = logx.exp();
	                let temp: f64 = p.mx / x;
	                let s: f64 = sm_entropy_density(temp);
	
	                let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	                let ww: f64 = w[0];
	
	                let pf: f64 =
	                    -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	                let sigmav: f64 = p.thermal_cross_section(x);
	
	                // dW_e / dlogx
	                dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	            };
ddd9309dd92d6eefc7b606cdd8f041af|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|76|1|V|rust
	                let x: f64 = logx.exp();
	                let temp: f64 = p.mx / x;
	                let s: f64 = sm_entropy_density(temp);
	
	                let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	                let ww: f64 = w[0];
	
	                let pf: f64 =
	                    -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	                let sigmav: f64 = p.thermal_cross_section(x);
	
	                // dW_e / dlogx
	                dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
90116abc2b48cb1db035b21195b32182|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|80|1|V|rust
	                let x: f64 = logx.exp();
	                let temp: f64 = p.mx / x;
	                let s: f64 = sm_entropy_density(temp);
	
	                let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	                let ww: f64 = w[0];
	
	                let pf: f64 =
	                    -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	                let sigmav: f64 = p.thermal_cross_section(x);
	
	                // dW_e / dlogx
	                dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
f42de2dfcb678dbafae614016b70633a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|76|1|V|rust
	                p.dudt(dw.view_mut(), w.view(), logx, p)
5b2f383069e9532b6841e588fec4a032|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|7|1|V|rust
	impl OdeFunction for KineticMixing { fn dudt(&mut self, mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    }
	    fn dfdu(&mut self, mut dw: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64) {
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    }
	}
99c15044ee3be08437e53996d89536b5|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|15|1|V|rust
	//fn neq_scaled(x: f64, spin2: usize) -> f64 {
	//    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	//    let integrand = |z: f64| z * (z * z - x * x).sqrt() / (z.exp() - eta);
	//    (*GK).integrate(integrand, x, f64::INFINITY).val / (2.0 * PI * PI)
	//}
	//
	//fn energy_density_scaled(x: f64, spin2: usize) -> f64 {
	//    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	//    let integrand = |z: f64| z * z * (z * z - x * x).sqrt() / (z.exp() - eta);
	//    (*GK).integrate(integrand, x, f64::INFINITY).val / (2.0 * PI * PI)
	//}
	//
	//fn pressure_density_scaled(x: f64, spin2: usize) -> f64 {
	//    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	//    let integrand = |z: f64| (z * z - x * x).powf(1.5) / (z.exp() - eta);
	//    (*GK).integrate(integrand, x, f64::INFINITY).val / (6.0 * PI * PI)
	//}
	//
	//fn entropy_density_scaled(x: f64, spin2: usize) -> f64 {
	//    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	//    let integrand = |z: f64| (4.0 * z * z - x * x) * (z * z - x * x).sqrt() / (z.exp() - eta);
	//    (*GK).integrate(integrand, x, f64::INFINITY).val / (6.0 * PI * PI)
	//}
9bafbe6a55eff6cf19d9548e67f79556|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|2|V|rust
	    let integrand = |z: f64| z * (z * z - x * x).sqrt() / (z.exp() - eta);
fbc4803f3df40228a06c98d5925b24a6|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|5|V|rust
	    (*GK).integrate(integrand, x, f64::INFINITY).val / (2.0 * PI * PI)
01f8cf1e5ff5e37b41cca78526df1e76|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|3|1|V|rust
	use 
669e8e78bbe5c62f6c13749b8f3d9751|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|43|5|V|rust
	    for n in 1..=5{
36aad33e0fa3eb4594fa12c2fb546c0d|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|5|V|rust
	    let res = 0.0;
437812b8bd812c2d8ff7d0a0dcf44f94|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|57|v|rust
	as f64
33fe40ffa0b1a8bd70381718ccdda65e|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|35|v|rust
	: i32
5511f5fe83746612434b54a0eaa1bc31|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|42|1|V|rust
	    (1..=5).fold(0.0, |acc: f64, n| {
	        acc + eta.powi(n as i32) / (1 + n) as f64 * ((1 + n) as f64 * x).cyl_bessel_kn(2)
	    }) * x
	        * x
	        / (2.0 * std::f64::consts::PI)
a3bbe64f090f3eb66212e76cbc63c5c0|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|1|V|rust
	    let integrand = |z: f64| z * z * (z * z - x * x).sqrt() / (z.exp() - eta);
	    (*GK).integrate(integrand, x, f64::INFINITY).val / (2.0 * PI * PI)
ce971a87f252809b5ea16605864e0a7f|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|52|43|v|rust
	.powi(2)
4faccc5f00006a7b265e659f7cf58e04|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|5|V|rust
	    (1..=5).fold(0.0, |acc: f64, n|
d44e888398a321892020bbb1fc6bcc9b|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|9|V|rust
	        acc + eta.powi(n as i32) / ((1 + n) as f64).powi(2) * (((1 + n) as f64 * x).cyl_bessel_kn(2))
08c2c64d9e96658e797afffe3ae2158f|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|5|V|rust
	    }) * x
0901317dd9ef0ece91eabfec0ca08404|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|9|V|rust
	        * x
f62a485c17565b0eadf31138a04ae3a0|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|51|9|V|rust
	        / (2.0 * std::f64::consts::PI)
6f888aa27a4b9572751c28bc59ba7b92|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|54|30|v|rust
	(1 + n)
e38eab471c5e22a972742d05c213ebac|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|54|45|v|rust
	(1+n)
4af236d0990b7475ceee91610e64e5d3|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|54|52|v|rust
	(1+n) 
6b9bd7b4bb402a479dae42029f60dda0|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|58|1|v|rust
	/ (2.0 *
19f6e6899b1b94ab68681dc4ebfc12b7|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|52|1|V|rust
	    for n in 1..=5 {
	        let np1 = (n + 1) as f64;
	        res += eta.powi(n) / np1.powi(2)
	            * (np1 * x * (np1 * x).cyl_bessel_k1() + 3.0 * (np1 * x).cyl_bessel_kn(2));
	    }
	    res * x * x / (2.0 * std::f64::consts::PI)
2c8cd5dae0c5baf387f24285c5005c38|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|46|15|v|rust
	np1 * x * (np1 * x).cyl_bessel_k1() + 3.0 * (np1 * x).cyl_bessel_kn(2)
1b009cbc517ee9370d9ab17a1373bacf|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|46|51|v|rust
	+ 3.0 * (np1 * x).cyl_bessel_kn(2);
f60e2e567a893edeb9cfb844689ed6cd|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|45|44|v|rust
	np1 * x *
602c2aa28d160072f5c57bd16b01a622|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|40|1|V|rust
	fn neq_scaled(x: f64, spin2: usize) -> f64 {
	    let eta: f64 = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	    let res = 0.0;
	    for n in 0..=5 {
	        let np1 = (n + 1) as f64;
	        res += eta.powi(n) / np1.powi(2) * (np1 * x).cyl_bessel_kn(2);
	    }
	    res * x * x / (2.0 * std::f64::consts::PI)
	}
	
	fn energy_density_scaled(x: f64, spin2: usize) -> f64 {
	    let eta: f64 = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	    let res = 0.0;
	    for n in 0..=5 {
	        let np1 = (n + 1) as f64;
	        res += eta.powi(n) / np1.powi(2)
	            * (np1 * x * (np1 * x).cyl_bessel_k1() + 3.0 * (np1 * x).cyl_bessel_kn(2));
	    }
	    res * x * x / (2.0 * std::f64::consts::PI)
	}
41095b454c326e599b92457b99350de7|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/thermal_functions.rs|40|1|V|rust
	fn pressure_density_scaled(x: f64, spin2: usize) -> f64 {
	    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	    let integrand = |z: f64| (z * z - x * x).powf(1.5) / (z.exp() - eta);
	    (*GK).integrate(integrand, x, f64::INFINITY).val / (6.0 * PI * PI)
	}
	
	fn entropy_density_scaled(x: f64, spin2: usize) -> f64 {
	    let eta = if spin2 % 2 == 0 { 1.0 } else { -1.0 };
	    let integrand = |z: f64| (4.0 * z * z - x * x) * (z * z - x * x).sqrt() / (z.exp() - eta);
	    (*GK).integrate(integrand, x, f64::INFINITY).val / (6.0 * PI * PI)
	}
7448b26a80178109f31190b269624121|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|14|25|v|rust
	neq(temp, self.mx, 2.0, 1)
b500e4b5e0314b4bbec6af8a20a80261|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|15|1|V|rust
	        let n = 2.0 * temp.powi(3) / (2.0 * PI * PI) * x * x * x.cyl_bessel_kn(2);
	        let weq: f64 = (n / s).ln();
ee5fb52ffd94dfbe5e2b8e7c5ad15f6a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|33|8|V|rust
	        let weq: f64 = (neq(temp, self.mx, 2.0, 1) / s).ln();
583e1892e77b8cfb3964ffcde8e5edd1|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|14|1|V|rust
	        //let n = neq(temp, self.mx, 2.0, 1);
82d91c8e47ce65a8dc5bfcfedb2e062e|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|30|1|V|rust
	        //let n = neq(temp, self.mx, 2.0, 1);
	        let n = 2.0 * temp.powi(3) / (2.0 * PI * PI) * x * x * x.cyl_bessel_kn(2);
b41f303945375576e1c2507b79b7c5d3|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|8|1|V|rust
	use std::time::{Duration, Instant};
e52d4b2239e9d1d53bf7b07d2db0f9b5|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|106|9|V|rust
	        let 
e300f5e2e480acc6927171c6602fb4de|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|106|1|V|rust
	        println!("{}, {}", km.relic_density(), now.elapsed().as_secs());
c6478cde62b8578298fc3f502ff3afdb|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|108|1|V|rust
	        println!("{}", km.relic_density());use std::time::{Duration, Instant};
9d27a80487427d5ca9ced5f51bf8b3ef|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|110|1|V|rust
	        println!("{}", km.relic_density());
78dcecc0e263b9f856c319f487e04f29|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|104|1|V|rust
	        let now = Instant::now();
fa6e863b04cbb53e13ce948f05ef2c09|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|106|62|v|rust
	as_secs(
bc26bebbc66b225b981d996df9a90614|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|106|61|v|rust
	.as_millis()
fbb4e2fc9ad67db3d9fd9986339173db|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|110|61|v|rust
	.as_secs()
c671d78155eb050e9efd52a472a4251a|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|46|9|V|rust
	        //let n = 2.0 * temp.powi(3) / (2.0 * PI * PI) * x0 * x0 * x0.cyl_bessel_kn(2);
d2924cb6d22210217a893df86cc96694|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|31|9|V|rust
	        let n = 2.0 * temp.powi(3) / (2.0 * PI * PI) * x * x * x.cyl_bessel_kn(2);
abf022bf2f367bc27d3dd5c5a835c593|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|5|18|v|rust
	value of the
a6888f06050deac81c4c36469778e5c4|file:///Users/loganmorrison/Documents/coding/rust/autodiff/src/dual.rs|10|1|V|rust
	impl<T: Float> std::ops::Neg for Dual<T> {
	    fn neg(self) -> Self {
	        Dual {
	            val: -self.val,
	            eps: -self.eps,
	        }
	    }
	}
	
	impl<T: Float> std::cmp::PartialEq for Dual<T> {
	    fn eq(self, other: Dual<T>) -> bool {
	        return self.val == other.val;
	    }
	}
	
	impl std::cmp::PartialEq<f64> for Dual<f64> {
	    fn eq(self, other: f64) -> bool {
	        return self.val == other;
	    }
	}
	
	impl std::cmp::PartialEq<f32> for Dual<f32> {
	    fn eq(self, other: f32) -> bool {
	        return self.val == other;
	    }
	}
	
	impl std::cmp::PartialEq<i32> for Dual<f64> {
	    fn eq(self, other: i32) -> bool {
	        return self.val == f64::from(other);
	    }
	}
	
	impl<T: Float> std::cmp::PartialOrd for Dual<T> {
	    fn partial_cmp(&self, other: &Dual<T>) -> Option<std::cmp::Ordering> {
	        return self.val.partial_cmp(&other.val);
	    }
	}
	
	impl std::cmp::PartialOrd<f64> for Dual<f64> {
	    fn partial_cmp(&self, other: &f64) -> Option<std::cmp::Ordering> {
	        return self.val.partial_cmp(&other);
	    }
	}
	
	impl std::cmp::PartialOrd<f32> for Dual<f32> {
	    fn partial_cmp(&self, other: &f32) -> Option<std::cmp::Ordering> {
	        return self.val.partial_cmp(&other);
	    }
	}
ea68a623dc82cf98cdd1bc81baa4029d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|16|1|V|rust
	impl<T: Float> Float for Dual<T> {}
7a1e02de026fb5eb0999e3904ca4b102|file:///Users/loganmorrison/Documents/coding/rust/autodiff/src/dual.rs|63|1|v|rust
	impl<T: Float> Float for Dual<T> {
aec8815e9ff71cc6f015b7ceb878d0f2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|9|18|v|rust
	: Float
0c0a82694a9248e9db9fcb57453a5fd1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|8|1|V|rust
	#[derive(Clone, Copy, Debug)]
4d1aace07a2bd50cf31f944c3550e3a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|5|1|V|rust
	use num::Float;
e84d0b302344ac9b18b9d954ec7eaa3c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|9|1|V|rust
	            val: self.val + other.val,
a1392911eb2d2bea6d149d3d839f8b46|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|4|1|V|rust
	impl<T: Add<Output = T>> Add for Dual<T> {
	    type Output = Self;
	
	    fn add(self, other: Self) -> Self {
	        Self {
	            val: self.val + other.val,
	            eps: self.eps + other.eps,
	        }
	    }
	}
db8dc3c1a9a29001a97f4f12d0c7a706|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|15|1|V|rust
	impl<T: Sub<Output = T>> Sub for Dual<T> {
	    type Output = Self;
	
	    fn sub(self, other: Self) -> Self {
	        Self {
	            val: self.val - other.val,
	            eps: self.eps - other.eps,
	        }
	    }
	}
c15bad78c5356a6149f6f7bac570c306|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|32|27|v|rust
	- other.eps
f59ceb244d72d4a2e57a49dca47a4d57|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|26|1|V|rust
	impl<T: Mul<Output = T> + Add<Output = T>> Mul for Dual<T> {
	    type Output = Self;
	
	    fn mul(self, other: Self) -> Self {
	        Self {
	            val: self.val * other.val,
	            eps: self.eps * other.val + self.val * other.eps,
	        }
	    }
	}
7d620513df77ce3b4823153316e587dd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|37|25|v|rust
	+ Mul<Output = T>
426191ca3b62db62a7efc4fba89897ce|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|37|7|v|rust
	: Div<Output = T> + Mul<Output = T> + Sub<Output = T>
360fb9e5a59a04c6f8158866f3cec852|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|2|16|v|rust
	NumOps
bbfe82d4f6730cf1cc7a55a291c53d2b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|4|1|V|rust
	impl<T: One + Zero> One for Dual<T> {
	    fn one(self) -> Self {
	        Self {
	            val: T::one(),
	            eps: T::zero(),
	        }
	    }
	}
f84a2ce535a71c3ca1732d8c4966a796|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|4|9|v|rust
	One 
121bfe437848276172e2e9a6b11e0687|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|37|1|V|rust
	impl<T> Div for Dual<T>
	where
	    T: Div<Output = T> + Mul<Output = T> + Sub<Output = T>,
	{
	    type Output = Self;
	
	    fn div(self, other: Self) -> Self {
	        Self {
	            val: self.val / other.val,
	            eps: (self.eps * other.val - self.val * other.eps) / (other.val * other.val),
	        }
	    }
	}
762b5a9b7ce12fedfec712c17fa9bf68|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|8|v|rust
	Div<Output = T> + Mul<Output = T> + Sub<Output = T>,
0aee6fdbfac5387727e5091eeacea8e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|5|V|rust
	    T: Rem,
ce15c1f934ea148be03b2a460a556e24|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|56|18|v|rust
	self.val / other.val,
2a318b341c8c72eee2037125fadea5ba|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|57|18|v|rust
	(self.eps * other.val - self.val * other.eps) / (other.val * other.val),
8cd043ef3b50ffd74ec8f01878af3eeb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|51|7|v|rust
	: Rem<Output = T> + Sub<O
878f10b0981ddffc90dd8fbfdb4af81f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|60|v|rust
	+ Mul<Output = T> + Sub<Output = T>,
3ed95e34ebbcc81078825412b931899a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|5|V|rust
	    T: Rem<Output = T> + Sub<Output = T> + Div<Output = T>,
4ecba62c8a5387f6095e70321239f227|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|52|1|V|rust
	impl<T: Float> Rem for Dual<T> {
	    type Output = Self;
	
	    fn rem(self, other: Self) -> Self {
	        Self {
	            val: self.val.rem(other.val),
	            eps: self.eps - other.eps * (self.val / other.val).trunc(),
	        }
	    }
	}
22ae0e2b89e5e3d477f988cc36d3272b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|9|v|rust
	Float
10b4eb76294b70d7fd6df997ff06edb1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|9|v|rust
	Complex
e5efc2fde8b165156e4bfb83d49cfa81|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|1|V|rust
	impl<T: Float> Rem for Dual<Complex<T>> {
357c36d1a237b8becd8817a3ec4f93b7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|5|V|rust
	    type Output = Self;
9926c199ea39e597b0b3ada57f900bfe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|5|V|rust
	    fn rem(self, other: Self) -> Self {
199e4dc87b547a05d43eb8f3e4f2cba9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|9|V|rust
	        Self {
ec7ee41c5798747d11e9951867c8e758|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|13|V|rust
	            val: self.val.rem(other.val),
5ec94aad59d78b78aba449c0a377863a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|63|13|V|rust
	            eps: self.eps - other.eps * (self.val / other.val).trunc(),
cd842bd280cb977b709c0790823cece5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|30|13|V|rust
	            val: T::from(n),
988d014d55f90908b1a32f19f12e38fe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|30|13|V|rust
	            eps: T::zero(),
bf6631959bcdaa672a8f57a3d5b4296b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|24|1|V|rust
	    fn to_i64(&self) -> Option<i64>{
	        self.val.to_i64()
	    }
fa17aaba6cb427b81d9a6809b56e878e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|2|10|v|rust
	float::FpCategory;
39f0e5eb1610c8f5812a4a7204e4d275|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_cmp.rs|5|1|V|rust
	impl<T: Neg> std::ops::Neg for Dual<T> {
	    fn neg(self) -> Self {
	        Dual {
	            val: -self.val,
	            eps: -self.eps,
	        }
	    }
	}
3b30b92742eeff34a10d97353dff257d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|2|1|V|rust
	use num::{Complex, Float};
a2d6e530b8ec4205b31f65aa7b4e122b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|5|14|v|rust
	std::ops::
00c0b5b8a46b62d14cf41ce8e6f04356|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_cmp.rs|3|1|V|rust
	use std::ops::Neg;
6e49deaa87012335542208869d9ef9a9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_cmp.rs|5|16|v|rust
	std::cmp::
fe0c817d0d8dea0eca2d76a8956aa798|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|62|7|v|rust
	: !Float
02d9b0cada58338dbfd8a6ca0d5dc3a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|62|10|V|rust
	impl<T> Rem for Dual<T> {
	    type Output = Self;
	
	    fn rem(self, other: Self) -> Self {
	        Self {
	            val: self.val.rem(other.val),
	            eps: self.eps - other.eps * (self.val / other.val).trunc(),
	        }
	    }
	}
68ed4b3951329e83716198803919a060|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|5|7|v|rust
	: Neg<Output = T>
d5f26db94e29355c2ae961d59fb69b74|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|14|7|v|rust
	: Add<Output = T>
13e11fd0260327c22c6b4f58fc5e7199|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|25|7|v|rust
	: Sub<Output = T>
b68f662be95d9c43cbbfb06f5f33a747|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|36|7|v|rust
	: Mul<Output = T
30c23d16d26728f0f4771375f92b99e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|36|7|v|rust
	> + Add<Output = T>
5464146860774706b1f4abecc4d8c8c8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|49|5|V|rust
	    T: Div<Output = T> + Mul<Output = T> + Sub<Output = T>,
fcbf6c9dd8077278231c169d3e7e6f8f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|14|9|v|rust
	One + Zero
d7ed4ee1df437474d005188535f74875|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|5|9|v|rust
	Zero
b1ad6b483678551b288a129d59e78e1c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|24|9|v|rust
	ToPrimitive
443db02f94ffcfdf778fdd5fdb5824eb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|33|9|v|rust
	NumCast + Zero
ddacd19296e83621ba24c2ad0ed3112d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|44|9|v|rust
	Num + Zero
2a9f1f5e9af49984910bbedbba5410af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|46|62|v|rust
	T::FromStrRadixErr
3429f293dde992b585ec61813af161df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|44|14|v|rust
	 + Num
b84b79c58a056f24ca1413f53510ca62|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_cmp.rs|5|25|v|rust
	Dual<T>
a52f336a703cb4a2b5af9daeaf12cecd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|10|23|v|rust
	T::zero()
bcdf20fbaa9330fd9c219f85dc6c41cd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|39|9|V|rust
	        let eps = T::zero();
23caf57c0c41c8ab5e287cc5fb1e28ab|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_num.rs|56|17|v|rust
	eps: T::zero(),
6dc421cbb047678f55a1f5ffc29b49f2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|19|1|V|rust
	        Self {
	            value: self.value + other.value,
	            partials: self
	                .partials
	                .iter()
	                .zip(other.partials.iter())
	                .map(|(x, y)| *x + *y)
	                .collect(),
	        }
76e499f82c42f153dcba0960de45726b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|35|1|V|rust
	        Self {
	            val: self.val - other.val,
	            eps: self.eps - other.eps,
	        }
6885a8b7e06ec0de0ac5ec72f0be4654|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|23|v|rust
	self.eps * other.val + self.val * other.eps
5ed1558ee3c8b7e76852dd56773b3c8d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|53|23|v|rust
	self
	                .partials
	                .iter()
	                .zip(other.partials.iter())
	                .map(|(x, y)| *y * self.value + *x * other.value)
	                .collect(),
78ffa11aa632745d5a97f364e501e494|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|73|49|v|rust
	*x * other.value
7309330afd8d71765b7a3a7739bf6d43|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|73|66|v|rust
	+ *x * other.value
c52d7606437367dcab8bead875e80d47|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|86|56|v|rust
	(self.value / other.value).trunc()
efa4782a4f6b4af9357c7dd8c987eed8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_ops.rs|86|23|v|rust
	self.partials - other.partials * ,
028f7c8948b110507ddafd408fd8dc83|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|12|9|v|rust
	partials
628f1e2b942d2de6beda62742baefc13|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|12|14|v|rust
	Vec<T>
10cfe62974611ca93933a4d1614f4e76|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|26|1|V|rust
	        assert!((x.sin().eps - x.val.cos()).abs() < 1e-12);
d6e6586153b997ce247720e281ff78a0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|22|9|v|rust
	let x = Dual {
	            val: 0f64,
	            eps: 1f64,
	        };
cee71e1e5e9cbb9405dcc338b767dfae|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual.rs|27|18|v|rust
	1f64
36e5a697214a622ac03e32c91be9d1ce|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1193|51|v|c
	pbadist_local
e63fb117b353c5430de3891f5fa4e6b3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1193|10|v|c
	background_parameters_for_distributions
8adb7f7dc4adf321c24c73d177e1c71c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1191|5|v|c
	background_ncdm_distribution
eb8d2ceb859eb4ae9ffad6684a78c217|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1852|5|v|c
	background_ncdm_momenta
2d79dfbb33d5ad004ab9bfb547e2562a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|59|20|v|dosini
	 * 0.5
93d6b79391cee93dd06bf27f9512d6b4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|59|1|v|dosini
	omega_cdm = 0.12038
df6c7c38d7fa8dbdbbc76d420c313dc5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|97|11|v|dosini
	ilenames = psd_FD_single.dat
2cf58c87d0918d7d513ef2d9c7abb15a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|123|8|v|dosini
	efault: set to 0.71611, which is slightly larger than the
86b2b2886fcb7ee4dd74e76521870798|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|161|1|v|c
	    class_call(array_interpolate_spline(
2263eb19773e7df84c4a57e23cf91c38|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|116|21|v|c
	    Output: vector (assumed to be already allocated)
1b1825b0b06156eddff661f0ffb9f18f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|116|1|V|c
	 * @param pvecback  
a184ffc1abed487b16719d29d87232e5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/background.h|262|45|v|cpp
	_table[index_tau] with values of \f$ \tau \f$ (conformal time) */
ad0d4ae7b6fb26b7d88f8db90de3777c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/background.h|196|44|v|cpp
	ctor */
a05806c6a41c877d6e17db79175ad9bc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/background.h|196|1|V|cpp
	  int index_bg_a;             /**< scale faj
0a5547a50b486847ecb811a5f33242c3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/background.h|220|44|v|cpp
	of first ncdm species (others contiguous) */
8fdf7aebedc5cad96290987e1fcb18d4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|728|8|v|c
	or (n_ncdm = 0; n_ncdm < pba->N_ncdm; n_ncdm++) {
0aedbf97a587a69b82c2dd3f88be4d2c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|738|46|v|c
	g[n_ncdm], pba->w_ncdm_bg[n_ncdm],
7af903dc6684973adeac32eaa697eb0b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1863|2|V|c
	    double *qvec, double *wvec, int qsize, double M, double factor, double z,
5094ba998b75fb4a2b047e7be0339b0a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1848|16|v|c
	    Input: quadrature weights
1ce1be4ee0da8ba708312755592bcf09|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1861|1|V|c
	// 0xFr43r4r3r
ec3b4aebec075608b489534ffcb3b497|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1861|1|V|c
	int background_ncdm_momenta2(
	    /* Only calculate for non-NULL pointers: */
	    double *qvec, double *wvec, int qsize, double M, double factor, double z,
	    double *n,
	    double *rho,     // density
	    double *p,       // pressure
	    double *drho_dM, // d rho / d M used in next function
	    double *pseudo_p // pseudo-p used in ncdm fluid approx
	) {
	
	  // int_a^b f(x) dx = sum_i w_i f(x_i)
	  int index_q;
	  double epsilon;
	  double q2;
	  double factor2;
	  /** Summary: */
	
	  /** - rescale normalization at given redshift */
	  factor2 = factor * pow(1 + z, 4);
	
	  /** - initialize quantities */
	  if (n != NULL)
	    *n = 0.;
	  if (rho != NULL)
	    *rho = 0.;
	  if (p != NULL)
	    *p = 0.;
	  if (drho_dM != NULL)
	    *drho_dM = 0.;
	  if (pseudo_p != NULL)
	    *pseudo_p = 0.;
	
	  /** - loop over momenta */
	  for (index_q = 0; index_q < qsize; index_q++) {
	
	    /* squared momentum */
	    q2 = qvec[index_q] * qvec[index_q];
	
	    /* energy */
	    epsilon = sqrt(q2 + M * M / (1. + z) / (1. + z));
	
	    /* integrand of the various quantities */
	    if (n != NULL)
	      *n += q2 * wvec[index_q];
	    if (rho != NULL)
	      *rho += q2 * epsilon * wvec[index_q];
	    if (p != NULL)
	      *p += q2 * q2 / 3. / epsilon * wvec[index_q];
	    if (drho_dM != NULL)
	      *drho_dM += q2 * M / (1. + z) / (1. + z) / epsilon * wvec[index_q];
	    if (pseudo_p != NULL)
	      *pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
	  }
	
	  /** - adjust normalization */
	  if (n != NULL)
	    *n *= factor2 / (1. + z);
	  if (rho != NULL)
	    *rho *= factor2;
	  if (p != NULL)
	    *p *= factor2;
	  if (drho_dM != NULL)
	    *drho_dM *= factor2;
	  if (pseudo_p != NULL)
	    *pseudo_p *= factor2;
	  // printf(" -> z, n, rho, p = %e, %e\n",z,*rho);
	  return _SUCCESS_;
	}
deb7bf21a7073c59ee4dc327ce0e87a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|102|1|V|c
	#include 
da0614766bfeb8b7e4e53684b593ced4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/background.h|13|1|V|cpp
	#include <gsl/gsl_integration.h>
ead4f920c72bf16b0f6d35bcfa5813fb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|33|1|v|c
	 * respect to time, that cannot be inferred analytically from
fb6dd5d34311a85f4cb9bdde20a26ef6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1195|13|v|c
	phase_space
d4f8eab6787fadf1d189929e739152d9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1193|8|v|c
	NcdmPsDistParams
503a0df1bdc23189f3ea30beb4f77b97|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1196|37|v|c
	ncdm_ps_dist_params)
d90ccffa01275a7a7795fb6d1274e75f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1213|9|v|c
	mass
d3e6eb879f1b36306b9d5912248662a6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1193|25|V|c
	struct NcdmPsDistParams{
		double temperature;
		double mass;
		double chemical_potential = 0.0;
	}
	
	/**
	 * Compute the value of the non-cold-dark-matter phase space distribution
	 * at a given momentum `q` given the distribution parameters `params`.
	 * Currently, this distribution is the Fermi-Dirac distribution. 
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_ps_dist(double q, void* params){
		struct NcdmPsDistParams *fp = (struct NcdmPsDistParams*)params;
		double cp = fp->chemical_potential;
		double temp = fp->temperature;
		double m = fp->mass;
		double eng = sqrt(q*q + m*m);
		return 1.0 / (exp((eng - cp) / temp) + 1.0);	
	}
7d47c13cda73159021f20fa354ddfdb6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1870|1|V|c
	/**
	 * Compute the value of the non-cold-dark-matter phase space distribution
	 * at a given momentum `q` given the distribution parameters `params`.
	 * Currently, this distribution is the Fermi-Dirac distribution. 
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_ps_dist(double q, void* params){
		struct NcdmPsDistParams *fp = (struct NcdmPsDistParams*)params;
		double cp = fp->chemical_potential;
		double temp = fp->temperature;
		double m = fp->mass;
		double eng = sqrt(q*q + m*m);
		return 1.0 / (exp((eng - cp) / temp) + 1.0);	
	}
05edc29350314ed3cae68e3a6d795b16|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1900|13|v|c
	ps_dist
31392ac0b0facb85badf631d914cbc09|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1891|1|V|c
	 * Compute the value of the non-cold-dark-matter phase space distribution
	 * at a given momentum `q` given the distribution parameters `params`.
	 * Currently, this distribution is the Fermi-Dirac distribution. 
373ab61ee24bd8012465060d79a113f0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|2|V|c
		struct NcdmPsDistParams *fp = (struct NcdmPsDistParams*)params;
1e5d82f16776c228a47ae91456cb9e7a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|2|V|c
		double cp = fp->chemical_potential;
bd6b48f2c73e347e712ef9c8852d0e11|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|2|V|c
		double temp = fp->temperature;
6d00e7e67d0a1e73d4685abcdf97538d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|2|V|c
		double m = fp->mass;
67f7e92435321f09518c785d379f7ef2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|2|V|c
		double eng = sqrt(q*q + m*m);
ae235442dc26f2e69f7ee3aebcd3cedd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1901|9|v|c
	1.0 / (exp((eng - cp) / temp) + 1.0);	
12bce785707e75296a6bb12e7941f237|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1890|1|V|c
	/**
	 * Returns the integrand of the NCDM number density integral, given by:
	 *	q^2 f(q)
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_number_density_integrand(double q, void* params){
		double fq = ncdm_ps_dist(q, params);
		return q * q * fq;
	}
b1bc248a7ff2b2e95569f56de68615df|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1905|38|v|c
	number
7934fb52db33ab3782b300248d1c47a8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1904|1|V|c
	/**
	 * Returns the integrand of the NCDM energy density integral, given by:
	 *	E(q) q^2 f(q) = sqrt(q^2 + m^2) q^2 f(q)
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_energy_density_integrand(double q, void* params){
		struct NcdmPsDistParams *fp = (struct NcdmPsDistParams*)params;
		double fq = ncdm_ps_dist(q, params);
		double m = fp->mass;
		double eng = sqrt(q*q + m*m);
		return eng * q * q * fq;
	}
05e7d19a6d002118deef70d21ff4226e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1922|38|v|c
	energy
d131be9f28f1cad7ca250cc0f64d10a4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1923|27|v|c
	= sqrt(q^2 + m^2) q^2 f(q)
6f53e40ecbbf5d33983045afb926f1c6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1936|15|v|c
	q * q * q * q
50d4f6bf41322a95284c29c072529872|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1936|9|v|c
	eng * 
0b545ec35450645b7c27d0b1e74922fd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1973|1|V|c
		gsl_integration_workspace *w = gsl_integration_workspace_alloc(1000);
b9b1aff3e8933d3cb01f13f16b20e5a5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1977|1|V|c
		// Alloc memory for GSL's integration routine. We may want to allocate
		// this elsewhere if it becomes too costly.
		gsl_integration_workspace *w = gsl_integration_workspace_alloc(1000);
a9b7ba70783b617e9998dc4dd82eb3c5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1985|65|v|c
	1000
34b9b7b501e4799c511c7f8e78e6147c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1995|32|v|c
	 .0,
0edf4bd84ee37fbb1bb7e7f7e7035d74|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1989|3|V|c
			doub
a117a813006e1b76072bf217c940af86|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1988|10|v|c
	nerr
19c85f15f3eadedadd36eac4c680e912|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1989|3|V|c
			*n = 0.0;
9e9b21f504488b33b89faa9992c6d003|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1988|1|V|c
			double error;
			double result;
			gsl_function F;
			F.function = &ncdm_number_density_integrand;
			F.params = &params;
b6504bd4a4ba84120f68114481d5ef85|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1991|1|V|c
		F.function = &ncdm_number_density_integrand;
339b49c0d5621f5fef78379c8cdf2622|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1993|1|V|c
		if n != NULL{
			// Set function to integrate:
			F.function = &ncdm_number_density_integrand;
			double lb = 0.0; // Lower bound of integration.
			// Perform integration:
			gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &result, &error);
			*n = result;
		}
5c80d4c5af32dbbe030e18c619fffa4e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2003|17|v|c
	ncdm_number_density_integrand
ed0d680e7d8859a49d33173f7bc4725e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2001|1|V|c
		if rho != NULL{
			// Set function to integrate:
			F.function = &ncdm_energy_density_integrand;
			double lb = 0.0; // Lower bound of integration.
			// Perform integration:
			gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &result, &error);
			*rho = result;
		}
d6a1113ea75abad5a6c23831dce2662b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2017|1|V|c
		if p != NULL
e860b10001a8695b94357b6e039cff86|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2019|17|v|c
	ncdm_energy_density_integrand
a4f9a3cc188914e9cf96b2eb4317f85b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1989|2|V|c
		double result;
2e030c3fa08386e6439930336c8d4067|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1990|18|v|c
	// Function struct needed by GSL to integrate a function
ca970703903976b0b913143d22f7cba4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1994|22|v|c
	// Parameters of the PS distribution needed to
2b0d081057ae134b44722c040a748cad|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2062|1|V|c
	      *drho_dM += q2 * M / (1. + z) / (1. + z) / epsilon * wvec[index_q];
24e55f55959a83f8d0153487139eaefb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1875|1|V|c
		double z = fp->z;
		double eng = sqrt(q*q + m*m / (1.0 + z) / (1.0 + z));
7f464ca33b3abced411ba53be308ae24|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2085|3|V|c
	  double 
67202c7f1a3452b78d4399ed78f94213|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2081|3|V|c
	  double factor2;
c781eb06d9717985091e90badfb52dc4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2089|3|V|c
	  double photon_temp = 2.39e-4 * (1.0 + z) * 1e-9; // Photon temp in GeV
dfd3b5848ab6731b889c4bf111003565|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2089|33|v|c
	1 + z
b75f0696c815635f696be0cea95fd91d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2110|33|v|c
	(1. + z) / (1. + z)
e121e41c0eb48e1f641c148d42aa0a2d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|240|1|V|c
	/**
	// * Structure for the non-cold-dark-matter phase space distribution.
	// */
f6504209d1a084f0393ea6f196b385ba|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1851|1|V|c
	///**
	// * Compute the value of the non-cold-dark-matter phase space distribution
eef438f7e448aa48c1f8db568d27b591|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1842|10|v|c
	temperature
962f2cddec79d77407bb782c4132c703|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1841|6|v|c
	Temperature of the NCDM
784218ba6268c8eb789eb623867d1c91|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1841|3|V|c
	  // Factor to rescale temperature
ce763aeb11cc0a792e17426a8a4dc091|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1841|3|V|c
	  double rescale;
f32da3d35179629ccb63d9f366235e1f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1864|3|V|c
	  double temp = fp->temperature;
c9181604c0a3cc18fe6431861e35aa1b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1867|37|v|c
	(1.0 + z) / (1.0 + z)
4cb62a661a0e772ed13ba86cd08d5b57|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1868|30|v|c
	) / temp
b928631bce97630aff08134c82f7b2db|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1868|10|v|c
	1.0 / (exp(eng - cp) + 1.0)
b8043a6f3851309e74b5f68d54679069|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1865|1|V|c
	  double z = fp->z;
	  double rescale = 1.0 + z;
fc220bde757f52bb2e9ce6cb3aff881e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1904|1|V|c
	/**
	 * Returns the integrand of the NCDM pressure density integral, given by:
	 *	(q^2 / 3E(q)) q^2 f(q)
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_pressure_density_integrand(double q, void *params) {
	  struct NcdmPsDistParams *fp = (struct NcdmPsDistParams *)params;
	  double fq = ncdm_ps_dist(q, params);
	  double m = fp->mass;
	  double z = fp->z;
	  double rescale = 1.0 + z;
	  double eng = sqrt(q * q + m * m / rescale / rescale);
	  double q4 = q * q * q * q;
	  return q4 / (3.0 * eng) * fq;
	}
efd15789d5ee5ecae16abb77845240e9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1925|38|v|c
	pressure 
b982e53a6e05e67d9e967e08cbf5aec9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1942|3|V|c
	  double q4 = q * q * q * q;
6bf0fe3f4afe0967b643d346d7ea9fad|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1942|40|v|c
	/ (3.0 * eng) 
2038e8cadc12484a3422b06541e0dc82|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1935|1|V|c
	//*drho_dM += q2 * M / (1. + z) / (1. + z) / epsilon * wvec[index_q];
f7037ad32a9c5f72d21c5b76ad24a9c5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1924|1|V|c
	/**
	 * Returns the integrand of the NCDM energy density derivative (w.r.t. m)
	 * integral, given by:
	 *	(q^2 / 3E(q)) q^2 f(q)
	 *
	 * @param q The magnitude of the three-momentum.
	 * @param params Parameters of the phase space distribution.
	 * @return Returns the value of f(q).
	 *
	 */
	double ncdm_pressure_density_integrand(double q, void *params) {
	  struct NcdmPsDistParams *fp = (struct NcdmPsDistParams *)params;
	  double fq = ncdm_ps_dist(q, params);
	  double m = fp->mass;
	  double z = fp->z;
	  double rescale = 1.0 + z;
	  double eng = sqrt(q * q + m * m / rescale / rescale);
	  return q * q * m / rescale / rescale * fq;
	}
d99fad96a5d0a7cb2eb41341ea556093|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1934|13|v|c
	pressure
5175d4e60466516256f996207b1ca2fa|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2088|1|V|c
	      *pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
a840422c3877a74b3f0031ec59de3728|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1962|32|v|c
	* m / rescale / rescale
fdf18c27778b246bac89e11c574beb52|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1955|1|V|c
	//*pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
4306e97cbf99daf283ffb92a62372ede|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1945|62|v|c
	derivative (w.r.t. m)
6a10630a35cb8456285acddc66953bd2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1946|4|v|c
	(q^2 / 3E(q)) q^2 f(q)
	
d936ae86733de8d4fada9d1d24f488f7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1946|4|v|c
	(q^2 / 3E(q)) q^2 f(q)
b5d1924e83b76d35e1887fa97cc9d093|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2038|1|V|c
	  if p
	    != NULL {
	      // Set function to integrate:
	      F.function = &ncdm_pressure_density_integrand;
	      double lb = 0.0; // Lower bound of integration.
	      // Perform integration:
	      gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &result, &error);
	      *p = result;
	    }
82b04457c2f3ba0c1f719616c03f8620|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2109|6|v|c
	drho_dM
313c1f4f45be19f3526883084596dee7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2050|21|v|c
	ncdm_pressure_density_integrand;
2536f742c8a8c7a7a25ba8d8df5b41a6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2049|7|V|c
	      // Set function to integrate:
7724b20a22b3dfc0f66c044179a575db|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2051|7|V|c
	      // Perform integration:
13d11d5fc74baa46696d1c89236f8100|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|1|V|c
	  if drho_dM
	    != NULL {
	      F.function = &ncdm_energy_density_deriv_integrand;
	      double lb = 0.0; // Lower bound of integration.
	      gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &result, &error);
	      *drho_dM = result;
	    }
ab1d7ed6e10328f18d0cc296fc219b72|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2054|21|v|c
	ncdm_energy_density_deriv_integrand;
490ff314b5dd3d8401204ddb8b94b5c9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2055|23|v|c
	 // Lower bound of integration.
2159052f71fc378ebe0d71d2c48a04fd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2048|24|v|c
	ll/ Lower bound of integration.
616d2001c692df0e32da32894dafaa62|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2041|24|v|c
	// Lower bound of integration.
443d0a2aedb78b072813087820bd3fc9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2033|22|v|c
	; // Lower bound of integration.
94897d489d441e675670574dfe87a2ff|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2058|1|V|c
	  // int_a^b f(x) dx = sum_i w_i f(x_i)
	  int index_q;
	  double epsilon;
	  double q2;
	  double factor2;
	  /** Summary: */
0468456129daf528f50e11d92bebb78f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2060|1|V|c
	  factor2 = factor * pow(1 + z, 4);
e0d60c906c8f9dce601ed190c6118cc7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1997|3|V|c
	  // Compute the photon temperature from the redshift:
1a5baf2bd61f856156fb7f6c5f7f50ea|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1997|3|V|c
	  double photon_temp = 0.0;
0d1dc16fa1e963ee8fabc38a9baba459|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1997|3|V|c
	  // Compute the NCDM temperature from the photon temperature:
8c6e2938e84342ba7d342a6a979332d8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1997|3|V|c
	  double ncdm_temp = 0.0;
3308ee9518ef47365c09851d09e3f5f9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1997|3|V|c
	  // Set the parameters
f52a9d91766886fb3a524dd06d1581cb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1845|6|v|c
	Redshift
1ef6d68de961c136aeda41d80eae98f6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1867|3|V|c
	  double z = fp->z;
77bf720fed6588c030ba1a7b00fe22f5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1867|20|v|c
	1.0 + z;
67416a90a596de76080fc99cb57cb479|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1867|1|V|c
	  double rescale = fp->rescale;
3b3281d39c8f441daa35fb6c140e46d5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2052|1|V|c
	  /** - rescale normalization at given redshift */
	  factor2 = factor * pow(1 + z, 4);
	
	  /** - initialize quantities */
	  if (n != NULL)
	    *n = 0.;
	  if (rho != NULL)
	    *rho = 0.;
	  if (p != NULL)
	    *p = 0.;
	  if (drho_dM != NULL)
	    *drho_dM = 0.;
	  if (pseudo_p != NULL)
	    *pseudo_p = 0.;
fae5faed7b7a546f8757d74d648311f0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2053|1|V|c
	  /** - loop over momenta */
	  for (index_q = 0; index_q < qsize; index_q++) {
	
	    /* squared momentum */
	    q2 = qvec[index_q] * qvec[index_q];
	
	    /* energy */
	    epsilon = sqrt(q2 + M * M / (1. + z) / (1. + z));
	
	    /* integrand of the various quantities */
	    if (n != NULL)
	      *n += q2 * wvec[index_q];
	    if (rho != NULL)
	      *rho += q2 * epsilon * wvec[index_q];
	    if (p != NULL)
	      *p += q2 * q2 / 3. / epsilon * wvec[index_q];
	    if (drho_dM != NULL)
	      *drho_dM += q2 * M / (1. + z) / (1. + z) / epsilon * wvec[index_q];
	    if (pseudo_p != NULL)
	      *pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
	  }
ad4dbbe9f6e3e5e0a59b4e60ee0a3d10|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2055|1|V|c
	  if (n != NULL)
	    *n *= factor2 / (1. + z);
3f324e52fef8438dfe0d324764327303|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2054|1|V|c
	  /** - adjust normalization */
	  if (rho != NULL)
	    *rho *= factor2;
63879ef8ffd559ea945e9b70ac83b909|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2054|1|V|c
	  if (p != NULL)
	    *p *= factor2;
4c35e8fd7038c8aecac8ca1b39283ce5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2054|1|V|c
	  if (drho_dM != NULL)
	    *drho_dM *= factor2;
	  if (pseudo_p != NULL)
	    *pseudo_p *= factor2;
	  // printf(" -> z, n, rho, p = %e, %e\n",z,*rho);
2d62595ecc8af301313f43b6c7bdf3e9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2049|36|v|c
	/ rescale
18b43fb72d097614d82c738c4f613a38|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|103|1|V|c
	/**************************** *
	 *
	 * 
	 *
	 *
	 */
e3d1f1fe7fccf364384bdcdfcbd27e23|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1851|29|v|c
	= 0.0;
8cc4894b7a884cc092450a1cada05100|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1999|37|v|c
	ncdm_temp
215af071008c10e72ac6c3143190e153|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1865|1|v|c
	double ncdm_ps_dist(double q, void *params) {
ccdd6ad14394cb821273b300206816d2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1865|1|V|c
	double ncdm_ps_dist(double q, void *params) {
	  struct NcdmPsDistParams *fp = (struct NcdmPsDistParams *)params;
	  double cp = fp->chemical_potential;
	  double m = fp->mass;
	  double rescale = fp->rescale;
	  double eng = sqrt(q * q + m * m / rescale / rescale);
	  return 1.0 / (exp(eng - cp) + 1.0) + 1.0 / (exp(eng + cp) + 1.0);
	}
abf2174e91d59beb27b4a4d162d94c42|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1995|1|V|c
	  double rescale = 1.0 + z;
	  double factor2 = factor * pow(rescale, 4);
	
	  // Set the parameters
	  struct NcdmPsDistParams params = {rescale, M, 0.0};
f0112342833ef5a4449a0523e56d409e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1845|1|V|c
	struct NcdmPsDistParams {
	  // Mass of the NCDM scaled by the temperature.
	  double mass;
	  // Factor to rescale temperature based on redshift
	  double rescale;
	  // Chemical potential of the NCDM scaled by the temperature (default is 0.0)
	  double chemical_potential;
	};
fdf3669dfbd2b869280bc29302e55a27|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1995|1|V|c
	  double rescale = 1.0 + z;
	  double factor2 = factor * pow(rescale, 4);
	
	  // Set the parameters
	  struct NcdmPsDistParams params = {rescale, M, 0.0};
	
	  // Parameters for integration:
	  double epsabs = 0.0;  // Absolute tolerance
	  double epsrel = 1e-5; // Relative tolerance
	  size_t limit = 1000;  // Number of refinements allowed by routine.
	
	  // Alloc memory for GSL's integration routine. We may want to allocate
	  // this elsewhere if it becomes too costly.
	  gsl_integration_workspace *w = gsl_integration_workspace_alloc(limit);
	
	  double result; // We will store integration results here
	  double error;  // We will store the estimate integration errors here
	  // Function struct needed by GSL to integrate a function. We will use
	  // this for all functions and just set the `function` parameter
	  // appropriately (see below)
	  gsl_function F;
	  // Parameters of the PS distribution needed to evaluate integrands.
	  F.params = &params;
ded70ff62b75139759e9b6c3acfcc027|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/README.md|161|1|V|vimwiki
	// Set the parameters
46426c477f7458984af404fda1acd536|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2021|1|V|c
	    F.function = &ncdm_number_density_integrand;
19e41a302f538f1bc2861fa4deff319a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2020|1|V|c
	    // Set function to integrate:
d5d608aca5815285038228cdb4195aa7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2022|1|V|c
	    double lb = 0.0; // Lower bound of integration.
f6a38cffcfa00371d98a09d255bb119d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2023|1|V|c
	    // Perform integration:
	    gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &result, &error);
	    // Set the result and rescale. Need extra factor of 1/rescale since
	    // n ~ T^3 and factor2 is for something that goes like T^4
	    *n = result * factor2 / rescale;
bd96a0fc6a17f88a3d33364dc2cbe829|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/README.md|125|1|v|vimwiki
	---------------------------------------------
36c6f0b2061da514c400c0bc2749b5cf|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/README.md|194|1|V|vimwiki
	
	
	
	
	
	
	
	
	
	
	
	
	
5ec6dc6be9a8f9063a8ba936bdc8e4bd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|119|14|v|dosini
	, 0.04, 0.04
af8fa73186d8f6f1c46bc0ceaf694f75|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1999|37|v|c
	rescale, 
6daa9ebb30359da4b402e042c47e6023|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|59|1|V|dosini
	#omega_cdm = 0.12038
04e1d1a26ea7631a8b0b919a3ce515ee|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|120|1|V|dosini
	omega_ncdm = 0.12
b26071acceae81ac2070eba6a2f302dc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|1|1|V|dosini
	*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
	*  CLASS input parameter file  *
	*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
	
	> This example of input file, intended for CLASS beginners, lists all
	> possibilities with detailed comments.  You can use a more concise version, in
	> which only the arguments in which you are interested would appear.  Only
	> lines containing an equal sign not preceded by a sharp sign "#" are
	> considered by the code. Hence, do not write an equal sign within a comment,
	> the whole line would be interpreted as relevant input. Input files must have
	> an extension ".ini".
	
	----------------------------
	----> background parameters:
	----------------------------
	
	1) Hubble parameter : either 'H0' in km/s/Mpc or 'h' or '100*theta_s' where the
	   latter is the peak scale parameter 100(ds_dec/da_dec) close to 1.042143
	   (default: 'h' set to 0.67556)
e97e45d787cbb9b1ad6c7d58f0c1bc33|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|5|1|V|dosini
	2) photon density: either 'T_cmb' in K or 'Omega_g' or 'omega_g' (default:
	   'T_cmb' set to 2.7255)
8834357f000619125ee6f76c8c38085b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|9|1|V|dosini
	3) baryon density: either 'Omega_b' or 'omega_b' (default: 'omega_b' set to
	   0.022032)
d6fdfd1f5a6448c4518e2187e322709a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|12|1|V|dosini
	4a) ultra-relativistic species / massless neutrino density: either 'N_ur' or
	   'Omega_ur' or 'omega_ur' (default: 'N_ur' set to 3.046) (note: instead of
	   'N_ur' you can pass equivalently 'N_eff', although this syntax is
	   deprecated) (one more remark: if you have respectively 1,2,3 massive neutrinos, if you stick to the default value T_ncdm equal to 0.71611, designed to give m/omega of 93.14 eV, and if you want to use N_ur to get N_eff equal to 3.046 in the early universe, then you should pass here respectively 2.0328,1.0196,0.00641)
aebbd8ce4855eaa8fc679cd2ace6d310|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|16|1|V|dosini
	4b) to simulate ultra-relativistic species with non-standard
	    properties, you can pass 'ceff2_ur' and 'cvis2_ur' (effective squared
	    sound speed and viscosity parameter, like in the Generalised Dark
	    Matter formalism of W. Hu) (default: both set to 1/3)
3b214e690ed0d3276f217907a9ef0a69|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|19|1|V|dosini
	5) density of cdm (cold dark matter): 'Omega_cdm' or 'omega_cdm' (default:
	   'omega_cdm' set to 0.12038)
034547d94a93b2dec0ef060184ccfcff|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|23|1|V|dosini
	5b) For models with decaying cold dark matter (dcdm) you can choose to pass either:
	
	5b1) the current fractional density of dcdm+dr (decaying cold dark
	    matter and its relativistic decay radiation): 'Omega_dcdmdr' or
	    'omega_dcdmdr' (default: 'Omega_dcdmdr' set to 0)
aff66417ee9d7300fcf20059ef672494|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|23|1|v|dosini
	5b) For models with decaying cold dark matter (dcdm) you can choose to pass either:
	
	5b1) the current fractional density of dcdm+dr (decaying cold dark
	    matter and its relativistic decay radiation): 'Omega_dcdmdr' or
	    'omega_dcdmdr' (default: 'Omega_dcdmdr' set to 0)
	
	
86c866bbb4a075d856c72d2d9497b178|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|26|1|V|dosini
	5b2) the rescaled initial value for dcdm density (see 1407.2418 for definitions). If you specify 5b1, 5b2 will be found autamtically by a shooting method, and vice versa. (default: 'Omega_dcdmdr' set to 0, hence so is 'Omega_ini_dcdm')
baa5d11aa0b9072fa04ef1f5a3b0b217|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|29|1|V|dosini
	5c) decay constant of dcdm in km/s/Mpc, same unit as H0 above.
d95f2976cad0488693b699784aeb7129|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|31|1|V|dosini
	6) all parameters describing the ncdm sector (i.e. any non-cold dark matter
	   relics, including massive neutrinos, warm dark matter, etc.):
	
	  -> 'N_ncdm' is the number of distinct species (default: set to 0)
5e13355b72cef63b20c5823ddcf1aee6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|33|1|V|dosini
	  -> 'use_ncdm_psd_files' is the list of N_ncdm numbers: 0 means 'phase-space
	     distribution (psd) passed analytically inside the code, in the mnodule
	     background.c, inside the function background_ncdm_distribution()'; 1 means
	     'psd passed as a file with at list two columns: first for q, second for
	     f_0(q)', where q is p/T_ncdm (default: only zeros)
e19184c7805d474bd68280eea21c0a24|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|34|1|V|dosini
	  -> if some of the previous values are equal to one, 'ncdm_psd_filenames' is
	     the list of names of psd files (as many as number of ones in previous entry)
	
ac45c150401ed6544fc770c9e730cfc1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|35|1|V|dosini
	  -> 'ncdm_psd_parameters' is an optional list of double parameters to describe
	     the analytic distribution function or to modify a p.s.d. passed as a file.
	     It is made available in the routine background_ncdm_distribution.
2b655410ab0592134cdc9e735bb40044|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|37|1|V|dosini
	
	The remaining parameters should be entered as a list of N_ncdm numbers
	separated by commas:
	
	  -> 'Omega_ncdm' or 'omega_ncdm' or 'm_ncdm' in eV (default: all set to zero);
	           with only one of these inputs, CLASS computes the correct value of
	           the mass; if both (Omega_ncdm, m_ncdm) or (omega_ncdm, m_ncdm) are
	           passed, CLASS will renormalise the psd in order to fulfill both
	           conditions.
	           Passing zero in the list of m_ncdm's or Omeg_ncdm's means that for
	           this component, this coefficient is not imposed, and its value is
	           inferred from the other one.
	
68a0f88b0f7b9198db1d23f2613bc4e8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|39|1|V|dosini
	  -> 'T_ncdm' is the ncdm temperature in units of photon temperature
	     (default: set to 0.71611, which is slightly larger than the
	     instantaneous decoupling value (4/11)^(1/3); indeed, this default
	     value is fudged to give a ratio m/omega equal to 93.14 eV for
	     active neutrinos, as predicted by precise studies of active
	     neutrino decoupling, see hep-ph/0506164)
3b7d13fcd54d750ce5c1f5780dab32a5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|40|1|V|dosini
	  -> 'ksi_ncdm' is the ncdm chemical potential in units of its own temperature
	     (default: set to 0)
04c1ca1571f134f04cc9682f2cf431ed|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|41|1|V|dosini
	  -> 'deg_ncdm' is the degeneracy parameter multiplying the psd: 1 stands for
	     'one family', i.e. one particle + anti-particle (default: set to 1.0)
	
edc86c45e797553d4bca85d00b596cf0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|42|1|V|dosini
	  -> 'Quadrature strategy' is the method used for the momentum sampling of the
	  ncdm distribution function. 0 is the automatic method, 1 is Gauss-Laguerre
	  quadrature, 2 is the trapezoidal rule on [0,Infinity] using the transformation
	  q->1/t-1. 3 is the trapezoidal rule on [0,q_max] where q_max is the next input.
	  (default: set to 0)
546b2de92634591275373add31d8ec22|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|45|1|V|dosini
	  -> 'Maximum q' is the maximum q relevant only for Quadrature strategy 3.
	  (default: set to 15)
c04cae24d2f617f59f025ffede8e0214|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|48|1|V|dosini
	7) curvature: 'Omega_k' (default: 'Omega_k' set to 0)
b710c19cd8a974e42f9e1d31531e45f4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|64|1|V|dosini
	8b) The flag 'use_ppf' is 'yes' by default, to use the PPF approximation
	    (see 0808.3125 [astro-ph]) allowing perturbations to cross the
	    phantom divide. Set to 'no' to enforce true fluid equations for
	    perturbations. When the PPF approximation is used, you can choose
	    the ratio 'c_gamma_over_c_fld' (eq. (16) in 0808.3125). The
	    default is 0.4 as recommended by that reference, and implicitely
	    assumed in other codes. (default: 'use_ppf' to yes, 'c_gamma_over_c_fld' to 0.4)
395b11966e70b04ccad7dbc619683628|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|66|1|V|dosini
	8c) Choose your equation of state between different models, 'CLP' for
f36a9decee26e48fc5d178f37d0ce39d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|66|1|V|dosini
	8c) Choose your equation of state between different models, 'CLP' for
	    p/rho = w0_fld + wa_fld (1-a/a0) (Chevalier-Linder-Polarski),
	    'EDE' for early Dark Energy (default:'fluid_equation_of_state' set to 'CLP')
dff6ecae8d5d6fd03beccfc5a6cbbdcd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|67|1|V|dosini
	8c1) equation of state of the fluid in 'CLP' case (p/rho = w0_fld +
	    wa_fld (1-a/a0)) and squared sound speed 'cs2_fld' of the fluid
	    (this is the sound speed defined in the frame comoving with the
	    fluid, i.e. obeying to the most sensible physical
	    definition). Generalizing w(a) to a more complicated expressions
	    would be easy, for that, have a look into source/background.c at
	    the function background_w_fld().  (default: 'w0_fld' set to -1,
	    'wa_fld' to 0, 'cs2_fls' to 1)
7bbc594abab50c26c2a0bce9acb279db|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|69|1|V|dosini
	
	8c2) equation of state of the fluid in 'EDE' case and squared sound speed 'cs2_fld' of the fluid
	    (this is the sound speed defined in the frame comoving with the
	    fluid, i.e. obeying to the most sensible physical
	    definition). Generalizing w(a) to a more complicated expressions
	    would be easy, for that, have a look into source/background.c at
	    the function background_w_fld().  (default: 'w0_fld' set to -1,
	    'Omega_EDE' to 0, 'cs2_fls' to 1)
2ab7a54fc717da46e9683233b8dcd57d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|73|1|V|dosini
	8d) Scalar field (scf) initial conditions from attractor solution (assuming
	    pure exponential potential). (default: yes)
e12e6fdb005229b84fd287737f0547dc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|74|1|V|dosini
	8e) Scalar field (scf) potential parameters and initial conditions.  V equals
	    ((\phi-B)^\alpha + A)exp(-lambda*phi), see
	    http://arxiv.org/abs/astro-ph/9908085.
cf43c2efd723f5abd5652e3e9d6a2868|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|76|1|V|dosini
	If 'attractor_ic_scf' is set to 'no', the last two entries are assumed to be
	the initial values of phi in units of the reduced planck mass m_Pl and the
	conformal time derivative of phi in units of [m_Pl/Mpc]. (Note however that
	CLASS determines the initial scale factor dynamically and the results might not
	be as expected in some models.)
	
	8f) Scalar field (scf) tuning parameter: If Omega_scf is negative, the
	    following index (0,1,2,...) in scf_parameters will be used for tuning:
	
dc8bb8611c36fa89004212e207be3820|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|77|1|V|dosini
	9) scale factor today 'a_today' (arbitrary and irrelevant for most purposes)
	   (default: set to 1)
	
0c93d3c0f97f4490c6543f340c482ae5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|81|1|V|dosini
	
	1) primordial Helium fraction 'YHe', e.g. 0.25; if set to 'BBN' or 'bbn', will
	   be inferred from Big Bang Nucleosynthesis (default: set to 'BBN')
6c0842c1611be8e6c7f29fb4c705a1e7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|83|1|V|dosini
	2) 'recombination' algorithm set to 'RECFAST' or 'HyRec'
4668fbb80362145a633ace50726e5133|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|84|1|V|dosini
	
	2) parametrization of reionization: 'reio_parametrization' must be one
	   of 'reio_none' (no reionization), 'reio_camb' (like CAMB: one
	   tanh() step for hydrogen reionization one for second helium
	   reionization), 'reio_bins_tanh' (binned history x_e(z) with tanh()
	   interpolation between input values), 'reio_half_tanh' (like
	   'reio_camb' excepted that we match the function xe(z) from
	   recombination with only half a tanh(z-z_reio)), 'reio_many_tanh'
	   (arbitrary number of tanh-like steps with specified ending values,
	   a scheme usually more useful than 'reio_bins_tanh'), 'reio_inter'
	   (linear interpolation between discrete values of xe(z))...  (default:
	   set to 'reio_camb')
aef2de607195f51fb4f0aa91d2e78e63|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|85|1|V|dosini
	
	3.a.) if 'reio_parametrization' set to 'reio_camb' or 'reio_half_tanh': enter
	      one of 'z_reio' or 'tau_reio' (default: 'z_reio' set to 11.357 to get tau_reio of 0.0925), plus
	      'reionization_exponent', 'reionization_width',
	      'helium_fullreio_redshift', 'helium_fullreio_width'
	      (default: set to 1.5, 0.5, 3.5, 0.5)
57b2e7c4fa3783e7744369d3c2024165|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|93|1|V|dosini
	
	3.b.) if 'reio_parametrization' set to 'reio_bins_tanh': enter number of bins
	      and list of z_i and xe_i defining the free electron density at the center
	      of each bin. Also enter a dimensionless paramater regulating the
	      sharpness of the tanh() steps, independently of the bin width;
	      recommended sharpness is 0.3, smaller values will make steps too sharp,
	      larger values will make the step very progressive but with discontinuity
	      of x_e(z) derivative around z_i values.
	      (default: set to 0, blank, blank, 0.3)
	
8cdc0e0fa1ee4430e8df797996079f71|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|97|1|V|dosini
	
	3.c.) if 'reio_parametrization' set to 'reio_many_tanh': enter number of jumps,
	      list of jump redhsifts z_i (central value of each tanh()), list of free electron density x_i after each jump, and common width of all jumps. If you want to end up with all hydrogen reionized but neglecting helium reionization, the first value of x_i in the list should be 1. For each x_i you can also pass the flags -1 or -2. They mean: for -1, after hydrogen + first helium recombination (so the code will substitute a value bigger than one based on Y_He); for -2, after hydrogen + second helium recombination (the code will substitute an even bigger value based on Y_He). You can get results close to reio_camb by setting  these parameters to the value showed below (and adapting the second many_tanh_z to the usual z_reio). (default: not set)
1a47be08ac63942d1b3ceeb36efba539|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|101|1|V|dosini
	
	3.d.) if 'reio_parametrization' set to 'reio_inter': enter the number
	of points, the list of redshifts z_i, and the list of free electron
	fraction values x_i. The code will do linear interpolation between
	them. The first z_i should always be 0. Like above, for each x_i, you
	can also pass the flags -1 or -2. They mean: for -1, after the
	hydrogen and the first helium recombination (so the code will
	substitute a value bigger than one based on Y_He); for -2, after the
	hydrogen and the second helium recombination (the code will substitute
	an even bigger value based on Y_He). The last value of x_i should
	always be zero, the code will substitute it with the value that one
	would get in absence of reionization, as computed by the recombination
	code. (default: not set)
	
aedf1dd9a95b3d29610e7e21b445a49c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|104|1|V|dosini
	
	4.a) in order to model energy injection from DM annihilation, specify a
	     parameter 'annihilation' corresponding to the energy fraction absorbed by
	     the gas times the DM cross section divided by the DM mass, (f <sigma*v> /
	     m_cdm), see e.g. 0905.0003, expressed here in units of m^3/s/Kg
	     (default: set to zero)
405ad040c9084cd2b9f6c618850f57fb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|106|1|V|dosini
	
	4.b) you can model simple variations of the above quanity as a function of
	     redhsift. If 'annihilation_variation' is non-zero, the function F(z)
	     defined as (f <sigma*v> / m_cdm)(z) will be a parabola in log-log scale
	     between 'annihilation_zmin' and 'annihilation_zmax', with a curvature
	     given by 'annihilation_variation' (must be negative), and with a maximum
	     in 'annihilation_zmax'; it will be constant outside this range. To take DM
	     halos into account, specify the parameters 'annihilation_f_halo', the
	     amplitude of the halo contribution, and 'annihilation_z_halo', the
	     characteristic redshift of halos
	     (default: no variation, 'annihilation_variation' and 'annihilation_f_halo'
	     set to zero).
	
8ab5130bf907c7645c0cde59cc73468a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|112|1|V|dosini
	
	4.c) You can also state whether you want to use the on-the-spot approximation
	     (default: 'on the spot' is 'yes')
d6c9f9011407bce3b300af10997b8db6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|114|1|V|dosini
	
	5) to model DM decay, specify a parameter 'decay' which is equal to the energy
	   fraction absorbed by the gas divided by the lifetime of the particle, see
	   e.g.  1109.6322, expressed here in 1/s
	   (default: set to zero)
74cccfc269592063a13818dc3adfcae5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|116|1|V|dosini
	
	6) State whether you want the code to compute the simplest analytic approximation to the photon damping scale (it will be added to the thermodynamics output, and its value at recombination will be stored and displayed in the standard output) (default: 'compute damping scale' set to 'no')
d224babd89d24a3ee19a1670f3c3001c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|118|1|V|dosini
	
	----------------------------------------------------
	----> define which perturbations should be computed:
	----------------------------------------------------
	
	1.a) list of output spectra requested:
	- 'tCl' for temperature Cls,
	- 'pCl' for polarization Cls,
	- 'lCl' for CMB lensing potential Cls,
	- 'nCl' (or 'dCl') for density number count Cls,
	- 'sCl' for galaxy lensing potential Cls,
	- 'mPk' for total matter power spectrum P(k) infered from gravitational potential,
	- 'dTk' (or 'mTk') for density transfer functions for each species,
	- 'vTk' for velocity transfer function for each species.
	Warning: both lCl and sCl compute the C_ls of the lensing potential, C_l^phi-phi.
	If you are used to other codes, you may want to deal instead with the deflection
	Cls or the shear/convergence Cls. The relations between them are trivial:
	--> deflection d:
	    Cl^dd = l(l+1) C_l^phiphi
	--> convergence kappa and shear gamma: the share the same harmonic power spectrum:
	    Cl^gamma-gamma = 1/4 * [(l+2)!/(l-2)!] C_l^phi-phi
	By defaut, the code will try to compute the following cross-correlation Cls (if
	available): temperature-polarisation, temperature-CMB lensing, polarization-CMB
	lensing, CMB lensing-density, and density-lensing. Other cross-correlations are
	not computed because they would slow down the code considerably.
	
	Can be left blank if you do not want to evolve cosmological perturbations at
	all. (default: set to blanck, no perturbation calculation)
d7868eade67c3c9bb6c61ce4d7a7e752|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|122|1|V|dosini
	
	1.b) if you included 'tCl' in the list, you can take into account only some of
	     the terms contributing to the temperature spectrum: intrinsic temperature
	     corrected by Sachs-Wolfe ('tsw' or 'TSW'), early integrated Sachs-Wolfe
	     ('eisw' or 'EISW'), late integrated Sachs-Wolfe ('lisw' or 'LISW'),
	     Doppler ('dop' or 'Dop'), polarisation contribution ('pol' or 'Pol'). Put
	     below the list of terms to be included
	     (defaut: if this field is not passed, all terms will be included)
835349133ee294bef6d3ca100fca34ca|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|124|1|V|dosini
	
	1.c) if one of 'eisw' or 'lisw' is turned off, the code will read 'early/late
	     isw redshift', the split value of redshift z at which the isw is
	     considered as late or early (if this field is absent or left blank, by
	     default, 'early/late isw redshift' is set to 50)
96f29a688d4feb9ad60e72ff619584f4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|126|1|V|dosini
	
	1.d) if you included 'nCl' (or 'dCl') in the list, you can take into account
	     only some of the terms contributing to the obsevable number count
	     fluctuation spectrum: matter density ('density'), redshift-space and
	     Doppler distortions ('rsd'), lensing ('lensing'), or gravitational
	     potential terms ('gr'). Put below the list of terms to be included
	     (defaut: if this field is not passed, only 'dens' will be included)
64b6db3843c53cd1e12982e91531fd5e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|128|1|V|dosini
	
	1.e) if you included 'dTk' (or 'mTk') in the list, the code will give
	you by default the transfer function of the scale-invariant Bardeen
	potentials (for whatever gauge you are using). If you need the
	transfer function of additional metric fluctuations, specific to the
	gauge you are using, set the following flag to 'yes' (default:
	set to 'no')
0d7a1a4f49286978c9147f843398170b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|130|1|V|dosini
	
	2) if you want an estimate of the non-linear P(k) and Cls, enter 'halofit' or
	   'Halofit' or 'HALOFIT' for Halofit; otherwise leave blank
	   (default: blank, linear P(k) and Cls)
1c336a9daa2ea4b72b0c610b12a952aa|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|132|1|V|dosini
	
	3) if you want to consider perturbed recombination, enter a word containing the
	   letter 'y' or 'Y'. CLASS will then compute the perturbation in the
	   ionization fraction x_e and the baryon temperature. The initial conformal
	   time will be small, therefore you should use the default integrator ndf15
	   (i.e. do not set 'evolver' to 0, otherwise the code will be slower).
	   (default: neglect perturbed recombination)
	
405a73cb134dab975d56d2593a6b3afc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|133|1|V|dosini
	
	4) list of modes ('s' for scalars, 'v' for vectors, 't' for tensors). More than
	   one letter allowed, can be attached or separated by arbitrary characters;
	   letters can be small or capital.
	   (default: set to 's')
b0d886fd5a1cf389e4858ea7d2ed69bb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|136|1|V|dosini
	
	5) relevant only if you ask for 'tCl, lCl' and/or 'pCl, lCl': if you want the
	   spectrum of lensed Cls, enter a word containing the letter 'y' or 'Y'
	   (default: no lensed Cls)
3afb5b06ad97adf59f45e6738dac58fe|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|138|1|V|dosini
	
	6) which perturbations should be included in tensor calculations? write 'exact'
	   to include photons, ultra-relativistic species 'ur' and all non-cold dark
	   matter species 'ncdm'; write 'massless' to appriximate 'ncdm' as extra
	   relativistic species (good approximation if ncdm is still relativistic at
	   the time of recombination); write 'photons' to include only photons
	   (default: 'massless')
68d8d728657383d9ad4c05cb0c8ec30e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|140|1|V|dosini
	
	7) list of initial conditions for scalars ('ad' for adiabatic, 'bi' for baryon
	   isocurvature, 'cdi' for CDM isocurvature, 'nid' for neutrino density
	   isocurvature, 'niv' for neutrino velocity isocurvature). More than one of
	   these allowed, can be attached or separated by arbitrary characters; letters
	   can be small or capital.
	   (default: set to 'ad')
9f475e5191a38681b9b8d2732d7d1d99|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|143|1|V|dosini
	
	8) gauge in which calculations are performed: 'sync' or 'synchronous' or
	   'Synchronous' for synchronous, 'new' or 'newtonian' or 'Newtonian' for
	   Newtonian/longitudinal gauge
	   (default: set to synchronous)
3d78b7a9ce401cd7ca1a39e9250ed56e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|145|1|V|dosini
	
	---------------------------------------------
	----> define primordial perturbation spectra:
	---------------------------------------------
	
	1) primordial spectrum type ('analytic_Pk' for an analytic smooth function with amplitude, tilt, running, etc.; analytic spectra with feature can also be added as a new type;'inflation_V' for a numerical computation of the inflationary primordial spectrum, through a full integration of the perturbation equations, given a parametrization of the potential V(phi) in the observable window, like in astro-ph/0703625; 'inflation_H' for the same, but given a parametrization of the potential H(phi) in the observable window, like in astro-ph/0710.1630; 'inflation_V_end' for the same, but given a parametrization of the potential V(phi) in the whole region between the observable part and the end of inflation; there is also an option 'two scales' in order to specify two amplitudes instead of one amplitude and one tilt, like in the isocurvature mode analysis of the Planck inflation paper (works also for adiabatic mode only; see details below, item 2.c); finally 'external_Pk' allows for the primordial spectrum to be computed externally by some piece of code, or to be read from a table, see 2.d). (default: set to 'analytic_Pk')
	
05ebf9d26436a37ccd3f3546fa516eaf|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|148|1|V|dosini
	
	2) parameters related to one of the primordial spectrum types (will only be
	   read if they correspond to the type selected above)
	
	2.a) for type 'analytic_Pk':
	
	2.a.1) pivot scale in Mpc-1 (default: set to 0.05)
8ad81de89a2053f94e324395c840f9f1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|150|1|V|dosini
	
	2.a.2) scalar adiabatic perturbations: curvature power spectrum value at pivot scale ('A_s' or 'ln10^{10}A_s') OR 'sigma8' (found by iterations using a shooting method), tilt at the same scale 'n_s', and tilt running 'alpha_s' (default: set 'A_s' to 2.215e-9, 'n_s' to 0.9619, 'alpha_s' to 0)
a0184b1e94dbe9200532c44241e8f59b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|156|1|V|dosini
	
	2.a.3) isocurvature/entropy perturbations: for each mode xx ('xx' being one of
	       'bi', 'cdi', 'nid', 'niv', corresponding to baryon, cdm, neutrino
	       density and neutrino velocity entropy perturbations), enter the
	       entropy-to-curvature ratio f_xx, tilt n_xx and running alpha_xx, all
	       defined at the pivot scale; e.g.  f_cdi of 0.5 means S_cdi/R equal to
	       one half and (S_cdi/R)^2 to 0.25
	       (default: set each 'f_xx' to 1, 'n_xx' to 1, 'alpha_xx' to 0)
	
466fcb933e5a1eaa536efe12430aa5e6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|164|1|V|dosini
	
	etc.
	
	2.a.4) cross-correlation between different adiabatic/entropy mode: for each
	       pair (xx, yy) where 'xx' and 'yy' are one of 'ad', 'bi', 'cdi', 'nid',
	       'niv', enter the correlation c_xx_yy (parameter between -1 and 1,
	       standing for cosDelta, the cosine of the cross-correlation angle), the
	       tilt n_xx_yy of the function cosDelta(k), and its running alpha_xx_yy,
	       all defined at the pivot scale. So, for a pair of fully correlated
	       (resp. anti-correlated) modes, one should set (c_xx_yy, n_xx_yy,
	       alpha_xx_yy) to (1,0,0) (resp. (-1,0,0)
	       (default: set each 'c_xx_yy' to 0, 'n_xx_yy' to 0, 'alpha_xx_yy' to 0)
06d69f0cf2a2f1829f81c04101dfbe22|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|174|1|V|dosini
	etc.
	
	2.a.5) tensor mode (if any): tensor-to-scalar power spectrum ratio, tilt,
	       running at the pivot scale; if 'n_t' and/or 'alpha_t' is set to 'scc' or
	       'SCC' isntead of a numerical value, it will be inferred from the
	       self-consistency condition of single field slow-roll inflation: for n_t,
	       -r/8*(2-r/8-n_s); for alpha_t, r/8(r/8+n_s-1)
	       (default: set 'r' to 1, 'n_t' to 'scc', 'alpha_t' to 'scc')
a59f001f851f733ce4cbfaee518fd59a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|178|1|V|dosini
	
	2.b) for type 'inflation_V'
	
	2.b.1) type of potential: 'polynomial' for a Taylor expansion of the potential around phi_pivot. Other shapes can easily be defined in primordial module.
df9b2b44c8e33003866bcdb5a6a4bcae|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|188|1|V|dosini
	
	#R_0=2.18e-9
	#R_1=0.1
	#R_2=0.01
	#R_3=
	#R_4=
	
	#PSR_0 = 2.18e-9
	#PSR_1 = 0.001989
	#PSR_2 = 0.0003979
	#PSR_3 =
	#PSR_4 =
	
3d4cb32e74952f0803745af248468416|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|188|1|V|dosini
	2.c) for 'inflation_H': enter either the coefficients 'H_0', 'H_1', 'H_2', 'H_3', 'H_4' of the Taylor expansion (in units of Planck mass to appropriate power), or the Hubble-slow-roll parameters 'HSR_0', 'HSR_1', 'HSR_2', 'HSR_3', 'HSR_4'
7721b80be3d1613e41210d9afb182aff|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|194|1|V|dosini
	
	#HSR_0 = 2.18e-9
	#HSR_1 = 0.001989
	#HSR_2 = 0.0003979
	#HSR_3 =
	#HSR_4 =
e75a17286c8b9fa81a240e92809a4c83|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|1|1|V|dosini
	#H0 = 67.556
	h =0.67556
	#100*theta_s = 1.042143
	
	T_cmb = 2.7255
	#Omega_g =
	#omega_g =
	
	#Omega_b =
	omega_b = 0.022032
	
	N_ur = 3.046
	#Omega_ur =
	#omega_ur =
	
	#ceff2_ur =
	#cvis2_ur =
ffa6bb2648fd2053ddcb5a8da9e66853|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|4|1|v|dosini
	Omega_dcdmdr = 0.0
	#omega_dcdmdr = 0.0
	
	#Omega_ini_dcdm =
	#omega_ini_dcdm =
	
	Gamma_dcdm = 0.0
	
	
efbc87036508a626f8d00438f2dd5e24|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|7|1|V|dosini
	ncdm_psd_filenames = psd_FD_single.dat
46db5838dec97fdaa9bd2dd70180c86d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|7|1|V|dosini
	#ncdm_psd_parameters = Nactive, sin^2_12 ,s23 ,s13
0b719ebb7bbcbe47b30891eef1288e7e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|7|1|V|dosini
	#ncdm_psd_parameters = 0.3 ,0.5, 0.05
e479ca06b42bd7f20542c20bb5daa33b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|393|1|V|dosini
	output = tCl,pCl,lCl,mTk
0a10c6bd93ef43822a5c1ebf807f449c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2106|1|V|c
	    if (n != NULL)
	      *n += q2 * wvec[index_q];
	    if (rho != NULL)
	      *rho += q2 * epsilon * wvec[index_q];
	    if (p != NULL)
	      *p += q2 * q2 / 3. / epsilon * wvec[index_q];
	    if (drho_dM != NULL)
	      *drho_dM += q2 * M / rescale / epsilon * wvec[index_q];
	    if (pseudo_p != NULL)
	      *pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
3e0008cc45528300a4544704e91fe204|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1865|33|v|c
	void *params
bf98f235682755b328479af546a0cc27|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1866|3|V|c
	  struct NcdmPsDistParams *fp = (struct NcdmPsDistParams *)params;
9d12e079efc9600641607e010b933209|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1866|3|V|c
	  double cp = fp->chemical_potential;
bbb3422af6916419361790e72013caa3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1866|3|V|c
	  double m = fp->mass;
a6db7f61b144ad03fed618bc86c86992|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1866|3|V|c
	  double eng = sqrt(q * q + m * m / rescale / rescale);
ad1bd032bd8406b50ed3678edeb7a11d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1856|15|v|c
	momentum `q`
97a43a5daf14d758e49b5bb559eeabe5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1856|20|v|c
	 given the distribution parameters `params`.
a4c2b4443ee25648d85faf61b411ab20|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1860|11|v|c
	q The magnitude of the three-momentum rescaled by temperature.
e0d6597825837b20a8422a7a4f38cca2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1861|11|v|c
	params Parameters of the phase space distribution.
2ff9e715913ae5d761ca9c0d7eb98058|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1906|1|V|c
	  struct NcdmPsDistParams *fp = (struct NcdmPsDistParams *)params;
	  double fq = ncdm_ps_dist(q, params);
	  double m = fp->mass;
	  double rescale = fp->rescale;
	  double eng = sqrt(q * q + m * m / rescale / rescale);
1df2dff3ff63f016d1151ca1d0aad318|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1893|3|V|c
	  double fq = ncdm_ps_dist(q, params);
a7216a51305ddddf1a8dc471472fcfa7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1914|28|v|c
	q, params
46d2adc6acc5c37905f22e4b577b193d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1914|1|V|c
	  double fq = ncdm_ps_dist(eng, fp->cp);
a853265729612a7809e1e7be21f629a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1870|1|V|c
	double ncdm_eng
1223d52b33131240a268d43c69238faf|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1899|15|v|c
	 sqrt(q * q + m * m / rescale / rescale)
4a8eafa38c6d4a46889b80858bb63017|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1899|16|v|c
	sqrt(q * q + m * m / rescale / rescale);
c953b5cc8f445764ac759ad92f47fce9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1899|1|V|c
	  double eng = ncdm_eng(q, m, rescale)l
bc2021f46d18d58c2dc9a6c1d9ae1549|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1897|1|V|c
	  double eng = ncdm_eng(q, fp->mass, fp->rescale)l
0ea72b0ead028a566cf6cc7a04479e68|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|3|V|c
	    if (n != NULL)
b22bdbde2147eba0d9d774ae51461640|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|7|V|c
	      *n += q2 * wvec[index_q];
f1bd288a59ea6a70ee4e65fc420efb7f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|5|V|c
	    if (rho != NULL)
d119a106cf97364103ee4401ce9a4938|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|7|V|c
	      *rho += q2 * epsilon * wvec[index_q];
fa75bdf9d4ac93603d97f3e0bdb34ec9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|5|V|c
	    if (p != NULL)
7375ac11c3adba59a6a302adc9c56f44|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|7|V|c
	      *p += q2 * q2 / 3. / epsilon * wvec[index_q];
2c6d5399c2e52c24ed0964ea2020b764|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1949|43|v|c
	fp->rescale
98919c9ddf895fd6f74999a805a980db|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|5|V|c
	    if (drho_dM != NULL)
a8fc57dc498af6aab6a8a77a9af09e1d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|7|V|c
	      *drho_dM += q2 * M / rescale / epsilon * wvec[index_q];
0551420dd0d62c0d2ac412e517def77e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|1|V|c
	    if (pseudo_p != NULL)
	      *pseudo_p += pow(q2 / epsilon, 3) / 3.0 * wvec[index_q];
fb8b2adf2077c8a413e0ca964eac2c11|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1969|5|V|c
	    if (pseudo_p != NULL)
1446acbdaa1abde816b920654eb50381|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1942|1|V|c
	  double eng = ncdm_eng(q, fp->mass, fp->rescale)l
	  double fq = ncdm_ps_dist(eng, fp->cp);
004fc3e6cf92493dd034edea682f5622|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1962|1|V|c
	  double eng = sqrt(q * q + m * m / rescale / rescale);
	  double fq = ncdm_ps_dist(eng, fp->cp);
750168d5eb044e9832d34bccaf4a36fb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1967|37|v|c
	chemical_potential
33c004661d86d4f91003868a8ad9a387|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|485|1|V|dosini
	gauge = synchronous
1303c4f41a88e739bc859612321b189f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|23|9|v|dosini
	synchronous
e59f3a28070e96269907ad691bf9f489|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/thermal_recoupling.ini|2|13|v|dosini
	1e-6
0f05edb0ab4d7ee0517cc6dcb4c1776d|term://.//1341%3A/bin/zsh|82|5|v|floaterm
	non-cold dark matter species with
6b563d76a548eef68265f6e7f647a85d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|833|42|v|c
	pba->deg_ncdm[n_ncdm]
71eefd538f4ed2858303f307ce07bbfa|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|947|1|V|c
		  printf("fnu_factor = %e", fnu_factor);
fb112bec7baee8ea2afcfe85fc878213|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|948|1|V|c
	          printf("fnu_factor = %e", fnu_factor);
9cde7b1409dd708986b9c2ec09cad092|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|949|19|v|c
	fnu_factor
88c6ace1fb2365a866660ca8aa5a129c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|948|1|V|c
	          printf("fnu_factor = %e\n", fnu_factor);
39727d1bc66f198f388b796c9718a3ed|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|939|9|V|c
	        printf("factor = %e\n", pba->factor_ncdm[n]);
742f32c65ffd18b766fa307f8de2d47d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1914|11|v|c
	factor
a005f126209488c52427063331cbfe59|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1914|32|v|c
	pba->factor_ncdm[n]
4068a099290319214545c52353b8fe61|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1914|3|V|c
	  printf("eng, fq = %e, %e\n", eng, fq);
850d8cb3330e1747b4492661a857dd12|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2036|13|v|c
	eng, fq
3e1b8a01dd8e39fe47cc54a9584c03a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2036|24|v|c
	, %e
8fadc2f1703d1014476265e009dc24bb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2036|1|V|c
	    printf("result = %e\n", result);
2292b562b685c259cf101ca883c4e915|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2044|5|V|c
	    printf("result, factor2, factor = %e, %e, %e\n", result, factor2, factor);
6a98530ed241c3a784c7cb714f025982|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|939|17|v|c
	result, factor2, 
0764c33673e62d834bb8f931285023a8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|939|28|v|c
	, %e, %e
59dcfc90b8ea027b2d1bf9a87988bf30|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2003|3|V|c
	  factor
eaca2e35a08c951c6ccc80ce1624a163|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|939|1|V|c
	        printf("factor_ncdm = %e\n", pba->factor_ncdm[n]);
002ed4d0618e362e4bd697a3d035e735|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2003|17|v|c
	_ncdm
5084011c0b02491cf3a6baf1714427ee|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2003|1|V|c
	  printf("factor (passed to background_ncdm_momenta = %e\n", factor);
a6eceb10a461b7aede385e184bc8fcf6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|21|v|c
	passed to background_ncdm_momenta
9bec592e5ffc6c05ff5016ebddbdfe84|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|5|V|c
	    printf("factor (in rho calc) = %e\n", factor);
edbe5eda89ff716a183ed7540b2383ba|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2046|13|v|c
	factor (in rho calc)
c2db692014470f531036534134638028|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2046|5|V|c
	    printf("rho = %e\n", *rho);
415e3ed7931928a0603469f684a93fc9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|13|v|c
	factor_ncdm
f21ccabcc6aa2ce6d5c0292932e7b9c3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2022|1|V|c
	  double result; // We will store integration results here
253e318a2f43bdd7524377752ae8e8a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2044|61|v|c
	&result
facc77e3b34213ee262f46392dbcf48a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|13|v|c
	result * 
e01dd3ca0775bada19b51dd7e4b0c045|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2046|16|v|c
	, result
1db0e29a3b7e419434f1440afd61fc7a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2046|1|V|c
	    printf("rho, factor2 = %e, %e, %e\n", *rho, result, factor2);
54809b0280dacec04bf26c5f868f020c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|16|v|c
	, factor2
c11ecccf59e36d015e526767d6fa0463|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|30|v|c
	, result, factor2
3311f21c9ca4a155e698fa70fe413469|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2047|13|v|c
	rho, 
8619612844b828f71874b21159fa94d7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2047|1|V|c
	    printf("rho, factor2 = %e, %e\n", *rho, factor2);
24cd289820284394c83410fa0a2ce80b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2062|60|v|c
	 &result
39063c9052c8f28b27d33b48f4cd2867|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2026|1|V|c
	  gsl_function F;
f366af72732613965f52113d5bc18071|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2041|1|V|c
	    gsl_function F;
3544e350c7782baf5869b7242ea2e6dc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2028|1|V|c
	  F.params = &params;
0810ec7fd1f3ff6e8d31496a4cbd217d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2032|1|V|c
	    F.params = &params;
f9a6dea107b6804e239e6b1bd219a4ea|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2023|1|V|c
	  // Function struct needed by GSL to integrate a function. We will use
	  // this for all functions and just set the `function` parameter
	  // appropriately (see below)
	  gsl_function F;
	  // Parameters of the PS distribution needed to evaluate integrands.
	  F.params = &params;
5a13acbf92229a6726d9c063cc614992|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2025|1|V|c
	    gsl_function F;
	    F.params = &params;
fb250f4f2bd4cfdc222478cb42dffde8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2022|1|V|c
	  double error; // We will store the estimate integration errors here
7cc27d70cf31b74de28de850a22adcdc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2032|1|V|c
	    double error; // We will store the estimate integration errors here
276c6007215df68086316c323560f05d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|18|v|c
	 // We will store the estimate integration errors here
fd5d64b7a00c11e90a21a31f4c5e2355|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2018|50|v|c
	We may want to allocate
	  // this elsewhere if it becomes too costly.
	
d4de1681c4b5217f92674bb70899e210|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1879|23|v|c
	0.0 * 
43d2a381ca52df539648fb6a10cc899b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|136|20|v|rust
	Self::zero()
957ff95003c76d7437da9b3021a3f513|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|136|19|v|rust
	 Self{T::zero(), T::zero()}
e7c9a611fdfa6dbde2b2e6ffffab8023|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|136|9|V|rust
	        let zero =;
1a33636304768eaae566b0a466edbf78|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|136|23|v|rust
	zero{
3275d09b46d4d68a2493008fc9a1814d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|139|18|v|rust
	 self.val
6b3a109bb99727dbbe46415b162a2526|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|136|1|V|rust
	        let mut val = self.val;
06c5e4252cc135ac860db9bc99eec63e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|137|23|v|rust
	self.val
e3f5f2f0af154a55f73fda197842c3e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|139|1|V|rust
	            Dual{val,eps}
3a4d980112a17f555f090461c13538f2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|145|1|v|rust
	{
	            val: self.val.abs(),
	            eps: T::zero(),
	        }
	
8540f37d0cb2d4ade4b2b0c0b855b041|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|144|9|V|rust
	        Dual 
df6644b0a0849faed621d83bc0742a14|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|140|13|V|rust
	            val *= -1.0;
2d89d1901542fa2d85d8e1622552412f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|137|9|V|rust
	        let mut eps = 1.0;
b6a8e00ebea516be82a30780b5b01d2b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-autodiff/src/dual/dual_float.rs|134|47|v|rust
	 Returns `Float::nan()` if the
92963b7fef5791d52a97ac943049df7b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|14|1|V|toml
	ndarray = "0.13.1"
cc801bd8b3e2970a29e5346ff2068dc8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|13|8|v|toml
	interpolation
db33499b6f01bae817110bba13b93a24|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|4|1|V|toml
	authors = ["Logan A Morrison <loanmorr@ucsc.com>"]
b3c777922e44395eb1cb03242d6d7a16|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|22|28|v|toml
	"../cyphus-autodiff"
2b41d5393382e2bce9dfe655002484fd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|23|1|V|toml
	cyphus-autodiff = { path = , optional = true }
909ee6521b6e3620cc4002cd1602b61c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|16|1|V|toml
	num = "0.2.1"
95e7887f81394d5781616e74fc16deae|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|16|35|v|toml
	["max_level_debug", "release_max_level_warn"]
f7c50e0ec6339107dd754f1c5f216086|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|16|1|V|toml
	log = { version = "*", features =  }
3942de5a1dea3a3bd5749b564266520d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/Cargo.toml|26|22|v|toml
	specfun
d74ebbd0a58d31769a70895cdb401171|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/lambert_w.rs|43|9|V|rust
	        let mut tol;
46aa47f61498ec0a851a256e3a4ae5f1|file:///Users/loganmorrison/Documents/coding/gsl-2.6/specfunc/bessel_j.c|43|1|V|c
	    const double y = x*x;
	    const double c1 = -1.0/6.0;
	    const double c2 =  1.0/120.0;
	    const double c3 = -1.0/5040.0;
	    const double c4 =  1.0/362880.0;
	    const double c5 = -1.0/39916800.0;
	    const double c6 =  1.0/6227020800.0;
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
10e51314a7eed86b1b229ccdf383502e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|15|9|v|rust
	const 
a19e304a56f7efeb08f0d65873e9bca9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|22|1|V|rust
	        result.err = 2.0 * f64::EPSILON * result.val.abs();
0f994d130df111b0fb9dc1aa9ee37785|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|32|1|V|rust
	    let result = SpecFunResult::<f64>::default();
c7f49f4f390eaa831982b61e21db947f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|32|1|V|rust
	    let mut result = SpecFunResult::<f64>::default();
b5dbc93c3fea8c2afc02b9a12d80a914|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|5|1|v|rust
	let mut result = SpecFunResult::default();
	
9446fd204117ccd4ea06fc4c4fb9882f|file:///Users/loganmorrison/Documents/coding/gsl-2.6/specfunc/bessel_j.c|77|1|V|c
	    const double y = x*x;
	    const double c1 = -1.0/10.0;
	    const double c2 =  1.0/280.0;
	    const double c3 = -1.0/15120.0;
	    const double c4 =  1.0/1330560.0;
	    const double c5 = -1.0/172972800.0;
	    const double sum = 1.0 + y*(c1 + y*(c2 + y*(c3 + y*(c4 + y*c5))));
f77fb36b8f23d312f4ae4f98e13c21fc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|47|24|v|rust
	1.0 + y * (c1 + y * (c2 + y * (c3 + y * (c4 + y * c5))));
fce9ee4ef8a3da35869c386d4bf197ec|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|31|1|V|rust
	    let ax = x.abs();
	    let mut result = SpecFunResult::<f64>::default();
	
	    if x == 0.0 {
	        result.val = 0.0;
	        result.err = 0.0;
	    } else if ax < 3.1 * f64::MIN_POSITIVE {
	        result.val = f64::NAN;
	        result.code = SpecFunCode::DomainErr;
	    } else if ax < 0.25 {
	        let y: f64 = x * x;
	        let c1: f64 = -1.0 / 10.0;
	        let c2: f64 = 1.0 / 280.0;
	        let c3: f64 = -1.0 / 15120.0;
	        let c4: f64 = 1.0 / 1330560.0;
	        let c5: f64 = -1.0 / 172972800.0;
	        let sum: f64 = c5
	            .mul_add(y, c4)
	            .mul_add(y, c3)
	            .mul_add(y, c2)
	            .mul_add(y, c1)
	            .mul_add(y, 1.0);
	        result.val = x / 3.0 * sum;
	        result.err = 2.0 * f64::EPSILON * result.val.abs();
	    } else {
	        let cos = x.cos();
	        let sin = x.sin();
	        result.val = (sin / x - cos) / x;
	        result.err = 2.0 * f64::EPSILON * ((sin / (x * x)).abs() + (cos / x).abs());
	        result.err += 2.0 * f64::EPSILON * result.val.abs();
	    }
	
	    result
7bd5434ed095899d01ab2d1c9118cba0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|67|1|V|rust
	    if x == 0.0{
	        res
	    }
4bff8423f49d475c794b1198c8014582|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|73|20|v|rust
	3.1 * f64::MIN_POSITIVE {
619df151b39ea4a4895d9a84b6a758b3|file:///Users/loganmorrison/Documents/coding/gsl-2.6/specfunc/bessel_j.c|114|1|V|c
	    const double y  = x*x;
	    const double c1 = -1.0/14.0;
	    const double c2 =  1.0/504.0;
	    const double c3 = -1.0/33264.0;
	    const double c4 =  1.0/3459456.0;
	    const double c5 = -1.0/518918400;
	    const double c6 =  1.0/105859353600.0;
	    const double c7 = -1.0/28158588057600.0;
	    const double c8 =  1.0/9461285587353600.0;
	    const double c9 = -1.0/3916972233164390400.0;
db3438f0c3df9d66ea096067f2a80737|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|77|1|V|rust
	        let y: f64 = x * x;
	        let c1: f64 = -1.0 / 10.0;
	        let c2: f64 = 1.0 / 280.0;
	        let c3: f64 = -1.0 / 15120.0;
	        let c4: f64 = 1.0 / 1330560.0;
	        let c5: f64 = -1.0 / 172972800.0;
7d29738ec840c519f7e449c308c69aa2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|90|1|V|rust
	            .mul_add(y, c6)
	            .mul_add(y, c5)
d01dc92815b20e3f71f9ea2d98597dc8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|74|1|V|rust
	        result.val = f64::NAN;
	        result.code = SpecFunCode::DomainErr;
828d74e51c715ad7b4eb80b18cd36b25|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|125|1|V|rust
	        let pre = ((0.5 * std::f64::consts::PI) / x).sqrt();
b3431418a5de2546a8f710dcfd8de540|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|133|1|V|rust
	        let pre = 
3a85e8b37e0532bf1a5d04fb5b4b4b3e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|132|1|V|rust
	        let b = super::bessel_helpers::besseljv_asympx_e(0.5 + l as f64, x);
	        let pre = ((0.5 * std::f64::consts::PI) / x).sqrt();
	        result.val = pre * b.val;
	        result.err = 2.0 * f64::EPSILON * result.val + pre * b.err;
	        result
2cb19572de7214f9e5a41c3df5412608|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|138|1|v|rust
	        result
832e8970fc41334e48bed241952b57d4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|138|1|V|rust
	        resul
dc898a10d316fb18293451afe0e2c519|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|138|24|v|rust
	bessel_helpers
1b190be0162f1e941ff23ce529b66732|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|138|24|v|rust
	bessel_
251d11051cd19a478ca47e9b274a79a2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|138|1|V|rust
	        let b = super::olver::besseljv_asymp_olver_e(0.5 + l as f64, x);
	        let pre = ((0.5 * std::f64::consts::PI) / x).sqrt();
	        result.val = pre * b.val;
	        result.err = 2.0 * f64::EPSILON * result.val + pre * b.err;
	        result
839822501d47fd427606793b50c22a65|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|132|1|V|rust
	        let b = super::bessel_helpers::besseljv_asympx_e(0.5 + l as f64, x);
d755abea491f56995a259dc0db114fe6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|144|1|V|rust
	        let b = super::olver::besseljv_asymp_olver_e(0.5 + l as f64, x);
d3736c72b09c8be1a461100a00000562|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|162|1|V|rust
	            let j0 = sph_bessel_j0_e(x);
	            let pre = small / jl;
	            result.val = j0.val * pre;
	            result.err = j0.err * pre.abs();
	            result.err += 4.0 * f64::EPSILON * (0.5 * l as f64 + 1.0) * result.val.abs();
	            result
d545120310a9da5972cce88fb53af045|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|3|1|V|rust
	#[allow(dead_code)]
5132845258d9f6146a08608a606ab2da|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|3|1|V|rust
	/// Compute the spherical bessel function of the first kind of order 0 along
	/// with an error estimate.
c4cce66ce484083116bcd4bc3c79e4e2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|33|1|V|rust
	/// Compute the spherical bessel function of the first kind of order 1 along
	/// with an error estimate.
a213da288e6fee88f2c2e40051243158|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel.rs|8|1|V|rust
	pub(crate) mod sph_bessel_j;
c96f8ff09d5efbe3326413bf2f4aadf7|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_j.rs|1|1|V|rust
	use crate::result::{SpecFunCode, SpecFunResult};
ecf9e84b8f6226e6f431340422db4bc2|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_y.c|52|1|V|c
	    const int lmax = 200;
	    double t = -0.5*x*x;
	    double sum = 1.0;
	    double t_coeff = 1.0;
	    double t_power = 1.0;
	    double delta;
	    int i;
52138da3596f6dcec8e549c33f419034|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|13|9|v|rust
	const int
86ee2ba55aa03b06900298d3c1884440|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|19|9|v|rust
	int 
7cf534f51ff84ba678d5868ac618e723|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|19|9|V|rust
	        let mut i;
7823555192e005ee91d830849567054a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|39|1|V|rust
	        result.val = f64::NAN;
54fefb768feb70e95d174f3741f4acc6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|39|1|V|rust
	        result.val = f64::NAN;
	        result.err = f64::NAN;
	        result.code = SpecFunCode::DomainErr;
	        result
9aaebc7380c092f81c636a3d0281270f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|44|27|v|rust
	NAN;
323457e0d467c7ff2a6118f6951ec3c4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|46|36|v|rust
	DomainErr
cd783a0d3e78eb9ae83fcfe5168654e5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|37|1|V|rust
	#[allow(dead_code)]
	pub(crate) fn sph_bessely0_e(x: f64) -> SpecFunResult<f64> {
	    let mut result = SpecFunResult::<f64>::default();
	    if x <= 0.0 {
	        result.val = f64::NAN;
	        result.err = f64::NAN;
	        result.code = SpecFunCode::DomainErr;
	        result
	    } else if 1.0 / std::f64::MAX > 0.0 && x < 1.0 / std::f64::MAX {
	        result.val = f64::INFINITY;
	        result.err = f64::INFINITY;
	        result.code = SpecFunCode::OverflowErr;
	        result
	    } else {
	        let cos = crate::trig::cos_e(x);
	        result.val = -cos.val / x;
	        result.err = (cos.err / x).abs();
	        result.err += 2.0 * f64::EPSILON * result.val.abs();
	        result
	    }
	}
8bbf5718f249b2809a6ce4d79ddc1aa2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|67|15|v|rust
	1.0 / std::f64::MAX > 0.0 && x < 1.0 / std::f64::MAX {
4b49d010131a37d4199b5d824c3cf95d|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_y.c|109|1|V|c
	    const double y = x*x;
	    const double c1 =  1.0/2.0;
	    const double c2 = -1.0/8.0;
	    const double c3 =  1.0/144.0;
	    const double c4 = -1.0/5760.0;
	    const double c5 =  1.0/403200.0;
	    const double c6 = -1.0/43545600.0;
05972ab559461fee82e23724957f1d87|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|83|1|V|rust
	            .mul_add(y, c3)
7934fd1f4e84ade2422e02836e740278|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|85|1|V|rust
	            .mul_add(y, c1)
bc95feeb84e10872d61af94ce45af529|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|92|1|V|rust
	        let cos = crate::trig::cos_e(x);
	        result.val = -cos.val / x;
	        result.err = (cos.err / x).abs();
	        result.err += 2.0 * f64::EPSILON * result.val.abs();
	        result
1935365dc04c3c3b3868ec703bf3f482|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|92|1|V|rust
	        let cos = crate::trig::cos_e(x);
de94d0ff57cfcefafd14d49464595b50|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|94|9|V|rust
	        let cx = cos
e31ce65e258ac411a240626e5e5cae54|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|59|1|V|rust
	#[allow(dead_code)]
	pub(crate) fn sph_bessely1_e(x: f64) -> SpecFunResult<f64> {
	    let mut result = SpecFunResult::<f64>::default();
	    if x <= 0.0 {
	        result.val = f64::NAN;
	        result.err = f64::NAN;
	        result.code = SpecFunCode::DomainErr;
	        result
	    } else if x < 1.0 / crate::consts::SQRT_DBL_MAX {
	        result.val = f64::INFINITY;
	        result.err = f64::INFINITY;
	        result.code = SpecFunCode::OverflowErr;
	        result
	    } else if x < 0.25 {
	        let y: f64 = x * x;
	        let c1: f64 = 1.0 / 2.0;
	        let c2: f64 = -1.0 / 8.0;
	        let c3: f64 = 1.0 / 144.0;
	        let c4: f64 = -1.0 / 5760.0;
	        let c5: f64 = 1.0 / 403200.0;
	        let c6: f64 = -1.0 / 43545600.0;
	        let sum = c6
	            .mul_add(y, c5)
	            .mul_add(y, c4)
	            .mul_add(y, c3)
	            .mul_add(y, c2)
	            .mul_add(y, c1)
	            .mul_add(y, 1.0);
	
	        result.val = -sum / y;
	        result.err = f64::EPSILON * result.val.abs();
	        result
	    } else {
	        let cos = crate::trig::cos_e(x);
	        let sin = crate::trig::sin_e(x);
	        result.val = -(cos.val / x + sin.val) / x;
	        result.err = ((cos.err / x).abs() + sin.err) / x.abs();
	        result.err += f64::EPSILON * ((sin.val / x).abs() + (cos.val / (x * x)).abs());
	        result
	    }
	}
07c8efa8a113875637887052a455ab6c|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_y.c|148|1|V|c
	    const double c1 =  1.0/6.0;
	    const double c2 =  1.0/24.0;
	    const double c3 = -1.0/144.0;
	    const double c4 =  1.0/3456.0;
	    const double c5 = -1.0/172800.0;
	    const double c6 =  1.0/14515200.0;
	    const double c7 = -1.0/1828915200.0;
9fb9453f01d124f37c855bc157d59c3b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|116|1|V|rust
	        let c1: f64 = 1.0 / 2.0;
	        let c2: f64 = -1.0 / 8.0;
	        let c3: f64 = 1.0 / 144.0;
	        let c4: f64 = -1.0 / 5760.0;
	        let c5: f64 = 1.0 / 403200.0;
	        let c6: f64 = -1.0 / 43545600.0;
15760bf24d3240be788a877cdfad12ce|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|128|1|V|rust
	            .mul_add(y, c2)
0e33bab836dc579888a8a07fc628cfca|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|132|23|v|rust
	sum / y;
773a33c7963e28895cee0af1b4e7ea7f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|139|22|v|rust
	-(cos.val / x + sin.val) / x;
3eb66d99106b71437db057c52c30ca8c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|140|22|v|rust
	((cos.err / x).abs() + sin.err) / x.abs();
fbf6466eee50761c6a05fc9cff9e0456|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|141|23|v|rust
	f64::EPSILON * ((sin.val / x).abs() + (cos.val / (x * x)).abs());
96cbcebfc162de622c4336e8ea022c95|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|114|19|v|rust
	0.25 {
3250187cc1f1860a7158dcd38c84eaa0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|154|1|V|rust
	        sph_bessely0_e(x)
a9043c551442ec246e82fcdbe77f4dcf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|153|1|V|rust
	    } else if l == 0{
	        sph_bessely0_e(x)
	    }
2b9a8679de925898134fbc3f93357989|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|153|7|v|rust
	else if l == 0{
	        sph_bessely0_e(x)
	    }
	
561285d70ed037b4568a5214cb8a3df5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|162|9|v|rust
	let yv
d8f4426299e3dbe8afd93e44e5e4faf0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|162|1|V|rust
	        result = super::bessel_helpers::besselyv_asympx_e(0.5 + l as f64, x);
	        let pre = ((0.5 * std::f64::consts::PI) / x).sqrt();
	        result.val *= pre;
	        result.err *= pre;
	        result
82b52ffa46c7d75e2b282f92e1d86a16|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|168|32|v|rust
	besselyv_asympx_e(0.5 + l as f64, x);
12a821d8f0fe84caf9d3c756be474d28|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|168|32|v|rust
	besselyv_asympx_e
9beb342ff34ef70c1928c357bc913315|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|175|1|V|rust
	        let r_by = sph_bessely1_e(x);
cfbde71409b5b8c2394a5b00444abfa0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_y.rs|175|13|V|rust
	        let  r_by = sph_bessely1_e(x);
	        let mut r_bym = sph_bessely0_e(x);
ec519d764091538d36e96bb7ae02fbb0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel.rs|8|1|V|rust
	pub(crate) mod sph_bessel_j;
	pub(crate) mod sph_bessel_y;
b78454d3f004dcaeef79d8c532ac3ace|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|3|62|v|rust
	, ratio:f64
1db9e5306ee61828fca76ce1ce047973|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_i.c|46|17|v|c
	(x/(2.0*l+1.0+2.0*k)) * (x/(2.0*l+3.0+2.0*k));
	    rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0 + rhok));
	    tk  *= rhok;
	    sum += tk;
	
da83a6284e8bdaec860da9bf3e56c44d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|3|69|v|rust
	SpecFunResult<f64> {
44be3f8cdf49c87cb7fd92150040eb01|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|18|9|V|rust
	        if k == kmax{
96ad9f826ee6b00e9e51d7ab14fb696e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|18|13|V|rust
	            code
2e88df11c07dd2462d323786c212b41d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|10|5|v|rust
	for k in 1..=kmax {
8480cfa36eb015d1144748f0f26f54b2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|27|5|V|rust
	    if k = 
9811a01dec250c61764c318c82d301df|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|26|5|v|rust
	let ratio = 
687cdc1888775789b09ffa1ccba3c7b7|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_i.c|76|1|V|c
	    const double eax = exp(-ax);
	    const double y = ax*ax;
	    const double c1 = 1.0/6.0;
	    const double c2 = 1.0/120.0;
	    const double c3 = 1.0/5040.0;
	    const double c4 = 1.0/362880.0;
	    const double c5 = 1.0/39916800.0;
6a50e9667aa57d91b109df3ae128d1c8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|30|1|V|rust
	#[allow(dead_code)]
	pub(crate) fn sph_bessel_i0_scaled_e(x: f64) -> SpecFunResult<f64> {
	    let ax = x.abs();
	    let mut result = SpecFunResult::<f64>::default();
	
	    if x == 0.0 {
	        result.val = 1.0;
	        result
	    } else if ax < 0.2 {
	        let eax: f64 = (-ax).exp();
	        let y: f64 = ax * ax;
	        let c1: f64 = 1.0 / 6.0;
	        let c2: f64 = 1.0 / 120.0;
	        let c3: f64 = 1.0 / 5040.0;
	        let c4: f64 = 1.0 / 362880.0;
	        let c5: f64 = 1.0 / 39916800.0;
	        let sum = c5
	            .mul_add(y, c4)
	            .mul_add(y, c3)
	            .mul_add(y, c2)
	            .mul_add(y, c1)
	            .mul_add(y, 1.0);
	        result.val = eax * sum;
	        result.err = 2.0 * f64::EPSILON * result.val;
	        result
	    } else if ax < -0.5 * crate::consts::LN_DBL_EPS {
	        result.val = (1.0 - (-2.0 * ax).exp()) / (2.0 * ax);
	        result.err = 2.0 * f64::EPSILON * result.val;
	        result
	    } else {
	        result.val = 1.0 / (2.0 * ax);
	        result.err = 2.0 * f64::EPSILON * result.val;
	        result
	    }
	}
f72f7aeb5b24a0bcfa066708a3b7c50d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|72|9|V|rust
	        result.val = 1.0;
17db1d3eff4a5e2783380ebb7d1ce285|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|73|20|v|rust
	0.2 {
f8964dc717295db09aaed222d5e214a4|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_i.c|115|1|V|c
	    const double y  = x*x;
	    const double c1 = 1.0/10.0;
	    const double c2 = 1.0/280.0;
	    const double c3 = 1.0/15120.0;
	    const double c4 = 1.0/1330560.0;
	    const double c5 = 1.0/172972800.0;
9c75e6be76ab00285db9892b93c29c87|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|81|1|V|rust
	        let c1: f64 = 1.0 / 6.0;
	        let c2: f64 = 1.0 / 120.0;
	        let c3: f64 = 1.0 / 5040.0;
	        let c4: f64 = 1.0 / 362880.0;
	        let c5: f64 = 1.0 / 39916800.0;
c167f27e26791590d99ae2f180f2102d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|81|5|V|rust
	    const double y  = x*x;
5200e9a87e0b4991fbf2f0426ebde062|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|95|7|v|rust
	else if ax < -0.5 * crate::consts::LN_DBL_EPS {
	        result.val = (1.0 - (-2.0 * ax).exp()) / (2.0 * ax);
	        result.err = 2.0 * f64::EPSILON * result.val;
	        result
	    }
c208e8e70f2a5198524d138943f6cf38|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|96|1|V|rust
	        result.val = 1.0 / (2.0 * ax);
	        result.err = 2.0 * f64::EPSILON * result.val;
8748caf3c2f7dc8789a7b4d93a92dcc8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|66|1|V|rust
	#[allow(dead_code)]
	pub(crate) fn sph_bessel_i1_scaled_e(x: f64) -> SpecFunResult<f64> {
	    let ax = x.abs();
	    let mut result = SpecFunResult::<f64>::default();
	
	    if x == 0.0 {
	        result
	    } else if ax < 3.0 * f64::MIN_POSITIVE {
	        result.val = f64::NAN;
	        result.err = f64::NAN;
	        result.code = SpecFunCode::OverflowErr;
	        result
	    } else if ax < 0.25 {
	        let eax: f64 = (-ax).exp();
	        let y: f64 = ax * ax;
	        let c1: f64 = 1.0 / 10.0;
	        let c2: f64 = 1.0 / 280.0;
	        let c3: f64 = 1.0 / 15120.0;
	        let c4: f64 = 1.0 / 1330560.0;
	        let c5: f64 = 1.0 / 172972800.0;
	        let sum = c5
	            .mul_add(y, c4)
	            .mul_add(y, c3)
	            .mul_add(y, c2)
	            .mul_add(y, c1)
	            .mul_add(y, 1.0);
	        result.val = eax * x / 3.0 * sum;
	        result.err = 2.0 * f64::EPSILON * result.val;
	        result
	    } else {
	        let ex = (-2.0 * ax).exp();
	        result.val = 0.5 * (ax * (1.0 + ex) - (1.0 - ex)) / (ax * ax);
	        result.err = 2.0 * f64::EPSILON * result.val.abs();
	        if x < 0.0 {
	            result.val *= -1.0;
	        }
	        result
	    }
	}
6c8687b9ad919c7c2d04be64e6b00b3c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|113|24|v|rust
	* f64::MIN_POSITIVE {
610dea2aee77f3ac634c6fce31e78a65|file:///Users/loganmorrison/Documents/coding/gsl/specfunc/bessel_i.c|152|1|V|c
	    const double c1 = 1.0/14.0;
	    const double c2 = 1.0/504.0;
	    const double c3 = 1.0/33264.0;
	    const double c4 = 1.0/3459456.0;
	    const double c5 = 1.0/518918400.0;
5966b504005249eec915a1f83f316abd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|121|1|V|rust
	        let c1: f64 = 1.0 / 10.0;
	        let c2: f64 = 1.0 / 280.0;
	        let c3: f64 = 1.0 / 15120.0;
	        let c4: f64 = 1.0 / 1330560.0;
	        let c5: f64 = 1.0 / 172972800.0;
d3156efe6f627829724246d34e477945|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|133|22|v|rust
	eax * x / 3.0 * sum;
c9c93572126c3a311970e5a7fb33d3c9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|138|28|v|rust
	(ax * (1.0 + ex) - (1.0 - ex)) / (ax * ax);
dd3bf24cb5e597de24ab19118e7d4a3f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|141|1|V|rust
	        if x < 0.0 {
	            result.val *= -1.0;
	        }
1272f4baed9087601c65809baf28201a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|145|1|V|rust
	#[allow
f0e6919112dc9058c6712b49505562f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|119|1|V|rust
	        let eax: f64 = (-ax).exp();
a9c26dd8c558d25d431f3055a2d23dda|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|106|1|V|rust
	#[allow(dead_code)]
	pub(crate) fn sph_bessel_i2_scaled_e(x: f64) -> SpecFunResult<f64> {
bf00d8e75c7a08e8457212c3addcfde2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|144|1|V|rust
	#[allow(dead_code
4c2c12cae6e7f72a2641f4aece72c3d8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|156|5|V|rust
	    if 
f46cc4c49ee7650cf538f09ab03950a8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|160|7|v|rust
	else if l == 0{
	        result = sph_besseli1_scaled_e(x);
	        result.val *= sgn;
	        result
	    }
	
6a4276677615ee10d25fea8d7fdad1bf|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|181|19|v|rust
	stat_cf1
e18345cdb7605316d4fcd472ac76b584|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|194|28|v|rust
	(l*l+1)as f64)
c5179803b7bfd68fa83524264b176c2d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|194|42|v|rust
	(l*l+1)as f64) 
856cbffb246318369a098551ae5302fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|204|5|V|rust
	    result
10a1cc022f5d97e49a1202ab73d3931c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|198|19|v|rust
	((0.5 * std::f64::consts::PI) / x).sqrt();
02f0cd5d761fa8d891ea403cf1d6df9e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|205|60|v|rust
	.trunc()
a119636df68d65932034db4f30bfdc6a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|197|18|v|rust
	super::bessel_helpers::besseliv_scaled_asymp_unif_e(0.5 + l as f64, x);
958df418524129631d48365238240b72|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|206|1|V|rust
	        let r_ilp1 = super::bessel_helpers::besseliv_scaled_asymp_unif_e(0.5 + l as f64, x);
60c73cc51c89cf91ec5c1f0de908f81b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|219|57|v|rust
	(r_ilp1.err/r_ilp1.val).abs()
fc86b6c8e4ea42690aeed11202185b96|file:///Users/loganmorrison/Documents/coding/rust/cyphus-specfun/src/bessel/sph_bessel_i.rs|213|29|v|rust
	LMAX
d91588bc700c37b39495d4989c9c6db0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|2|1|V|rust
	    println!("Hello, world!");
7039af102e3f48be902f12ae0713d572|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|1|1|V|rust
	pub mod 
9e7405c70b28aac8b39e322813f4bc15|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|10|1|V|toml
	cyphus-integration = { path = "../../cyphus-integration"}
776ea3bf11df5829827f7afb43c37174|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|11|8|v|toml
	integration
0d7cbd46be16d66e01ce44cb0020c276|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|11|1|V|toml
	cyphus-diffeq = { path = "../../cyphus-diffeq"}
2bff7c4c23b0654ed3c4889f3bbc7193|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|12|8|v|toml
	diffeq
75c3c0d094b98ddaa0ba65f77d32045c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|1|1|V|rust
	pub struct  
d9e6b69d1660c92f0cdfa9a751d2eb94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|5|5|v|rust
	pub gx: f64,
e95642d762fb9fb5713f9fd629be2197|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|8|13|v|rust
	Array1
0dfa2c5d9986faebd55cde8015db795b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|21|9|v|rust
	Thermal transfer function
968196fe8e703b8def47d62c2b001c1f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|24|8|v|rust
	thermal_
90126dd1d90fa23be74fa653bceb23a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|12|1|V|toml
	cyphus-specfun = { path = "../../cyphus-specfun"}
6c87eb1e46ae97e1a63063f563d5ee52|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|13|1|v|toml
	cyphus
d1d11ae26e9ac0b5caea1f28bea6bbc1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|13|1|v|toml
	-specfun
e199f80437d21a6991e7e76f741f3ef1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|31|1|V|rust
	    fn feq(&self, x:f64, q:f64) -> f64{
	        unimplemented!()
	    }
80fe5e2c4420d0f023a4cb3396f35477|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|34|26|v|rust
	, q:f64
46bef83690a954b8ae010dd01e658361|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|34|1|V|rust
	    fn gamma(&self, x:f64) -> f64{
	        unimplemented!()
	    }
05b048d7242cb7b8b57cfa3b1d65ecea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|37|8|v|rust
	gamma
c4f2f8f24016ee65202704d61e2e4e09|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|13|1|V|toml
	haliax-thermal-functions = { path = "../../haliax-thermal-functions"}
4c3b3aa9a980e64ded54896eff6e051d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/Cargo.toml|14|8|v|toml
	thermal-functions
3455e42cbe1b03891e7eb1bb5d17b997|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|1|1|V|rust
	pub struct KineticMixing {
	    /// Dark matter mass
	    pub mx: f64,
	    /// Vector mediator mass
	    pub mv: f64,
	    /// Couping of DM to vector mediator.
	    pub gvxx: f64,
	    /// Kinetic mixing parameter.
	    pub eps: f64,
	    /// Width of the vector mediator.
	    widthv: f64,
	}
5e11b73b60061af15425f7d76e868f4e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|1|1|V|rust
	pub mod kinetic_mixing;
c0134de2205435c800cb99263adca9ca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|1|1|V|rust
	pub mod models;
975826920e100645fa7b60f265742446|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|6|9|v|rust
	Effective
088219f9efbc5953202eb164f80e8cc9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|2|1|V|rust
	    /// Mass of the lightest DM particle.
	    pub ml: f64,
6fe390b9bc4863a3a63bbd0cb8da7bc5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|4|21|v|rust
	lightest
9ef0d06fbdf35dddb218dc5a4f5887f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|6|5|V|rust
	    /// Mass splitting between lightest and next-to-lightest DM particle.
f99f83d88eff33844a70996a21657543|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|6|5|V|rust
	    pub dm: f64,
868f411b023a2f6cb23f122902ed8be0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/model.rs|1|1|v|rust
	use ndarray::prelude::*;
	
	/// Structure to hold the a phase-space distribution.
	pub struct PhaseSpaceDist {
	    /// Momentum values
	    pub qs: Array1<f64>,
	    /// Values of m / T.
	    pub xs: Vec<f64>,
	    /// Phase space distribution corresponding to the values in `xs`.
	    pub fs: Vec<Array1<f64>>,
	}
	
	pub struct ToyModel {
	    /// Dark matter mass
	    pub mx: f64,
	    /// Number of d.o.f.
	    pub gx: f64,
	}
	
	pub trait FullBoltzmann {
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate
	    fn gamma(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn avg_cross_section(&self, x: f64) -> f64;
	}
	
	impl FullBoltzmann for ToyModel {
	    fn feq(&self, x: f64, q: f64) -> f64 {
	        unimplemented!()
	    }
	    fn gamma(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	    fn avg_cross_section(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	}
6fa7f8f1d9bcbefd14dcaab4384518da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|13|1|V|rust
	pub struct ToyModel {
	    /// Dark matter mass
	    pub mx: f64,
	    /// Number of d.o.f.
	    pub gx: f64,
	}
bf5b8fb4d6c4667662a2c861bbcc0ad1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|24|1|V|rust
	impl FullBoltzmann for ToyModel { fn feq(&self, x: f64, q: f64) -> f64 {
	        unimplemented!()
	    }
	    fn gamma(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	    fn avg_cross_section(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	}
41f7712f999935eeb94d538f11ea317c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|4|12|v|rust
	PhaseSpaceDist {
a8fef3ed77cc1a4f55b5d81b0500b6b9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|7|5|V|rust
	    /// Values of m / T.
da654a88157f12600ecbc0e358aafe13|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|7|5|V|rust
	    pub xs: Vec<f64>,
9282bd44943a5c81055c3331c73c1493|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|7|5|V|rust
	    /// Phase space distribution corresponding to the values in `xs`.
7223e2818bdb7a365cd0c93dbaf8a5cf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|7|5|V|rust
	    pub fs: Vec<Array1<f64>>,
3eec3515403223330013e8245465f65b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|23|11|v|rust
	: Array::linspace(qmin, qmax,
6064453c264835919ad2c17208f2eef4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|24|1|V|rust
	    let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t:f64, p: &FullBoltzmannParams|{
	    }
cee44a4736519848cd908612350c85fe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|26|21|v|rust
	(n-1)
a1a8bb339ecb2f1fe85876772480a470|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|27|22|v|rust
	1..(n-1)
d5a137ee3793a60f2d283567d0869fc7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|17|V|rust
	                if j != n-1{
4d7d45d3171b8ffe3b5e2d78e50505e4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|21|V|rust
	                    le
81789648c34c70b46164eb7a6f015c95|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|17|V|rust
	                }
a3bb2139e031d93474ef3ccea74894e9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|1|V|rust
	                let feqi = p.model.feq(x, qi);
a147ec902938d6080ab003f933d06477|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|29|1|V|rust
	                let fi = u[i];
03b1ac698c2444c4415a2e73b048fffe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|32|21|V|rust
	                    ((u[i+1] -u[i]) / (p.qs[i+1]-p.qs[i]), (u[i+2] 
066758da027cd5480bd8a47a807632c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|27|21|v|rust
	(n - 1)
e8fa397f3208e59ce3d218639b867c2a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|18|1|V|rust
	impl DipoleDm {
	    pub fn gamma(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	    pub fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        unimplemented!()
	    }
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	        let n = u.shape()[0];
	        for i in 0..n {
	            for j in 0..n{
	                
	            }
	        }
	    }
	}
fb1d3b24b9dee12169ad2169024bf1ea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|36|1|V|rust
	    pub fn gamma(&self, x: f64) -> f64 {
	        unimplemented!()
	    }
	    pub fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        unimplemented!()
	    }
967cf03acfce8782c03a1c39c81ba062|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|25|1|V|rust
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	        let n = u.shape()[0];
	        for i in 0..n {
	            for j in 0..n{
	                
	            }
	        }
	    }
c388927fc08bec9dcf0b6bc862b6ab87|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|27|1|V|rust
	impl DipoleDm {
	    pub fn dudt(&self, mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64) {
	        let n = u.shape()[0];
	        for i in 0..n {
	            let qi = self.
	            for j in 0..n {
	                
	            }
	        }
	    }
	}
762c2aca7b6d305aa1ee028bea1dac99|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|28|1|V|rust
	                let qi = p.qs[i];
	                let feqi = p.model.feq(x, qi);
	                let fi = u[i];
	                // Compute the derivatives of f_i(x,q)
	                let (dfi, d2fi) = if i == 0 { (0.0, 0.0) } else { (0.0, 0.0) };
	
5bcb38aff25de9f9e3d5db692a5c53fd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|29|1|V|rust
	                    let qj = p.qs[j];
	                    let dqj = p.qs[j + 1] - qj;
	                    let fj = u[j];
	                    let feqj = p.model.feq(x, qj);
	                    let sigij = p.model.sigmav(x, qi, qj);
299be63b294c618619350844c4c6e176|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|29|1|V|rust
	                qi = p.qs[i];
5070a24ee8f0075c2137a2edd4e82df1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|1|V|rust
	                qip1 = p.qs[i+1];
78d2650d5e676ca257e2c325bad9f7a7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|32|1|V|rust
	                let qi = p.qs[i];
4f89863e2981ef3c745be8e19b3d5d28|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|36|1|V|rust
	                let df = (fip1 - fim1) / (qip1 - qim1);
1907dd21c762d1f00a4325fb8200305a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|29|1|V|rust
	            let sig = p.model.sigmav(x,
c768ffe9468c713ba81bdf58a99fc0d6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|52|1|V|rust
	                    let qj = p.qs[j];
7965ac31d798a17ffd5f6a0eb0ceff86|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|55|1|V|rust
	                    let sigij = p.model.sigmav(x, qi, qj);
7b9b00b06787b95d8a33147f7968e842|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|45|1|V|rust
	                // momenta
	                let qi = p.qs[i];
	                let qip1 = p.qs[i + 1];
	                let qim1 = p.qs[i - 1];
	                let xq = (x * x + qi * qi).sqrt();
03778a5dddc976f6a851bcdc9b5de203|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|66|34|v|rust
	qj*qj *sigij*(feqi * feqj - fi * fj) +
2aad1b317c59e368b15fda8e5b10b414|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|1|V|rust
	                    let fj = f[j];
299bf93abcc4094d573e3b10e7896c81|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|62|1|V|rust
	                    let feqj = p.model.feq(x, qj);
8b528ffcc9e8866a10a9db94ea597d7a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|21|v|rust
	qj * qj * sigij * (feqi * feqj - fi * fj)
	                        + qjp1 * qjp1 * sigijp1 * (feqi * feqjp1 - fi * fjp1)
115616187fabe921aecfb4085690067d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|81|28|v|rust
	mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2))
681c717d2495946f43a08c2047c5c325|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|18|8|v|rust
	avg_cross_section
6f73bf00d7a037bd7159a095c99f5728|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|11|11|v|rust
	FullBoltzmann
7b721831176cc2e409c66855f4e39082|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|20|21|v|rust
	, x: f64
8c94c142fb05bd067a5b6973dd74ed23|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|19|1|V|rust
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
0ede032eb767c096430956481189cd3d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|1|V|rust
	            let n = f.shape()[0];
	            let gam = p.model.gamma(x);
	            let gt = gefft(x);
	            let ht = hubblet(x);
	            let g = p.model.g();
	            let mx = p.model.dm_mass();
	            let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	
	            for i in 0..n {
	                // momenta
	                let qi = p.qs[i];
	                let qip1 = p.qs[i + 1];
	                let qim1 = p.qs[i - 1];
	                let xq = (x * x + qi * qi).sqrt();
	                // PS density
	                let fi = f[i];
	                let fip1 = f[i + 1];
	                let fim1 = f[i - 1];
	                let feqi = p.model.feq(x, qi);
	                // Derivative of f(x,q)
	                let df = (fip1 - fim1) / (qip1 - qim1);
	                let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	
	                let mut term1: f64 = 0.0;
	
	                for j in 0..n {
	                    // Momentum
	                    let qj = p.qs[j];
	                    let qjp1 = p.qs[j + 1];
	                    let dqj = qjp1 - qj;
	                    // PS densities
	                    let fj = f[j];
	                    let fjp1 = f[j + 1];
	                    let feqj = p.model.feq(x, qj);
	                    let feqjp1 = p.model.feq(x, qjp1);
	                    // Cross-sections
	                    let sigij = p.model.sigmav(x, qi, qj);
	                    let sigijp1 = p.model.sigmav(x, qi, qjp1);
	
	                    term1 += dqj / 2.0
	                        * (qj * qj * sigij * (feqi * feqj - fi * fj)
	                            + qjp1 * qjp1 * sigijp1 * (feqi * feqjp1 - fi * fjp1));
	                }
	
	                let term2 = gam / (2.0 * ht * x)
	                    * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi);
	                let term3 = gt * qi / x * df;
	
	                deriv[i] = pre * term1 + term2 + term3;
	            }
0da2cd5512d15f6f1f5959580cc9a849|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|17|V|rust
	                deriv[i] = pre * term1 + term2 + term3;
9e5698a8d0869b22397b3660e1ee0123|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|136|1|V|rust
	                let term2 = gam / (2.0 * ht * x)
	                    * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi);
	                let term3 = gt * qi / x * df;
8140fdfaf3f7c9932e1609244255fe35|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|15|V|rust
	    let dfdu =
	        |mut jac: ArrayViewMut2<f64>, f: ArrayView1<f64>, x: f64, p: &FullBoltzmannParams<T>| {
	            let n = f.shape()[0];
	            let gam = p.model.gamma(x);
	            let gt = gefft(x);
	            let ht = hubblet(x);
	            let g = p.model.g();
	            let mx = p.model.dm_mass();
	            let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	
	            for i in 0..n {
	                // momenta
	                let qi = p.qs[i];
	                let qip1 = p.qs[i + 1];
	                let qim1 = p.qs[i - 1];
	                let xq = (x * x + qi * qi).sqrt();
	                // PS density
	                let fi = f[i];
	                let fip1 = f[i + 1];
	                let fim1 = f[i - 1];
	                let feqi = p.model.feq(x, qi);
	                // Derivative of f(x,q)
	                let df = (fip1 - fim1) / (qip1 - qim1);
	                let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	
	                let term2 = gam / (2.0 * ht * x)
	                    * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi);
	                let term3 = gt * qi / x * df;
	
	                let mut term1: f64 = 0.0;
	
	                for j in 0..n {
	                    // Momentum
	                    let qj = p.qs[j];
	                    let qjp1 = p.qs[j + 1];
	                    let dqj = qjp1 - qj;
	                    // PS densities
	                    let fj = f[j];
	                    let fjp1 = f[j + 1];
	                    let feqj = p.model.feq(x, qj);
	                    let feqjp1 = p.model.feq(x, qjp1);
	                    // Cross-sections
	                    let sigij = p.model.sigmav(x, qi, qj);
	                    let sigijp1 = p.model.sigmav(x, qi, qjp1);
	
	                    term1 += dqj / 2.0
	                        * (qj * qj * sigij * (feqi * feqj - fi * fj)
	                            + qjp1 * qjp1 * sigijp1 * (feqi * feqjp1 - fi * fjp1));
	                }
	            }
	        };
296e08c3138a5b00346ff3aa74634381|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|1|V|rust
	        let temp1:f64 = m_m2.powi(2);
	        let temp2:f64 = pow(m_m1, 4);
	        let temp3:f64 = pow(m_width2, 2);
	        let temp4:f64 = pow(m_m1, 3);
	        let temp5:f64 = pow(m_m1, 2);
	        let temp6:f64 = pow(m_m2, 4);
	        let temp7:f64 = temp1 + temp3;
	        let temp8:f64 = pow(m_width2, 4);
	        let temp9:f64 = pow(m_m2, 6);
	        let temp10:f64 = pow(m_width2, 6);
	        let temp11:f64 = pow(m_m2, 8);
	        let temp12:f64 = pow(m_width2, 8);
	        let temp13:f64 = pow(m_m2, 10);
	        let temp14:f64 = pow(m_m2, 18);
	        let temp15:f64 = pow(temp7, 5);
	        let temp16:f64 = pow(w, 2);
	        let temp17:f64 = pow(m_m2, 16);
	        let temp18:f64 = pow(temp7, 4);
	        let temp19:f64 = pow(m_m2, 14);
	        let temp20:f64 = pow(temp7, 3);
	        let temp21:f64 = pow(m_m2, 12);
	        let temp22:f64 = pow(temp7, 2);
	        let temp23:f64 = pow(temp7, 6);
	        let temp24:f64 = pow(m_m1, 29);
	        let temp25:f64 = pow(m_m1, 28);
	        let temp26:f64 = pow(m_m1, 30);
	        let temp27:f64 = pow(w, 3);
	        let temp28:f64 = pow(m_m1, 26);
	        let temp29:f64 = pow(m_m1, 27);
	        let temp30:f64 = pow(m_m1, 24);
	        let temp31:f64 = pow(m_m1, 25);
	        let temp32:f64 = pow(m_m1, 5);
	        let temp33:f64 = pow(m_m1, 21);
	        let temp34:f64 = pow(m_m1, 22);
	        let temp35:f64 = pow(m_m1, 23);
	        let temp36:f64 = pow(m_m1, 20);
	        let temp37:f64 = pow(m_m1, 17);
	        let temp38:f64 = pow(m_m1, 9);
	        let temp39:f64 = pow(m_m1, 18);
	        let temp40:f64 = pow(m_m1, 8);
	        let temp41:f64 = pow(m_m1, 6);
	        let temp42:f64 = pow(m_m1, 16);
	        let temp43:f64 = pow(m_m1, 19);
	        let temp44:f64 = pow(m_m1, 7);
	        let temp45:f64 = pow(m_m1, 14);
	        let temp46:f64 = pow(m_m1, 10);
	        let temp47:f64 = pow(m_m1, 15);
	        let temp48:f64 = pow(m_m1, 12);
	        let temp49:f64 = pow(m_m1, 11);
	        let temp50:f64 = pow(m_m1, 13);
71c4313a98f133e2d7bf873601938c42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|59|9|v|rust
	8.0
	            * (self.ce.powi(2) + self.cm.powi(2)).powi(2)
	            * temp4
	            * (temp2 + temp1 * temp3 - 2 * temp1 * temp5 + temp6)
	            * pow(w, 8)
	            * (365472 * temp14 * temp15 * temp16
	                + (740745 * temp1 + 413042 * temp16) * temp25
	                + 63595 * temp26
	                + temp1 * temp28 * (436745 * temp1 + 5992788 * temp16 + 91185 * temp3)
	                + 1728
	                    * temp17
	                    * temp18
	                    * temp5
	                    * (569 * temp16 * temp3
	                        + 6 * temp1 * (71 * temp16 + 315 * temp3)
	                        + 1890 * temp6)
	                + 2 * temp34
	                    * temp6
	                    * (4014688 * temp16 * temp3
	                        + temp1 * (-38345168 * temp16 + 2655410 * temp3)
	                        + 8860695 * temp6
	                        + 15275 * temp8)
	                + temp30
	                    * (245938 * temp1 * temp16 * temp3
	                        + (13450346 * temp16 + 1706015 * temp3) * temp6
	                        - 10777345 * temp9)
	                + 2 * temp39
	                    * (1205 * temp10
	                        + 5 * (4946156 * temp16 + 154811 * temp3) * temp6
	                        + 2106324 * temp16 * temp8
	                        + temp1 * (-69172784 * temp16 * temp3 + 4515595 * temp8)
	                        - 75607855 * temp9)
	                    * temp9
	                - 36 * temp19
	                    * temp2
	                    * temp20
	                    * (2 * (73658 * temp16 + 292485 * temp3) * temp6
	                        + temp1 * (50304 * temp16 * temp3 - 7905 * temp8)
	                        - 4692 * temp16 * temp8
	                        + 592875 * temp9)
	                + 2 * temp36
	                    * temp6
	                    * ((66429754 * temp16 - 13453320 * temp3) * temp6
	                        + 34262 * temp16 * temp8
	                        + temp1 * (22383072 * temp16 * temp3 + 613105 * temp8)
	                        + 13609415 * temp9)
	                + temp13
	                    * temp46
	                    * temp7
	                    * (50973925 * temp11 - 9 * (35 * temp12 + 16092 * temp10 * temp16)
	                        + temp6 * (658540268 * temp16 * temp3 - 35793090 * temp8)
	                        + 20 * temp1 * (47789 * temp10 + 4473339 * temp16 * temp8)
	                        + (724794260 * temp16 - 27247260 * temp3) * temp9)
	                + 48 * temp21
	                    * temp22
	                    * temp41
	                    * (1311465 * temp11
	                        + 189 * temp10 * temp16
	                        + temp6 * (1704619 * temp16 * temp3 + 151365 * temp8)
	                        + temp1 * (-6795 * temp10 + 535251 * temp16 * temp8)
	                        + (1474357 * temp16 + 1469625 * temp3) * temp9)
	                + temp11
	                    * temp45
	                    * (-247599705 * temp11 - 865 * temp12
	                        + 280464 * temp10 * temp16
	                        + temp6 * (782252656 * temp16 * temp3 - 53538830 * temp8)
	                        + 20 * temp1 * (298201 * temp10 + 562252 * temp16 * temp8)
	                        - 20 * (-54220084 * temp16 + 15398371 * temp3) * temp9)
	                + 2 * temp42
	                    * temp9
	                    * (134103655 * temp11
	                        - 2634 * temp10 * temp16
	                        - temp6 * (40111446 * temp16 * temp3 + 8049355 * temp8)
	                        + temp1 * (175475 * temp10 + 25973742 * temp16 * temp8)
	                        + (-290753742 * temp16 + 74643625 * temp3) * temp9)
	                - temp13
	                    * temp40
	                    * temp7
	                    * (96619485 * temp13 - 162 * temp12 * temp16
	                        + 15 * temp1 * (1355 * temp12 + 61176 * temp10 * temp16)
	                        + 2 * temp11 * (144511991 * temp16 + 59013150 * temp3)
	                        + temp6 * (-7996020 * temp10 + 162459748 * temp16 * temp8)
	                        + 2 * (218370964 * temp16 * temp3 + 6695235 * temp8) * temp9)
	                + temp11
	                    * temp48
	                    * (95976965 * temp13 - 3294 * temp12 * temp16
	                        + temp1 * (-8715 * temp12 + 16443408 * temp10 * temp16)
	                        + 2 * temp11 * (-565359371 * temp16 + 120083490 * temp3)
	                        + 4 * temp6 * (2022905 * temp10 - 94198711 * temp16 * temp8)
	                        + 2 * (-732604144 * temp16 * temp3 + 69665175 * temp8) * temp9)
	                - 272160 * m_m1 * temp14 * temp15 * w
	                + 90740 * temp24 * w
	                + 765880 * temp1 * temp29 * w
	                - 20 * temp1 * (140423 * temp1 - 7337 * temp3) * temp31 * w
	                + 6480 * temp17 * temp18 * (1697 * temp1 + 897 * temp3) * temp4 * w
	                - 40 * (265467 * temp1 - 59581 * temp3) * temp35 * temp6 * w
	                - 1080
	                    * temp19
	                    * temp20
	                    * temp32
	                    * (33130 * temp1 * temp3 + 46547 * temp6 + 455 * temp8)
	                    * w
	                + 40 * temp33
	                    * temp6
	                    * (-23725 * temp1 * temp3 + 2631056 * temp6 + 2007 * temp8)
	                    * w
	                - 160
	                    * temp43
	                    * (425630 * temp1 * temp3 + 2302858 * temp6 - 16691 * temp8)
	                    * temp9
	                    * w
	                + 120
	                    * temp21
	                    * temp22
	                    * temp44
	                    * (-467 * temp10
	                        + 854067 * temp3 * temp6
	                        + 129333 * temp1 * temp8
	                        + 794107 * temp9)
	                    * w
	                - 80 * temp11
	                    * temp47
	                    * (-15682 * temp10
	                        + 9043644 * temp3 * temp6
	                        + 1216791 * temp1 * temp8
	                        + 11445371 * temp9)
	                    * w
	                + 40 * temp37
	                    * temp9
	                    * (587 * temp10
	                        + 8141273 * temp3 * temp6
	                        + 272263 * temp1 * temp8
	                        + 18423717 * temp9)
	                    * w
	                - 40 * temp13
	                    * temp49
	                    * (673190 * temp1 * temp10 + 6529157 * temp11 - 705 * temp12
	                        + 5677332 * temp6 * temp8
	                        + 11532594 * temp3 * temp9)
	                    * w
	                + 20 * temp11
	                    * temp50
	                    * (679300 * temp1 * temp10 + 34668601 * temp11 - 103 * temp12
	                        + 11939142 * temp6 * temp8
	                        + 43033940 * temp3 * temp9)
	                    * w
	                - 20 * temp13
	                    * temp38
	                    * (-162809 * temp1 * temp12
	                        + 1674283 * temp13
	                        + 4496683 * temp11 * temp3
	                        + 519910 * temp10 * temp6
	                        + 3505182 * temp8 * temp9
	                        + 63 * pow(m_width2, 10))
	                    * w)
	            * pow(sinh(w / (2.0 * T)), -2)
405d3276e5a10d281999270aa5277f77|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|339|33|v|rust
	pow(m_
1699975dd514ab733d9052bc80179d79|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|232|30|v|rust
	pow(m_m1
a7cd83fe6a92873f5118a3dd9edeff2d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|226|19|v|rust
	sinh
a02d7948402a59adfb6476bac4faf666|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|1|V|rust
	lazy_static!{
ed266979f549f3252e64afd8938be3aa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|5|V|rust
	    static ref 
455851a5515f406081e36ed24cf3b637|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|246|1|V|cpp
	    double ce2 = m_ce * m_ce;
	    double cm2 = m_cm * m_cm;
	    double m22 = m_m2 * m_m2;
	    double m12 = m_m1 * m_m1;
	    double m23 = m22 * m_m2;
	    double lam2 = m_lam * m_lam;
	
	    return (ce2 + cm2) * pow(m22 - m12, 3) / (8.0 * M_PI * lam2 * m23);
f0f03e762862456497a6996e28201d01|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|2|1|V|rust
	mod widths;
b6f77d18195cb66c92745469582a08d7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|686|1|V|cpp
	    return gam / (48.0 * pow(M_PI * m_m1, 3) * 2.0 * T);
14c53c8eb7d4236d218e1ff450640e64|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|467|1|V|rust
	       gam / (
fc60b1562597d2ed3343a290f81e09bc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|54|1|v|rust
	    pub fn gamma(&self, x: f64) -> f64 {
	        unimplemented!()
	 
68e4fcd72e87ba52e753d0af1b16fc7d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|54|1|V|rust
	   }
62dca49f0781bf26b4305bddb0414bea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|65|49|v|rust
	100.0
f455a04b64a1b57977e7bc2993f6dba0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|266|1|V|cpp
	    double temp1 = pow(m_m1, 2);
	    double temp2 = pow(Q, 2);
	    double temp3 = -2 * temp1;
	    double temp4 = pow(m_m2, 2);
	    double temp5 = 2 * temp4;
	    double temp6 = temp2 + temp3 + temp5;
	    double temp7 = -4 * temp1;
	    double temp8 = temp2 + temp7;
	    double temp9 = -Q;
	    double temp10 = sqrt(temp8);
	    double temp11 = temp10 + temp9;
	    double temp12 = pow(m_m1, 4);
	    double temp13 = 36 * temp12;
	    double temp14 = pow(m_m2, 4);
	    double temp15 = 36 * temp14;
	    double temp16 = 9 * temp4;
	    double temp17 = 2 * temp2;
	    double temp18 = temp16 + temp17;
	    double temp19 = -8 * temp1 * temp18;
	    double temp20 = pow(Q, 3);
	    double temp21 = Q + temp10;
	    double temp22 = pow(m_width2, 2);
	    double temp23 = temp2 + temp22;
	    double temp24 = -12 * temp23 * temp4;
	    double temp25 = pow(m_m1, 8);
	    double temp26 = pow(m_m1, 6);
	    double temp27 = -4 * temp26 * temp4;
	    double temp28 = pow(m_m2, 6);
	    double temp29 = -6 * temp22 * temp4;
	    double temp30 = pow(m_width2, 4);
	    double temp31 = temp14 + temp29 + temp30;
	    double temp32 = temp14 * temp31;
	    double temp33 = -temp10;
	    double temp34 = Q + temp33;
	    double temp35 = Q * temp34;
	    double temp36 = temp3 + temp35 + temp5;
	    double temp37 = 1 / temp36;
	    double temp38 = 2 * m_m2 * temp37 * m_width2;
	    double temp39 = atan(temp38);
	    double temp40 = pow(Q, 4);
	    double temp41 = 3 * temp14;
	    double temp42 = -7 * temp22 * temp4;
	    double temp43 = temp41 + temp42;
	    double temp44 = 2 * temp12 * temp43;
	    double temp45 = -5 * temp14 * temp22;
	    double temp46 = temp28 + temp45;
	    double temp47 = -4 * temp1 * temp46;
	    double temp48 = temp25 + temp27 + temp32 + temp44 + temp47;
	    double temp49 = Q * temp21;
	    double temp50 = temp3 + temp49 + temp5;
	    double temp51 = 1 / temp50;
	    double temp52 = 2 * m_m2 * temp51 * m_width2;
	    double temp53 = atan(temp52);
	    double temp54 = -temp4;
	    double temp55 = temp1 + temp54;
	    double temp56 = -(temp22 * temp4);
	    double temp57 = temp14 + temp56;
	    double temp58 = 6 * temp12 * temp57;
	    double temp59 = -3 * temp14 * temp22;
	    double temp60 = temp28 + temp59;
	    double temp61 = -4 * temp1 * temp60;
	    double temp62 = temp25 + temp27 + temp32 + temp58 + temp61;
	    double temp63 = 2 * temp1;
	    double temp64 = -2 * temp1 * temp4;
	    double temp65 = temp12 + temp14 + temp56 + temp64;
	    double temp66 = -2 * temp4;
	    double temp67 = Q * temp10;
	    return (pow(pow(m_ce, 2) + pow(m_cm, 2), 2) * (-12 * temp2 * temp39 * temp48 +
	            48 * temp1 * temp22 * temp4 * temp40 * temp53 + 12 * temp2 * temp48 * temp53 +
	            24 * temp39 * temp55 * temp62 - 24 * temp53 * temp55 * temp62 -
	            (m_m2 * Q * temp11 * (temp13 + temp15 + temp19 + temp11 * temp20 +
	                    temp24) * temp6 * m_width2) / 2. - (m_m2 * Q * temp21 * (temp13 + temp15 + temp19
	            - temp20 * temp21 + temp24) * temp6 * m_width2) / 2. +
	            48 * temp1 * temp22 * temp4 * temp40 * atan((2 * m_m2 * m_width2) / (-temp2 +
	                    temp63 + temp66 + temp67)) + 6 * m_m2 * ((temp12 - 4 * temp1 * temp4 -
	            temp4 * (temp22 + temp4)) * temp40 + 8 * pow(temp55, 2) * temp65 -
	            4 * temp2 * (temp54 + temp63) * temp65) * m_width2 * log((temp12 + temp14 +
	            (temp20 * temp21) / 2. - temp1 * (Q * (2 * Q + temp10) + temp5) + temp4 * (temp2
	            + temp22 + temp67)) / (temp12 + temp14 + (temp20 * temp34) / 2. +
	            (-(Q * temp10) + temp2 + temp22) * temp4 + temp1 * (Q * (-2 * Q + temp10) +
	            temp66))))) / (96. * pow(m_lam, 4) * m_m2 * M_PI * pow(Q, 2) * temp6 * temp8 * m_width2);
df14e1892e491233674c7e3acfd1750c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|10|21|v|rust
	pow(m
3a6a73a8d1573fcb05283afb5b516c57|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|22|22|v|rust
	pow(m_m2
26ebc2559159d7f68e26a77d20d95d93|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|28|22|v|rust
	pow(Q
3cb4f1834954eac3b193ebce9b6c11b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|35|21|v|rust
	 pow(
fb734a4f8106f70a7d778a645d0d7344|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|48|22|v|rust
	atan(
6d86bcdc87773d8bb8527c65ed349b97|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|83|54|v|rust
	atan
e9843febae23a8e07254abec1963c946|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|90|40|v|rust
	pow(m_l
f03cbc68bfbac5c1af7f36e0f53d20d2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|20|1|V|rust
	    /// Integrator for computing gamma
	    pub(super) gk_gamma: GaussKronrodIntegrator,
e51cc2de3e75add81bebff1046c2b541|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|28|1|V|rust
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .singular_points(vec![mh - ml])
	            .build();
27a00d305d1a940d4268cb689939aaf4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|38|13|V|rust
	            .singular_points(vec![mh - ml])
6b076469075efcfe60ea2b613b675732|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|56|1|V|rust
	            gk_gamma,
d2e4973307b4086c66b54a26e4a81769|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|131|1|V|rust
	            let E1 = (q*q - self.ml*self.ml).sqrt();
91df1e2a5cac87d29854c7e4bce88316|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|136|16|v|rust
	k.kt = 
b08d3adb29a9d667eb0ecbdc8f7e1d70|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|64|1|V|rust
	    pub fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        unimplemented!()
	    }
74e2025c50ff86a448f0848fbda9f8a3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|63|1|V|rust
	impl DipoleDm {
	}
48f623786593bd21959b2a307b77989f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|12|1|V|rust
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate
	    fn gamma(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, x: f64, qi: f64, qj: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
4d7c4df74b325044e5a7248aa40e8fc9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|65|5|V|rust
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
6d7412177c53315d5eb1c8f606d4a16f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|65|5|V|rust
	    /// x = m / T.
f82cd75a9b48f8a0c6ebb7561c3e05ef|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|66|5|V|rust
	    /// Momentum exchange rate
45f2f15de1c7e24ea20811b60bce8002|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|67|5|V|rust
	    /// velocity-weighted  cross  section  averaged  over angles
fc2f04d62b866b66ee04e4303ff4c3e4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|68|5|V|rust
	    /// Dark matter mass
3e0e2d78285467eba8b0fc1b0198b004|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|69|5|V|rust
	    /// Dark matter d.o.f.
bd4f4772b6d8a08d61faa8916e4b9e5f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|462|1|V|rust
	    pub fn gamma(&self, x: f64) -> f64 {
	        let f = |w: f64| self.gamma_integrand(w, x);
	        let gam = self.gk_gamma.integrate(&f, 0.0, f64::INFINITY).val;
	
	        gam / (48.0 * (std::f64::consts::PI * self.ml).powi(3) * 2.0 * self.ml / x)
	    }
a1a6a804e81482b145f38e7c46787d0a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|129|9|v|rust
	fn sigmav_avg(&self, x: f64, q: f64, qt: f64) -> f64 {
	        let temp = self.ml / x;
	        let k = q * temp;
	        let kt = qt * temp;
	        let f = |theta: f64| -> f64 {
	            let e1 = (k * k - self.ml * self.ml).sqrt();
	            let e2 = (kt * kt - self.mh * self.mh).sqrt();
	            // (E1;k).(E2;kt)
	            let dot = e1 * e2 - k * kt * theta;
	
	            let vmol = (dot * dot - self.ml.powi(4)).sqrt() / (e1 * e2);
	            let cme = 2.0 * self.ml * self.ml + 2.0 * dot;
	            self.sigma_ll_to_gg(cme) * vmol
	        };
	        self.gk_sig.integrate(f, -1.0, 1.0).val / 2.0
	    }
	
ab00acabd8d252e5a5467f87f90107bd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|129|1|V|rust
	    pub fn sigmav_avg(&self, x: f64, q: f64, qt: f64) -> f64 {
	        let temp = self.ml / x;
	        let k = q * temp;
	        let kt = qt * temp;
	        let f = |theta: f64| -> f64 {
	            let e1 = (k * k - self.ml * self.ml).sqrt();
	            let e2 = (kt * kt - self.mh * self.mh).sqrt();
	            // (E1;k).(E2;kt)
	            let dot = e1 * e2 - k * kt * theta;
	
	            let vmol = (dot * dot - self.ml.powi(4)).sqrt() / (e1 * e2);
	            let cme = 2.0 * self.ml * self.ml + 2.0 * dot;
	            self.sigma_ll_to_gg(cme) * vmol
	        };
	        self.gk_sig.integrate(f, -1.0, 1.0).val / 2.0
	    }
be296381f5c6306bdc00f968b85aea1b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|92|5|V|rust
	    fn sigmav(&self, x: f64, qi: f64, qj: f64) -> f64
8477cdadad43069ef6389609b1a167a7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|74|22|v|rust
	self.ml*self.ml
21d9b7693f177aae57a15d9c5e9a6852|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|73|9|V|rust
	        let k = q * t;
b3e3478c2be56fdcdc975177b0ecf089|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|72|9|V|rust
	        let t = self.ml / x;
fbddd0eb3f234f73a7315c2465192b57|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|83|17|v|rust
	let term2 = 
11f6efb0edf5f0356c29d749044cc00e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|17|v|rust
	let term3 = 
2f7f68f3c88d61f71188382aaa382a2d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|48|1|V|rust
	                // momenta
	                let qi = p.qs[i];
	                let qip1 = p.qs[i + 1];
	                let qim1 = p.qs[i - 1];
	                let xq = (x * x + qi * qi).sqrt();
	                // PS density
	                let fi = f[i];
	                let fip1 = f[i + 1];
	                let fim1 = f[i - 1];
	                let feqi = p.model.feq(x, qi);
	                // Derivative of f(x,q)
	                let df = (fip1 - fim1) / (qip1 - qim1);
	                let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	
2dd1e83f09460f1bee33a7fa331c8f85|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|56|1|V|rust
	                let fim1 = if i == 0 { f[0] } else { f[i - 1] };
02469a909d2c8a42539a60882a2c496b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|51|17|V|rust
	                let qim1 = if i == 0 { p.qs[0] } else { p.qs[i - 1] };
11075085d19b3979ca8d40056afaa2b8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|17|v|rust
	let df = 
59c2115abee98ecfaf84081d720d3e76|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|17|v|rust
	let d2f = 
3bae428dc11803193e69f2dd00061981|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|58|32|v|rust
	if i == 0 { p.qs[0] } else { 
28f70d116d7c020d609a598e74b780a6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|59|32|v|rust
	if i == 0 { f[0] } else { 
7d42b86c49d496c985b4aa947647df61|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|56|17|V|rust
	                // Derivative of f(x,q)
28a2fa47639f65efd1d1ddaa7090da23|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|57|22|v|rust
	df, d2f
15d286ba732ad6773b1d89a052fc99b9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|63|21|V|rust
	                    )
df099f2c4e7de5e0d476388f0bdb7f94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|17|V|rust
	                    (
a3b037b04b6bcfdc265c75a983cfc27a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|87|1|V|rust
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
78348d75efeeda1d622bb2a652d1494b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|1|V|rust
	                let (term2, term3) = if i != n - 1 {
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
	                } else {
	                    (0.0, 0.0)
	                };
	
428391b32a07c0fbb02d04272692e5fe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|57|1|V|rust
	                // second and third terms:
	                let (term2, term3) = if i != 0 {
	                    let qim1 = p.qs[i - 1];
	                    let fim1 = f[i - 1];
	                    let df = (fip1 - fim1) / (qip1 - qim1);
	                    let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
	                } else {
	                    (0.0, 0.0)
	                };
4d1c7c2403dd05fa9d8da1f6cf8e0542|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|98|26|v|rust
	OdeIntegrato
c5b8c6d3c92c5695432c29fc2e7d16ac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|72|1|V|rust
	        let e = (q * q + x * x).sqrt(); // energy / temperature
	        1.0 / (e.exp() + 1.0)
f8f7f078e16aea2b1b008a29ae0c7c33|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|100|9|v|rust
	(i,q)
bd20d258a028de5dcbaff4a491e81d9e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|35|9|v|rust
	tspan
20f35e630daf44dbfa4c3f68f5399d8c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|101|20|v|rust
	model
f6526c88fdd909782e3db76614a609bc|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|228|20|v|cpp
	 sm_sqrt_gstar(T) * sqrt(sm_geff(T)) / sm_heff(T) - 1.0;
ffcc2ce7253ccbd16b444c1d0f820902|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|228|1|V|cpp
	        double gt = sm_sqrt_gstar(T) * sqrt(sm_geff(T)) / sm_heff(T) - 1.0;
f01cdc85bb3a52088a859ddd35b7b03d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|29|9|v|rust
	double gt = 
56bce233e6a746a0cbf6c29ce685edc9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|5|V|rust
	    unimplemented!()
0ea9165a3754afee004a4b5aba3a25a3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|227|20|v|cpp
	sqrt(4.0 * pow(M_PI, 3) * sm_geff(T) / 45.0) * T * T / kM_PLANK;
	
363f5764d1fbf361e24aecd6ffb2a280|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/dipole_dm.hpp|229|21|v|cpp
	H / (1.0 + gt);
5d7698ab6621855690a8918cb8934880|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|34|5|V|rust
	    H / (1.0 + gt);
68b4d474a53494eb4509a9a74856b643|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|34|5|V|rust
	    let h = (4.0 * PI.powi(3) * sm_geff(temp) / 45.0).sqrt() * temp * temp / M_PLANK;
07cd367e97f58140f7fd7b5c587807da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|6|25|v|rust
	{
	        ml: 100.0,
	        mh: 100.1,
	        lam: 1e4,
	
	    };
	
75fff6426bc9d7515ad513e61dec9cd8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|17|V|rust
	                let qip1 = p.qs[i + 1];
aeb643801fb91675e9c64ce6a91a45b4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|63|17|V|rust
	                let fip1 = f[i + 1];
42a5323f0ece367a4e4096c7431c0989|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|88|1|V|rust
	                    let fip1 = f[i + 1];
	                    let qip1 = p.qs[i + 1];
	                    let qim1 = p.qs[i - 1];
	                    let fim1 = f[i - 1];
	                    let df = (fip1 - fim1) / (qip1 - qim1);
	                    let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
6672f7075576cce7d0ad9eddf16e60b3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|100|1|V|rust
	                    let fip1 = f[i + 1];
e202db52a87a77b842e881424fbc85fe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|107|1|V|rust
	                    let fim1 = f[i - 1];
0218b0c432841b7cbc60c499b72acca6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|106|38|v|rust
	fim1
f03146a3f076de70afa5d3591a415e72|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|106|52|v|rust
	qim1
5aa594446fbfe20ba21bc1d56b0c5990|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|58|17|V|rust
	                println!("i={}
c2e0dbac5bae2319ec9ff99083c9ee59|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|131|5|V|rust
	    integrator.integrate();
f80da366ac47d3dfeb5117f5c598a2d1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|132|5|V|rust
	    integrator.sol
ef0b633f0f8fc2ab4782815c9cc311c0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|43|3|v|rust
	-> OdeSolution
507da2f21f9bc2685ae307767bc1dc2f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|5|V|rust
	    for (t, u) in sol {
2cead58f96c5aa0406506a4b9104081c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|9|V|rust
	        println!("{}, {:?}", t, u);
9371431c83484ef652fe2bf7c800f039|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|17|5|v|rust
	let sol = 
aa18f2dbd86ff2d37b6edba425a1faa9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|17|V|rust
	                println!("{}", i);
528349c77054aa791648e9ffd6231202|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|123|20|v|rust
	&mut
fa47c6f11a33e30f73fc48091659cd57|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|123|29|v|rust
	).into_iter()
1050a42c14767def6a0405fa46172e06|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|1|V|rust
	    let xspan = (xmin, xmax);
	    let fbp = FullBoltzmannParams { qs, model };
ccba1fafc183e71b088bf44fb7bdf6a5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|1|33|v|mma
	Higgs-Portal DM
c0a253c83be3c131b64561c17f63ac01|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|445|1|V|mma
	    S[12] == {
	        ClassName      -> smp,
	        Unphysical     -> True,
	        SelfConjugate  -> True,
	        Definitions    -> {smp -> cmix * sm + smix * H}
	    }
3949db6b1d6e4b41e1be25bcbc8c1484|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|631|1|V|mma
	    smix == {
	        ParameterType    -> External,
	        BlockName        -> DMBLOCK,
	        OrderBlock       -> 1,
	        InteractionOrder -> {NPMIX, 1},
	        Value            -> 1.0*^-3,
	        TeX              -> Sin[Subscript[\[Theta], mix]],
	        Description      -> "Sine of higgs-scalar-mediator mixing angle"
	    },
	    gSXX == {
	        ParameterType    -> External,
	        BlockName        -> DMBLOCK,
	        OrderBlock       -> 2,
	        InteractionOrder -> {NP, 1},
	        Value            -> 1.0,
	        TeX              -> Subscript[g, SXX],
	        Description      -> "coupling of DM to scalar-mediator"
	    },
e36d2e6e750c56b2fbbd906c58560765|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|630|1|V|mma
	    (* Dark matter parameters *)
96170860c3d11e006cc2015033981907|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|269|1|V|mma
	    (* Fermionic dark matter *)
	    F[5] == {
	        ClassName        -> chi,
	        SelfConjugate    -> False,
	        Mass             -> {MDM, 5000.0},
	        Width            -> 0,
	        PropagatorLabel  -> "~chi",
	        PropagatorType   -> Straight,
	        PropagatorArrow  -> Forward,
	        PDG              -> 52,
	        ParticleName     -> "~chi",
	        AntiParticleName -> "~chibar",
	        FullName         -> "dark-matter"
	    },
c55ac3c6a9df264ddc151977aec96f11|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|763|40|v|mma
	1 - smix^2
08c3b84980b3e6c3a146252e0e5cd0fa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|763|1|V|mma
	        Definitions   -> {MSp -> (Sqrt[] * Sqrt[-MH^2 + MSM^2 + (MH^2 + MSM^2)/(1 - 2*smix^2)])/Sqrt[1 + 1/(1 - 2*smix^2)]},
569bad18df8db8438d99d28aad8b4e82|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|763|41|v|mma
	 * Sqrt[-MH^2 + MSM^2 + (MH^2 + MSM^2)/(1 - 2*smix^2)])/Sqrt[1 + 1/(1 - 2*smix^2)]
179738bc7fe95e8d7ef15ff70820d64e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|761|1|V|mma
	    MSp == {
	        ParameterType -> Internal,
	        Definitions   -> {MSp -> (Sqrt[]},
	        TeX           -> Subscript[c, 1],
	        Description   -> "coupling of scalar-mediator to Higgs"
	    }
6a3a3d28eface27cdb26881cc2cb9a78|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|748|5|v|mma
	cmix 
1467834bc624c609706be16bd6a5650c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|747|1|V|mma
	    (* dark matter parameters *)
	    lamS == {
	        ParameterType    -> Internal,
	        Definitions      -> {cmix -> Sqrt[1 - smix^2]},
	        TeX              -> Cos[Subscript[\[Theta], mix]],
	        Description      -> "Cosine of higgs-scalar-mediator mixing angle"
	    },
	    c1 == {
	        ParameterType    -> Internal,
	        Definitions      -> {c1 -> ((MH - MSM) * (MH + MSM) * Sqrt[1 - smix^2] * smix) / vev},
	        InteractionOrder -> {NPMIX, 1},
	        TeX              -> Subscript[c, 1],
	        Description      -> "coupling of scalar-mediator to Higgs"
	    }
90fad49509e115ca46890f67733c1497|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|608|1|V|mma
	    Vtb == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 9,
	        Value         -> 0.999105,
	        TeX           -> Subscript[V, tbR],
	        Description   -> "Magnitude of t-b CKM"
	    },
604f492e2d138c2421acd793895804e1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|618|9|V|mma
	        BlockName     -> CKMBLOCK,
c7962c6d9577bba218548542acd9a4ff|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|618|9|V|mma
	        OrderBlock    -> 9,
398aec943b484755471cd2bbd9d2e6cd|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|618|26|v|mma
	0.999105,
9139e04b92481058621eb74ec4638f2b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|620|27|v|mma
	Magnitude of t-b CKM
7969adebdb8bdf1fa39bf519edc5bf7c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|616|1|V|mma
	    lamS == {
	        ParameterType -> External,
	        Value         -> 1.0,
	        TeX           -> Subscript[\[Lambda], S],
	        Description   -> "Scalar-Higgs coupling"
	    },
d1fd9925041f6f7a5e496b3d4bec9a1d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|626|33|v|mma
	-Higgs
3fe0c249c787d980df458d453f9cf5d9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|850|11|v|mma
	I * chibar.Ga[mu].del[chi, mu] + 
e538e73173295e9dba33aaeb9d4544df|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|851|12|v|mma
	-MSM * chibar.chi 
34887ebe7656709a68d67082595e7847|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.m|852|11|v|mma
	-gSXX * smp * chibar.chi 
5f93dc4ad2a282b507267441490e7197|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|429|47|v|
	- smix * sm 
34d200e094281a5c3786df4757f28467|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|3|4|v|rust
	 lam_
c297f8a8b69bff7348bab3d65d684882|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|2|9|v|rust
	lam_
4e59f172f34b9ea77ee20c2d2c69e112|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|3|9|v|rust
	quartic
f58469618191cfa7534a8f73bbcd5e63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|24|10|v|rust
	pow(lamS
4b349e5c3414e137795f8734d56e028b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|9|1|V|rust
	    pub fn gamma_integrand_sf_sf(&self, w: f64, x: f64, mf: f64, ncol: f64) -> f64 {
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        let temp1: f64 = mf.powi(2);
	        let temp2: f64 = mh.powi(2);
	        let temp3: f64 = ms.powi(2);
	        let temp4: f64 = mh.powi(-2);
	        let temp5: f64 = 2.0 * w;
	        let temp6: f64 = ms + temp5;
	        let temp7: f64 = -4.0 * temp3;
	        let temp8: f64 = temp2 + temp7;
	        let temp9: f64 = temp1 * temp8;
	        let temp10: f64 = w.powi(2);
	        let temp11: f64 = 4.0 * ms * temp10;
	        let temp12: f64 = temp2 * temp6;
	        let temp13: f64 = temp11 + temp12;
	        let temp14: f64 = ms * temp13;
	        let temp15: f64 = temp14 + temp9;
	
	        (self.lam_hs.powi(2)
	            * ncol
	            * temp1
	            * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	            / 2.0
	    }
721b8f9e3fd357431087f8078e7ec11b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|36|27|v|rust
	_sf_sf
a50a1b2d2b06b11f4b2ed457204ff32c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|37|1|V|rust
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        let temp1: f64 = mf.powi(2);
	        let temp2: f64 = mh.powi(2);
	        let temp3: f64 = ms.powi(2);
	        let temp4: f64 = mh.powi(-2);
	        let temp5: f64 = 2.0 * w;
	        let temp6: f64 = ms + temp5;
	        let temp7: f64 = -4.0 * temp3;
	        let temp8: f64 = temp2 + temp7;
	        let temp9: f64 = temp1 * temp8;
	        let temp10: f64 = w.powi(2);
	        let temp11: f64 = 4.0 * ms * temp10;
	        let temp12: f64 = temp2 * temp6;
	        let temp13: f64 = temp11 + temp12;
	        let temp14: f64 = ms * temp13;
	        let temp15: f64 = temp14 + temp9;
	
	        (self.lam_hs.powi(2)
	            * ncol
	            * temp1
	            * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	            / 2.0
89c64f30426c48550e85c81a5a6db037|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|1|1|V|rust
	use haliax_constants::masses::HIGGS_MASS;
5249abbb069dc7ff976101f5b536d89d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|2|31|v|rust
	HIGGS_MASS
959233c503a33908dea14f6ab3c58b27|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|2|32|v|rust
	TAU_MASS
bce22a7302954092a18586a9bd6ed8da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|2|1|V|rust
	use haliax_constants::masses::{TOP_QUARK_MASS, CHARM_QUARK_MASS,UP_QUARK_MASS,BOTTOM_QUARK_MASS,STRANGE_QUARK_MASS,DOWN_QUARK_MASS,ELECTRON_MASS,MUON_MASS,TAU_MASS};
3f823bd542e12425dc82c2a94d109555|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|2|78|v|rust
	,BOTTOM_QUARK_MASS,STRANGE_QUARK_MASS,DOWN_QUARK_MASS,ELECTRON_MASS,MUON_MASS,TAU_MASS};
b0a0ede06f838d9c6c6e01fc04c243b4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|3|32|v|rust
	TOP_QUARK_MASS, CHARM_QUARK_MASS,UP_QUARK_MASS,
0c7770c60d078e87547f7c8975eda64a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|3|79|v|rust
	_MASS,ELECTRON_MASS,MUON_MASS,TAU_MASS};
effdffd4b924ef68d7837853b75c003f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|4|32|v|rust
	TOP_QUARK_MASS, CHARM_QUARK_MASS,UP_QUARK_MASS,BOTTOM_QUARK_MASS,STRANGE_QUARK_MASS,DOWN_QUARK_MASS,
d107b81de9d23c7720052a0adce1907a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|45|1|V|rust
	        sum += self.gamma_integrand_sf_sf(w, x,TOP_QUARK_MASS,3.0);
3c474cc1810bb37150d1be30879975f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|46|48|v|rust
	TOP_QUARK_MASS
664e152f43aa31f78ce4bd42bbe4dca2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|45|1|V|rust
	        sum += self.gamma_integrand_sf_sf(w, x,TOP_QUARK_MASS,3.0);
	        sum += self.gamma_integrand_sf_sf(w, x,CHARM_QUARK_MASS,3.0);
	        sum += self.gamma_integrand_sf_sf(w, x,UP_QUARK_MASS,3.0);
84b22646d5076f7a6fcbc49da6540792|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|49|48|v|rust
	CHARM_QUARK_MASS
dd1e45593e4508f586693b7d6325f7a4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|50|48|v|rust
	UP_QUARK_MASS,3.0);
dd80f5d78bd54e9d6c805f1d5dc3e88d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|46|1|V|rust
	        sum += self.gamma_integrand_sf_sf(w, x, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, x, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, x, BOTTOM_QUARK_MASS, 3.0);
396f4c0180148d59ad76443a650aa7b2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|50|49|v|rust
	STRANGE_QUARK_MASS
0929adef9a34a5dcf81d45d76a974870|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|51|49|v|rust
	BOTTOM_QUARK_MASS
a483d2e3948672c2d2a1544a388b090b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|40|49|v|rust
	, mf: f64, ncol: f64) -> f64 {
e95e91a6aa54ba46a0630f814e9fcb3c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|13|47|v|rust
	, x: f6
3fd03f0e32cef071f22cadf1d107e354|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|2|1|V|rust
	use haliax_constants::masses::W_BOSON_MASS;
10dd4f34c6593c31269e50b8e5dccfd5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|3|31|v|rust
	W_BOSON_MASS;
d403821b4ae7de2dd32793c6bbed64b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|5|31|v|rust
	W_BOSON_MASS
359a80ebcabc98e25b62534dbd16435c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|2|23|v|rust
	electroweak::ALPHA_EM;
8d109be9ba66061897d2283d22e0ce74|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|3|1|V|rust
	use haliax_constants::electroweak::SIN_THETA_WEAK;
7de0ab69f7b1a6750a5acecc5d0555ec|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|11|20|v|rust
	prelude 
6930472073161906a1fa50cfbf88e24f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|7|32|v|rust
	(cme * cme);
b53d013247184364b22c44166e4454df|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|8|26|v|rust
	MW.powi(2);
8910747f516181dafcf2846ac7ea7757|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|11|15|v|rust
	lamS
dd4d8b1119162ab07a5b006e16b4e3be|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|23|19|v|rust
	SINW
83393fd019b577f54fd50a9b4902c668|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|25|51|v|rust
	WIDTHH
c78266e1552de294d3b58638996fb317|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|6|1|V|rust
	        let s = cme * cme;
	        let mw = W_BOSON_MASS;
	        let mh = HIGGS_MASS;
632d189b5b060aff5988b3d36e3d7236|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|42|19|v|rust
	pow(MW
86f37c3e8c2bf2288b6380a8595fed91|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|43|19|v|rust
	pow(SINW
aee0527ad2fe3318ba4f275800770d05|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|44|28|v|rust
	pow(ms, 2)
0c0f51cd5fa8719cb146aba101a04256|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|45|51|v|rust
	pow(WIDTHH
715fb04d1a3c0297dab20cba81760da1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|14|33|V|rust
	        ncol * (ALPHA_EM.powi(2)
	            * self.lam_hs.powi(2)
	            * std::f64::consts::PI
	            * temp1
	            * (12.0 * mw.powi(4) + s.powi(2) - 4.0 * s * temp2)
	            * (1.0 - 4.0 * temp1 * temp2).sqrt()
	            * HIGGS_VEV.powi(4))
	            / (16.
	                * mw.powi(4)
	                * SIN_THETA_WEAK_SQRD.powi(2)
	                * (1.0 - 4.0 * self.ms.powi(2) * temp1).sqrt()
	                * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
64b735cce5ba1b992bc0b1df9241f88a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|13|17|v|rust
	MTOP
97cb9d92602cf34f7b8b62d6fd3dd73d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|12|9|V|rust
	        let temp3: f64 = mh.powi(2);
492d0be60fedc06ef0d7d5662b597813|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|11|9|V|rust
	        let temp2: f64 = mw.powi(2);
8f2ee46aa1b17d76df815a6dfaeadc69|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|10|9|V|rust
	        let temp1: f64 = 1.0 / s;
ea6933495ea2e1ba38c30be41ef12c55|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|8|9|V|rust
	        let mw = W_BOSON_MASS;
96cde0916e400d60bcbec9485cc01141|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|9|26|v|rust
	TOP_QUARK_MASS.powi(2);
b34beb38e0170cebefbb05b7adb5baaa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|57|19|v|rust
	COSW
df79f603bf0c82d51b5ef1bc6ecfc6a0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|697|42|v|
	smix
8e92decab2597b563cf0ca94a0be5d57|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|697|37|v|
	(1 - 0^2) * 
993facf52e3f3c9e2d9d2e8618d83932|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|697|45|v|
	(-1 + 1/(1 - 0^2)) * MSM^2
aab9224d8b0a3b3fec13ce3bbfff6de5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|703|35|v|
	Sqrt[1 - smix^2] * 
fe22d2ef19cf9cbf9a72eac9052153cc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|703|47|v|
	(-1 + 1/(1 - smix^2)) * MSM^2
8bf521a7cf08b937c344707ff1ee8655|file:///Users/loganmorrison/Documents/research/KineticRecoupling/mathematica/scalar_singlet/scalar_singlet.fr|703|35|v|
	Sqrt[
8615167a2df3c04314a514bac32a79fb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|85|33|v|rust
	temp17
d982ebbf7b26876432ef0020917f0f7a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|88|33|v|rust
	temp20
0b88fa21de52ff02130eab54048104ae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|101|23|v|rust
	ArcCot
bd637475d2e191e4d9b5e625a1fdf17e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|67|1|V|rust
	        if cme > 2.0 * HIGGS_MASS && cme > 2.0 * self.ms {
2cfd988b6049b2d9efb98056443e9fba|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|47|1|V|rust
	        if cme > 2.0 * Z_BOSON_MASS && cme > 2.0 * self.ms {
ab1666901f535f2dcc8b82f10b00140a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|25|1|V|rust
	        if cme > 2.0 * W_BOSON_MASS && cme > 2.0 * self.ms {
e0ed411abd9e2c41a3fa6b22d244b1ad|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|126|9|V|rust
	        (
415ece355bdeb6b5dc29971def54613c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|126|9|V|rust
	        )
6f11a3d46bcf75c264a013b6df34dfcd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|126|1|V|rust
	        self.sigma_ss_ff(cme, TOP_QUARK_MASS, 3.0) + 
37b44cb7edd62c7948403329f49ff86e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|128|31|v|rust
	TOP_QUARK_MASS, 3.0) + 
c34d58afc60c0a20580288f8f9498d5e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|134|1|V|rust
	        self.sigma_ss_ff(cme, ELECTRON_MASS, 3.0) + 
9a1dffb73145886a13ec6a4a255014ee|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|135|29|v|rust
	, ELECTRON_MASS, 3.0) + 
3f25d408400364cd3c549ded3418832c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|135|1|V|rust
	        self.sigma_ss_zz(cme)
92839e52a438bfe0680c723a50dd14e6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|135|1|V|rust
	        self.sigma_ss_zz(cme) + 
739f5a4ccbb74c9201e5a5974f80c672|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|136|1|V|rust
	        self.sigma_ss_ww(cme) + 
b24858911daa2ead0ad82d0e0b185e2f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|18|1|V|rust
	impl ScalarSinglet {
	    fn gamma_integrand_sf_sf(&self, w: f64, mf: f64, ncol: f64) -> f64 {
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        if w >= mf {
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = mh.powi(2);
	            let temp3: f64 = ms.powi(2);
	            let temp4: f64 = mh.powi(-2);
	            let temp5: f64 = 2.0 * w;
	            let temp6: f64 = ms + temp5;
	            let temp7: f64 = -4.0 * temp3;
	            let temp8: f64 = temp2 + temp7;
	            let temp9: f64 = temp1 * temp8;
	            let temp10: f64 = w.powi(2);
	            let temp11: f64 = 4.0 * ms * temp10;
	            let temp12: f64 = temp2 * temp6;
	            let temp13: f64 = temp11 + temp12;
	            let temp14: f64 = ms * temp13;
	            let temp15: f64 = temp14 + temp9;
	
	            (self.lam_hs.powi(2)
	                * ncol
	                * temp1
	                * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                    + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	                / 2.0
	        } else {
	            0.0
	        }
	    }
	    fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        let temp = x / self.ms;
	        let pre = 1.0 / (48.0 * (self.ms * PI).powi(3) * 1.0) / 8.0;
	        let temp_fac = 1.0 / (2.0 * temp) / (1.0 + (w / temp).cosh());
	        let mut sum = 0.0;
	
	        sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
	        pre * temp_fac * sum
	    }
	    pub fn gamma(&self, x: f64) -> f64 {
	        let f = |w: f64| self.gamma_integrand(w, x);
	        self.gk_gamma.integrate(f, 0.0, f64::INFINITY).val
	    }
	}
e21ba72f40311afb8a101144af9fc58f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|53|1|V|rust
	    pub fn gamma(&self, x: f64) -> f64 {
	        let f = |w: f64| self.gamma_integrand(w, x);
	        self.gk_gamma.integrate(f, 0.0, f64::INFINITY).val
	    }
9afaa78c8cf018e3dcfaa88ab595f3c8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|19|1|V|rust
	    fn gamma_integrand_sf_sf(&self, w: f64, mf: f64, ncol: f64) -> f64 {
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        if w >= mf {
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = mh.powi(2);
	            let temp3: f64 = ms.powi(2);
	            let temp4: f64 = mh.powi(-2);
	            let temp5: f64 = 2.0 * w;
	            let temp6: f64 = ms + temp5;
	            let temp7: f64 = -4.0 * temp3;
	            let temp8: f64 = temp2 + temp7;
	            let temp9: f64 = temp1 * temp8;
	            let temp10: f64 = w.powi(2);
	            let temp11: f64 = 4.0 * ms * temp10;
	            let temp12: f64 = temp2 * temp6;
	            let temp13: f64 = temp11 + temp12;
	            let temp14: f64 = ms * temp13;
	            let temp15: f64 = temp14 + temp9;
	
	            (self.lam_hs.powi(2)
	                * ncol
	                * temp1
	                * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                    + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	                / 2.0
	        } else {
	            0.0
	        }
	    }
	    fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        let temp = x / self.ms;
	        let pre = 1.0 / (48.0 * (self.ms * PI).powi(3) * 1.0) / 8.0;
	        let temp_fac = 1.0 / (2.0 * temp) / (1.0 + (w / temp).cosh());
	        let mut sum = 0.0;
	
	        sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
	        pre * temp_fac * sum
	    }
4cf531cf03613379042bf4bbb48ef4b8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|5|1|V|rust
	use haliax_constants::masses::HIGGS_MASS;
	use haliax_constants::masses::{BOTTOM_QUARK_MASS, DOWN_QUARK_MASS, STRANGE_QUARK_MASS};
	use haliax_constants::masses::{CHARM_QUARK_MASS, TOP_QUARK_MASS, UP_QUARK_MASS};
	use haliax_constants::masses::{ELECTRON_MASS, MUON_MASS, TAU_MASS};
	use std::f64::consts::PI;
3e04c0afba98271f793bccdadffec471|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|19|9|V|rust
	        let f = |w: f64| self.gamma_integrand(w, x);
3dc4d7fe9a0a0c0c95a651bab544385e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|19|9|V|rust
	        self.gk_gamma.integrate(f, 0.0, f64::INFINITY).val
e54fbe2cccac3788cc8105893b8c05ce|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|19|1|V|rust
	        let e1 = (q1 * q1 + self.ms * self.ms).sqrt();
4a8b239a1e72c5a899aa320701755e60|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|22|19|v|rust
	e1 * e2 - q1 * q2 * theta
73196518a50ae275a1a9e9a94586c683|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|18|26|v|rust
	cme: f64
4ed2066ac2f396a90d3dba329224854f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|28|30|v|rust
	e1 + e2
0592bf659b5ed50b4b72b5d23143ad36|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|8|16|v|rust
	gauss_legendre_nodes = [f64;50] = [
	        -0.998866404420071, -0.9940319694320907, -0.9853540840480058, -0.972864385106692, -0.9566109552428079, -0.936656618944878, -0.9130785566557919, -0.8859679795236131, -0.8554297694299461, -0.821582070859336, -0.7845558329003993, -0.7444943022260685, -0.7015524687068222, -0.6558964656854394, -0.6077029271849502, -0.5571583045146501, -0.5044581449074642, -0.44980633497403877, -0.39341431189756515, -0.33550024541943735, -0.276288193779532, -0.21600723687604176, -0.1548905899981459, -0.09317470156008614, -0.03109833832718888, 0.03109833832718888, 0.09317470156008614, 0.1548905899981459, 0.21600723687604176, 0.276288193779532, 0.33550024541943735, 0.39341431189756515, 0.44980633497403877, 0.5044581449074642, 0.5571583045146501, 0.6077029271849502, 0.6558964656854394, 0.7015524687068222, 0.7444943022260685, 0.7845558329003993, 0.821582070859336, 0.8554297694299461, 0.8859679795236131, 0.9130785566557919, 0.936656618944878, 0.9566109552428079, 0.972864385106692, 0.9853540840480058, 0.9940319694320907, 0.998864044200716
	    ]
	
3652d7ef865a3d4943b20c2d1e8be464|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|11|1|V|rust
	const gauss_legendre_nodes: [f64; 50] = [
	    -0.998866404420071,
	    -0.9940319694320907,
	    -0.9853540840480058,
	    -0.972864385106692,
	    -0.9566109552428079,
	    -0.936656618944878,
	    -0.9130785566557919,
	    -0.8859679795236131,
	    -0.8554297694299461,
	    -0.821582070859336,
	    -0.7845558329003993,
	    -0.7444943022260685,
	    -0.7015524687068222,
	    -0.6558964656854394,
	    -0.6077029271849502,
	    -0.5571583045146501,
	    -0.5044581449074642,
	    -0.44980633497403877,
	    -0.39341431189756515,
	    -0.33550024541943735,
	    -0.276288193779532,
	    -0.21600723687604176,
	    -0.1548905899981459,
	    -0.09317470156008614,
	    -0.03109833832718888,
	    0.03109833832718888,
	    0.09317470156008614,
	    0.1548905899981459,
	    0.21600723687604176,
	    0.276288193779532,
	    0.33550024541943735,
	    0.39341431189756515,
	    0.44980633497403877,
	    0.5044581449074642,
	    0.5571583045146501,
	    0.6077029271849502,
	    0.6558964656854394,
	    0.7015524687068222,
	    0.7444943022260685,
	    0.7845558329003993,
	    0.821582070859336,
	    0.8554297694299461,
	    0.8859679795236131,
	    0.9130785566557919,
	    0.936656618944878,
	    0.9566109552428079,
	    0.972864385106692,
	    0.9853540840480058,
	    0.9940319694320907,
	    0.998864044200716,
	];
ca15fd43dfaeb80eb8c125735e0479b0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|64|22|v|rust
	nodes
d6319112239cebb73348cac0685727e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|65|1|V|rust
	    -0.998866404420071,
	    -0.9940319694320907,
	    -0.9853540840480058,
	    -0.972864385106692,
	    -0.9566109552428079,
	    -0.936656618944878,
	    -0.9130785566557919,
	    -0.8859679795236131,
	    -0.8554297694299461,
	    -0.821582070859336,
	    -0.7845558329003993,
	    -0.7444943022260685,
	    -0.7015524687068222,
	    -0.6558964656854394,
	    -0.6077029271849502,
	    -0.5571583045146501,
	    -0.5044581449074642,
	    -0.44980633497403877,
	    -0.39341431189756515,
	    -0.33550024541943735,
	    -0.276288193779532,
	    -0.21600723687604176,
	    -0.1548905899981459,
	    -0.09317470156008614,
	    -0.03109833832718888,
	    0.03109833832718888,
	    0.09317470156008614,
	    0.1548905899981459,
	    0.21600723687604176,
	    0.276288193779532,
	    0.33550024541943735,
	    0.39341431189756515,
	    0.44980633497403877,
	    0.5044581449074642,
	    0.5571583045146501,
	    0.6077029271849502,
	    0.6558964656854394,
	    0.7015524687068222,
	    0.7444943022260685,
	    0.7845558329003993,
	    0.821582070859336,
	    0.8554297694299461,
	    0.8859679795236131,
	    0.9130785566557919,
	    0.936656618944878,
	    0.9566109552428079,
	    0.972864385106692,
	    0.9853540840480058,
	    0.9940319694320907,
	    0.998864044200716,
6680dba00f3a88f66f8029a93d71d93c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|64|1|v|rust
	const
ee17798742cc06341dfa86aebfd52783|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|8|5|V|rust
	    //static ref
2128f6c9822d095c993b7d0b850fb43d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|126|42|v|rust
	, theta: f64
41c537cf93c0899151ba37d1f9107cb5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|8|16|v|rust
	gauss_legendre_nodes: [f64; 50] = [
3de8262c30424eb4bfac65411ce126a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|8|16|v|rust
	gauss_legendre_nodes
042b0da218ff7afae813d0a2cc1eaa65|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|60|16|v|rust
	gauss_legendre_weights
d81c980cce098a14e9f3318934b77bf8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|141|1|V|rust
	        vmol * self.sigma_ss(cme)
61a74be60d291cc4678ab46cc1cdaf91|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|134|43|v|rust
	theta
36c4536996ca5615dcf9911f068786dc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|132|14|v|rust
	node
7edabf994b76a00cbc60c95af337db8f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|132|21|v|rust
	weight
a1ec23e9b9ab43a88222d9949ee26499|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|126|52|v|rust
	give
0b74c957172c287f559cb479a5fc35f1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|127|65|v|rust
	scalars 
cc86f64ffb4059a85fab0789fbf8ea97|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|22|22|v|rust
	x: f64, 
377967556e6e9568b8fce5a851e16e49|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|70|53|v|rust
	x / mx
4921fa7f20de4e39dcd81e7cfac91e32|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|77|9|V|rust
	        let temp = self.ml / x;
04189c482b16516cc88766069288a5e9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|76|20|v|rust
	, x: f64,
9b550bbbe6ac7a8645e5128caa9bff42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|78|9|V|rust
	        let kt = qt * temp;
d3fd9261c1ba60edb5b0bf323e8464cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|77|9|V|rust
	        let k = q * temp;
fc28e12a6d08dc856668b7950aebcfbc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|71|1|V|rust
	    fn feq(&self, x: f64, q: f64) -> f64 {
	        let e = (q * q + x * x).sqrt(); // energy / temperature
	        1.0 / (e.exp() + 1.0)
	    }
ff975b3e49e70b3f1272c627e0e768fa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|89|1|V|rust
	    fn dm_mass(&self) -> f64 {
	        self.ml
	    }
	    fn g(&self) -> f64 {
	        2.0
	    }
4c75d652f63065cd8a500f9723135785|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|16|17|v|rust
	DipoleDm
c8745baa52c9f5aa9301b71aefaa5f80|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|5|5|v|rust
	dipole_dm
ee47c0e5c8c615ae462480a24e924562|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|16|30|v|rust
	::new(ml, mh, lam, ce, cm);
16c8e5cb06f28bf247bd364307be29ca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|27|1|V|rust
	impl DipoleDm {
	    pub fn new(ml: f64, mh: f64, lam: f64, ce: f64, cm: f64) -> DipoleDm {
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .singular_points(vec![mh - ml])
	            .build();
	        let gk_sig = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
	
	        let width_h = {
	            let ce2: f64 = ce * ce;
	            let cm2: f64 = cm * cm;
	            let m22: f64 = mh * mh;
	            let m12: f64 = ml * ml;
	            let m23: f64 = m22 * mh;
	            let lam2: f64 = lam * lam;
	            (ce2 + cm2) * (m22 - m12).powi(3) / (8.0 * std::f64::consts::PI * lam2 * m23)
	        };
	
	        DipoleDm {
	            ml,
	            mh,
	            lam,
	            ce,
	            cm,
	            gk_gamma,
	            gk_sig,
	            width_h,
	        }
	    }
	}
8d8c85864d5a9b184d035d41927bfa9f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|117|5|V|rust
	    pub lam_ss: f64,
8270b47f83426edf68a392701b8fc2f6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|121|16|v|rust
	ml: f64, mh: f64, lam: f64, ce: f64, cm: f64
5da8c1e51997b2d63055441a26233a58|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|128|1|V|rust
	        let gk_sig = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
e84730edc490fb2ddce34aec33db7ad9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|128|1|V|rust
	        let width_h = {
	            let ce2: f64 = ce * ce;
	            let cm2: f64 = cm * cm;
	            let m22: f64 = mh * mh;
	            let m12: f64 = ml * ml;
	            let m23: f64 = m22 * mh;
	            let lam2: f64 = lam * lam;
	            (ce2 + cm2) * (m22 - m12).powi(3) / (8.0 * std::f64::consts::PI * lam2 * m23)
	        };
7999a106c6b0a473470ab4eeabde6cc1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|129|1|V|rust
	            ml,
	            mh,
	            lam,
	            ce,
	            cm,
82f88f5aed2791fd8823c814f160fd63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|130|13|V|rust
	            gk_sig,
f7d94dbddcdd51950689e8ffc420bd36|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|130|13|V|rust
	            width_h,
ad0b8650d907c4bfe59364b43b53d861|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|128|9|v|rust
	DipoleDm 
cec7cefd70fd0f78f287b7199f7a3c83|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|17|9|v|rust
	ms: 
d7a1c69b58726aa3ed8e03b15a2c5a3b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|18|9|v|rust
	lam_hs: 
04c97d0dfaa0009c6f6cb799866f4add|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|9|V|rust
	        lam_ss: 0.0,
5d5a085ffb5ddec29568863f4ddb0ae6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|10|1|V|rust
	    let ml = 100.0;
	    let mh = 101.0;
	    let lam = 1e4;
	    let ce = 1.0;
	    let cm = 1.0;
2c5452a1cdf37d666d4d806fa029abc2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|12|36|v|rust
	57.0, 0.1
fb0c7af1f530fe363c1fcc021756801f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|41|23|v|rust
	shape()[0];
93a5dc8e46b573d7437ef4c8cc782d1c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|114|37|v|rust
	raw_dim
f69ec3dc1649a94ba4d0cdcd911e316c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|125|5|v|rust
	sol 
a5e8c1c3a74cd1e3712b6900f3b0924f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|109|17|V|rust
	                println!("deriv[{}] = {}", i, deriv[i]);
f332c533163523b1c6f9b5fc8b75c769|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|109|57|v|rust
	deriv[i]); 
d7145f0318121bdbf1ff3ec922cfde86|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|74|17|V|rust
	                    println!("sigij, sigijp1 = {}, {}", sigij, sigijp1);
14d7c46daad5989848ac1be7765d83ac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|167|1|V|rust
	            println!("dot, vmol = {}, {}", dot, vmol);
943f211c8bfd733c25e67e00e66091f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|167|33|v|rust
	self.sigma_ss(cme)
f7013de185c31b7347e412833a99442b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|156|29|v|rust
	self.ms * self.ms
42f25e1f8451dda15fdd8ac5721c4e0a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|157|29|v|rust
	self.ms * self.m
d10069f7fd2fc22cd7cd9b9d69726e44|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|171|17|V|rust
	                theta,
21ec26df91d5b41f9d95fb003401d849|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|171|17|V|rust
	                wgt,
447035a5f7629287196368b52b980da5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|170|18|v|rust
	theta, wft, 
cbdc47ab5907d86223a1e54d1bdb2753|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|170|34|v|rust
	{}, {},
05bfb2b6879d405b63dc92b324d9c7be|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|169|9|V|rust
	            println!("sum, cme, sig = {}, {}, {}", sum, cme, self.sigma_ss(cme));
27de63b830cc5b090abe99588fb6352f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|126|5|v|rust
	cw sol = 
f07ea572360ee4468fb34319de0bbb83|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|127|1|V|rust
	
	    println!("retcode = {:?}", sol.retcode);
	    println!("#pts = {}", sol.ts.len());
	
	    for (t, u) in sol {
	        println!("{}, {:?}", t, u);
	    }
439912438c3e3e6e1e1198c347ca5a7e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|18|1|V|rust
	        let mut t_str = String::from(format!("{}", t));
ed14567e46d8fb225fcfa0c4615546ed|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|9|V|rust
	        u_str = std::u_str[1..(u_str.len() - 2)];
9000cff2b902884a02a72caf507f5a86|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|38|v|rust
	format!("{}", u)
6b2e6a9fe73dd749617c54c94718f32a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|21|v|rust
	format!(
	
8f3260f09670075ebfbed18d4cd29d38|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|38|v|rust
	        let mut u_str = String::from(format!("{}", u)[1..);
18f826b86bae3311989fcdc018e1c82e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|21|19|v|rust
	_fmt
47790ee523687ae93106fae9cba70149|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|21|1|V|rust
	        file.write(t_str);
481a2793a0ab741fd1584d687f1e42f5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|39|v|rust
	.as_bytes();
78cc947dd29edc83b83c6c729672bf6e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|37|v|rust
	format!("{},", t)
82509e7598861dc7f2d602bfc0d1e57a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|24|v|rust
	String::from(
5c4ddc798335ffe9a6ea207d1a2c16f3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|30|v|rust
	as_owned
72ffd36bae53aaf3a577c578fdb4b5c9|untitled:5|3|1|v|
	creates a temporary which is freed while still in use
	
	note: consider using a `let` binding to create a longer lived value
a80004cc670e71c66b7686ed05e42193|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|9|V|rust
	        let t_string = t_str.to_string().as_bytes();
26899189110cbde386015ef4d3f84830|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|21|9|V|rust
	        u_str.
30d3ad4035e000b1cea583b065873cb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|21|9|V|rust
	        let u_string = String::from(&u_str[1..(u_str.len() - 1)]).as_bytes();
8218248a3e2b2c29cec9e83f733a8498|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|19|v|rust
	ct();
f15279e537750d1d8fc4952c082ee16c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|13|V|rust
	            .colle
05a1d98bd29b484c0dabd766dfba59a1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|22|13|v|rust
	.retain(|c| !r#"(),"[]"#.contains(c));
8f8cf2dc187c4786cfe6a108b2065549|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|17|53|v|rust
	.unwrap();
f03362e4662ce3d4a61fcfe12ce033d0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/data.csv|529|1|v|csv
	2.003704030591701,0.1558495685391433 0.03799547445205545 0.0035951308372152452 0.00029026122757696996 0.000022203114685786388 0.0000016585609399569223 0.0000001223866378365219 0.000000008967209325066338 0.0000000006541088873548026 0.000000000047571102971305053 0.0000000000034524415545566963 0.00000000000025017618044346585 0.000000000000018107865252199387 0.0000000000000013094978251151404 0.00000000000000009463253903912012 0.000000000000000006834938075509995 0.0000000000000000004934376086006602 0.000000000000000000035609679722999705 0.0000000000000000000025690287528033515 0.0000000000000000000001852918031986249
58b019950fce84179f936a6295cea461|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|9|V|rust
	        let mut u_str = format!("{}\n", u).to_string();
a77a0182ae825e757551c434e8eff205|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|13|v|rust
	t_str
986ae3dd54e9fa9607892dac9cbb7afd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|9|v|rust
	u_str
c11e6845faa46b8a8f85757025548aed|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|22|9|V|rust
	        file.write(u_str.as_bytes())?;
02541b7cbb840b5f6bd8eff3c9f56f61|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|15|56|v|rust
	500.0
0edc1f85810165cd3742de79907ed413|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	                    let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
3c0cb196a5815a66fafb88d0b9211b62|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|63|13|V|rust
	            // [
4d35cb40ab01fae884097208d91db54f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|5|V|rust
	    static ref DERIV_MAT: Array2<f64> = {
811a1e46d636ec7a5b46b40a8f28a583|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|9|V|rust
	        let m = Array2::
8961e3cf0adb11b389a41395067d6852|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|51|1|V|rust
	                m[[i,i-1]] = -1.0;
ccdde59b7ea5819a99a3d3e10b3a6471|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|50|1|V|rust
	                m[[i, i - 1]] = -1.0;
	                m[[i, i + 1]] = 1.0;
6f409906c2a29da07030a8cb6b0b76e0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|23|v|rust
	i - 1
a04701420d265402b1accfd3d53b2c6a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|52|15|v|rust
	else if i == 0{
	                m[[0, ]] = -1.0;
	                m[[i, i + 1]] = 1.0;
	            }
	
b47d40d171eaf791b4fd85bafb7d7af2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|49|13|V|rust
	            if i != 0 && i != n - 1 {
233a87a0e3be3af9d704b78435d8fc35|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|48|1|V|rust
	        m[[0, 0]] = -2.0;
	        m[[0, 1]] = 2.0;
f08d0198c2c67da877fe0f0956d85c0c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|51|9|V|rust
	        m[[0, 1]] = 2.0;
f5476c5acfb61c55f6cac9e086c0d542|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|50|9|V|rust
	        m[[0, 0]] = -2.0;
c4e7fe8fb1f9afacc14172da4a70c9a3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|48|1|V|rust
	        let mut m = Array2::<f64>::zeros((n, n));
b418006988a4ffb1204be0bb581c4d53|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|46|1|V|rust
	    let 
995b988e711abada7cab113eee925124|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|9|V|rust
	        m
a635f48c8a1543ade7ef09415c826999|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|5|V|rust
	    };
f2be03a381ace3a54b5b25fa7fedd62c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|47|5|V|rust
	    let dmat =
5869642350e369b88ea65fe42cfbc695|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|46|1|V|rust
	    let mut dmat = Array2::<f64>::zeros((n, n));
facad7e0d61b0470068e1bf117567544|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|1|V|rust
	        d2mat[[i,i + 1]] = 1.0;
762dfb06c7c0d0e9a3d4b39621ecb5cf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|48|1|V|rust
	    dmat[[0, 0]] = -2.0;
	    dmat[[0, 1]] = 2.0;
caf43eed9a8f2b087fa4408a4e784454|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|50|5|V|rust
	    dmat[[0, 0]] = -2.0;
05497631fa1bdd2fa68c0a491c7f23e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|50|1|V|rust
	    dmat[[0, 1]] = 2.0;
ca2e91df2f9d413d3f96b7dc0b0a2294|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|41|5|V|rust
	    qs: Array1<f64>,
451a03eff6cd976d18f8e16683033abc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|42|5|v|rust
	xmin
cbac0415800c398a7db6ffe5361474af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|43|5|V|rust
	    xmax: f64,
094c9f713519e54110c48698eeb2d8f3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|41|5|v|rust
	qvals
e4d81f789ba1798f1ee3263436e611a5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|41|1|V|rust
	    qspan: (f64, f64, f64),
ae824bbf15a0243ac94856d1bc158724|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|42|5|v|rust
	qspan
daddac986d1153bb0dcbcb279e74777c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|42|10|v|rust
	(f64, f64, f64),
26912021303ae943a791f892d09d46fd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|41|21|v|rust
	, f64),
dff0ac1df1552dd89aaa23f67bd6c170|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|42|5|V|rust
	    nqs: usize,
bb16e6288219ab6cfd33677459fbd49f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|47|5|V|rust
	    let n = qs.len();
7072565556453d50431f099be8e22840|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|46|1|V|rust
	    let dq = qs[1] - qs[0];
e9ada945751984da6655e31baf272cd7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|47|15|v|rust
	qs[1] - qs[0];
32be6ee120ad91bce9f895d9b1f8b9f4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|76|22|v|rust
	&f.slice(s![1..]) - &f.slice(s![..-1]);
5acd400509f1fdcd35e9762dc2cd6941|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|76|1|V|rust
	            let df = dmat.dot(&f);
5011edd003551a2e11d48b218c8ee141|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|1|V|rust
	            //let d2f =
	            //let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	            // a = [0,1,2,3,4,5,6]
	            //
	            // [0,1,2,3,4,5] = a[:-1]
	            // [1,2,3,4,5,6] = a[1:]
	            //
	            // [0,1,2,3,4] = f[i-1]
	            // [1,2,3,4,5] = f[i]
	            // [2,3,4,5,6] = f[i+1]
	
5f8337baf7c9dbadf488c5772891f9e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|82|1|V|rust
	                let xq = (x * x + qi * qi).sqrt();
74c6fee0540a803f34fe419614413049|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|22|v|rust
	(x * x + qi * qi).sqrt()
a072150c4dd3c3651ec8d366a3f07a67|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|120|1|V|rust
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
61e5e9f1a276729c0041ea02277ea136|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|125|1|V|rust
	                        gt * qi / x * df,
8c6eec42d7b50bc49cfd35a4ae8b8fc1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|115|1|V|rust
	
	                let (term2, term3) = if i != 0 && i != n - 1 {
	                    let fip1 = f[i + 1];
	                    let qip1 = p.qs[i + 1];
	                    let qim1 = p.qs[i - 1];
	                    let fim1 = f[i - 1];
	                    let df = (fip1 - fim1) / (qip1 - qim1);
	                    let d2f = (fip1 + fim1 - 2.0 * fi) / (qip1 - qi) / (qi - qim1);
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
	                } else if i == 0 {
	                    // Use forward derivatives
	                    let fip1 = f[i + 1];
	                    let fip2 = f[i + 2];
	                    let qip1 = p.qs[i + 1];
	                    let qip2 = p.qs[i + 2];
	                    let df = (fip1 - fi) / (qip1 - qi);
	                    let d2f = (fip2 + fi - 2.0 * fip1) / (qip1 - qi) / (qip2 - qip1);
	                    (
	                        gam / (2.0 * ht * x)
	                            * (xq * d2f + (qi + 2.0 * xq / qi + qi / xq) * df + 3.0 * fi),
	                        gt * qi / x * df,
	                    )
	                } else {
	                    (0.0, 0.0)
	                };
dccb42c5987669757ee174a61b3ad0a4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|108|1|V|rust
	                    term1 += dqj / 2.0
	                        * (qj * qj * sigij * (feqi * feqj - fi * fj)
	                            + qjp1 * qjp1 * sigijp1 * (feqi * feqjp1 - fi * fjp1));
56d939696eb50799eb9d8107e0cb04ae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|81|13|V|rust
	            let dq
779fa9d6faa4c59aafaf8895c45fadcf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|83|13|V|rust
	            let feqi = 
67b68418201148640d60ffcb086be27c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|81|1|V|rust
	            let qj = qs.slice(s![..-1]);
a3851c1d9bbe8af49d52e2c2e9326fe4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|13|V|rust
	            //
49b03a63a4dd07912c00dd32f3ab2063|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|13|V|rust
	            let qjp1 = qs.slice(s![1..]);
ee21952e2d1dee93631965b1e7dc6062|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|81|25|v|rust
	dq / 2.0
	                * (qj * qj * sigij * (feqi * feqj - fi * fj)
	                    + qjp1 * qjp1 * sigijp1 * (feqi * feqjp1 - fi * fjp1));
	
	
0aec50ad24444abc737d90e7f94944e5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|114|1|V|rust
	                // second and third terms:
	                //let term2 = gam / (2.0 * ht * x) * (
	                deriv[i] = pre * term1 + term2 + term3;
	                //println!("deriv[{}] = {} * {} + {} + {}", i, pre, term1, term2, term3);
91bfc3e02c4acf907d427b76643a799a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|17|V|rust
	                let qi = qs[i];
a8017f7d922f9d13ac7fc50903f88df4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|17|V|rust
	                // momenta
c3ce9e01d460532e384e26ffae089879|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|17|V|rust
	                // PS density
2f1cb57c7d9a91bfe8888978e9c06557|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|17|V|rust
	                let fi = f[i];
66f66202b5e2ea9d8308117b044295d6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|97|21|V|rust
	                    let fjp1 = f[j + 1];
402d0d21dfdd8de358fb09ae2f55766a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|97|21|V|rust
	                    let feqjp1 = p.model.feq(x, qjp1);
a6851b3b0274920a0012dbc50d864254|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|96|21|V|rust
	                    // PS densities
a7528dd85a70346b26099d728efb3e87|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|21|V|rust
	                    let qjp1 = p.qs[j + 1];
bdbecd50128b7527096155ccfca969d5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|21|V|rust
	                    let dqj = qjp1 - qj;
6507fcabbdf745536c3c7893960776a5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|92|21|V|rust
	                    // Momentum
89085859e98566c804eab61768908973|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|1|V|rust
	                    let sigij = p.model.sigmav(qs[i] * temp, qs[j] * temp);
ee274e581fd8b514544b66651011a834|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|1|V|rust
	                    let sigij = p.model.sigmav(qs[i] * temp, qs[j] * temp);
	                    let sigijp1 = p.model.sigmav(qs[i] * temp, qs[j + 1] * temp);
6d6ef1307cb32e398b55d2a6ac4ab631|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|12|V|rust
	            let sigijp1 = p.model.sigmav(qs[i] * temp, qs[j + 1] * temp);
1efa54b2e4492c2cf703e460afc2734c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|77|23|v|rust
	p.model.sigmav(qs[i] * temp, qs[j] * temp);
cd1318e3d72db7b43d6f072c417136a3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|99|21|V|rust
	                    let sigijp1 = p.model.sigmav(qs[i] * temp, qs[j + 1] * temp);
4b47bcc8893a2a63690ed51158950cf1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|98|21|V|rust
	                    // Cross-sections
3e88e820daddfd66ea26e0221068168b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|96|17|V|rust
	                let mut term1: f64 = 0.0;
e8e1138820061878ba2ed21a3b2dd68d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|95|17|V|rust
	                // First term
66dd6bcab3e277d7d1d1cd73e1ba0d41|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	            feq.sig.feq.qs.qs
00e1a86e606c813e07f15771241b490c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|95|13|v|rust
	f.sig.f
6740d5c4202cdefbe2a082a5de50a640|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|30|v|rust
	.feq
ebc8f74f911d1f672be3d92e932fee27|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|95|13|V|rust
	            .qs.qs
c18107ad6d3fbb87e8ccfbb071d16071|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	            (feq.sig.feq-f.sig.f).qs.qs
85aeafe4e194f6379b3735f0096f53c2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	            (feq.dot(&sig).dot(&feq)-f.dot(&sig).dot(&f)).qs.qs
e484357bbcfe2dcd9ba8e3096e2e460a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	            (feq.dot(&sig[s![..,..-1]]).dot(&feq[s![..-1]])-f.dot(&sig[s![..,..-1]]).dot(&f[..-1]))*qs*qs;
b70b58c578190f7308d6e24ce07a5c54|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	            (&feq.dot(&sig.slice(s![.., ..-1])).dot(&feq.slice(s![..-1]))
	                - &f.dot(&sig.slice(s![.., ..-1])).dot(&f.slice(s![..-1])))
	                * &qs
	                * &qs;
8d974e481a3a6d005d2096ca803e4fb3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|98|1|V|rust
	            (feq.dot(&sig[s![.., 1..]]).dot(&feq[s![1..]]) - f.dot(&sig[s![.., 1..]]).dot(&f[1..]))
	                * qs
	                * qs;
32e1fffe6fbee28b1d9ac24ead9975cc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|96|22|v|rust
	.slice(s![..-1])
1aa44eabed9d33f599006bb4ccfc2245|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|96|1|V|rust
	                * &qs.slice(s![..-1])
	                * &qs.slice(s![..-1]);
4009352e3aa87c638f8f890df69f12c2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|100|1|V|rust
	                * &qs
	                * &qs;
a3ea23b75dd19835a29f26f8fff0bcae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|13|V|rust
	            let mut term1s = Array1::<f64>::zeros(n);
2419d5a08dfe5964473f4ac60aa5abd1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|1|V|rust
	            let term1s = dq / 2.0
	                * ((&feq.dot(&sig.slice(s![.., ..-1])).dot(&feq.slice(s![..-1]))
	                    - &f.dot(&sig.slice(s![.., ..-1])).dot(&f.slice(s![..-1])))
	                    * &qs.slice(s![..-1])
	                    * &qs.slice(s![..-1])
	                    + (&feq.dot(&sig.slice(s![.., 1..])).dot(&feq.slice(s![1..]))
	                        - &f.dot(&sig.slice(s![.., 1..])).dot(&f.slice(s![1..])))
	                        * &qs.slice(s![1..])
	                        * &qs.slice(s![1..]));
e829d0d06145c8ebecc12db4254077f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|102|1|V|rust
	            for i in 0..n {
	                for j in 0..(n - 1) {
	                    term1s[i] += dq / 2.0
	                        * (qs[j] * qs[j] * sig[[i, j]] * (feq[i] * feq[j] - f[i] * f[j])
	                            + qs[j + 1]
	                                * qs[j + 1]
	                                * sig[[i, j + 1]]
	                                * (feq[i] * feq[j + 1] - f[i] * f[j + 1]));
	                }
	            }
b4bdb97d877f41fc90bec417de92ec50|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|20|v|rust
	(&feq.dot(&sig.slice(s![.., ..-1])).dot(&feq.slice(s![..-1]))
	                    - &f.dot(&sig.slice(s![.., ..-1])).dot(&f.slice(s![..-1])))
	                    * &qs.slice(s![..-1])
	                    * &qs.slice(s![..-1])
	                    
61a4a192503527e2850c6fb8b4de6f1c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|14|v|rust
	&feq.dot(
e043b0da2e5e3820e84feba145eb2990|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|23|v|rust
	dot(
ea7afcc2d8a2b37248a01d890338d85b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|14|v|rust
	&sig.slice(s![.., ..-1]).dot(
	                    &feq.slice(s![..-1]) * qs.slice(s![..-1]) * qs.slice(s![..-1]))
922b300cd03b080dfa60075bb1ad83c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|92|1|V|rust
	            (&sig.slice(s![.., ..-1]).dot(
	                    &feq.slice(s![..-1]) * qs.slice(s![..-1]) * qs.slice(s![..-1]))
	                    - &sig.slice(s![.., ..-1]).dot(&f.slice(s![..-1])))
	                    * &qs.slice(s![..-1])
	                    * &qs.slice(s![..-1])
16d99438de383086a4c72ad837f9631b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|1|V|rust
	            &sig.slice(s![.., ..-1]).dot(
	                    &feq.slice(s![..-1]) * qs.slice(s![..-1]) * qs.slice(s![..-1]))
1f64a4d1350ef6bff550aef5fa746ce7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|21|v|rust
	&feq.slice(s![..-1])
1a32b7fd16b801dd7fbf840a83e68c64|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|21|V|rust
	                    &feq.slice(s![..-1]) * qs.slice(s![..-1]) * qs.slice(s![..-1]))
30ddccb34ea8ede655871b45f6e339d9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|13|V|rust
	            &sig.slice(s![.., ..-1]).dot(
dee5dcc982bd95f6bec23df1f680ea9b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|38|v|rust
	-&f.slice(s![..-1])
56bf5575cdb242eb7f7f8e9127068192|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|7|1|V|rust
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        if w >= mf {
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = mh.powi(2);
	            let temp3: f64 = ms.powi(2);
	            let temp4: f64 = mh.powi(-2);
	            let temp5: f64 = 2.0 * w;
	            let temp6: f64 = ms + temp5;
	            let temp7: f64 = -4.0 * temp3;
	            let temp8: f64 = temp2 + temp7;
	            let temp9: f64 = temp1 * temp8;
	            let temp10: f64 = w.powi(2);
	            let temp11: f64 = 4.0 * ms * temp10;
	            let temp12: f64 = temp2 * temp6;
	            let temp13: f64 = temp11 + temp12;
	            let temp14: f64 = ms * temp13;
	            let temp15: f64 = temp14 + temp9;
	
	            (self.lam_hs.powi(2)
	                * ncol
	                * temp1
	                * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                    + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	                / 2.0
	        } else {
	            0.0
	        }
4e978f435837d5f54e7ebbeef229ce83|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|43|9|v|rust
	sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
4885c3d7ef75ff81a39252649937e3b2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|1|v|rust
	            &feq * &sig.slice(s![.., ..-1]).dot(
e3b8e4943cf607f91adb8831a6dc230d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|1|v|rust
	                (&feq.slice(s![..-1])) * qs.slice(s![..-1]) * qs.slice(s![..-1]))
3ab0b193f243ab49eb5f78540b12dd70|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|52|v|rust
	qs.slice(s![..-1])
b8e34d6d4092827a8f8e5cf66312bca0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|25|v|rust
	sig.slice(s![.., ..-1]).dot(
	                &(&qs.slice(s![..-1])
	                    * &qs.slice(s![..-1])
	                    * &(&feq.slice(s![..-1]) - &f.slice(s![..-1]))),
	            );
	
4753281464af54aed2a77c3d77af3e0d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|21|v|rust
	feq * (sig.slice(s![.., ..-1]).dot(
	            &(&qs.slice(s![..-1])
	                * &qs.slice(s![..-1])
	                * &(&feq.slice(s![..-1]) - &f.slice(s![..-1]))),
	        )) + sig.slice(s![.., 1..]).dot(
	            &(&qs.slice(s![1..]) * &qs.slice(s![1..]) * &(&feq.slice(s![1..]) - &f.slice(s![1..]))),
	        );
	
8e79255c9f4dec6431fe0d0bda307ada|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|92|1|V|rust
	        let term1s = dq / 2.0
	            * ((&feq.dot(&sig.slice(s![.., ..-1])).dot(&feq.slice(s![..-1]))
	                - &f.dot(&sig.slice(s![.., ..-1])).dot(&f.slice(s![..-1])))
	                * &qs.slice(s![..-1])
	                * &qs.slice(s![..-1])
	                + (&feq.dot(&sig.slice(s![.., 1..])).dot(&feq.slice(s![1..]))
	                    - &f.dot(&sig.slice(s![.., 1..])).dot(&f.slice(s![1..])))
	                    * &qs.slice(s![1..])
	                    * &qs.slice(s![1..]));
948411d78f242ccfa240e54c461954a3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|17|V|rust
	                let kkkkkkkkkkk
6f72b84fe1372e631f433687f26f15f1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|105|28|v|rust
	pre * 
e8549df90102e5f619e6288b10e36980|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|75|13|V|rust
	            // Compute arra
624c25942810a3688e573f2c9246cdf1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|1|V|rust
	        // these will produce (f[i+1] - f[i-1]) / (2dq) - central difference
41aabbfd7c00bcba608b47ac792c35fb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|63|65|v|rust
	 - central difference
ed106cae987589626ff0b561cbdbb7bc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|54|1|V|rust
	    // use (f[i+1]-f[i]) / dq at i = 0
fa244b9dc390bdc62119da837e6c69a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|57|40|v|rust
	 at i = 0
9c2207d0a5a8e4822a7123f655cbe858|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|13|V|rust
	            let n = p.qs.len();
c7304c26a853f6b21d85604262eda641|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|23|v|rust
	p.model.gamma(x)
2b88b93d233c2c75f20720e4dfbcc63b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|13|V|rust
	            let gam = ;
0be0ac5976b0e0ff95170c4636719b4d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|22|v|rust
	gefft(x)
cd81bc1dc307e4da1c43d77b04de6df0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|13|V|rust
	            let gt = gefft(x);
897fe703477a48815a60ff42fe8df924|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|13|V|rust
	            let ht = hubblet(x);
e43814bf696b38818a8780e42a84f85f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|123|5|V|rust
	    let xspan = (xmin, xmax);
0ef16604b4a2f96c0d417d857abdb3d0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|1|V|rust
	    let qs = Array::linspace(1e-6, 50.0, 500);
ce533716df5ae07e5cf4bd914d65006d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|47|v|rust
	(1e-6, 50.0),
85a46ab485b18c0df1d56fd725a3489b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|45|43|v|rust
	qspan.0
01168748edbc8fbb8d6864221521fe1e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|45|48|v|rust
	 qspan.1
09987821a7ac6234c441364996bbd40f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|42|5|V|rust
	    qspan: (f64, f64),
d4b6bdc451944c3a26dd75cb6def6c8e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|71|73|v|rust
	FullBoltzmannParams
23b78a37e18d605f61915510be7be3eb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|109|26|v|rust
	odel
88db79c686cb806692137ba4d5e21a07|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|123|83|v|rust
	, fbp
bda08221996125c1bec658c98cee3093|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|122|5|V|rust
	    let fbp = FullBoltzmannParams { qs, model };
56cf8f7798798155dd4a1c5160b26019|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|8|5|V|rust
	/// Structure to hold the a phase-space distribution.
	pub struct FullBoltzmannParams<T> {
	    /// Momentum values
	    pub qs: Array1<f64>,
	    /// Model
	    pub model: T,
	}
b0b529f838f450aa32a71c00f22b31ad|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|1|V|rust
	        let mut term1 = Array1::<f64>::zeros(n);
	        for i in 0..n {
	            for j in 0..(n - 1) {}
	        }
068710e51ec661e23a8049707ccda2c0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|102|42|v|rust
	qs.len()
bd7b32bf210de68320f5bb79a7733db6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|43|1|v|rust
	                integrator.cache.f1.view_mut(),
b7c5a60ea71df4333920cc923f3096ca|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|45|45|v|rust
	.view()
621c719d5e381a60437c7dee57ffcb71|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|45|17|v|rust
	aview1(
e858701b4787973c4683a1645b401b92|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|45|38|v|rust
	).view()
81067292820ff377057bb879d793fcb4|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|4|14|v|rust
	aview1
03797bc7c108037efe99102d35d86f46|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|88|38|v|rust
	.view(),
11c5e811795e96a726fdfd1d94335da3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|1|V|rust
	    let dudt = |mut deriv: ArrayViewMut1<f64>, f: ArrayView1<f64>, x: f64, p: &T| {
	        let ht = hubblet(x);
	        let g = p.g();
	        let mx = p.dm_mass();
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let temp = mx / x;
	        let feq = qs.mapv(|q| p.feq(x, q));
	
	        // Construct a matrix out of the first term in the ODE. This will
	        // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	        // We will want to integrate this term of qt or the j-index. We
	        // do so below using the trapizoid rule.
	        let mut sigterm = Array2::<f64>::zeros((n, n));
	        for i in 0..n {
	            for j in 0..(n - 1) {
	                sigterm[[i, j]] = pre
	                    * dq
	                    * qs[j]
	                    * qs[j]
	                    * p.sigmav(qs[i] * temp, qs[j] * temp)
	                    * (feq[i] * feq[j] - f[i] * f[j]);
	            }
	        }
	        // Perform trapizoid integration.
	        let mut term1 = sigterm.sum_axis(Axis(1));
	        term1[0] /= 2.0;
	        term1[n - 1] /= 2.0;
	
	        // Compute the derivatives of f
	        let df = dmat.dot(&f);
	        let d2f = d2mat.dot(&f);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	
	        let term2 = p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f);
	        let term3 = gefft(x) * &qs / x * &df;
	
	        deriv.assign(&(&term1 + &term2 + &term3));
	    };
765959341b013193d86fdb2753ef323c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|101|21|v|rust
	deriv
296e43fb5ddb83bd9bfc10b090daba9c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|121|24|v|rust
	feq[i] * feq[j] - 
96a836b5051941261e15b6303cdaf851|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|121|24|v|rust
	feq[i] * feq[j]
e9cf1ed6f0df6145dfdc7434931b0155|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|17|v|rust
	sigterm
af58898e121b62c75b360ed36aedba84|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|76|17|v|rust
	sigterm[[i, j]]
4e57f306c2c67bae91b584de3533a5e6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|9|V|rust
	        let mut term1 = sigterm.sum_axis(Axis(1));
161c535244e197a98cb5fcaef803eb86|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|84|12|v|rust
	Perform trapizoid integration.
fa0c284b3a2407a65e4ab88fff49b7c5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|69|1|V|rust
	        // Construct a matrix out of the first term in the ODE. This will
	        // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	        // We will want to integrate this term of qt or the j-index. We
	        // do so below using the trapizoid rule.
	        let mut term1 = Array1::<f64>::zeros(n);
	        for i in 0..n {
	            for j in 0..(n - 1) {
	                term1[i] += pre
	                    * dq
	                    * qs[j]
	                    * qs[j]
	                    * p.sigmav(qs[i] * temp, qs[j] * temp)
	                    * (feq[i] * feq[j] - f[i] * f[j]);
	            }
	        }
	        // Adjust the endpoints
	        term1[0] /= 2.0;
	        term1[n - 1] /= 2.0;
876056ed8db873443fe35464972597f4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|107|1|V|rust
	        // Construct a matrix out of the first term in the ODE. This will
	        // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	        // We will want to integrate this term of qt or the j-index. We
	        // do so below using the trapizoid rule.
	        let mut sigterm = Array2::<f64>::zeros((n, n));
	        for i in 0..n {
	            for j in 0..(n - 1) {
	                sigterm[[i, j]] =
	                    pre * dq * qs[j] * qs[j] * p.sigmav(qs[i] * temp, qs[j] * temp) * f[i] * f[j];
	            }
	        }
	        // Perform trapizoid integration.
	        let mut term1 = sigterm.sum_axis(Axis(1));
	        term1[0] /= 2.0;
	        term1[n - 1] /= 2.0;
973b52cb90d920cb4079d39822ae32c9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|9|V|rust
	        let mut term1 = Array1::<f64>::zeros(n);
700ee855f4f7e49477e0021e1af679da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|17|v|rust
	term1
45653b7126f2cfa3a7b48522b5b83576|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|118|23|v|rust
	(feq[i] * feq[j] - 
7b26427f40d2387514dea535e1f6bfe1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|112|13|V|rust
	            for 
dab2e46fa47783befa7aca94dbaaa0e4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|17|V|rust
	                if i != j {
cb59efb70f4e82786613bedf9d5a4126|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|114|1|V|rust
	                }else{
0aa92a7ed3534f3169c84d7ebf65b085|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|116|1|V|rust
	                        jac[[i, j]] += -pre
	                            * dq
	                            * qs[k]
	                            * qs[k]
	                            * p.sigmav(qs[i] * temp, qs[k] * temp)
	                            * f[i]
	                            * f[k];
06032066d637b3ca34e2b4e20c4c033d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|114|25|v|rust
	jac[[i, j]] +=
c09395f913684769f45149700324cf9c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|119|25|V|rust
	                            * f[i]
700fb47e93c5c96fbbecadc92c403c91|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|120|25|V|rust
	                            * f[k];
96d5bc2122771a6c7664bb26fa0f73ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|117|25|V|rust
	                        if k != 0 && k != n-1
2b820f2ccfe3520bf083973f9eb5f7bf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|128|9|V|rust
	        // Adjust the endpoints
57762ff5b5b114f5ad0267b6065d1f42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|128|9|V|rust
	        term1[0] /= 2.0;
503b34c6841491c29ce1a7ef834fabe4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|128|9|V|rust
	        term1[n - 1] /= 2.0;
0ad0eb4000ac3e28263b740b0964b6cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|117|1|V|rust
	                        jac[[i, j]] += if k == 0 || k == n - 1 { 0.5 } else { 1.0 }
12da19acd3f07119bc53272314f11a55|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|32|v|rust
	
	                        jac[[i, j]] +=
bb956fd8a98855dc4d96a6c2e9b893d2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|80|v|rust
	* &f
82164c79cf4bdd0e9d5f38a31bdde04b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|139|1|V|rust
	        let term2 = p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0);
	        let term3 = gefft(x) * &qs / x * &df;
331299ff4c91794604e7eb1aeaeba4a7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|134|9|v|rust
	let term3 =
585dfe841ea9c6fd3a37616a6172e9dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|132|1|V|rust
	            jac[[i,j]] += p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0);
	        jac[[i gefft(x) * &qs / x * &df;
fa254ff8f998a40a1005b1c522a99274|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|132|27|v|rust
	p.gamma(x)
8f1acf6754cdbf6d574b14ef9ea62d6a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|139|1|V|rust
	        // Compute the derivatives of f
	        let df = dmat.dot(&f);
	        let d2f = d2mat.dot(&f);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	
	        let term2 = p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0);
	        let term3 = gefft(x) * &qs / x * &df;
3782381e61a57f2fa63f554d317bbbeb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|1|V|rust
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
2bd0f9cbbd32231984b56b7fa23e2121|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|136|47|v|rust
	2.0 * xq[i] / qs[i]
2b3d36e3cfb34225720839a409ad1ae6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|134|17|V|rust
	                let df = f[
613e744165c92f5c737b0cdff02ab4f4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|1|V|rust
	                    (f[i + 1] - f[i - 1]) / (2.0 * dq)
ecfa0c6ef01ebd74f3152629fc8f1a51|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|137|25|v|rust
	(f[i + 1] - f[i - 1])
a934eb497c02739a398e0e8e627d7cb3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|21|V|rust
	                    (f[i + 1] - f[i]) / dq
0ddbe46903a94af2f877a0429eca9e95|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|147|21|v|rust
	(f[i + 1] - f[i])
ba755d471381a0ec6d668d66d320dc0a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|47|v|rust
	&df;
4b260fe5d63828e3b76f41c8ca1ce20e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|135|1|V|rust
	                let dfdf = if i != 0 && i != n - 1 {
	                    if j == i + 1 {
	                        1.0 / (2.0 * dq)
	                    } else if j == i - 1 {
	                        -1.0 / (2.0 * dq)
	                    } else {
	                        0.0
	                    }
	                } else if i == 0 {
	                    if j == i + 1 {
	                        1.0 / dq
	                    } else if j == i {
	                        -1.0 / dq
	                    } else {
	                        0.0
	                    }
	                } else {
	                    0.0
	                };
40bf29296e84db76ab21791958216ec7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|31|v|rust
	(2.0 * dq)
8194c1d307abd2f40060840e06e9ac4e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|1|V|rust
	                        1.0 / dq / dq
86d45111e9bafc54669be18fb03a764c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|159|1|V|rust
	                        -1.0 / (2.0 * dq)
d740f6c2aee5a2d33116d4bbb8c91643|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|161|1|V|rust
	                        0.0
11c19633c6d7b85eec5efafdd655392d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|166|29|v|rust
	i + 1
52414a01ad5f32ba8aced337597a0e49|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|167|1|V|rust
	                        1.0 / dq
099a6751462cfe781f79ca5e99977a2f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|1|V|rust
	                        -1.0 / dq
7aabb6a7fa567c4889096ae4f08b4d85|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|158|23|V|rust
	                    } else if j == i - 1 {
	                        1.0 / dq / dq
d8c42d458e06c37d8db867f37249b83d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|158|23|v|rust
	else if j == i - 1 {
	                        1.0 / dq / dq
	                    }
6ce1f2127e5c6564eca1e549b9566ad1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|176|32|v|rust
	d2f 
207169080fa1f9421c9e3955cf28bb43|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|181|9|V|rust
	        deriv.assign(&(&term1 + &term2 + &term3));
bb8cab4f85a6c2c0873f16e6f15936f7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|105|5|V|rust
	        let feq = qs.mapv(|q| p.feq(x, q));
f77807f58ce715885ad75fa35f8405da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|93|1|V|rust
	        let term2 = p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f);
32ece855d15308972c5984d52f9a3740|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|1|V|rust
	                let xq = (x * x + qs[i] *
	                let term2 = p.gamma(x) / (2.0 * ht * x)
	                    * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f);
452d53cabd943f08363cf928889d82ad|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|88|1|V|rust
	            let df = if i != 0 && i != n - 1 {
	                (f[i + 1] - f[i - 1]) / (2.0 * dq)
	            } else if i == 0 {
	                (f[i + 1] - f[i]) / dq
	            } else {
	                0.0
	            };
b65aaf77c04694ae5e18935818db89b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|116|1|V|rust
	        let term3 = gefft(x) * &qs / x * &df;
0c6772ce03e3ba82e69c27613a2f0cda|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|104|23|v|rust
	 gefft(x)
b6908d3c207b8106a0271cc932e917e3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|1|V|rust
	        // Compute the derivatives of f
	        let df = dmat.dot(&f);
	        let d2f = d2mat.dot(&f);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	
	        let term2 = p.gamma(x) / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f);
	        let term3 = *&qs / x * &df;
8367b0b556c2fd1c4861191ab78dc177|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|1|V|rust
	    // Construct derivative matrices. These are constructed such that
	    // dmat.f = df/dq and d2mat.f = d^2f/dq^2 with df/dq and d^2f/dq^2 equal
	    // to zero for i = n-1. We use forward difference at i=0.
	    let mut dmat = Array2::<f64>::zeros((n, n));
	    let mut d2mat = Array2::<f64>::zeros((n, n));
	    // use (f[1]-f[0]) / dq at i = 0
	    dmat[[0, 0]] = -1.0 / dq;
	    dmat[[0, 1]] = 1.0 / dq;
	    // use (f[2] + f[0] - 2f[1]) / dq^2
	    d2mat[[0, 0]] = 1.0 / dq2;
	    d2mat[[0, 1]] = -2.0 / dq2;
	    d2mat[[0, 2]] = 1.0 / dq2;
	    for i in 1..(n - 1) {
	        // these will produce (f[i+1] - f[i-1]) / (2dq)
	        dmat[[i, i - 1]] = -1.0 / (2.0 * dq);
	        dmat[[i, i + 1]] = 1.0 / (2.0 * dq);
	        // these will produce (f[i+1] + f[i-1] - 2f[i]) / (dq^2)
	        d2mat[[i, i + 1]] = 1.0 / dq2;
	        d2mat[[i, i]] = -2.0 / dq2;
	        d2mat[[i, i - 1]] = 1.0 / dq2;
	    }
1a9142d8888b180aebd16a661aa0f899|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|77|44|v|rust
	/ dq
5c05b071716267d03e98efbe86127ca0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|83|40|v|rust
	2.0 * xq / qs[i]
09170029cd73bf7abd4d9f321e2d9034|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|40|V|rust
	        let mut term2 = Array1::<f64>::zeros(n);
f59bcf74b45fde57a330abec1d89f5c1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|53|40|V|rust
	        let mut term3 = Array1::<f64>::zeros(n);
d1461746d0511c904951bb21ac75e53b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|49|23|V|rust
	        // Construct a matrix out of the first term in the ODE. This will
	        // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	        // We will want to integrate this term of qt or the j-index. We
	        // do so below using the trapizoid rule.
f064ba69eec828668eb9475146e336b5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|75|13|v|rust
	term2
2b93e5a33c8b3930da81b7b986f395e4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|77|13|v|rust
	term3
b185fd4b26a5ee9a947be04223c9ed6b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|111|22|v|tex
	f_{\chi,\mathrm{eq}}(q)
3131a002e61d4bfa5c2872a8ae480b8f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|111|10|v|tex
	&\times
b71eb7b75a86d7a398cbea6e17345abe|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|117|19|v|tex
	\tilde{g}
05efe0a4a7c41d53f90ddec343a661b9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|107|1|V|tex
	\begin{align}
		\pdv{f}{x}(x,q) 
		&= \dfrac{g_{\chi}m_{\chi}^3}{2\pi^2\tilde{H}x^4}
		\int\dd{\tilde{q}}\tilde{q}^2\dfrac{1}{2}
		\int\dd{\cos\theta}v_{\mathrm{Mol}}\sigma_{\bar{\chi}\chi\to \bar{f}f}
		\qty[f_{\chi,\mathrm{eq}}(q)f_{\chi,\mathrm{eq}}(\tilde{q})-f(\tilde{q})f(q)]\\
		&\qquad + \dfrac{\gamma(x)}{2\tilde{H}x}
		\qty[x_q\pdv[2]{f}{q}+\qty(q+\dfrac{2x_q}{q}+\dfrac{q}{x_q})\pdv{f}{q}
		+3f
		]\\
		&\qquad + \tilde{g}\dfrac{q}{x}\pdv{f}{q}
	\end{align}
87bc8881f68415dd22c157d6f0e523f0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|121|1|v|tex
		\pdv{f}{x}(x,q) 
d5fbb8e760f59b2d61ccaee1c61831f0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|124|21|v|tex
	v_{\mathrm{Mol}}
7fca278cd4e9e23da4407289408cb479|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|124|2|v|tex
	\int\dd{\cos\theta}
b562cc189f994ee64836481559a7027c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|123|31|v|tex
	\dfrac{1}{2}
9e1497b528c453ee9b7b1029c1520101|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|125|10|v|tex
	\chi,
05a4c3fe37dd5267d00a2f615e697e44|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|125|68|v|tex
	f(q)
1f6a51aa8623c66f2946cc2f0f663912|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|127|14|v|tex
	l2]{f}{q}
2f8b123541714a19ef423425bc870419|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|120|1|V|tex
	\begin{align}
		\dv{f_i}{x}
		&= \dfrac{g_{\chi}m_{\chi}^3}{2\pi^2\tilde{H}x^4}
		\int\dd{\tilde{q}}\tilde{q}^2
		\expval{\sigma_{\bar{\chi}\chi\to \bar{f}f}v_{\mathrm{Mol}}}
		\qty[f_{\mathrm{eq},i}f_{\chi,\mathrm{eq}}(\tilde{q})-f(\tilde{q})f_i]\\
		&\qquad + \dfrac{\gamma(x)}{2\tilde{H}x}
		\qty[x_q\pd{q}^2f_i+\qty(q+\dfrac{2x_q}{q}+\dfrac{q}{x_q})\pd{q}f_i
		+3f_i
		]\\
		&\qquad + \tilde{g}\dfrac{q}{x}\pd{q}f_i
	\end{align}
7f0d44ca7191a7169fa2a63e8a05dbde|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|135|1|V|tex
		\dv{f_i}{x}
		&= \dfrac{g_{\chi}m_{\chi}^3}{2\pi^2\tilde{H}x^4}
97105f70ea2aa0b6cfe4e820ff2f7452|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|138|1|V|tex
		&\qquad + \dfrac{\gamma(x)}{2\tilde{H}x}
		\qty[x_q\pd{q}^2f_i+\qty(q+\dfrac{2x_q}{q}+\dfrac{q}{x_q})\pd{q}f_i
		+3f_i
		]\\
		&\qquad + \tilde{g}\dfrac{q}{x}\pd{q}f_i
e576d3ad5cbe1dedb3f05d1e5a4cd00d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|136|1|V|tex
		\expval{\sigma_{\bar{\chi}\chi\to \bar{f}f}v_{\mathrm{Mol}}}
29005a27aa568b852ebcada7614930fa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|137|1|V|tex
		\qty[f_{\mathrm{eq},i}f_{\chi,\mathrm{eq}}(\tilde{q})-f(\tilde{q})f_i]
09f0482073b0d3dacabac4658cb6a5de|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|140|41|v|tex
	(\tilde{q})
ace0060e7758e53c47ea0a06a359cc82|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|138|23|v|tex
	\tilde
8a30532e2e4fbac1d59983c62d910902|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|138|34|v|tex
	tilde
33d4f191adf52231ff050c6a427c3922|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|140|7|v|tex
	f_{\mathrm{eq},i}
56fec20a5d1887d074ab7c2bb25624dc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|138|23|v|tex
	\bar{q}
f7704555759acae8b14a4301bf7fd830|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|146|1|V|tex
		\dv{f_i}{x}
		&= \dfrac{g_{\chi}m_{\chi}^3}{2\pi^2\tilde{H}x^4}
		\int\dd{\tilde{q}}\tilde{q}^2
		\expval{\sigma_{\bar{\chi}\chi\to \bar{f}f}v_{\mathrm{Mol}}}
		\qty[f_{\mathrm{eq},i}f_{\chi,\mathrm{eq}}(\tilde{q})-f(\tilde{q})f_i]\\
		&\qquad + \dfrac{\gamma(x)}{2\tilde{H}x}
		\qty[x_q\pd{q}^2f_i+\qty(q+\dfrac{2x_q}{q}+\dfrac{q}{x_q})\pd{q}f_i
		+3f_i
		]\\
6412a35d2ec86f2bcb443a40d872228c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|146|2|v|tex
	&\qquad + \tilde{g}\dfrac{q}{x}
2236b3467c76d24ca0f0db16539408a2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|146|1|V|tex
		\pd{q}f_i &= \dfrac{f_{i+1}-f_{i-1}}{2\Delta q_i}\\
23b4faaaa3bae723e35cf2cccbf4e7c0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|145|23|v|tex
	 formulea
6f3ce5b3cba41302c85a6fa40fbbe0ff|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|146|1|V|tex
	\begin{align}
		\pd{q}f_i &= \dfrac{f_{i+1}-f_{i-1}}{2\Delta q_i}, \qquad i\in\{2,\dots,N-1\}\\
		\pd{q}^2f_i &= \dfrac{f_{i+1}+f_{i-1}-2f_i}{\Delta q_i^2}
	\end{align}
1a35246d51eec3ed91e93d83d214d895|file:///Users/loganmorrison/Documents/research/KineticRecoupling/latex/KineticRecoupling.tex|152|47|v|tex
	, \qquad i\in\{2,\dots,N-1\}\\
7457ddf137eb56c9ce011ae948e2163b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|5|V|rust
	    let sol = integrate_full_boltzmann(model, 20, (1.0, 100.0));
7dc812905908a19b437cf9206e76aeca|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|1|1|V|cpp
	#include <lanre/diffeq/radau.hpp>
1e998685587b8143857a9fd3189646d4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|2|24|v|cpp
	radau.hpp>
d7a607ead7d9f61541eb89309d2dd3db|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|2|1|V|cpp
	#include <lanre/diffeq/problem.hpp>
158ad32bf4cbf2daa8b7e6410c848735|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|3|24|v|cpp
	problem.hpp>
98a7a1ef5bcb2480d5be37d1dbfba39c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|5|1|V|cpp
	clas
2c24fa3f463f07c33fd225a0bc181f9c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|5|1|V|cpp
	class FullBoltzmann 
ef336c691f45b6aa2203b1d757e51ec4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|3|V|cpp
	  Sc
bc7f7a06a1a13baaf336c12ad7baa1b3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|10|2|V|cpp
		double 
726da5641ed0ecaed908b9553ca0205b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|14|1|V|cpp
		  integrator = std::integral_constant
0b230a0a3a0017381a526ea2effbfed8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|3|V|cpp
	  lanre::integrate::Quad<double> integrator;
d479d68cd8b8481a3b8ce332edc08923|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|1|V|cpp
	  double gamma_integrand_sf_sf(double, double, double, double);
947d5400677a3b4591dc36771ce09a16|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|9|40|v|cpp
	, double, double);
5d1749159dfa1408ceb83f50dfa14524|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|9|1|V|cpp
	  double gamma_integrand(double, double);
e4a17bc7e1ec1654a2f73cc341c4e27a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|15|15|v|cpp
	_integrand
1fac923acb5cb91d430ac88f85abcc60|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|1|V|cpp
	  double gamma_integrand_sf_sf(double, double, double, double);
	  double gamma_integrand(double, double);
abcbfe0c36e40fd09e1a15062d490321|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|19|9|V|cpp
	        double ms = self.ms;
771d0bbe9dc951a50c8fa078b18ef8a0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|19|9|V|cpp
	        let mh = HIGGS_MASS;
4742299175ab00cd7745c993f296c624|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|23|1|V|cpp
	    double temp1 = mf.powi(2);
	    double temp2 = mh.powi(2);
	    double temp3 = ms.powi(2);
	    double temp4 = mh.powi(-2);
	    double temp5 = 2.0 * w;
	    double temp6 = ms + temp5;
	    double temp7 = -4.0 * temp3;
	    double temp8 = temp2 + temp7;
	    double temp9 = temp1 * temp8;
	    double temp10 = w.powi(2);
	    double temp11 = 4.0 * ms * temp10;
	    double temp12 = temp2 * temp6;
	    double temp13 = temp11 + temp12;
	    double temp14 = ms * temp13;
	    double temp15 = temp14 + temp9;
	
	    (self.lam_hs.powi(2) * ncol * temp1 *
	     ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) /
	          temp15 +
	      ((temp15 * temp4) / (temp1 + ms * temp6)).ln())) /
	        2.0
1ae452c4aeffd037a95948ea5d648207|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|22|17|v|cpp
	
		  sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
aae811fa416e5ddcc38ae33d47ab4e3e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|19|62|v|cpp
	, double) {
b01495bc49f961ffe9d62694afa630fa|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|21|3|V|cpp
	  double lamS = 
002ed31cb2395f558e330770d8c0f47b|file:///Users/loganmorrison/.config/nvim/init.vim|61|1|v|vim
	Plug 
2ec2243e3d050f25a5707829bedf8ae0|file:///Users/loganmorrison/.vim/plugged/rust.vim/ftplugin/rust.vim|46|1|V|vim
	setlocal smartindent nocindent
94829098e4b7e933c0f54396998eb953|file:///Users/loganmorrison/.vim/plugged/rust.vim/ftplugin/rust.vim|50|1|V|vim
	    setlocal tabstop=8 shiftwidth=4 softtabstop=4 expandtab
2986831ae18bf2304c7d237b75dcbd32|file:///Users/loganmorrison/.vim/plugged/rust.vim/ftplugin/rust.vim|51|1|V|vim
	    setlocal textwidth=99
721655e27efc9984b3c4dc8f275f0f47|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|38|1|V|rust
	        let temp = x / self.ms;
	        let pre = 1.0 / (48.0 * (self.ms * PI).powi(3) * 1.0) / 8.0;
	        let temp_fac = 1.0 / (2.0 * temp) / (1.0 + (w / temp).cosh());
	        let mut sum = 0.0;
	
	        sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
	        pre * temp_fac * sum
28c5e409e6642b2cfe079b9f0f29c1a9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|50|46|v|cpp
	.powi(3)
413d89338f68e4347305107f46a8d5ce|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|54|40|v|cpp
	lanre::k
8731b1390f289080b1244803970aaee8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|51|69|v|cpp
	.cosh()
cb6c46a83ec68b3ece43e7193de6ff42|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|19|1|V|cpp
	/**
	 * Compute the integrand for the transfer integral for scalar scattering off
	 * a SM fermion.
	 */
6629667414d0de450e97ddcb009bb4f0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|12|1|V|cpp
	  double sigma_ss_ff(double, double, double);
a30d2109b9b45077d3b8e66693959513|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|13|1|V|cpp
	  double sigma_ss_ww(double);
039fe7643f6ad6d207c22898e751bc08|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|14|1|V|cpp
	  double sigma_ss_zz(double);
2712eb277c7f8a65bc1226c7a5f4ac0a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|12|1|V|cpp
	  double sigma_ss_ff(double, double, double);
	  double sigma_ss_ww(double);
	  double sigma_ss_zz(double);
	  double sigma_ss_hh(double);
be4bdc77421cf3aa609aacaf0ab7101a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|61|8|v|cpp
	ScalarSinglet::
35018f810941236c8cc0c1b6eebe43ff|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|81|3|v|cpp
	if (cme > 2.0 * mf && cme > 2.0 * ms){
	  }
2e1b111645d914e3b30cf5f81126603a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|96|1|V|cpp
	double ScalarSinglet::sigma_ss_hh(double cme) {
5aa5ac48f7e2a9af75128320fe12e41a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|96|1|V|cpp
	if (cme > 2.0 * lanre::kHIGGS_MASS && cme > 2.0 * ms){
1b85e00262be818e9fa2797d71f14ec8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|83|1|V|cpp
	    return 0.0;
03936a66ba05d0156aa3c3cdb5252646|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|102|23|v|cpp
	lanre::kW_BOSON_MASS
ac12de4d55391c29616e1deaaeefa871|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|102|1|V|cpp
	            (12 * pow(lanre::kW_BOSON_MASS, 4) + pow(s, 2) - 4 * s * temp2) *
	            sqrt(1 - 4 * temp1 * temp2) * pow(VH, 4)) /
c4f7dca19e1f7f67015009672ecb26d8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|119|23|v|cpp
	lanre::kZ_BOSON_MASS
ed370ab3523bcbd274a3ce53c008f081|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|161|15|v|cpp
	ArcCoth
da274aa5ca4392ec5d1fcce96c5ff42b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|126|1|V|rust
	        self.sigma_ss_ff(cme, TOP_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, CHARM_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, UP_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, BOTTOM_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, STRANGE_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, DOWN_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, TAU_MASS, 1.0)
	            + self.sigma_ss_ff(cme, MUON_MASS, 1.0)
	            + self.sigma_ss_ff(cme, ELECTRON_MASS, 1.0)
	            + self.sigma_ss_zz(cme)
	            + self.sigma_ss_ww(cme)
	        //+ dbg!(self.sigma_ss_hh(cme))
2b2339d187e9751c135ff7b65481c097|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|178|3|v|cpp
	//+ 
69e4f07865c515990127dd6888f789ce|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|22|1|V|cpp
	  double sigma_ss(double);
f0c0789a8c4630e1b63623a724a8aa11|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|98|34|v|cpp
	->double
cb427738a5c5903f5f88cfcd91b8ffe3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|100|20|v|cpp
	limits
301b412b59972014cd8d7db1eb0581e0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|100|42|v|cpp
	<double>
867ee49782b8dfedb893f5f0bd1f4d5d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|99|26|v|cpp
	::quad
46e4dce2fcac76dbc058fb15ff16f667|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|97|43|V|cpp
	auto ScalarSinglet::gamma(double x) -> double {
	  auto f = [this, x](double w) { return gamma_integrand(w, x); };
	  return lanre::integrate::Quad<double>::integrate(
	      f, 0.0, std::numeric_limits<double>::infinity());
	}
f8b77555ced217c66020db60cd2169d5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|103|1|v|cpp
	/*
	 * Cross sections
	 */
	
	
586c9afa5080619e82dc343893c1547f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|87|1|V|cpp
	/* ===========================
	 * Annihilation Cross sections
	 * ===========================
	 */
f0eda8116adaf5bda3dd845e04c1c148|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|27|3|v|cpp
	 Annihilation Cross sections
04eb28fdf814af8bca87989b153037b5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|100|1|V|cpp
	/**
	 * Compute the annihilation cross section for s+s -> f + fbar
	 */
88e87b5c9d4d9be4682d4bcd43d29170|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|119|1|V|cpp
	/**
	 * Compute the annihilation cross section for s+s -> w+ + w-.
	 */
9c374e6683fbb6e1bbd7264ffd354050|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|140|1|V|cpp
	/**
	 * Compute the annihilation cross section for s+s -> Z + Z.
	 */
4212217cf852850c75cb7880b07cdd12|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|161|1|V|cpp
	/**
	 * Compute the annihilation cross section for s+s -> H + H.
	 */
8652ff485e6a680af900eb77750195c5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|204|1|V|cpp
	/**
	 * Compute the annihilation cross section for s+s -> X, where X is all
	 * available final states.
	 */
	auto ScalarSinglet::sigma_ss(double cme) -> double {
	  return sigma_ss_ff(cme, lanre::kTOP_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kCHARM_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kUP_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kBOTTOM_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kSTRANGE_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kDOWN_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kTAU_MASS, 1.0) +
	         sigma_ss_ff(cme, lanre::kMUON_MASS, 1.0) +
	         sigma_ss_ff(cme, lanre::kELECTRON_MASS, 1.0) + sigma_ss_zz(cme) +
	         sigma_ss_ww(cme) + sigma_ss_hh(cme);
	}
fe4049b88d50a7c6e9ed6e4f54a12276|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|228|1|V|cpp
	  return sigma_ss_ff(cme, lanre::kTOP_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kCHARM_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kUP_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kBOTTOM_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kSTRANGE_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kDOWN_QUARK_MASS, 3.0) +
	         sigma_ss_ff(cme, lanre::kTAU_MASS, 1.0) +
	         sigma_ss_ff(cme, lanre::kMUON_MASS, 1.0) +
	         sigma_ss_ff(cme, lanre::kELECTRON_MASS, 1.0) + sigma_ss_zz(cme) +
	         sigma_ss_ww(cme) + sigma_ss_hh(cme);
801416bf25100f3552e027868dbf8df4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|224|1|V|cpp
	 * Compute the annihilation cross section for s+s -> X, where X is all
	 * available final states.
a092fcfcc467651173fcaff4907d02ce|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|8|1|V|rust
	    static ref GAUSS_LEG_NS: [f64; 50] = [
	        -0.998866404420071,
	        -0.9940319694320907,
	        -0.9853540840480058,
	        -0.972864385106692,
	        -0.9566109552428079,
	        -0.936656618944878,
	        -0.9130785566557919,
	        -0.8859679795236131,
	        -0.8554297694299461,
	        -0.821582070859336,
	        -0.7845558329003993,
	        -0.7444943022260685,
	        -0.7015524687068222,
	        -0.6558964656854394,
	        -0.6077029271849502,
	        -0.5571583045146501,
	        -0.5044581449074642,
	        -0.44980633497403877,
	        -0.39341431189756515,
	        -0.33550024541943735,
	        -0.276288193779532,
	        -0.21600723687604176,
	        -0.1548905899981459,
	        -0.09317470156008614,
	        -0.03109833832718888,
	        0.03109833832718888,
	        0.09317470156008614,
	        0.1548905899981459,
	        0.21600723687604176,
	        0.276288193779532,
	        0.33550024541943735,
	        0.39341431189756515,
	        0.44980633497403877,
	        0.5044581449074642,
	        0.5571583045146501,
	        0.6077029271849502,
	        0.6558964656854394,
	        0.7015524687068222,
	        0.7444943022260685,
	        0.7845558329003993,
	        0.821582070859336,
	        0.8554297694299461,
	        0.8859679795236131,
	        0.9130785566557919,
	        0.936656618944878,
	        0.9566109552428079,
	        0.972864385106692,
	        0.9853540840480058,
	        0.9940319694320907,
	        0.998864044200716,
	    ];
	    static ref GAUSS_LEG_WS: [f64; 50] = [
	        0.0029086225531551016,
	        0.006759799195745375,
	        0.010590548383650852,
	        0.01438082276148563,
	        0.018115560713489423,
	        0.021780243170124725,
	        0.025360673570012402,
	        0.028842993580535152,
	        0.03221372822357803,
	        0.03545983561514616,
	        0.038568756612587685,
	        0.04152846309014772,
	        0.04432750433880324,
	        0.04695505130394836,
	        0.049400938449466275,
	        0.05165570306958109,
	        0.05371062188899619,
	        0.05555774480621255,
	        0.057189925647728415,
	        0.058600849813222416,
	        0.05978505870426544,
	        0.06073797084177024,
	        0.06145589959031668,
	        0.061936067420683256,
	        0.0621766166553472,
	        0.0621766166553472,
	        0.061936067420683256,
	        0.06145589959031668,
	        0.06073797084177024,
	        0.05978505870426544,
	        0.058600849813222416,
	        0.057189925647728415,
	        0.05555774480621255,
	        0.05371062188899619,
	        0.05165570306958109,
	        0.049400938449466275,
	        0.04695505130394836,
	        0.04432750433880324,
	        0.04152846309014772,
	        0.038568756612587685,
	        0.03545983561514616,
	        0.03221372822357803,
	        0.028842993580535152,
	        0.025360673570012402,
	        0.021780243170124725,
	        0.018115560713489423,
	        0.01438082276148563,
	        0.01059048383650852,
	        0.006759799195745375,
	        0.00290862255315510165,
	    ];
a81259cef8e959c624df1d456e5d3297|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|9|5|v|cpp
	static
baa53a5e40e2419fe06775a7e7d6dc7d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|9|11|v|cpp
	ref 
a5b07843b020c36f19b4d1865f7583d0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|27|30|v|cpp
	 : [f64; 50] = [
9f2123b924dede75c18ee6961091bd2b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|155|1|V|rust
	        let ms2 = self.ms * self.ms;
	        let e1 = (k1 * k1 + ms2).sqrt();
	        let e2 = (k2 * k2 + ms2).sqrt();
b1c0492f011fe5483893b53c41569b8c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/boltzmann.hpp|28|1|V|cpp
	    void dudt(Vector<double> &dw, const Vector<double> &w, const double logx) override {
	        double x = exp(logx);
	        double T = params.mx / x;
	        double s = cosmology::sm_entropy_density(T);
	
	        double weq = log(cosmology::neq(T, params.mx, 2.0, 1) / s);
	        double ww = w(0);
	
	        double pf = -sqrt(M_PI / 45) * kM_PLANK * cosmology::sm_sqrt_gstar(T) * T;
	        double sigmav = thermal_cross_section(params, x, "all", "all");
	
	        // dW_e / dlogx
	        dw(0) = pf * sigmav * (exp(ww) - exp(2.0 * weq - ww));
	    }
	
	    void dfdu(Matrix<double> &J, const Vector<double> &w, const double logx) override {
	        double x = exp(logx);
	        double T = params.mx / x;
	        double s = cosmology::sm_entropy_density(T);
	
	        double weq = log(cosmology::neq(T, params.mx, 2.0, 1) / s);
	        double ww = w(0);
	
	        double pf = -sqrt(M_PI / 45) * kM_PLANK * cosmology::sm_sqrt_gstar(T) * T;
	        double sigmav = thermal_cross_section(params, x, "all", "all");
	
	        // dW_e / dlogx
	        J(0, 0) = pf * sigmav * (exp(ww) + exp(2.0 * weq - ww));
	    }
55e4d42a82610bb41904448a57e1e7ac|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|292|1|V|cpp
	void ScalarSinglet::dudt(Vector<double> &dw, const Vector<double> &w,
	                         const double logx) override {
2b07e9f582744a07c41a4c03bf787bda|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|1|V|cpp
	use namespace lanre::
b72487aeeb2ca93b3691d6edec5718d9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|70|1|V|cpp
	  void dudt(Vector<double> &dw, const Vector<double> &w,
	            const double logx) override{};
57dea6f5039281b7fee517fc43bf3110|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|72|13|v|cpp
	Vector
a79a1f80d5f1d7a5cd14587b2965d419|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|73|26|v|cpp
	logx
8f4c567f6bd79d288e9823ff9f7d698b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|7|1|V|cpp
	#include <lanre/cosmology/thermodynamic_functions.hpp>
bc0188295c05dd7a15b7228cdd092b98|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|8|27|v|cpp
	thermodynamic_functions.hpp>
2dc307b49ac6dff988b8d53b68524640|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|65|1|V|cpp
	  auto gefft(double) -> double;
c9a5ede0f54d9e7677a1d8fc9dab8911|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|66|8|v|cpp
	gefft
74eb7276255270f521d1dd96df95ba38|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|65|1|V|cpp
	  auto gefft(double) -> double;
	  auto hubblet(double) -> double;
ee066958d2ad8beb377e157353264ac1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|11|1|V|cpp
	using namespace ::lanre;
fb764ee4a99e43a973bdb98c0a119cd0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|26|1|V|rust
	    let h = (4.0 * PI.powi(3) * sm_geff(temp) / 45.0).sqrt() * temp * temp / M_PLANK;
	    h / (1.0 + gefft(temp))
c92cb7aec339f6fd415f1475f5ddc14e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|309|68|v|cpp
	.sqrt()
98e63ad7defe1527b5edb3b4a0af2f44|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|310|29|v|cpp
	temp));
8c5ad06f48082e2cd7788d90a6a6209c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|315|45|v|cpp
	override 
34a57fa375013352939fdcb1cf606048|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|78|3|v|cpp
	void 
d4566fea2f796ca060af5559f8c860f9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|78|1|V|cpp
	  diffeq::ODESolution integrate_full_boltzmann(size_t n, double xmin,
	                                               double xmax);
20407c113fb0b0e0b51e8104d935c95d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|40|1|V|rust
	        let ht = hubblet(x);
	        let g = p.g();
	        let mx = p.dm_mass();
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let temp = mx / x;
	        let feq = qs.mapv(|q| p.feq(x, q));
	        let gam = p.gamma(x);
	        let gt = gefft(x);
	
	        deriv.fill(0.0);
	
	        for i in 0..n {
	            for k in 0..n {
	                deriv[i] += if k != 0 && k != n - 1 { 1.0 } else { 0.5 }
	                    * pre
	                    * dq
	                    * qs[k]
	                    * qs[k]
	                    * p.sigmav(qs[i] * temp, qs[k] * temp)
	                    * (feq[i] * feq[k] - f[i] * f[k]);
	            }
	
	            let xq = (x * x + qs[i] * qs[i]).sqrt();
	            let df = if i != 0 && i != n - 1 {
	                (f[i + 1] - f[i - 1]) / (2.0 * dq)
	            } else if i == 0 {
	                (f[i + 1] - f[i]) / dq
	            } else {
	                0.0
	            };
	            let d2f = if i != 0 && i != n - 1 {
	                (f[i + 1] + f[i - 1] - 2.0 * f[i]) / dq2
	            } else if i == 0 {
	                (f[2] + f[0] - 2.0 * f[1]) / dq2
	            } else {
	                0.0
	            };
	            deriv[i] += gam / (2.0 * ht * x)
	                * (xq * d2f + (qs[i] + 2.0 * xq / qs[i] + qs[i] / xq) * df + 3.0 * f[i]);
	            deriv[i] += gt * qs[i] / x * df;
	        }
aeacb68c85d48b6d923acba1d782885a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|319|1|V|cpp
	  double x = exp(logx);
	  double T = params.mx / x;
	  double s = cosmology::sm_entropy_density(T);
	
	  double weq = log(cosmology::neq(T, params.mx, 2.0, 1) / s);
	  double ww = w(0);
	
	  double pf = -sqrt(M_PI / 45) * kM_PLANK * cosmology::sm_sqrt_gstar(T) * T;
	  double sigmav = thermal_cross_section(params, x, "all", "all");
	
	  // dW_e / dlogx
	  dw(0) = pf * sigmav * (exp(ww) - exp(2.0 * weq - ww));
16b7d607b090373b99ce1d2915029fd6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|320|3|V|cpp
	  double g = p.g();
948a3826f64661164a8c0a413a353a14|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|322|33|v|cpp
	.powi(4)
03b57d852e14dac355851001524eb04a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|322|46|v|cpp
	std::f64::consts::
e5808e8228a1caad854701eddbb56927|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|320|3|V|cpp
	  double mx = p.dm_mass();
546e51b326e5de1e3d5a739fb2d4050c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|326|3|V|cpp
	  deriv.fill(0.0);
7101949e24d9c980661a5ab95e488323|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|328|31|v|cpp
	in 0..n
5c899b128678e05b3d24a57cac6c2ad4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|326|7|v|cpp
	(size_t i = 0; i < n; i++) {
cff69d08411f9723f2ffa3944b610453|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|328|1|V|cpp
	              k in 0..n {
3cdf0cecaed79ff884ebf0c751c27637|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|329|45|v|cpp
	{ 1.0 }
f717bb891c3ce4e5a3d78ae04c6cbf36|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|330|7|v|cpp
	else {0.5}
4d430af2245255479ebddd1db6f696c1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|340|5|V|cpp
	    else {0.0};
f788a5989ef3b893d1bbdbf0f082b42f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|341|1|V|cpp
	    double d2f = 0.0;
49f4b1bbc4ddb54fa273660215503834|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|327|1|V|cpp
	  double dq = qs[1] - qs[0];
8efed9bc6c18954847630a7379e20e0e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|323|1|V|cpp
	  std::vector<double> feq = qs.mapv(| q | p.feq(x, q));
3c954790c7b5d29dfcf27554a2c5845a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|325|29|v|cpp
	qs.mapv(| q | p.feq(x, q));
a1651bf9cd34fa66fedcf7f45679374a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|83|1|V|rust
	        let ht = hubblet(x);
	        let g = p.g();
	        let mx = p.dm_mass();
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let temp = mx / x;
	        let gam = p.gamma(x);
	        let gt = gefft(x);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	
	        jac.fill(0.0);
	
	        // Construct a matrix out of the first term in the ODE. This will
	        // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	        // We will want to integrate this term of qt or the j-index. We
	        // do so below using the trapizoid rule.
	        for i in 0..n {
	            for j in 0..n {
	                jac[[i, j]] += if j == 0 || j == n - 1 { 0.5 } else { 1.0 }
	                    * -pre
	                    * dq
	                    * qs[j]
	                    * qs[j]
	                    * p.sigmav(qs[i] * temp, qs[j] * temp)
	                    * f[i];
	                if i == j {
	                    for k in 0..n {
	                        jac[[i, j]] += if k == 0 || k == n - 1 { 0.5 } else { 1.0 }
	                            * -pre
	                            * dq
	                            * qs[k]
	                            * qs[k]
	                            * p.sigmav(qs[i] * temp, qs[k] * temp)
	                            * f[k];
	                    }
	                }
	
	                let dfdf = if i != 0 && i != n - 1 {
	                    if j == i + 1 {
	                        1.0 / (2.0 * dq)
	                    } else if j == i - 1 {
	                        -1.0 / (2.0 * dq)
	                    } else {
	                        0.0
	                    }
	                } else if i == 0 {
	                    if j == i + 1 {
	                        1.0 / dq
	                    } else if j == i {
	                        -1.0 / dq
	                    } else {
	                        0.0
	                    }
	                } else {
	                    0.0
	                };
	                let d2fdf = if i != 0 && i != n - 1 {
	                    // f[i+1] + f[i-1] - f[i]
	                    if j == i + 1 || j == i - 1 {
	                        1.0 / dq / dq
	                    } else if j == i {
	                        -2.0 / dq / dq
	                    } else {
	                        0.0
	                    }
	                } else if i == 0 {
	                    if j == 2 || j == 0 {
	                        1.0 / dq / dq
	                    } else if j == 1 {
	                        -2.0 / dq / dq
	                    } else {
	                        0.0
	                    }
	                } else {
	                    0.0
	                };
	
	                jac[[i, j]] += gam / (2.0 * ht * x)
	                    * (xq[i] * d2fdf + (qs[i] + 2.0 * xq[i] / qs[i] + qs[i] / xq[i]) * dfdf + 3.0);
	                jac[[i, j]] += gt * qs[i] / x * dfdf;
	            }
	        }
d17a9b58739314add9ce39a214d017cb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|363|1|V|cpp
	  double x = exp(logx);
	  double T = params.mx / x;
	  double s = cosmology::sm_entropy_density(T);
	
	  double weq = log(cosmology::neq(T, params.mx, 2.0, 1) / s);
	  double ww = w(0);
	
	  double pf = -sqrt(M_PI / 45) * kM_PLANK * cosmology::sm_sqrt_gstar(T) * T;
	  double sigmav = thermal_cross_section(params, x, "all", "all");
	
	  // dW_e / dlogx
	  J(0, 0) = pf * sigmav * (exp(ww) + exp(2.0 * weq - ww));
37950d9ed2167360195965419f771e51|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|373|3|V|cpp
	  jac.fill(0.0);
6865e30a71fb1f63974998cb761c2af6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|364|14|v|cpp
	 p.dm_mass();
b654cb42d975678a3ae4e0312a95c65c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|364|3|V|cpp
	  double mx =
3bd83e6e44bc2e62e76c93e9070b7011|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|365|42|v|cpp
	std::f64::consts::PI.powi(2)
f1cbd113125af64011e059e10799788d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|375|12|v|cpp
	i in 0..n
0a01c6bb0d8557d2372daeafe8124e9a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|376|1|V|cpp
	              j in 0..n {
a12c3f41062cec78ca7bc2911ea5c489|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|376|46|v|cpp
	 { 0.5 }
09385e0a5df0db1f7c738bd909432d46|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|377|6|v|cpp
	 else {1.0} *
efc16eb04748cad953430ae827d15a99|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|375|9|v|cpp
	(size_t j = 0; j < n; j++) {
d3edc6d31d58502e5d76e30463512466|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|381|1|V|cpp
	                      k in 0..n {
26240ab595d2430fae0d75d15e9df0f9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|382|11|v|cpp
	else {1.0} * -
ba7aa292b4b42e11858dd129ac849476|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|395|17|V|cpp
	        } else {
	          0.0
	        }
f303ed2f682628da39ca53bdba637746|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|402|11|v|cpp
	else {
	            0.0
	          }
a1ae7235a1d97aacd8b309b5ed8c20b6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|403|9|v|cpp
	else {
	        0.0
	      };
	
09807935065af2ecb025b6a204087bc8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|411|9|v|cpp
	else {
	          0.0
	        }
272b8da17a756a09cb45c7d5f12d9c31|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|417|1|V|cpp
	        else {
	          0.0
	        }
e35c27896456db933a4c42e2c2d7f017|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|403|14|v|cpp
	d2fdf
b5c4f8f5a4f73c3efe34f9c5ea33768b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|407|11|v|cpp
	d2fdf = 
8f9feca599326da891a8abb835720b90|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|369|29|v|cpp
	(x * x + q * q).sqrt()
d35ea97220baf618050627b9424eb872|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|369|3|V|cpp
	  double xq = qs.mapv(| q |);
d028c6a3e7c2e7df9ecff1d3dce210b5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|372|1|V|cpp
	  // Construct a matrix out of the first term in the ODE. This will
	  // represent: qt[j]^2 * <sv>[i,j] * (feq[i]*feq[j]-f[i]*f[j]).
	  // We will want to integrate this term of qt or the j-index. We
	  // do so below using the trapizoid rule.
6c1d2b64e274988b51813e60853c517d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|404|30|v|cpp
	/ dq;
adc3cb13859ec80abba1629cd00ee2d2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|402|28|v|cpp
	 / dq;
ac57a0220be4496cc51cb97d625de347|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|422|1|V|cpp
	diffeq::ODESolution
1d67e0640f0a0ed3ca90b0e073e9ae69|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|424|3|V|cpp
	  diffeq::ODESolution
511a0c40e27422744f1853894b1e65ad|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/kinetic_mixing/boltzmann.hpp|73|1|V|cpp
	    auto logx_span = std::make_pair(std::log(xstart), std::log(xend));
	
	    KineticMixingBoltzman boltz{params};
	    double Tinit = params.mx / exp(logx_span.first);
	
	    Vector<double> winit{1};
	    winit(0) = log(neq(Tinit, params.mx, 2.0, 1) / sm_entropy_density(Tinit));
	
	    ODEProblem problem{std::make_shared<KineticMixingBoltzman>(boltz), winit, logx_span};
	
	    if (t_alg == "rodas") {
	        Rodas alg{};
	        ODEIntegratorOptions opts{};
	        opts.abstol = abstol;
	        opts.reltol = reltol;
	
	        return solve(problem, alg, opts);
	    } else {
	        Radau5 alg{};
	        ODEIntegratorOptions opts{};
	        opts.abstol = abstol;
	        opts.reltol = reltol;
	
	        return solve(problem, alg, opts);
	    }
2ce79be2b9cb76c04ae2b0ace684f604|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|425|44|v|cpp
	xstart
8fb64d9b70675a78aec5a62b8ba31a48|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|422|78|v|cpp
	xmax
d6569add588a6b6fdf050d307000d66a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|428|3|v|cpp
	KineticMixingBoltzman 
02c84f1dc96e428fb92ae66cdab53b72|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|428|3|V|cpp
	  ScalarSinglet boltz{params};
a2a07fcc46fdda1bc3c34a398808c5d3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|428|18|v|cpp
	params.
ba91d7b7d65d8f21171df50ebf9f9311|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|426|35|v|cpp
	std::log(
1280946fa7253360150017b80ac8cc69|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|426|43|v|cpp
	xend
46ea11fd7454239b850efb8a6bb79f41|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|428|23|v|cpp
	exp(logx_span.first);
8d3707435ac49ad99285be3d1800299b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|434|39|v|cpp
	KineticMixingBoltzman
605f15382180e83633e7391e6d37ff6f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|431|18|v|cpp
	winit{1};
fd35b1acf9c16766a1630340474463a3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|435|1|V|cpp
	  auto xspan = std::make_pair(xstart, xend);
820b4ef8fca9cf2e7df561e61aec2333|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|437|1|V|cpp
	  double Tinit = ms / xstart;
97f4fb7836f6fcd2b1a3cd50de7cc1d1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|438|1|V|cpp
	  for (size_t i = 0; i < n; i++) {
	    qs.push_back(qmin + i * qstep);
	  }
fa1ab3a1054eeb12e2c3a1e7549e7957|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|432|1|V|cpp
	  for 
bcd035610d61566d8189cbf78c60179a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|436|1|V|cpp
	  // Fill in the qs
	  qs.clear();
	  qs.reserve(n);
	  double qstep = (qmax - qmin) / double(n - 1);
	  for (size_t i = 0; i < n; i++) {
	    qs.push_back(qmin + i * qstep);
	  }
09af47755cef3d170355e46fc2f31a4d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|441|2|v|cpp
	   qs.push_back(qmin + i * qstep);
317e8442c83a97972d0559a3d193c564|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|444|3|V|cpp
	  Vector<double> f(
3b92dde4cd674401b94aac9c469e2c31|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|444|3|V|cpp
	  winit(0) = log(neq(Tinit, params.mx, 2.0, 1) / sm_entropy_density(Tinit));
9e18a3311e807db18f7ec710e5e21f38|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|444|62|v|cpp
	winit
e1067caea5c2092f877d3913118c2dda|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|454|1|V|cpp
	    Radau5 alg{};
7f155c4be9ea6d0a01285ed783abb05c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|447|1|V|cpp
	  if (t_alg == "rodas") {
	    Rodas alg{};
	    ODEIntegratorOptions opts{};
	    opts.abstol = abstol;
	    opts.reltol = reltol;
	
	    return solve(problem, alg, opts);
	  } else {
	    Radau5 alg{};
	    ODEIntegratorOptions opts{};
	    opts.abstol = abstol;
	    opts.reltol = reltol;
	
d8a2db4dcd9f6cdb80c0791ba263f81c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|423|1|V|cpp
	auto ScalarSinglet::integrate_full_boltzmann(size_t n, double qmin, double qmax,
	                                             double xstart, double xend)
	    -> diffeq::ODESolution {
9df22f196a33acd0b372fe502de51211|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|79|3|v|cpp
	auto
f7b797747128aba2817136cbef564613|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|81|5|V|cpp
	    -> diffeq::ODESolution {
bc97b86448b2d20553387f4f31ffc5f7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|79|62|v|cpp
	qmin
91f12bec42d6b31f3fbae53e709e22cc|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|79|71|v|cpp
	qmax
b02d06eec80b690cfc62801d6f4cc58c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|444|48|v|cpp
	*this
6e013a4a3ca32fea1f8f1c3d5f52a3ee|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|444|39|v|cpp
	decltype(Sca)
0861a099e9593791de261ebb86e75eac|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|6|24|v|cpp
	problem
bedc2cf49041c37afec33c158f229fe1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|6|24|v|cpp
	.hpp
5a013b7d2adba97e568e04ae839cd053|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_autodiff_dual.cpp|197|1|v|cpp
	int main(int argc, char *argv[]) {
	    testing::InitGoogleTest(&argc, argv);
	    return RUN_ALL_TESTS();
	}
d3bc617b6b8c61911c5f6664ab1079ad|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_full_boltz.cpp|465|1|v|cpp
	int main(){
	}
75b660e72e8914462bab05c4c2fa0f47|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|335|1|V|cmake
	add_executable(test_particles test_particles.cpp)
	target_link_libraries(test_particles PUBLIC
	        lanre
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	set_target_properties(test_particles PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
7e45214f92b501af4495b82455b39e7c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|347|21|v|cmake
	particles
2b3de2eab7f59d513ab55c9c8ac3177a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|347|32|v|cmake
	test_particles.cpp)
34b8ef675aa930331938aa8be2f44d0a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|348|23|v|cmake
	test_particles
92c564d0d0319643a47889971ebc4f94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|80|1|V|rust
	            let s = cme * cme;
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = self.lam_hs.powi(2);
	            let temp3: f64 = HIGGS_MASS.powi(2);
	            let temp4: f64 = self.ms.powi(2);
	            let temp5: f64 = temp2.powi(2);
	            let temp6: f64 = -s;
	            let temp7: f64 = temp3 + temp6;
	            let temp8: f64 = temp7.powi(2);
	            let temp9: f64 = HIGGS_WIDTH.powi(2);
	            let temp10: f64 = temp3 * temp9;
	            let temp11: f64 = temp10 + temp8;
	            let temp12: f64 = 1.0 / temp11;
	            let temp13: f64 = HIGGS_VEV.powi(2);
	            let temp14: f64 = 2.0 * temp3;
	            let temp15: f64 = temp14 + temp6;
	            let temp16: f64 = 4.0 * temp3;
	            let temp17: f64 = temp16 + temp6;
	            let temp18: f64 = 1.0 / temp17.sqrt();
	            let temp19: f64 = -4.0 * temp4;
	            let temp20: f64 = s + temp19;
	            let temp21: f64 = 1.0 / temp20.sqrt();
	            (temp1
	                * temp2
	                * (1.0 - 4.0 * temp1 * temp3).sqrt()
	                * (1.0
	                    + 3.0 * temp12 * (2.0 * s * temp3 + temp5)
	                    + (2.0 * temp2 * HIGGS_VEV.powi(4))
	                        / (s * temp4 - 4.0 * temp3 * temp4 + temp5)
	                    + (8.0
	                        * self.lam_hs
	                        * temp12
	                        * temp13
	                        * temp18
	                        * temp21
	                        * (-((-s.powi(2) + self.lam_hs * temp13 * (s - temp3) + 4.0 * temp5)
	                            * temp7)
	                            + temp3 * (self.lam_hs * temp13 + temp14 + temp6) * temp9)
	                        * (temp15 * temp18 * temp21).recip().atan())
	                        / temp15))
	                / (16.0 * std::f64::consts::PI * (1.0 - 4.0 * temp1 * temp4).sqrt())
a37f3f1461dccac34a92061bc02bd111|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|83|29|v|rust
	lanre::
b895419a5f6894a618081f213dd82111|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|85|29|v|rust
	lanre
076aa5179dee9aa46525b68bb305de79|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|105|39|v|rust
	pow(lanre::k
bc256f630971b8a54f1c2fdef69266a8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|108|45|v|rust
	pow(s, 2)
03d734a4901930676367606890a5db51|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|110|33|v|rust
	atanh
414d10e220423cb59a592025fd09e21a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|49|9|V|rust
	        deriv.fill(0.0);
fb0d963ecdb655a38ed5b009bf8331af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|1|V|rust
	        jac.fill(0.0);
a21a77b818188c13cc419542dde60b74|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|79|1|V|rust
	            dbg!(deriv[i]);
18ced54a5cb34cc112a7262bba96618b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|158|1|V|rust
	                dbg!(jac[[i, j]]);
7d5948d53917e72c744e43281f0b70b7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|158|22|v|rust
	jac[[i, j]]
9b4be03a642d3a0a8b313ba46d05d2ed|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|158|1|V|rust
	                dbg!(i);
	                dbg!(j);
	                dbg!(jac[[i, j]]);
7926b3e3d06e2a5b68f79cd535dff5a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|2|1|V|rust
	    fn thermal_cross_section(&self, x: f64) -> f64;
2c965779afa5926fe883ff8c8d13fa99|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|3|8|v|rust
	thermal_cross_section
e63d42d3da135b5db4cb4c43df7c4bf2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|3|1|V|rust
	    fn mass(&self, x: f64) -> f64;
e583cf12b5a721164b51e69e9723ddcc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|10|1|V|rust
	    let dudt = |mut dw: ArrayViewMut1<f64>, w: ArrayView<f64>, logx:f64| {
	
	    }
68af0923db6100fb2ddc9878eb9819bf|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|11|1|V|rust
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	        let n = neq(temp, self.mx, 2.0, 1);
	        let weq: f64 = (n / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
831d29ebfae542a68b5b9485868ff379|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|25|1|V|rust
	        let x: f64 = logx.exp();
	        let temp: f64 = self.mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let n = neq(temp, self.mx, 2.0, 1);
	        let weq: f64 = (n / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = self.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
c7f618c2a21efdc2ef18cdc7ba6b66b7|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|56|1|V|rust
	        let mut integrator =
	            OdeIntegratorBuilder::default(&dudt, uinit, tspan, Radau5, self.clone())
	                .dfdu(&dfdu)
	                .reltol(1e-7)
	                .abstol(1e-7)
	                .build();
411d265dbc3a6a16dc9c4abd7a546ffc|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/boltzmann.rs|42|1|V|rust
	        let temp = self.mx / x0;
	        let n = neq(temp, self.mx, 2.0, 1);
	        let uinit = array![(n / sm_entropy_density(temp)).ln()];
	        let tspan = (x0.ln(), x1.ln());
6d96b9250f06567143cff6b7354ae5e1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|51|84|v|rust
	 .clone())
dacf1136401efaa18f1ca67a70698a12|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|138|5|V|rust
	    pub fn thermal_cross_section_integrand(&s
7f39d72b11a4d6bffb73ed43e47ee7f4|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing/thermal_cross_section.rs|8|1|V|rust
	        let m = self.mx;
	        let denom = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.annihilation_cross_section(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        pf * self.gk.integrate(integrand, 2.0, f64::INFINITY).val
72d759dd8f964d9b0b9b074505e7941b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|185|28|v|rust
	annihilation_cross_section
ee25d5274e434a27080f7d7b35d8796d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|118|1|V|rust
	    pub(super) gk_gamma: GaussKronrodIntegrator,
a047b7a251987fcd21dd18f2cfde42b5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|124|1|V|rust
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
f8c614793a50ad7840467caa6807533d|file:///Users/loganmorrison/Documents/coding/rust/haliax-dm-models/src/kinetic_mixing.rs|40|1|V|rust
	        let resonance = mv / mx;
	        let threshold = 2.0 * mv / mx;
	
	        let singular_points = if threshold > 2.0 {
	            if resonance > 2.0 {
	                vec![resonance, threshold]
	            } else {
	                vec![threshold]
	            }
	        } else {
	            vec![]
	        };
85602091da654f9d0e2bac6057880671|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|144|30|v|rust
	vec![]
7fee1e1c77065694a41dbf131048a358|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|18|1|V|rust
	    //    let mut file = std::fs::File::create("data.dat")?;
	    //    for (t, u) in sol {
	    //        let mut string = format!("{} {}\n", t, u).to_string();
	    //        string.retain(|c| !r#"(),"[]"#.contains(c));
	    //        file.write(string.as_bytes())?;
	    //    }
a44fc8fbcb981316e6b4cfe1d178e702|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|1|v|rust
	//        
a44fc8fbcb981316e6b4cfe1d178e702|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|1|v|rust
	//        
a44fc8fbcb981316e6b4cfe1d178e702|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|1|v|rust
	//        
cb8c5152a9cbd6ccb648bd26c344a106|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|15|1|V|rust
	    let sol = integrate_full_boltzmann(model, 20, (1.0, 20.0));
	    println!("retcode = {:?}", sol.retcode);
decd0127ec40e6e4dbfc385f37ed5286|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|23|1|V|rust
	    // let sol = integrate_full_boltzmann(model, 20, (1.0, 20.0));
	    // println!("retcode = {:?}", sol.retcode);
e0315e1f90d50b0f814fce3e6ecab58d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|16|1|V|rust
	    let mut file = std::fs::File::create("data.dat")?;
74fabfc22f0041952de39e6e3c62d1fa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|25|1|V|rust
	    // let mut file = std::fs::File::create("data.dat")?;
276d702ad3e6bce9bf201c9f26c2eb1f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|17|25|v|rust
	full_boltzmann
8dbdda48fb8748d6746f1965824e966a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|11|4|v|rust
	simple
cd0da137dcea0ddccdb52d4c449aab3b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|11|13|V|rust
	fn simple<T:FullBoltzmann>(model:T, hhh
9df600792d1465ca25171c0bea85b8c9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|20|49|v|rust
	 model.
8b92ae02461ec970cb5e93d29dabfce0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|14|v|rust
	57.0;
9d1d22ce0573bb7488dc22ec67520ef9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|33|v|rust
	1.0;
78c6f315d54c4d96e7a017baa0643654|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|19|54|v|rust
	20.0);
2176fde3afdb7fe4e693b0e74befaf75|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|15|15|v|rust
	1e-1;
f6fc3da44836d629ad790c3e70b72632|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|31|v|rust
	+ 10.0;
877e1e44d60e968a20e4b75ed0ac023e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|15|15|v|rust
	10.0;
7cd63fb419478286f922ac99f108ac0e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|15|15|v|rust
	1.1;
450c633d9b694371134728b920785a10|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|1|V|rust
	    let ms = HIGGS_MASS / 2.0 - 1.0;
	    let lam = 1e-3;
	    let model = ScalarSinglet::new(ms, lam);
	
	    let mut file = std::fs::File::create("analysis/simple_boltz_data.dat")?;
	    let sol = integrate_simple_boltzmann(model, 1.0, 1000.0);
	    let rd = sol.us[sol.us.len() - 1][0].exp() * ms * S_TODAY / RHO_CRIT;
	    println!("retcode = {:?}", sol.retcode);
	    println!("rd = {}", rd);
	    for (t, u) in sol {
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
	    }
254d6fed82a2f3237b15a6b35848a894|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|55|1|V|rust
	    Ok(())
8255c76aa06c4d0b40aab1f0984962de|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|37|1|V|rust
	    let mut file = std::fs::File::create("analysis/simple_boltz_data.dat")?;
	    let sol = integrate_simple_boltzmann(model, 1.0, 1000.0);
	    let rd = sol.us[sol.us.len() - 1][0].exp() * ms * S_TODAY / RHO_CRIT;
	    println!("retcode = {:?}", sol.retcode);
	    println!("rd = {}", rd);
	    for (t, u) in sol {
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
	    }
8b0f1eb0f78207d75a65b16af34bdb4b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|46|5|v|rust
	//     
8b0f1eb0f78207d75a65b16af34bdb4b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|46|5|v|rust
	//     
8b0f1eb0f78207d75a65b16af34bdb4b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|46|5|v|rust
	//     
eb10e42861b14609767cf3d5f7870040|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|33|1|V|rust
	    let ms = HIGGS_MASS / 2.0 - 1.0;
	    let lam = 1e-3;
	    let model = ScalarSinglet::new(ms, lam);
	
	    let mut file = std::fs::File::create("data.dat")?;
	    let sol = integrate_full_boltzmann(model, 20, (1.0, 20.0));
	    println!("retcode = {:?}", sol.retcode);
	    let mut file = std::fs::File::create("data.dat")?;
	    for (t, u) in sol {
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
	    }
	    Ok(())
72cc471de135a34db1daaf62c17dd673|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|46|27|v|rust
	mx / x
2d006d1521ce5d64721502186e3ba999|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|13|V|rust
	            let xq = (x * x + qs[i] * qs[i]).sqrt();
71deb79fc543f4d862a7f31fcfbe70a6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|60|1|V|rust
	            // Compute the first derivative of f
2d919de77a4641043a757e1a1f042457|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|28|v|rust
	first 
6d5d036b2f15d3b4ea728a7ac16254e8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|32|39|v|rust
	v.len()
cb85913bab8d03df211954af997d7918|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|38|9|V|rust
	        dv[i] = h;
e875f94b84dbfb38c2a3c1eac4a6ab42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|35|1|V|rust
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
794b7021e3612de6cf8ee31581c5c690|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|35|1|V|rust
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
1f644a14c20475c135564bff1bb7bdbf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|35|1|V|rust
	    // Use forward derivatives for first two entries
8b04d5e3775d298e78455efc5ca404d5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|39|38|v|rust
	first
cb3e77ee1266f825fa3f82ba8502c578|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|33|8|v|rust
	5-pt stencil requires at least 6 pts.
126cd17fd15e80ee73dbb6166fde753c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|33|5|V|rust
	    // this function requires the
1e83712194592655bdd8c3ea0edf74f2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|1|V|rust
	/// Construct the derivative vector from `v` using a 5-pt stencil.
	pub fn first_deriv_vec(v: &ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    // this function requires the vector to be at least of length 6 or dv[1]
	    // will fail.
	    assert!(n >= 6);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = 1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / h
	}
6beaaf1c9a74860e4563818ab540efa6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|13|v|rust
	-25.0 / 12.0
f63629e543fdf7c5a8dcd7dbf572d93a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|23|v|rust
	4.0 
7d2e8fc423d73fe6475541e3fd61f805|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|30|v|rust
	- 3.0
7bdd153c8c018a436abd7426f48e46a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|39|v|rust
	 4.0 / 3.0
512cfbe74379efdb1bc292f24d937a63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|49|v|rust
	1.0 / 4.0
23f4b186a9d84ba8bc7f5a24f9147079|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|1|V|rust
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
75c2e691a8c5190ebf42fca00c32a804|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|74|5|V|rust
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
16ebe935e7eb78ffb9c6e47fda39a25f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|68|1|V|rust
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
7f9b58ea44d36c400b3c1d323da391d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|76|1|V|rust
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
0d5740fdde3b8deb62e6125ae4d3af2d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|64|1|V|rust
	    // 1/12 	4/3 	5/2 	4/3 	1/12
	    // 15/4 	77/6 	107/6 	13 	61/12 	5/6
2b13feb4295ff4e23c05a0fd47cd50b5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|35|v|rust
	.view(
94d45fb27c368558fda5a1d86767aa7b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|1|V|rust
	        let df = first_deriv_vec(f, dq);
d18293ba5c15c75fc332fa0559c12f41|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|112|35|v|rust
	_deriv_vec
ba16090d17e0880ea5c2f711ca29a98c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|136|1|V|rust
	            // Compute the 2nd derivative of f
	            let d2f = if i != 0 && i != n - 1 {
	                (f[i + 1] + f[i - 1] - 2.0 * f[i]) / dq2
	            } else if i == 0 {
	                (f[2] + f[0] - 2.0 * f[1]) / dq2
	            } else {
	                0.0
	            };
6a52f843f706ebb74dcef45ca21f8898|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|128|13|V|rust
	            // Compute the first derivative of f
	            let df = if i != 0 && i != n - 1 {
	                (f[i + 1] - f[i - 1]) / (2.0 * dq)
	            } else if i == 0 {
	                (f[i + 1] - f[i]) / dq
	            } else {
	                0.0
	            };
ef0c8a57da15ded0dfca7bf3ff5397b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|128|1|V|rust
	            let xq = (x * x + qs[i] * qs[i]).sqrt();
	            // Compute the elastic scattering term
	            deriv[i] += gam / (2.0 * ht * x)
	                * (xq * d2f + (qs[i] + 2.0 * xq / qs[i] + qs[i] / xq) * df + 3.0 * f[i]);
	            deriv[i] += gt * qs[i] / x * df;
bf1472a794fb4d6ad95a29ca5a6ff2d6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|130|1|V|rust
	        let xq = (x * x + qs[i] * qs[i]).sqrt();
5295a1a065fb94423243db479c57f793|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|18|v|rust
	(x * x + qs[i] * qs[i]).sqrt();
81f5a38b801a8cf8302af052811029c3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|100|5|V|rust
	    let dq2 = dq * dq;
d49b9cd77221f2726262b42fcc29b449|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|129|1|V|rust
	                    * pre
	                    * dq
	                    * qs[k]
	                    * qs[k]
	                    * p.sigmav(qs[i] * temp, qs[k] * temp)
	                    * (feq[i] * feq[k] - f[i] * f[k]);
0579d58fa80ff7cdaffd3d206f5262d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|119|21|V|rust
	                    * pre
722986caceefdd70d9fe9ef67abb322a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|119|21|V|rust
	                     dq
8263bcbb67c8cdfce92267d6d4e612d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|119|21|V|rust
	                    * qs[k]
bfb5101b804d6e0c679d050d81a2d999|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|127|9|V|rust
	        //
7465b993370069e2fc3a6eeb684ac7b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|102|1|V|rust
	    wgts[0] /=0.5;
34735342672c4f64cbc8b982932ea17a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|122|45|v|rust
	wgts[k]
b5d7906606d93caa0a5bf151fb1379f9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|129|22|v|rust
	&(pre * dq * &scattering_matrix.sum_axis(Axis(1)))
69d364383ca8aa78e8a28542e4c00adb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|130|9|V|rust
	        // Correct the endpoints
53973385c8481bb5b39e79a475c52361|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|131|8|v|rust
	 for i in 0..n {
	            deriv[i] = 0.0;
	
	            // Integrate scattering term using trapizoid rule
	            for k in 0..n {
	                // Endpoints have extra factor of 1/2
	                deriv[i] += if k != 0 && k != n - 1 { 1.0 } else { 0.5 }
	                    * pre
	                    * dq
	                    * qs[k]
	                    * qs[k]
	                    * p.sigmav(qs[i] * temp, qs[k] * temp)
	                    * (feq[i] * feq[k] - f[i] * f[k]);
	            }
	        }
4bcbc7369885809e8f325110ead5fefd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|21|1|V|rust
	pub struct FullBoltzmannIntegrator<T: FullBoltzmann> {
	    pub model: T,
	    pub qs: Array1<f64>,
	    
	}
78429c8a897c841ab68ec0dad4ebff64|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|114|1|V|rust
	        let df = first_deriv_vec(f.view(), dq);
	        let d2f = second_deriv_vec(f.view(), dq);
54805052d8232b5bd5d53d151d939199|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|112|9|V|rust
	        let gam = p.gamma(temp);
62407d5ac25fcb678c0bbcd8187a1621|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|112|9|V|rust
	        let gt = gefft(temp);
c300b75b985763ac3ba40b0f05356209|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|108|9|V|rust
	        let mx = p.dm_mass();
ca0e9f5ad2890da429ff2191a8587885|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|106|1|V|rust
	    let mx = model.dm_mass();
5fc889ea3504d5307aa2dda9f7d4a1a1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|9|V|rust
	        let g = p.g();
44e6b1c102274eab95ece505548fc202|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|109|1|V|rust
	    // Construct function for RHS of ODE.
efcb7c5082653acb773610c2e8b6a3ed|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|9|V|rust
	        let ht = hubblet(x);
c14b57256a91e783c6af7c49433d2e26|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|9|V|rust
	        let temp = mx / x;
aacf4cff4c462bb09ac42edf6d8e28ba|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|1|V|rust
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn first_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    // this function requires the vector to be at least of length 6 or dv[1]
	    // will fail.
	    assert!(n >= 6);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = 1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / h
	}
9901e49949bcc00e651170220edc13c8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|30|1|V|rust
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn first_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    // this function requires the vector to be at least of length 6 or dv[1]
	    // will fail.
	    assert!(n >= 6);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = 1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / h
	}
	
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn second_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    // this function requires the vector to be at least of length 7 or dv[1]
	    // will fail.
	    assert!(n >= 7);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = -15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
	        + 13.0 * v[n - 5]
	        - 61.0 / 12.0 * v[n - 6]
	        + 5.0 / 6.0 * v[n - 7];
	    dv[n - 1] = -15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
	        + 13.0 * v[n - 4]
	        - 61.0 / 12.0 * v[n - 5]
	        + 5.0 / 6.0 * v[n - 6];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = -1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
	            + 4.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / (h * h)
	}
efc21e9fc5714aabb5c11a0778fc544a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|209|30|v|rust
	* v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
7b59a2a1e5395990304d681108eb07a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|17|v|rust
	-25.0 / 12.0 * v[0] + 
22e3ba56509cd6283ec32b395247f397|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|27|v|rust
	 - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
d9b8c4272ffee35aa9a5737e89c0710a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|17|v|rust
	-25.0 / 12.0 * v[0] + 4.0 * v[1] 
f4bf20df2fd99ad87d15f53532925323|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|28|v|rust
	 + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
d3f788115de025d3f0f39eefb9d98da8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|17|v|rust
	-25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 
656a1b927b013fc11c5b4dfdd42323fe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|33|v|rust
	 - 1.0 / 4.0 * v[4];
005f3f1a86f63d0c07d1c30432860fb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|17|v|rust
	-25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] 
cf9da1282284d9f627450e945b301c96|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|209|1|V|rust
	    dv[[0, 0]] = -25.0 / 12.0;
	    dv[[0, 1]] = 4.0 * v[1];
	    dv[[0, 2]] = -3.0 * v[2];
	    dv[[0, 3]] = 4.0 / 3.0 * v[3];
	    dv[[0, 4]] = -1.0 / 4.0 * v[4];
9cce30d8e656c18184604f0425856bc3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|215|1|V|rust
	    dv[[1,1]] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	    dv[[1,2]] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	    dv[[1,3]] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	    dv[[1,4]] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	    dv[[1,5]] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
d42e046b112e835c5b4b59fff6484d96|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|21|v|rust
	 * v[1];
f4a5da2be61d788d965f95037f19396f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|217|22|v|rust
	 * v[2];
434d45e906eee2fa175ef32c2490d097|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|218|27|v|rust
	 * v[3];
f7a7470cf9831cc2e8665072b8ed3c42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|219|28|v|rust
	 * v[4];
d0c2fefdb6e0074aebb3135cf0cc26b0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|209|1|V|rust
	    dv[[0, 0]] = -25.0 / 12.0;
	    dv[[0, 1]] = 4.0;
	    dv[[0, 2]] = -3.0;
	    dv[[0, 3]] = 4.0 / 3.0;
	    dv[[0, 4]] = -1.0 / 4.0;
	
	    dv[[1, 1]] = -25.0 / 12.0;
	    dv[[1, 2]] = 4.0;
	    dv[[1, 3]] = -3.0;
	    dv[[1, 4]] = 4.0 / 3.0;
	    dv[[1, 5]] = -1.0 / 4.0;
	
55ffbb470f867d28d670d82edb3d80c5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|233|1|V|rust
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
5a3368ca321752551dfba2b91d543f51|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|9|V|rust
	        for j in 2..=2 {
e304a1bc03ab260fc59c98e895171513|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|1|V|rust
	        dv[i] = 1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
dcb8370a69f8137a699e428093aecebb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|240|23|v|rust
	1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
5a22cfcc2e72230e5f74793b2ecb766b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|240|35|v|rust
	 * v[i + 2];
cb67dbdb7b089641c621fb1d87f84cb4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|239|13|V|rust
	            - 1.0 / 12.0 * v[i + 2];
cc2e03557546d1787c7f56af466463ee|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|238|23|v|rust
	1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 
aa72fb8c2058a14a2e7c976a03d5d290|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|238|32|v|rust
	 * v[i + 1]
63b2b5e4a919b08ec55082af5269fb40|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|236|23|v|rust
	1.0 / 12.0 * v[i - 2] 
ccc6b851710714caef9fafad75cec337|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|236|45|v|rust
	 + 2.0 / 3.0 * v[i + 1]
48a1e4f7405d589cd1a1e9a51bf30160|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|44|v|rust
	 - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
a6284addfa50c1d1dd3059fc652a8df8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|36|v|rust
	 * v[i - 2];
5dc5073972408dc446ad9442431234cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|235|36|v|rust
	 * v[i - 1];
6e4e965d208b69b501382d8703333e7d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|240|11|v|rust
	 / h;
9a538e702c643e8f5839e9b9d7b01fb2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|243|1|V|rust
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn second_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    // this function requires the vector to be at least of length 7 or dv[1]
	    // will fail.
	    assert!(n >= 7);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = -15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
	        + 13.0 * v[n - 5]
	        - 61.0 / 12.0 * v[n - 6]
	        + 5.0 / 6.0 * v[n - 7];
	    dv[n - 1] = -15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
	        + 13.0 * v[n - 4]
	        - 61.0 / 12.0 * v[n - 5]
	        + 5.0 / 6.0 * v[n - 6];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = -1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
	            + 4.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / (h * h)
	}
f739acd563f8fec7593bb96931f575ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|304|5|V|rust
	        + 61.0 / 12.0 * v[4]
4af35be90766a0717467820957c29ae6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|303|12|v|rust
	 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
75dc7ea897455e0fe57818a2ee267b38|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|302|9|V|rust
	        - 5.0 / 6.0 * v[5];
941eefabaa7ebf7b21dfc17c6e09f448|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|297|13|v|rust
	15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] 
80824b04ad446c2c8f0e45d8f49c3f4f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|288|30|v|rust
	 - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
8857458dea81393b73eb0fea69532b15|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|289|13|v|rust
	15.0 / 4.0 * v[0] 
3d92eb33cfc8fe7860ce0ca4ec236682|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|289|32|v|rust
	 + 107.0 / 6.0 * v[2] - 13.0 * v[3]
913b17187969c48be54dd2ff6865abe4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|290|13|v|rust
	15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 
bf77529a525c83313e4f4caffb90b9a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|290|31|v|rust
	 - 13.0 * v[3]
2adcd2110e5a2934d336516584ad498c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|288|27|v|rust
	 * v[0];
209dd9048f07de2343e5e034329d4e20|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|288|1|V|rust
	    dv[[0, 0]] = 15.0 / 4.0;
	    dv[[0, 1]] = -77.0 / 6.0;
	    dv[[0, 2]] = 107.0 / 6.0;
	    dv[[0, 3]] = -13.0;
	    dv[[0, 4]] = 61.0 / 12.0;
	    dv[[0, 6]] = -5.0 / 6.0;
5d9fc64c000d35ecf4e1d15cd7dc8036|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|303|1|V|rust
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
e34ff888c3e7eb57d3b26c205327c132|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|288|1|V|rust
	    dv[[0, 0]] = 15.0 / 4.0;
	    dv[[0, 1]] = -77.0 / 6.0;
	    dv[[0, 2]] = 107.0 / 6.0;
	    dv[[0, 3]] = -13.0;
	    dv[[0, 4]] = 61.0 / 12.0;
	    dv[[0, 6]] = -5.0 / 6.0;
	
	    dv[[1, 1]] = 15.0 / 4.0;
	    dv[[1, 2]] = -77.0 / 6.0;
	    dv[[1, 3]] = 107.0 / 6.0;
	    dv[[1, 3]] = -13.0;
	    dv[[1, 5]] = 61.0 / 12.0;
	    dv[[1, 6]] = -5.0 / 6.0;
0f67eeacb778f564a0b8c13113e453c8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|317|1|V|rust
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = -15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
	        + 13.0 * v[n - 5]
	        - 61.0 / 12.0 * v[n - 6]
	        + 5.0 / 6.0 * v[n - 7];
	    dv[n - 1] = -15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
	        + 13.0 * v[n - 4]
	        - 61.0 / 12.0 * v[n - 5]
	        + 5.0 / 6.0 * v[n - 6];
5c96a2434f2fdc6a4b7736718e82ded0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|320|1|V|rust
	        dv[i] = -1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
	            + 4.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
d9a1ad56b526441dd072c82d2d0f4f0f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|333|9|V|rust
	            + 4.0 / 3.0 * v[i + 1]
a04714ccb9609f1581ab9390cb086357|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|332|16|v|rust
	 -1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
94fc8d9e8f7bcf98a4ab8f8e007c4823|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|326|17|v|rust
	-1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] 
c06c522f30837e8d75151af7322ba804|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|321|16|v|rust
	 -1.0 / 12.0 * v[i - 2] + 
2829047757e320cfc7b7ed645e7b55ac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|321|36|v|rust
	 - 5.0 / 2.0 * v[i]
d78c2e349633b6f0a41999ead3cd359a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|320|39|v|rust
	 + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
977effdc916e3ebb8d8afd2603fe72b9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|322|32|v|rust
	 * v[i]
35d5f3b6d089d06bb9a0874be985016a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|48|1|V|rust
	        let temp = mx / x;
	        let ht = hubblet(temp);
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let feq = qs.mapv(|q| p.feq(x, q));
	
	        // Construct scattering matrix:
	        let mut scattering_matrix = Array2::<f64>::zeros((n, n));
	        for i in 0..n {
	            for k in 0..n {
	                scattering_matrix[[i, k]] = qs[k].powi(2)
	                    * p.sigmav(qs[i] * temp, qs[k] * temp)
	                    * (feq[i] * feq[k] - f[i] * f[k]);
	            }
	        }
	
	        // Integrate the scattering matrix using trapizoid rule
	        deriv.assign(&(pre * dq * scattering_matrix.dot(&wgts)));
	
	        // Compute the elastic scattering term
	        let gam = p.gamma(temp);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	        let df = first_deriv_vec(f.view(), dq);
	        let d2f = second_deriv_vec(f.view(), dq);
	        deriv += &(gam / (2.0 * ht * x)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f));
	        // Compute the other term (not sure what this is physically. Expansion?)
	        let gt = gefft(temp);
	        deriv += &(gt * &qs / x * &df);
e225fc00493bce7053167bfd280f5bac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|1|V|rust
	        let temp = mx / x;
	        let ht = hubblet(temp);
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let gam = p.gamma(temp);
	        let gt = gefft(temp);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	
	        for i in 0..n {
	            for j in 0..n {
	                jac[[i, j]] = 0.0;
	                jac[[i, j]] += if j == 0 || j == n - 1 { 0.5 } else { 1.0 }
	                    * -pre
	                    * dq
	                    * qs[j]
	                    * qs[j]
	                    * p.sigmav(qs[i] * temp, qs[j] * temp)
	                    * f[i];
	                if i == j {
	                    for k in 0..n {
	                        jac[[i, j]] += if k == 0 || k == n - 1 { 0.5 } else { 1.0 }
	                            * -pre
	                            * dq
	                            * qs[k]
	                            * qs[k]
	                            * p.sigmav(qs[i] * temp, qs[k] * temp)
	                            * f[k];
	                    }
	                }
	
	                let dfdf = if i != 0 && i != n - 1 {
	                    if j == i + 1 {
	                        1.0 / (2.0 * dq)
	                    } else if j == i - 1 {
	                        -1.0 / (2.0 * dq)
	                    } else {
	                        0.0
	                    }
	                } else if i == 0 {
	                    if j == i + 1 {
	                        1.0 / dq
	                    } else if j == i {
	                        -1.0 / dq
	                    } else {
	                        0.0
	                    }
	                } else {
	                    0.0
	                };
	                let d2fdf = if i != 0 && i != n - 1 {
	                    // f[i+1] + f[i-1] - f[i]
	                    if j == i + 1 || j == i - 1 {
	                        1.0 / dq / dq
	                    } else if j == i {
	                        -2.0 / dq / dq
	                    } else {
	                        0.0
	                    }
	                } else if i == 0 {
	                    if j == 2 || j == 0 {
	                        1.0 / dq / dq
	                    } else if j == 1 {
	                        -2.0 / dq / dq
	                    } else {
	                        0.0
	                    }
	                } else {
	                    0.0
	                };
	
	                jac[[i, j]] += gam / (2.0 * ht * x)
	                    * (xq[i] * d2fdf
	                        + (qs[i] + 2.0 * xq[i] / qs[i] + qs[i] / xq[i]) * dfdf
	                        + (if i == j { 3.0 } else { 0.0 }));
	                jac[[i, j]] += gt * qs[i] / x * dfdf;
	            }
	        }
7cca4f5ffaffcf1659093d9a0937ad09|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|23|v|rust
	(feq[i] * feq[k] 
c3d42c04a12dbc7e03d335bb313ebf7f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|90|81|v|rust
	-f[i] * f[k]
7f77ca431d3f5b509b9086a8508b1ec8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|1|V|rust
	                    j_scattering_matrix[[i, j, k]] =
7af51fa7a7465797893df5efdfbefa5d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|21|V|rust
	                    j_scattering_matrix[[i, j, k]] *= if i == j
cfc1540da0921f89e3c45e8695e1b17c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|92|25|v|rust
	j_scattering_matrix[[i, j, k]] *=
fef35dabb5e8455852e834b7d67b20ae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|94|25|v|rust
	j_scattering_matrix[[i, j, k]] *= 
6c1bee212b3ea5736ecc0466a106df7c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|65|v|rust
	, n));
45e8a0d8d90edf179fbcaf4b16e26205|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|21|v|rust
	j_scattering_matrix[[i, j]]
cfa2cab872dfd18363d112b82ae3f045|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|88|16|V|rust
	                j_scattering_matrix[[i, j]]
ee9fab8ebe0f314973b98dec15b1d958|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|9|V|rust
	        let mut j_scattering_matrix = Array2::<f64>::zeros((n, n));
e5ce818a626c48dcfa9fcfbab91fb432|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|88|21|v|rust
	j_scattering_matrix
5202ab3ed6f221299ed6e9bef7c95200|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|106|1|V|rust
	        // Integrate the scattering matrix using trapizoid rule
e9548d9ce0f63ddf78a5e1dd2c2cb330|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|84|1|V|rust
	        // Construct the jacobian of the scattering matrix:
b1e4b7a658407e234f0fe99d02b0fce0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|106|1|V|rust
	        // Integrate the scattering matrix using trapizoid rule
	        jac.assign(&(pre * dq * scattering_matrix.dot(&wgts)));
4cfd4b361fd0f38138743650f3f965a5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|107|1|V|rust
	        let gam = p.gamma(temp);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
e3289aae9254836aa26e84824f2c21de|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|109|1|V|rust
	        let j_df = jac_first_deriv_vec(f.view(), dq);
	        let j_d2f = jac_second_deriv_vec(f.view(), dq);
b496a4fd913dd20d807fdce380289b07|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|1|V|rust
	        jac += &(gam / (2.0 * ht * x)
	            * (&xq * &j_d2f
	                + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &j_df
	                + 3.0 * Array::eye(n)));
6ac96d098663647bda330d867e22354a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|107|17|v|rust
	gam / (2.0 * ht * x)
	                    * (xq[i] * j_d2f[[i, j]]
	                        + (qs[i] + 2.0 * xq[i] / qs[i] + qs[i] / xq[i]) * j_df[[i, j]]
	                        + 3.0 * Array::eye(n))
d599b0c64fd21daa53946a4904818353|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|110|31|v|rust
	* Array::eye(n)
201900db28907da8564d9d38f7fa325e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|110|33|v|rust
	Array::eye(n)
efcc8b174d0db41f9cea5623d36ca85a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|121|1|V|rust
	        jac += &(gt * &qs / x * &j_df);
7b8e1cd2bb7e9ee3e538362efb19fe6e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|111|24|v|rust
	gt * &qs / x * &j_df
ea74290dc48b6e57c6dc517fce76272c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|116|1|V|rust
	        // Compute the elastic scattering term
	        jac += &(gam / (2.0 * ht * x)
	            * (&xq * &j_d2f
	                + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &j_df
	                + 3.0 * Array::eye(n)));
	        // Compute the other term (not sure what this is physically. Expansion?)
	        let gt = gefft(temp);
	        jac += &(gt * &qs / x * &j_df);
401db463e75cd6fb52d2e45a9c07c9b9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|89|5|V|rust
	        // Integrate the jacobian of the scattering matrix using trapizoid rule
1b04a49967704dc1b6331340a1d3b2aa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|161|28|v|rust
	v: ArrayView1<f64>
e08168780322aa8a3695e61e5e9c69bb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|162|5|V|rust
	    let n = v.len();
2c2eed617ce2e3d5fe812a01cbe6a33c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|165|5|V|rust
	    let mut dv = Array2::<f64>::zeros((n, n));
e0a90c1e5a19370699719d1fca442e2c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|46|36|v|rust
	f.view()
130ad29cc03d6854302e217477fc5729|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|47|38|v|rust
	f.view(
e330ec1f6d08a4efb1f11bfbff5eb10d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|39|47|v|rust
	100, (1.0, 100.0));
169bdc3a7d641f6eefc59fe339a2fd02|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|129|1|v|dosini
	T_ncdm = 0.71611
2ec0fe0ea1cbabf341aa93585013c7dd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/explanatory.ini|129|10|v|dosini
	0.71611
5645163f70bde0359fdec9d083d73ba2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|310|20|v|c
	_cdm * pow(pba->H0, 2) / pow(a_rel, 3);
d508f37e2946ade35431c75771a56554|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|498|20|v|c
	o_ncdm;
2a8b6fddc8b69380d6ebf74ad0f779c0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2014|1|V|c
	  printf("mass = %e", M);
f1fba9ac4e0ab171803fa69885be583e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2053|24|V|c
	    p
82858b926cd7e0a6f20338e4569b6b8d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1880|23|v|c
	m * m
31429f1c7bd0de52e9bbe5ad0d6ea813|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1876|24|v|c
	 mass
6b3d26c75b62bc0d507b5c42cf5e4854|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2014|1|V|c
	  printf("mass = %e\n", M);
73dc98fe9da4fe0308025eb7458e3d13|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2014|11|v|c
	rescale
27f08d8456301db56dc90d51a2726332|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2014|35|v|c
	%e\n
1f8b00bd3ee4a3f51e9931212bb9ed86|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2014|49|v|c
	,%e\n
d0683f979fb3b22d8f092b135d84179a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2013|21|v|c
	actor * pow(rescale, 4);
dae63d468f4953f7b26c2e158444ad19|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1866|1|v|c
	inline double ncdm_ps_dist(double k, double eng, double cp) {
	  // return (1.0 / (exp(eng - cp) + 1.0) + 1.0 / (exp(eng + cp) + 1.0)) /
	  //        pow(2.0 * _PI_, 3.0);
	  return (exp(-eng));
	}
215d75c0b80c55ac9082351622ae7705|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|16|v|c
	, double eng, double cp
89fa5ad4c0021c2736ee08964f091263|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1874|16|v|c
	rescale*
0567c803af4e76cb2c9ebb65fbb607cf|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1871|49|v|c
	, double rescale
41106c27c1515fdb694b8dc54c13af73|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(eng, fp->chemical_potential);
7d9489cbf768719cdd446fe2d63abca4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|v|c
	eng, fp->chemical_potential);
41106c27c1515fdb694b8dc54c13af73|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(eng, fp->chemical_potential);
41106c27c1515fdb694b8dc54c13af73|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(eng, fp->chemical_potential);
41106c27c1515fdb694b8dc54c13af73|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(eng, fp->chemical_potential);
974fba83e97ea178115f44b07f86857e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|v|c
	q, M
196c8caffcad5a5de99a64fa7cb0cbc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(q, fp->mass);
196c8caffcad5a5de99a64fa7cb0cbc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(q, fp->mass);
196c8caffcad5a5de99a64fa7cb0cbc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(q, fp->mass);
196c8caffcad5a5de99a64fa7cb0cbc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(q, fp->mass);
0071dba247cafded13690ea32ece8ce3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|v|c
	q, fp->mass
196c8caffcad5a5de99a64fa7cb0cbc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1902|1|V|c
	  double fq = ncdm_ps_dist_nr(q, fp->mass);
524c3d961b77795e12f021bd5475943e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1875|10|v|c
	exp(-q * q / (2.0 * M));
138d3bb7569855b12080aeb42cbb8ab2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas.rs|1|1|V|rust
	pub(crate) mod alg;
	pub(crate) mod cache;
	pub(crate) mod core;
1ff472748ba859c08276c06c1c7c5dcd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas.rs|1|1|V|rust
	pub(crate) mod algorithm;
ed469618898d75b149e5c7c4b6a1c415|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas.rs|2|16|v|rust
	algorithm
20b8a9f7c91b0227ca9e928e41d19941|file:///Users/loganmorrison/Documents/coding/stiff/rodas.f90|895|1|V|fortran
	    1      C2 = 0.386D0
	    C3 = 0.21D0
	    C4 = 0.63D0
	    BET2P = 0.0317D0
	    BET3P = 0.0635D0
	    BET4P = 0.3438D0
	    D1 = 0.2500000000000000D+00
	    D2 = -0.1043000000000000D+00
	    D3 = 0.1035000000000000D+00
	    D4 = -0.3620000000000023D-01
	    A21 = 0.1544000000000000D+01
	    A31 = 0.9466785280815826D+00
	    A32 = 0.2557011698983284D+00
	    A41 = 0.3314825187068521D+01
	    A42 = 0.2896124015972201D+01
	    A43 = 0.9986419139977817D+00
	    A51 = 0.1221224509226641D+01
	    A52 = 0.6019134481288629D+01
	    A53 = 0.1253708332932087D+02
	    A54 = -0.6878860361058950D+00
	    C21 = -0.5668800000000000D+01
	    C31 = -0.2430093356833875D+01
	    C32 = -0.2063599157091915D+00
	    C41 = -0.1073529058151375D+00
	    C42 = -0.9594562251023355D+01
	    C43 = -0.2047028614809616D+02
	    C51 = 0.7496443313967647D+01
	    C52 = -0.1024680431464352D+02
	    C53 = -0.3399990352819905D+02
	    C54 = 0.1170890893206160D+02
	    C61 = 0.8083246795921522D+01
	    C62 = -0.7981132988064893D+01
	    C63 = -0.3152159432874371D+02
	    C64 = 0.1631930543123136D+02
	    C65 = -0.6058818238834054D+01
	    GAMMA = 0.2500000000000000D+00
	
	    D21 = 0.1012623508344586D+02
	    D22 = -0.7487995877610167D+01
	    D23 = -0.3480091861555747D+02
	    D24 = -0.7992771707568823D+01
	    D25 = 0.1025137723295662D+01
	    D31 = -0.6762803392801253D+00
	    D32 = 0.6087714651680015D+01
	    D33 = 0.1643084320892478D+02
	    D34 = 0.2476722511418386D+02
	    D35 = -0.6594389125716872D+01
bd9a6f9e82e3b5a3546b77ff142b01ec|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/constants.rs|6|5|v|rust
	1      
eab284917c32b923ff8ac9e5c3692b0c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|12|1|V|rust
	    pub(crate) mujac: usize,
	    pub(crate) mljac: usize,
	    pub(crate) mumas: usize,
	    pub(crate) mlmas: usize,
270cbf7b5b6432bd74c77b71d7eb3698|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|12|1|V|rust
	    pub(crate) m1: usize,
	    pub(crate) m2: usize,
a77b5ffc095fffe2b691c3d6a5ebe72c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|12|1|V|rust
	    pub(crate) nind1: usize,
	    pub(crate) nind2: usize,
	    pub(crate) nind3: usize,
03f70e7a8dca986ce83f236005b71ef5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|12|1|V|rust
	    pub(crate) mle: usize,
	    pub(crate) mue: usize,
	    pub(crate) mbjac: usize,
	    pub(crate) mbb: usize,
	    pub(crate) mdiag: usize,
	    pub(crate) mdiff: usize,
	    pub(crate) mbdiag: usize,
	    pub(crate) ldmas: usize,
	    pub(crate) ldjac: usize,
	    pub(crate) lde1: usize,
e1f62736f1d8c1a1e74fe0ce9ce0b9ba|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|33|1|V|rust
	pub(crate) enum RodasCacheErr {
	    HessErr,
	}
	
	impl std::fmt::Debug for RodasCacheErr {
	    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
	        match self {
	            RodasCacheErr::HessErr => write!(
	                f,
	                "Hessenberg option only for explicit equations with full Jacobian.",
	            ),
	        }
	    }
	}
	
	impl RodasCache {
	    pub(crate) fn new<F, J>(
	        alg: &Rodas,
	        prob: &OdeProblem<F, J>,
	    ) -> Result<RodasCache, RodasCacheErr>
	    where
	        F: Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        J: Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    {
	        let n = prob.uinit.shape()[0];
	        let nm1 = n - prob.m1;
	        let implct = prob.mass_matrix.is_none();
	        let jband = prob.jac_lbw < nm1;
	
	        let mut prob_type = 1;
	
	        let (mljac, mujac, ldjac, lde1) = if jband {
	            (
	                prob.jac_lbw,
	                prob.jac_ubw,
	                prob.jac_lbw + prob.jac_ubw + 1,
	                2 * prob.jac_lbw + prob.jac_ubw + 1,
	            )
	        } else {
	            (nm1, nm1, nm1, nm1)
	        };
	        let mut mlmas = prob.mm_lbw;
	        let mut mumas = prob.mm_ubw;
	        let mut ldmas = 1;
	        if implct {
	            if prob.mm_lbw != nm1 {
	                ldmas = mlmas + mumas + 1;
	                prob_type = if jband { 4 } else { 3 };
	            } else {
	                mumas = nm1;
	                mlmas = nm1;
	                prob_type = 5;
	            }
	        } else {
	            ldmas = 0;
	            if jband {
	                prob_type = 2;
	            } else {
	                prob_type = 1;
	                if n > 2 && alg.hess {
	                    prob_type = 7;
	                }
	            }
	        }
	        ldmas = ldmas.max(1);
	
	        if (implct || jband) && prob_type == 7 {
	            return Err(RodasCacheErr::HessErr);
	        }
	
	        if prob.m1 > 0 {
	            prob_type += 10;
	        }
	
	        let mle = mljac;
	        let mue = mujac;
	        let mbjac = mljac + mujac + 1;
	        let mbb = mlmas + mumas + 1;
	        let mdiag = mle + mue;
	        let mdiff = mle + mue - mumas;
	        let mbdiag = mumas + 1;
	
	        Ok(RodasCache {
	            prob_type,
	            implct,
	            jband,
	            caljac: false,
	            calhes: false,
	            first: true,
	            reject: false,
	            mujac,
	            mljac,
	            mumas,
	            mlmas,
	            m1: prob.m1,
	            m2: prob.m2,
	            nind1: prob.num_index1_vars,
	            nind2: prob.num_index2_vars,
	            nind3: prob.num_index3_vars,
	            mle,
	            mue,
	            mbjac,
	            mbb,
	            mdiag,
	            mdiff,
	            mbdiag,
	            ldmas,
	            ldjac,
	            lde1,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            unew: Array1::<f64>::zeros(n),
	            du: Array1::<f64>::zeros(n),
	            du1: Array1::<f64>::zeros(n),
	            dfdt: Array1::<f64>::zeros(n),
	            cont: Array1::<f64>::zeros(4 * n),
	            ak1: Array1::<f64>::zeros(n),
	            ak2: Array1::<f64>::zeros(n),
	            ak3: Array1::<f64>::zeros(n),
	            ak4: Array1::<f64>::zeros(n),
	            ak5: Array1::<f64>::zeros(n),
	            ak6: Array1::<f64>::zeros(n),
	            ip: Array1::<i32>::zeros(nm1),
	            e: Array2::<f64>::zeros((lde1, nm1)),
	            dfdu: Array2::<f64>::zeros((ldjac, n)),
	            mass_matrix: Array2::<f64>::zeros((ldmas, nm1)),
	        })
	    }
	}
f5916b90cc6eadaa23e872b948d5b1eb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|30|1|V|rust
	pub(crate) mass_matrix: Array2<f64>,
ed309c86f7a92814ecaffb553226e461|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|1|1|V|rust
	use super::cache::Radau5Cache;
	use super::Radau5;
	use crate::ode::*;
	use ndarray::prelude::*;
0943dd5ecd6be2477fe378e9aac8be3b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|2|12|v|rust
	Radau5
db32b5da7ea6ab2891b4edb602a2e9a3|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas.rs|2|1|V|rust
	pub(crate) mod constants;
93fb40ec02c008121fa9199899b31202|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas.rs|3|16|v|rust
	constants
8d5a95931f1ecfd3755a8853deb0d19b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/cache.rs|1|1|V|rust
	use super::Rodas;
b3f8587f1e9e42f828cb80b0036d9e07|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|24|1|V|rust
	    fn new_cache<Params>(integrator: &mut OdeIntegratorBuilder<Params, Self>) -> Self::Cache {
3da3aed7e4af63dc66779281216b397f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|100|1|V|rust
	    fn step<Params>(integrator: &mut OdeIntegrator<Params, Self>) {
3e15cab5c343e23e2307c85f67f00e64|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|9|1|V|rust
	        let mut opts = OdeIntegratorOpts::new();
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.theta = 0.001;
	        opts.fnewt = 0.0;
	        opts.quot1 = 1.0;
	        opts.quot2 = 1.2;
	        opts.facr = 1.0 / 8.0;
	        opts.facl = 5.0;
	        opts.max_steps = 100000;
	        opts.max_newt_iter = 7;
	        opts.use_ext_col = true;
	        opts.modern_pred = true;
	        opts
51521ff787470af32f1af6055e905932|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|20|9|V|rust
	        opts.use_ext_col = true;
428112b33df01e435bc9f5817c29e8e9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|19|9|V|rust
	        opts.max_newt_iter = 7;
dced432eee97046922bc52848fbad473|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|16|1|V|rust
	        opts.facr = 1.0 / 8.0;
8aaa55e269e1cbf4c41fe3c32e6db582|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|13|1|V|rust
	        opts.fnewt = 0.0;
e88071dc9f01a70d92d671e8b69813f5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|13|14|v|rust
	facr
8b38161adf5488d20bf39a8415049fbe|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|13|21|v|rust
	1.0 / 8.0;
131f3abbfd1f5745d3f6541eb98e1ed0|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|14|9|V|rust
	        opts.quot1 = 1.0;
bbbd623f7350143ef8553d35549a783e|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|14|9|V|rust
	        opts.quot2 = 1.2;
2563b2475af6fee3d65b0354d9b3d082|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/rodas/algorithm.rs|12|9|V|rust
	        opts.theta = 0.001;
6d70934c02aa010f81f64461d325d7d9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|8|1|V|rust
	            let s = cme * cme;
	            let mh = HIGGS_MASS;
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = 1.0 / s;
	            let temp3: f64 = mh.powi(2);
	            (self.lam_hs.powi(2)
	                * ncol
	                * (s - 4.0 * temp1)
	                * temp1
	                * temp2
	                * (1.0 - 4.0 * temp1 * temp2).sqrt())
	                / (16.0
	                    * std::f64::consts::PI
	                    * (1.0 - 4.0 * self.ms * self.ms * temp2).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
f1605a77ccb3904d0c99fd5d949927dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|30|12|v|rust
	 let s = cme * cme;
	            let mw = W_BOSON_MASS;
	            let mh = HIGGS_MASS;
	
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = mw.powi(2);
	            let temp3: f64 = mh.powi(2);
	            (ALPHA_EM.powi(2)
	                * self.lam_hs.powi(2)
	                * std::f64::consts::PI
	                * temp1
	                * (12.0 * mw.powi(4) + s.powi(2) - 4.0 * s * temp2)
	                * (1.0 - 4.0 * temp1 * temp2).sqrt()
	                * HIGGS_VEV.powi(4))
	                / (16.0
	                    * mw.powi(4)
	                    * SIN_THETA_WEAK_SQRD.powi(2)
	                    * (1.0 - 4.0 * self.ms * self.ms * temp1).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
bd322f437e28915cf16ee6e8cc9fc9cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|56|1|V|rust
	            let s = cme * cme;
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = Z_BOSON_MASS.powi(2);
	            let temp3: f64 = HIGGS_MASS.powi(2);
	            (ALPHA_EM.powi(2)
	                * self.lam_hs.powi(2)
	                * std::f64::consts::PI
	                * temp1
	                * (12.0 * Z_BOSON_MASS.powi(4) + s.powi(2) - 4.0 * s * temp2)
	                * (1.0 - 4.0 * temp1 * temp2).sqrt()
	                * HIGGS_VEV.powi(4))
	                / (16.0
	                    * COS_THETA_WEAK.powi(4)
	                    * Z_BOSON_MASS.powi(4)
	                    * SIN_THETA_WEAK_SQRD.powi(2)
	                    * (1.0 - 4.0 * self.ms * self.ms * temp1).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
828675f9a28313978ee06f5352570d1a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|80|1|V|rust
	            let s: f64 = cme * cme;
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = self.lam_hs.powi(2);
	            let temp3: f64 = HIGGS_MASS.powi(2);
	            let temp4: f64 = self.ms.powi(2);
	            let temp5: f64 = HIGGS_MASS.powi(4);
	            let temp6: f64 = -s;
	            let temp7: f64 = temp3 + temp6;
	            let temp8: f64 = temp7.powi(2);
	            let temp9: f64 = HIGGS_WIDTH.powi(2);
	            let temp10: f64 = temp3 * temp9;
	            let temp11: f64 = temp10 + temp8;
	            let temp12: f64 = 1.0 / temp11;
	            let temp13: f64 = -temp3;
	            let temp14: f64 = s + temp13;
	            let temp15: f64 = HIGGS_VEV.powi(2);
	            let temp16: f64 = 2.0 * temp3;
	            let temp17: f64 = -4.0 * temp3;
	            let temp18: f64 = s + temp17;
	            let temp19: f64 = -4.0 * temp4;
	            let temp20: f64 = s + temp19;
	            let temp21: f64 = temp18 * temp20;
	            let temp22: f64 = 1.0 / temp21.sqrt();
	            return (temp1
	                * temp2
	                * (1.0 - 4.0 * temp1 * temp3).sqrt()
	                * (1.0
	                    + 3.0 * temp12 * (2.0 * s * temp3 + temp5)
	                    + (2.0 * temp2 * HIGGS_VEV.powi(4))
	                        / (s * temp4 - 4.0 * temp3 * temp4 + temp5)
	                    - (8.0
	                        * self.lam_hs
	                        * temp12
	                        * temp15
	                        * temp22
	                        * (temp14 * (-s * s + self.lam_hs * temp14 * temp15 + 4.0 * temp5)
	                            + temp3 * (self.lam_hs * temp15 + temp16 + temp6) * temp9)
	                        * (1.0 / (temp22 * (s - 2.0 * temp3))).atanh())
	                        / (temp16 + temp6)))
	                / (16.0 * std::f64::consts::PI * (1.0 - 4.0 * temp1 * temp4).sqrt());
56bd44f5e582252195183fa4d3bffc86|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/masses.rs|1|1|V|rust
	/// Electron mass in GeV
	pub const ELECTRON_MASS: f64 = 0.5109989461e-3;
	/// Muon mass in GeV
	pub const MUON_MASS: f64 = 105.6583745e-3;
	/// Tau mass in GeV
	pub const TAU_MASS: f64 = 1776.86e-3;
	/// Up-quark mass in GeV
	pub const UP_QUARK_MASS: f64 = 2.16e-3;
	/// Down-quark mass in GeV
	pub const DOWN_QUARK_MASS: f64 = 4.67e-3;
	/// Strange-quark mass in GeV
	pub const STRANGE_QUARK_MASS: f64 = 93e-3;
	/// Charm-quark mass in GeV
	pub const CHARM_QUARK_MASS: f64 = 1.27;
	/// Bottom-quark mass in GeV
	pub const BOTTOM_QUARK_MASS: f64 = 4.18;
	/// Top-quark mass in GeV
	pub const TOP_QUARK_MASS: f64 = 172.9;
	/// W-boson mass in GeV
	pub const W_BOSON_MASS: f64 = 80.379;
	/// Z-boson mass in GeV
	pub const Z_BOSON_MASS: f64 = 91.1876;
	/// Higgs-boson mass in GeV
	pub const HIGGS_MASS: f64 = 125.10;
	/// Neutron-pion mass in GeV
	pub const NEUTRAL_PION_MASS: f64 = 134.9766e-3;
	/// Charged-pion mass in GeV
	pub const CHARGED_PION_MASS: f64 = 139.57018e-3;
	/// Neutral-pion mass in GeV
	pub const NEUTRAL_KAON_MASS: f64 = 497.61e-3;
	/// Long-Kaon mass in GeV
	pub const LONG_KAON_MASS: f64 = 497.614e-3;
	/// Charged-Kaon mass in GeV
	pub const CHARGED_KAON_MASS: f64 = 493.68e-3;
2191bbfc63e7d6774b1901d1751b58c1|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/electroweak.rs|1|1|V|rust
	/// Fermi constant in GeV^-2
	pub const G_FERMI: f64 = 1.1663787e-5;
	/// Higgs VEV in GeV
	pub const HIGGS_VEV: f64 = 246.21965;
	/// Fine-structure constant at p^2 = 0
	pub const ALPHA_EM: f64 = 1.0 / 137.0; //at p^2 = 0
	/// Sine of the Weinberg angle
	pub const SIN_THETA_WEAK: f64 = 0.480853;
	/// Sine squared of the Weinberg angle
	pub const SIN_THETA_WEAK_SQRD: f64 = 0.23122;
	/// Cosine of the Weinberg angle
	pub const COS_THETA_WEAK: f64 = 0.876801;
ab80c0e9b07f35ac9802ce070abaed15|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|1|1|V|rust
	/// Plank mass in GeV
	pub const M_PLANK: f64 = 1.220910e19;
	/// Critical energy density divided by h^2 in units of GeV cm^-3
	pub const RHO_CRIT: f64 = 1.05375e-5;
	/// Entropy density of the Universe today in units of cm^-3
	pub const S_TODAY: f64 = 2891.2;
	/// Temperature of Universe when the CMB was formed
	pub const T_CMB: f64 = 2.56215e-10;
	/// Temperature of Universe when BBN occured
	pub const T_BBN: f64 = 0.0001; // 0.1 MeV in GeV
	/// Dark matter relic density: (rho_dm * h^2 / rho_crit)
	pub const OMEGA_H2_CDM: f64 = 0.1198;
99f654214bf5794bbd8dbc599f9f4232|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/widths.rs|1|1|V|rust
	/// W-boson decay width in GeV
	pub const W_BOSON_WIDTH: f64 = 2.085;
	/// Z-boson decay width in GeV
	pub const Z_BOSON_WIDTH: f64 = 2.4952;
	/// Higgs-boson decay width in GeV
	pub const HIGGS_WIDTH: f64 = 4.07e-3;
7a5157490795fab9115cde232af7532f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|11|1|V|rust
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = mh.powi(2);
	            let temp3: f64 = ms.powi(2);
	            let temp4: f64 = mh.powi(-2);
	            let temp5: f64 = 2.0 * w;
	            let temp6: f64 = ms + temp5;
	            let temp7: f64 = -4.0 * temp3;
	            let temp8: f64 = temp2 + temp7;
	            let temp9: f64 = temp1 * temp8;
	            let temp10: f64 = w.powi(2);
	            let temp11: f64 = 4.0 * ms * temp10;
	            let temp12: f64 = temp2 * temp6;
	            let temp13: f64 = temp11 + temp12;
	            let temp14: f64 = ms * temp13;
	            let temp15: f64 = temp14 + temp9;
d11d7aa248c52e1c1eb9dbf0e5229889|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|27|1|V|rust
	            (self.lam_hs.powi(2)
	                * ncol
	                * temp1
	                * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                    + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	                / 2.0
05bdb8326875bb23edc323dce7c10cc7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|38|1|V|rust
	        let temp = x / self.ms;
	        let pre = 1.0 / (48.0 * (self.ms * PI).powi(3) * 1.0) / 8.0;
	        let temp_fac = 1.0 / (2.0 * temp) / (1.0 + (w / temp).cosh());
	        let mut sum = 0.0;
3b68069dc3c8f1ddd594b9e5c84b0207|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|43|1|V|rust
	        sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
	        pre * temp_fac * sum
09bd3268bbc975f59aa886258644006f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|178|1|V|rust
	        let ms2 = self.ms * self.ms;
	        let e1 = (k1 * k1 + ms2).sqrt();
	        let e2 = (k2 * k2 + ms2).sqrt();
	
	        let mut sum = 0.0;
a73a11ed28efd84d2c96b153cd674ce2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|185|1|V|rust
	            // p1.p2
	            let dot = e1 * e2 - k1 * k2 * theta;
	            // Moler velocity
	            let vmol = (dot * dot - self.ms.powi(4)).sqrt() / (e1 * e2);
	            // s = (p1 + p2)^2
	            let cme = (2.0 * ms2 + 2.0 * dot).sqrt();
	            sum += wgt * vmol * self.sigma_ss(cme);
79f251791c50e62d7591a15468f36801|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|167|1|V|rust
	        let e = (q * q + x * x).sqrt(); // energy / temperature
	        1.0 / (e.exp() - 1.0)
aaa68764242d96f41f8583f859b74cc0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|136|1|V|rust
	    let n = v.len();
	    // this function requires the vector to be at least of length 6 or dv[1]
	    // will fail.
	    assert!(n >= 6);
	    let mut dv = Array1::<f64>::zeros(n);
	
	    // Use forward derivatives for first two entries
	    dv[0] = -25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	    dv[1] = -25.0 / 12.0 * v[1] + 4.0 * v[2] - 3.0 * v[3] + 4.0 / 3.0 * v[4] - 1.0 / 4.0 * v[5];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = 25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
	        + 1.0 / 4.0 * v[n - 6];
	    dv[n - 1] = 25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
	        + 1.0 / 4.0 * v[n - 5];
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = 1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
	    }
	
	    dv / h
d1cab2c4f7b8820f8a592c40db53d4c1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|168|1|V|rust
	    dv[[0, 0]] = -25.0 / 12.0;
	    dv[[0, 1]] = 4.0;
	    dv[[0, 2]] = -3.0;
	    dv[[0, 3]] = 4.0 / 3.0;
	    dv[[0, 4]] = -1.0 / 4.0;
	
	    dv[[1, 1]] = -25.0 / 12.0;
	    dv[[1, 2]] = 4.0;
	    dv[[1, 3]] = -3.0;
	    dv[[1, 4]] = 4.0 / 3.0;
	    dv[[1, 5]] = -1.0 / 4.0;
	
	    dv[[n - 1, n - 1]] = 25.0 / 12.0;
	    dv[[n - 1, n - 2]] = -4.0;
	    dv[[n - 1, n - 3]] = 3.0;
	    dv[[n - 1, n - 4]] = -4.0 / 3.0;
	    dv[[n - 1, n - 5]] = 1.0 / 4.0;
	
	    dv[[n - 2, n - 2]] = 25.0 / 12.0;
	    dv[[n - 2, n - 3]] = -4.0;
	    dv[[n - 2, n - 4]] = 3.0;
	    dv[[n - 2, n - 5]] = -4.0 / 3.0;
	    dv[[n - 2, n - 6]] = 1.0 / 4.0;
4663af17c589d962cb9404ff4a9ae5da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|194|1|V|rust
	        dv[[i, i - 2]] = 1.0 / 12.0;
	        dv[[i, i - 1]] = -2.0 / 3.0;
	        dv[[i, i + 1]] = 2.0 / 3.0;
	        dv[[i, i + 2]] = -1.0 / 12.0;
e5375a5ce7d786380bbb55867172908f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = -15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
	        + 13.0 * v[n - 5]
	        - 61.0 / 12.0 * v[n - 6]
	        + 5.0 / 6.0 * v[n - 7];
	    dv[n - 1] = -15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
	        + 13.0 * v[n - 4]
	        - 61.0 / 12.0 * v[n - 5]
	        + 5.0 / 6.0 * v[n - 6];
	
b2ee5420486603bfb635c35f2033901f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|1|V|rust
	    dv[0] = 15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
	        + 61.0 / 12.0 * v[4]
	        - 5.0 / 6.0 * v[5];
	    dv[1] = 15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
	        + 61.0 / 12.0 * v[5]
	        - 5.0 / 6.0 * v[6];
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = -15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
	        + 13.0 * v[n - 5]
	        - 61.0 / 12.0 * v[n - 6]
	        + 5.0 / 6.0 * v[n - 7];
	    dv[n - 1] = -15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
	        + 13.0 * v[n - 4]
	        - 61.0 / 12.0 * v[n - 5]
	        + 5.0 / 6.0 * v[n - 6];
	
97a673dda39341c67c8a5083292972fd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|231|17|v|rust
	-1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
	            + 4.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
7cd15948069687b4ede324a5c9658fa4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|22|1|V|rust
	    sm_sqrt_gstar(temp) * sm_geff(temp).sqrt() / sm_heff(temp) - 1.0
34c672c42e23c707af744583b2aeb774|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 2.8)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build) # main (top) cmake dir
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build) # project specific cmake dir
	set(CMAKE_CXX_STANDARD 11)
	
	# CMake useful variables
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	
	# Set the name of your project here
	project("thdm")
	
	# Set the version number of your project here (format is MAJOR.MINOR.PATCHLEVEL - e.g. 1.0.0)
	set(VERSION_MAJOR "0")
	set(VERSION_MINOR "1")
	set(VERSION_PATCH "0")
	set(VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH})
	
	find_package(Boost REQUIRED thread)
	find_package(GSL REQUIRED)
	find_package(Armadillo REQUIRED)
	find_package(Eigen3 REQUIRED)
	find_package(NLOPT REQUIRED)
	
	
	# This sets the include directory for the reference project. This is the -I flag in gcc.
	# All the includes should be in this variable To add new directories to the include path,
	# just add them in this list (after a space), or add an include_directories statement in a
	# subdirectory's CMakeLists.
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	        ${Boost_INCLUDE_DIRS}
	        ${ARMADILLO_INCLUDE_DIRS}
	        ${NLOPT_INCLUDE_DIRS}
	)
	
	# Mac needed variables (adapt according to your needs)
	set(CMAKE_MACOSX_RPATH ON)
	
	#enable_testing()
	add_subdirectory(include)
	add_subdirectory(apps)
	add_subdirectory(tests)
1536501d9b78dc499e285042aee8fbaa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|12|10|v|cmake
	thdm
aee2f3a65f7946972213031c74fd0e30|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|15|1|V|cmake
	set(VERSION_MAJOR "0")
43469ef94fb01f0840adf36fd898a082|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|15|1|V|cmake
	set(VERSION_MINOR "1")
4153f82f283900b87c56ec9c9c9801fb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|15|1|V|cmake
	set(VERSION_PATCH "0")
0c93d60dc0286f600a8c7d3723869b5f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|15|1|V|cmake
	set(VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH})
853233b365cd01a405a0d23f26542f48|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|14|1|V|cmake
	# Set the version number of your project here (format is MAJOR.MINOR.PATCHLEVEL - e.g. 1.0.0)
9a6dd283c3de653fbca500f9721f634f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/CMakeLists.txt|38|18|v|cmake
	apps
f5fe93b057c2e0705589cc311573405b|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/include/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 2.8)
	add_subdirectory(thdm)
	
	set(THDM_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/thdm/include/thdm)
	
	set(LIB_HEADERS
	        ${THDM_INCLUDE_DIR}/constants.hpp
	        ${THDM_INCLUDE_DIR}/errors.hpp
	        ${THDM_INCLUDE_DIR}/dual.hpp
	        ${THDM_INCLUDE_DIR}/fields.hpp
	        ${THDM_INCLUDE_DIR}/parameters.hpp
	        ${THDM_INCLUDE_DIR}/vacuua.hpp
	        ${THDM_INCLUDE_DIR}/potentials.hpp
	        ${THDM_INCLUDE_DIR}/jacobi.hpp
	        ${THDM_INCLUDE_DIR}/root_finding_eff.hpp
	        ${THDM_INCLUDE_DIR}/tree_roots.hpp
	        ${THDM_INCLUDE_DIR}/minimize.hpp
	        ${THDM_INCLUDE_DIR}/extrema_type.hpp
	        ${THDM_INCLUDE_DIR}/root_refine.hpp
	        ${THDM_INCLUDE_DIR}/gauge_masses.hpp
	        ${THDM_INCLUDE_DIR}/fermion_masses.hpp
	        ${THDM_INCLUDE_DIR}/beta_functions.hpp
	        ${THDM_INCLUDE_DIR}/validation.hpp
	        ${THDM_INCLUDE_DIR}/csv_parser.hpp
	        )
	
	# Define two variables in order not to repeat ourselves.
	set(LIBRARY_NAME thdm)
	
	# Define the library
	add_library(${LIBRARY_NAME} INTERFACE)
	
	target_include_directories(${LIBRARY_NAME} INTERFACE include/)
	
	target_link_libraries(${LIBRARY_NAME})
6c53c3effa7f3599c11b45b813db7071|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/CMakeLists.txt|2|18|v|cmake
	thdm)
6b634844f728d7bee6f45ae986e39dda|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/CMakeLists.txt|4|5|v|cmake
	THDM
a8245aa4a1c094d0ba624e82dce32c46|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/CMakeLists.txt|7|1|V|cmake
	        ${THDM_INCLUDE_DIR}/constants.hpp
	        ${THDM_INCLUDE_DIR}/errors.hpp
	        ${THDM_INCLUDE_DIR}/dual.hpp
	        ${THDM_INCLUDE_DIR}/fields.hpp
	        ${THDM_INCLUDE_DIR}/parameters.hpp
	        ${THDM_INCLUDE_DIR}/vacuua.hpp
	        ${THDM_INCLUDE_DIR}/potentials.hpp
	        ${THDM_INCLUDE_DIR}/jacobi.hpp
	        ${THDM_INCLUDE_DIR}/root_finding_eff.hpp
	        ${THDM_INCLUDE_DIR}/tree_roots.hpp
	        ${THDM_INCLUDE_DIR}/minimize.hpp
	        ${THDM_INCLUDE_DIR}/extrema_type.hpp
	        ${THDM_INCLUDE_DIR}/root_refine.hpp
	        ${THDM_INCLUDE_DIR}/gauge_masses.hpp
	        ${THDM_INCLUDE_DIR}/fermion_masses.hpp
	        ${THDM_INCLUDE_DIR}/beta_functions.hpp
	        ${THDM_INCLUDE_DIR}/validation.hpp
	        ${THDM_INCLUDE_DIR}/csv_parser.hpp
a1e0bd6e0a3996550656ef03c174d016|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/include/thdm/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 2.8)
fb47f06d9f61831faf759b0a9e87d44c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/CMakeLists.txt|1|32|v|cmake
	2.8)
fdbcd4380f8cba081794b17d1ab9986e|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/tests/CMakeLists.txt|1|1|V|cmake
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	include_directories(${Boost_INCLUDE_DIRS} ${ARMADILLO_INCLUDE_DIRS})
	
	# Now simply link against gtest or gtest_main as needed. Eg
	
	add_executable(test_dual test_dual.cpp)
	target_link_libraries(test_dual
	        gtest_main
	        ${Boost_LIBRARIES}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_dual PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_potential test_potential.cpp)
	target_link_libraries(test_potential gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_potential PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_jacobi test_jacobi.cpp)
	target_link_libraries(test_jacobi gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_jacobi PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_scalar_masses test_scalar_masses.cpp)
	target_link_libraries(test_scalar_masses
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_scalar_masses PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_root_finding test_root_finding.cpp)
	target_link_libraries(test_root_finding
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_root_finding PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_tree_roots test_tree_roots.cpp)
	target_link_libraries(test_tree_roots
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_tree_roots PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_minimize test_minimize.cpp)
	target_link_libraries(test_minimize
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_minimize PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	
	add_executable(test_model test_model.cpp)
	target_link_libraries(test_model
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_model PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	
	add_executable(test_tree_roots_explict test_tree_roots_explict.cpp)
	target_link_libraries(test_tree_roots_explict
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_tree_roots_explict PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_gauge_masses test_gauge_masses.cpp)
	target_link_libraries(test_gauge_masses
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_gauge_masses PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_rge test_rge.cpp)
	target_link_libraries(test_rge
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_rge PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_with_pedro test_with_pedro.cpp)
	target_link_libraries(test_with_pedro
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_with_pedro PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
afa65c8a8e9505b6c322888e015cf764|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/test/CMakeLists.txt|53|1|V|cmake
	
	add_executable(test_potential test_potential.cpp)
	target_link_libraries(test_potential gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_potential PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_jacobi test_jacobi.cpp)
	target_link_libraries(test_jacobi gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_jacobi PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_scalar_masses test_scalar_masses.cpp)
	target_link_libraries(test_scalar_masses
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_scalar_masses PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_root_finding test_root_finding.cpp)
	target_link_libraries(test_root_finding
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_root_finding PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_tree_roots test_tree_roots.cpp)
	target_link_libraries(test_tree_roots
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_tree_roots PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_minimize test_minimize.cpp)
	target_link_libraries(test_minimize
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_minimize PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	
	add_executable(test_model test_model.cpp)
	target_link_libraries(test_model
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_model PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	
	add_executable(test_tree_roots_explict test_tree_roots_explict.cpp)
	target_link_libraries(test_tree_roots_explict
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_tree_roots_explict PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_gauge_masses test_gauge_masses.cpp)
	target_link_libraries(test_gauge_masses
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_gauge_masses PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_rge test_rge.cpp)
	target_link_libraries(test_rge
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_rge PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	add_executable(test_with_pedro test_with_pedro.cpp)
	target_link_libraries(test_with_pedro
	        gtest_main
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	set_target_properties(test_with_pedro PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
25f0d4ffa595d65d12968e6bdf5b0426|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/test/CMakeLists.txt|45|1|v|cmake
	        thdm
58ea30808cddb9aabed5fa82e95aac8b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/test/CMakeLists.txt|50|28|v|cmake
	dual
64732282d6b99102aa583088e4c04fac|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/tests/CMakeLists.txt.in|1|1|V|cmake
	cmake_minimum_required(VERSION 2.8.2)
	
	project(googletest-download NONE)
	
	include(ExternalProject)
	ExternalProject_Add(googletest
	  GIT_REPOSITORY    https://github.com/google/googletest.git
	  GIT_TAG           master
	  SOURCE_DIR        "${CMAKE_CURRENT_BINARY_DIR}/googletest-src"
	  BINARY_DIR        "${CMAKE_CURRENT_BINARY_DIR}/googletest-build"
	  CONFIGURE_COMMAND ""
	  BUILD_COMMAND     ""
	  INSTALL_COMMAND   ""
	  TEST_COMMAND      ""
	)
e5f5602c277199194b08b3921091775f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/test/CMakeLists.txt.in|1|32|v|cmake
	2.8.2)
eeca6a075ccac3f7687296517e8bc4f5|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/apps/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 2.8)
	set(CMAKE_CXX_STANDARD 11)
	
	
	# Build the Effective Type A Extrema Finder Application
	set(INITIAL_DATA_GENERATOR_APP initial_data_generator)
	
	
	add_executable(${INITIAL_DATA_GENERATOR_APP} initial_data_generator.cpp)
	include_directories(${Boost_INCLUDE_DIRS})
	target_link_libraries(${INITIAL_DATA_GENERATOR_APP}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        ${Boost_THREAD_LIBRARY}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${INITIAL_DATA_GENERATOR_APP} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	# Build the Effective Type A Extrema Finder Application
	set(POST_PROCESSING post_processing)
	
	
	add_executable(${POST_PROCESSING} post_processing.cpp)
	target_link_libraries(${POST_PROCESSING}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${POST_PROCESSING} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	# Build the Effective Type A Extrema Finder Application
	set(FULL_SCAN find_double_mins)
	
	
	add_executable(${FULL_SCAN} full_scan.cpp)
	target_link_libraries(${FULL_SCAN}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${FULL_SCAN} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
768a2022871ce3671ced4be35e7c6eb3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|22|1|V|cmake
	
	# Build the Effective Type A Extrema Finder Application
	set(POST_PROCESSING post_processing)
	
	
	add_executable(${POST_PROCESSING} post_processing.cpp)
	target_link_libraries(${POST_PROCESSING}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${POST_PROCESSING} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
	# Build the Effective Type A Extrema Finder Application
	set(FULL_SCAN find_double_mins)
	
	
	add_executable(${FULL_SCAN} full_scan.cpp)
	target_link_libraries(${FULL_SCAN}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${FULL_SCAN} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
	
d2db35f1189bcb61a304d7562a92eef9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|5|5|v|cmake
	INITIAL_DATA_GENERATOR_APP initial_data_generator)
a917e43214c7b8510e45317c8a9e8d65|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|8|18|v|cmake
	INITIAL_DATA_GENERATOR_APP
c928cec6e3179c085d7891c358c8e28c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|8|28|v|cmake
	initial_data_generator
33d42e3033b21db8457cec1814d77f0d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|11|12|v|cmake
	m
	        ${
6972da0e7b1e97c357b88c209192ccaa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|4|18|v|cmake
	tive Type A Extrema Finder Application
a1455e88bc56e694e2030f30ea911dd8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|4|1|V|cmake
	# Build the Effec
376f065632ffa9521ac5414c9184e798|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/CMakeLists.txt|2|18|v|cmake
	KineticRecoupling
eb320f0c2b6a25b48ca861a120eea902|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|1|9|v|cpp
	macro
da4202ed7cd18be240049364a2d0a705|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|1|1|V|cpp
	#ifndef KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
a9fe981f2654edb8512ab3dacc47e54f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|2|2|v|cpp
	ifndef
632eb42a9e7412ca14d8774cac620e53|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|2|1|V|cpp
	#define KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
6f68ab4d9b0b58a6a246f0c109ff9ead|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|2|9|v|cpp
	KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
6731ea0acc61a379112b61e8181263d4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|7|1|V|cpp
	public:
fcdc8214d64e75b57282864c4120bdfc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet/model.hpp|1|1|V|cpp
	#ifndef KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
	#define KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
	
	namespace kin_recoup {
	
	class ScalarSinglet {
	private:
	public:
	  // Scalar mass
	  double ms;
	  // coefficient of SSH^*H
	  double lam_hs;
	
	  ScalarSinglet(double ms, double lam_hs) : ms(ms), lam_hs(lam_hs) {}
	};
	
	} // namespace kin_recoup
	
	#endif // KIN_RECOUP_SCALAR_SINGLET_MODEL_HPP
52d75543c3782416e34ae9e6c9ee2abc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|2|34|v|cpp
	_MODEL
6b02daa45abb137e96f945559d495453|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|17|3|V|cpp
	  auto gamma(
d7fec36cb38d8a6b00826d43a6622290|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|23|18|v|cpp
	average of the
1952382193c2f9e5f0a9db2bb28dc634|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|9|1|V|cpp
	  // Cross-section for SS -> ff
	  double sigma_ss_ff(double cme, double mf, double ncol);
7616777d1e5b9c8de80313cc89e420e4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|14|32|v|cpp
	, double mf, double ncol);
0574d23fba7426e1d9d47b626069906c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|18|1|V|cpp
	  // Compute the contribution to the integrand of momentum exchange rate from
	  // the scalar scattering off of SM fermions.
	  double gamma_integrand_sf_sf(double w);
889af03b40e7a9d3f0516321dd85e30f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|21|3|V|cpp
	  // Compute the contribution to the integrand of momentum exchange rate from
c1287597f1984b49d13817894e7cd300|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|21|3|V|cpp
	  // the scalar scattering off of SM fermions.
05dfdfe585c2a1890c6ab663cf9086e1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|1|9|v|cpp
	KIN_RECOUP_FULL_BOLTZ_MODEL_HPP
7f7feca57d65faef9bd702d441ad1ef5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|9|1|V|cpp
	  virtual double gamma(double T) = 0;
4a9a6ba474a73567472d3a3e01919677|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|9|29|v|cpp
	double T
5cecd558af4ee4032dc828610de35288|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|9|1|V|cpp
	  virtual double dm_mass() = 0;
636d80af7f3740a560f24d5ccc35d7c2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|34|1|V|cpp
	  double dm_mass() override { return ms; }
d31817a43d544ff17b5dd9efb655bee8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/CMakeLists.txt|42|1|v|cmake
	target_link_libraries(test_dual
853cf977a8f5937636d7016db4a3cf54|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|15|35|v|cpp
	for which
56b1ad0cb7fc5f25117aaea89d98e97f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|21|1|V|cpp
	  virtual double dm_dof() = 0;
79272b5f3ccd00b633cc94f595d8ac47|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|23|18|v|cpp
	dm_dof
13493c337aea9f39b691bddb5396f104|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|15|1|V|cpp
	  /**
	   * Scaleless momentum variables where the phase-space density function
	   * is defined: f_i(x) == f(x, qs[i])
	   */
	  std::vector<double> qs;
1a69e46c45819f2a9d06444ec8be4641|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|21|1|V|cpp
	  /**
	   * Scaleless momentum variables where the phase-space density function
	   * is defined: f_i(x) == f(x, qs[i])
	   */
	  std::vector<double> qs;
	
aee40d892da425f5be3ac0b484e74ca9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|24|9|v|cpp
	qs(std::vector<double>(nqs))
e22cf6472307add8772179df569a6f6b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|28|7|V|cpp
	      finit[i] = feq(
d4546310c7c21fcd45529d5ae85689ec|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|20|3|V|cpp
	  std::vector<double> finit;
294683ac723a7a1b2235cb185c66297b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|23|37|v|cpp
	, finit(std::vector<double>(nqs)) {
9e57b9a011e618164c175bfcd2190fe4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|18|1|V|cpp
	      : qs(std::vector<double>(nqs)) {
1c5e638a7394b5f05c1644021a8131a9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|18|5|V|cpp
	    double h = (qmax - qmin) / double(nqs - 1);
3b38bb383322cf4f7d369b6bc72c0178|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|18|5|V|cpp
	    for (size_t i = 0; i < nqs; i++) {
3e3aca470c2de3b34b259f7ee8be3df7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|18|7|V|cpp
	      qs[i] = qmin + h * i;
6f06754792a8823c68be8731d54c2727|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|16|59|v|cpp
	= default;
171cf86e02662a227b66e4aa8a0db2f2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|16|21|v|cpp
	double qmin, double qmax, size_t nqs
3a32a669253291f691ff5a725d7ca995|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|16|1|v|cpp
	  FullBoltzmanModel() = default;
c91135827e0f6f9d5fe9257205ca99f8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|33|9|v|cpp
	FullBoltzmanModel(), 
06049dac66853260628c124232c4c077|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|11|1|V|cpp
	  // Cross-section for S + S -> f + fbar
	  double sigma_ss_ff(double cme, double mf, double ncol);
	  // Cross-section for S + S -> W^+ + W^-
	  double sigma_ss_ww(double cme);
	  // Cross-section for S + S -> Z + Z
	  double sigma_ss_zz(double cme);
	  // Cross-section for S + S -> H + H
	  double sigma_ss_hh(double cme);
	
	  // Compute the contribution to the integrand of momentum exchange rate from
	  // the scalar scattering off of SM fermions.
	  double gamma_integrand_sf_sf(double w);
	  // Compute the integrand of the momentum exchange rate.
	  double gamma_integrand(double w, double T);
65be2a4b83237df52e5101362c210183|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|51|3|V|cpp
	  // Cross-section for S + S -> f + fbar
c20e246a24c27371614590d208fd4270|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|52|3|V|cpp
	  // Cross-section for S + S -> W^+ + W^-
2d824fcc0326f2241522bdde10803f48|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|53|3|V|cpp
	  // Cross-section for S + S -> Z + Z
09a001e76a69627215cd0d88c1274737|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|54|3|V|cpp
	  // Cross-section for S + S -> H + H
91e9c21dab97599528643ea70e001d15|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|54|48|v|cpp
	{return 0.0}
32a1067a6fd0184289159980bc6ecaca|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|62|1|V|cpp
	// Compute the contribution to the integrand of momentum exchange rate from
e86e4db3adf1768838d73f721727fcbe|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|62|1|V|cpp
	// the scalar scattering off of SM fermions.
3a53d89d095d73e224a1dac3e20853b6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|60|1|V|cpp
	double ScalarSinglet::sigma_ss_hh(double cme) { return 0.0; }
800d77c206dcc27c7de70eac3b563d7a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|40|1|V|cpp
	  double gamma(double T) override;
a1edea7b898abf0fe33d0c08d8c54f6d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|46|1|V|cpp
	  double sigmav_avg(double k1, double k2) override;
cd9b7831500f362bc181e9fc233ed537|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|35|1|V|cpp
	  double dm_dof() override { return 1.0; }
3fb3fbe07bc5d8abc11cba20949aee1a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|57|3|V|cpp
	  return 0.0;
c380c1f659c912031a0747fdbbeea5a1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|1|9|v|cpp
	KIN_RECOUP_CONSTANTS_HPP
d49207b1fe20de95ccade2d3c37b873a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|4|1|V|cpp
	namespace name = namespace;
1ac622a1384a979c36255aa192ca9907|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|9|1|V|cpp
	// Various physical constants
	static constexpr double kG_FERMI = 1.1663787e-5;
	static constexpr double kHIGGS_VEV = 246.21965;
	static constexpr double kALPHA_EM = 1.0 / 137.0; //at p^2 = 0
	static constexpr double kSIN_THETA_WEAK = 0.480853;
	static constexpr double kSIN_THETA_WEAK_SQRD = 0.23122;
	static constexpr double kCOS_THETA_WEAK = 0.876801;
	static constexpr double kM_PLANK = 1.220910e19;
	static constexpr double kRHO_CRIT = 1.05375e-5;
	static constexpr double kS_TODAY = 2891.2;
	static constexpr double kT_CMB = 2.56215e-10;
	static constexpr double kT_BBN = 0.0001; // 0.1 MeV in GeV
	static constexpr double kOMEGA_H2_CDM = 0.1198;
	
	//Masses
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTAU_MASS = 1776.86e-3;
	static constexpr double kUP_QUARK_MASS = 2.16e-3;
	static constexpr double kDOWN_QUARK_MASS = 4.67e-3;
	static constexpr double kSTRANGE_QUARK_MASS = 93e-3;
	static constexpr double kCHARM_QUARK_MASS = 1.27;
	static constexpr double kBOTTOM_QUARK_MASS = 4.18;
	static constexpr double kTOP_QUARK_MASS = 172.9;
	static constexpr double kW_BOSON_MASS = 80.379;
	static constexpr double kZ_BOSON_MASS = 91.1876;
	static constexpr double kHIGGS_MASS = 125.10;
	static constexpr double kNEUTRAL_PION_MASS = 134.9766e-3;
	static constexpr double kCHARGED_PION_MASS = 139.57018e-3;
	static constexpr double kNEUTRAL_KAON_MASS = 497.61e-3;
	static constexpr double kLONG_KAON_MASS = 497.614e-3;
	static constexpr double kCHARGED_KAON_MASS = 493.68e-3;
	
	//Boson widths
	static constexpr double kW_BOSON_WIDTH = 2.085;
	static constexpr double kZ_BOSON_WIDTH = 2.4952;
	static constexpr double kHIGGS_WIDTH = 4.07e-3;
	
	// Branching ratios
	static constexpr double kBR_PI0_TO_GG = 0.9882;         // Pi0   -> g   + g
	static constexpr double kBR_PI_TO_MUNU = 0.9998;        // pi    -> mu  + nu
	static constexpr double kBR_PI_TO_ENU = 0.000123;       // pi    -> e  + nu
	
	static constexpr double kBR_KS_TO_PIPI = 0.6920;        // ks    -> pi  + pi
	static constexpr double kBR_KS_TO_PI0PI0 = 0.3069;      // ks    -> pi0 + pi0
	
	static constexpr double kBR_KL_TO_PIENU = 0.4055;       // kl    -> pi  + e   + nu
	static constexpr double kBR_KL_TO_PIMUNU = 0.2704;      // kl    -> pi  + mu  + nu
	static constexpr double kBR_KL_TO_3PI0 = 0.1952;        // kl    -> pi0 + pi0  + pi0
	static constexpr double kBR_KL_TO_2PIPI0 = 0.1254;      // kl    -> pi  + pi  + pi0
	
	static constexpr double kBR_K_TO_MUNU = 0.6356;         // k     -> mu  + nu
	static constexpr double kBR_K_TO_PIPI0 = 0.2067;        // k     -> pi  + pi0
	static constexpr double kBR_K_TO_3PI = 0.05583;         // k     -> pi  + pi  + pi
	static constexpr double kBR_K_TO_PI0ENU = 0.0507;       // k     -> pi0 + e   + nu
	static constexpr double kBR_K_TO_PI0MUNU = 0.03352;     // k     -> pi0 + mu  + nu
	static constexpr double kBR_K_TO_PI2PI0 = 0.01760;      // k     -> pi  + pi0 + pi0
	
	static constexpr double kBR_ETA_TO_GG = 0.3941;         // eta   -> g   + g
	static constexpr double kBR_ETA_TO_3PI0 = 0.3268;       // eta   -> pi0 + pi0 + pi0
	static constexpr double kBR_ETA_TO_2PIPI0 = 0.2292;     // eta   -> pi  + pi  + pi0
	static constexpr double kBR_ETA_TO_2PIG = 0.0422;       // eta   -> pi  + pi  + g
	static constexpr double kBR_ETAP_TO_2PIETA = 0.429;     // eta'  -> pi  + pi  + eta
	static constexpr double kBR_ETAP_TO_RHOG = 0.291;       // eta'  -> rho + g
	static constexpr double kBR_ETAP_2PI0ETA = 0.222;       // eta'  -> pi0 + pi0 + eta
	static constexpr double kBR_ETAP_TO_OMEGAG = 0.0275;    // eta'  -> omega + g
	static constexpr double kBR_ETAP_TO_GG = 0.0220;        // eta'  -> g   + g
	static constexpr double kBR_ETAP_TO_3PI0 = 0.0214;      // eta'  -> pi0 + pi0 + pi-
	static constexpr double kBR_ETAP_TO_MUMUG = 0.0108;     // eta'  -> mu  + mu  + g
	
	static constexpr double kBR_OMEGA_TO_2PIPI0 = 0.892;    // omega -> pi + pi   + pi0
	static constexpr double kBR_OMEGA_TO_PI0G = 0.0828;     // omega -> pi0 + g
	static constexpr double kBR_OMEGA_TO_2PI = 0.0153;      // omega -> pi + pi
75237f892733ca641eed74d4e08a334d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|59|1|V|cpp
	  double s = cme * cme;
	  double temp1 = pow(kTOP_QUARK_MASS, 2);
	  double temp2 = 1 / s;
	  double temp3 = pow(kHIGGS_MASS, 2);
	  return (pow(lam_hs, 2) * ncol * (s - 4 * temp1) * temp1 * temp2 *
	          sqrt(1 - 4 * temp1 * temp2)) /
	         (16. * M_PI * sqrt(1 - 4 * pow(ms, 2) * temp2) *
	          (pow(-s + temp3, 2) + temp3 * pow(kHIGGS_WIDTH, 2)));
5b092b0e55686ea83a0e2b0086a7ad67|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|59|1|V|cpp
	  if (cme > 2 * ms && cme > 2 * mf) {
	    double s = cme * cme;
	    double temp1 = pow(kTOP_QUARK_MASS, 2);
	    double temp2 = 1 / s;
	    double temp3 = pow(kHIGGS_MASS, 2);
	    return (pow(lam_hs, 2) * ncol * (s - 4 * temp1) * temp1 * temp2 *
	            sqrt(1 - 4 * temp1 * temp2)) /
	           (16. * M_PI * sqrt(1 - 4 * pow(ms, 2) * temp2) *
	            (pow(-s + temp3, 2) + temp3 * pow(kHIGGS_WIDTH, 2)));
	  } else {
	    return 0.0;
	  }
4ea81bee10ddb9f6446bd196e81e8442|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|102|55|v|cpp
	return 0.0; 
8ff60d7008959e5321be8b999bfd579f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|87|54|v|cpp
	 return 0.0; 
2c41b2c4225864b09c807b6e93666a06|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|72|54|v|cpp
	 return 0.0;
98114d992786d23de6c4226744215d33|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|75|26|V|cpp
	    double s = cme * cme;
	    double temp1 = pow(kTOP_QUARK_MASS, 2);
	    double temp2 = 1 / s;
	    double temp3 = pow(kHIGGS_MASS, 2);
	    return (pow(lam_hs, 2) * ncol * (s - 4 * temp1) * temp1 * temp2 *
	            sqrt(1 - 4 * temp1 * temp2)) /
	           (16. * M_PI * sqrt(1 - 4 * pow(ms, 2) * temp2) *
	            (pow(-s + temp3, 2) + temp3 * pow(kHIGGS_WIDTH, 2)));
db8301ac79ece46265d440dccddc5ed0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|110|1|V|cpp
	    double temp1 = pow(kTOP_QUARK_MASS, 2);
	    double temp2 = 1 / s;
	    double temp3 = pow(kHIGGS_MASS, 2);
	    return (pow(lam_hs, 2) * ncol * (s - 4 * temp1) * temp1 * temp2 *
	            sqrt(1 - 4 * temp1 * temp2)) /
	           (16. * M_PI * sqrt(1 - 4 * pow(ms, 2) * temp2) *
	            (pow(-s + temp3, 2) + temp3 * pow(kHIGGS_WIDTH, 2)));
11395a52d7331ece0ffb7d149ae27879|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|111|24|v|cpp
	lam_hs
39bb8d57d18d53d0edea57a349fdb824|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|111|20|v|cpp
	pow(lam_hs, 2)
d9b62a25e191ac967cac4063e695fc84|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|112|24|v|cpp
	kHIGGS_MASS
8c121941be283305a11eadaa82830dc5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|112|20|v|cpp
	pow(kHIGGS_MASS, 2);
73aac19e5cad68e5e7dd98f156e5b618|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|113|20|v|cpp
	pow(ms, 2);
20425f012df437237c52199f7356bc2a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|114|20|v|cpp
	pow(kHIGGS_MASS, 4);
334b89be295dce80a93229451ea135f0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|117|20|v|cpp
	pow(temp7, 2);
f912d46db379c5ca06290b109197bacc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|118|20|v|cpp
	pow(kHIGGS_WIDTH, 2);
34e7cac0ea15753b92c05674759814c4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|124|21|v|cpp
	pow(kHIGGS_VEV, 2);
daca6ba02986be83497dda60bd70b194|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|134|29|v|cpp
	pow(kHIGGS_VEV, 4)
469e741930893019ba4ab4726c2720ed|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|19|1|V|cpp
	  // Cross-section for S + S -> H + H
	  double sigma_ss_hh(double cme) const;
9670293fc83621100d47225b518d1ab1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|21|33|v|cpp
	H + H
bcf163a34f231163cf2c41feb4b71ecd|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|151|1|V|cpp
	        sigma_ss_ff(cme, kTOP_QUARK_MASS, 3.0) +
0d218a61b42b179205cb37f899138040|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|152|26|v|cpp
	kTOP_QUARK_MASS
1ecba7d50244e041ca1e17545b3855f8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|156|1|V|cpp
	        sigma_ss_ff(cme, kDOWN_QUARK_MASS, 3.0) +
17f313ef9dee6c3b73823ff3f04371a3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|157|26|v|cpp
	kDOWN_QUARK_MASS
e435d7d437fcbb692c8463f0108c797c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|160|1|V|cpp
	        sigma_ss_ww(cme) + 
f808f8c8fc5031b198d6e82f0b1716a5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|109|7|v|cpp
	cme > 2 * ms &&
70900282cba71367ea7e4f4c7aecc796|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|93|7|v|cpp
	cme > 2 * ms && 
250988257d563a7943d3eb249345b0e7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|79|24|v|cpp
	kW_BOSON_MASS
7265d470f7f070e5e7ecb13d5357a6fc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|79|20|v|cpp
	pow(kW_BOSON_MASS, 2);
1945d038d24099c5768b7336bb0f27d7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|81|13|v|cpp
	pow(, 2)
c57c1f76d149a7bda9049b97393923bf|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|82|19|v|cpp
	pow(kW_BOSON_MASS, 4)
26ded072573496670c5abf5a0a922e1b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|85|40|v|cpp
	kSIN_THETA_WEAK_SQRD
70dd4c8ac8f61d5189512f5693b87aca|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|85|36|v|cpp
	pow(kSIN_THETA_WEAK_SQRD, 2) *
cf0474cb105e3baca88a52699a9c45f0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|87|26|v|cpp
	, 2)
4eadab1752a75125934dd4abc68ecca3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|87|14|v|cpp
	(-s + temp3)
6babc593a66fc445c2be211a04a0736f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|87|56|v|cpp
	kHIGGS_WIDTH
d05edc1c2645b08641749735f1e2e3ff|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|63|20|v|cpp
	pow(mf, 2);
784de0a2b670c31aeacf5a3fdc44069f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|99|24|v|cpp
	kZ_BOSON_MASS
b315ae815733acd9aebf800f09010a5c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|101|13|v|cpp
	pow(kALPHA_EM, 2)
0f49f769f9182c74bb02b81cfbe01b34|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|102|21|v|cpp
	pow(kZ_BOSON_MASS, 4)
c730d587113fa2d646fd489b0631018a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|106|13|v|cpp
	kSIN_THETA_WEAK_SQRD 
e4defbe0e262f3cc689f412d14d0cb92|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|107|13|v|cpp
	kSIN_THETA_WEAK_SQRD  
12f63614cdeb006bf6377d9c9e08bd54|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|106|20|v|cpp
	pow(kCOS_THETA_WEAK, 4)
4dd1a5a53894f5e6c22a407c843a1a68|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|106|20|v|cpp
	(1.0 - temp5)
c1ec8a34ba6a748624368d2782246067|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|171|58|v|cpp
	return 0.0; }
1858f1d5a719b216510ddbbb7d01b447|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|173|1|V|cpp
	  double e1 = sqrt(k1 * k1 + ms2);
0b6aa24c23454115943710215c3904a5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.rs|1|9|v|rust
	KIN_RECOUP_UTILS_HPP
48e8485d0c7d1ad975717e1935900492|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|11|1|V|rust
	        -0.998866404420071,
	        -0.9940319694320907,
	        -0.9853540840480058,
	        -0.972864385106692,
	        -0.9566109552428079,
	        -0.936656618944878,
	        -0.9130785566557919,
	        -0.8859679795236131,
	        -0.8554297694299461,
	        -0.821582070859336,
	        -0.7845558329003993,
	        -0.7444943022260685,
	        -0.7015524687068222,
	        -0.6558964656854394,
	        -0.6077029271849502,
	        -0.5571583045146501,
	        -0.5044581449074642,
	        -0.44980633497403877,
	        -0.39341431189756515,
	        -0.33550024541943735,
	        -0.276288193779532,
	        -0.21600723687604176,
	        -0.1548905899981459,
	        -0.09317470156008614,
	        -0.03109833832718888,
	        0.03109833832718888,
	        0.09317470156008614,
	        0.1548905899981459,
	        0.21600723687604176,
	        0.276288193779532,
	        0.33550024541943735,
	        0.39341431189756515,
	        0.44980633497403877,
	        0.5044581449074642,
	        0.5571583045146501,
	        0.6077029271849502,
	        0.6558964656854394,
	        0.7015524687068222,
	        0.7444943022260685,
	        0.7845558329003993,
	        0.821582070859336,
	        0.8554297694299461,
	        0.8859679795236131,
	        0.9130785566557919,
	        0.936656618944878,
	        0.9566109552428079,
	        0.972864385106692,
	        0.9853540840480058,
	        0.9940319694320907,
	        0.998864044200716,
947f67032eaccd3df55b4cb949daf0f3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|7|1|V|cpp
	const std::vector<double> GAUSS_LEG_NS = {
	    -0.998866404420071,   -0.9940319694320907,  -0.9853540840480058,
	    -0.972864385106692,   -0.9566109552428079,  -0.936656618944878,
	    -0.9130785566557919,  -0.8859679795236131,  -0.8554297694299461,
	    -0.821582070859336,   -0.7845558329003993,  -0.7444943022260685,
	    -0.7015524687068222,  -0.6558964656854394,  -0.6077029271849502,
	    -0.5571583045146501,  -0.5044581449074642,  -0.44980633497403877,
	    -0.39341431189756515, -0.33550024541943735, -0.276288193779532,
	    -0.21600723687604176, -0.1548905899981459,  -0.09317470156008614,
	    -0.03109833832718888, 0.03109833832718888,  0.09317470156008614,
	    0.1548905899981459,   0.21600723687604176,  0.276288193779532,
	    0.33550024541943735,  0.39341431189756515,  0.44980633497403877,
	    0.5044581449074642,   0.5571583045146501,   0.6077029271849502,
	    0.6558964656854394,   0.7015524687068222,   0.7444943022260685,
	    0.7845558329003993,   0.821582070859336,    0.8554297694299461,
	    0.8859679795236131,   0.9130785566557919,   0.936656618944878,
	    0.9566109552428079,   0.972864385106692,    0.9853540840480058,
	    0.9940319694320907,   0.998864044200716,
	};
03289081c91bde5756ec63e9cce39314|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|63|1|V|rust
	        0.0029086225531551016,
	        0.006759799195745375,
	        0.010590548383650852,
	        0.01438082276148563,
	        0.018115560713489423,
	        0.021780243170124725,
	        0.025360673570012402,
	        0.028842993580535152,
	        0.03221372822357803,
	        0.03545983561514616,
	        0.038568756612587685,
	        0.04152846309014772,
	        0.04432750433880324,
	        0.04695505130394836,
	        0.049400938449466275,
	        0.05165570306958109,
	        0.05371062188899619,
	        0.05555774480621255,
	        0.057189925647728415,
	        0.058600849813222416,
	        0.05978505870426544,
	        0.06073797084177024,
	        0.06145589959031668,
	        0.061936067420683256,
	        0.0621766166553472,
	        0.0621766166553472,
	        0.061936067420683256,
	        0.06145589959031668,
	        0.06073797084177024,
	        0.05978505870426544,
	        0.058600849813222416,
	        0.057189925647728415,
	        0.05555774480621255,
	        0.05371062188899619,
	        0.05165570306958109,
	        0.049400938449466275,
	        0.04695505130394836,
	        0.04432750433880324,
	        0.04152846309014772,
	        0.038568756612587685,
	        0.03545983561514616,
	        0.03221372822357803,
	        0.028842993580535152,
	        0.025360673570012402,
	        0.021780243170124725,
	        0.018115560713489423,
	        0.01438082276148563,
	        0.01059048383650852,
	        0.006759799195745375,
	        0.00290862255315510165,
4ad0ea1a6fb0d865e988a157d6e9b22b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|28|1|V|cpp
	    -0.998866404420071,   -0.9940319694320907,  -0.9853540840480058,
	    -0.972864385106692,   -0.9566109552428079,  -0.936656618944878,
	    -0.9130785566557919,  -0.8859679795236131,  -0.8554297694299461,
	    -0.821582070859336,   -0.7845558329003993,  -0.7444943022260685,
	    -0.7015524687068222,  -0.6558964656854394,  -0.6077029271849502,
	    -0.5571583045146501,  -0.5044581449074642,  -0.44980633497403877,
	    -0.39341431189756515, -0.33550024541943735, -0.276288193779532,
	    -0.21600723687604176, -0.1548905899981459,  -0.09317470156008614,
	    -0.03109833832718888, 0.03109833832718888,  0.09317470156008614,
	    0.1548905899981459,   0.21600723687604176,  0.276288193779532,
	    0.33550024541943735,  0.39341431189756515,  0.44980633497403877,
	    0.5044581449074642,   0.5571583045146501,   0.6077029271849502,
	    0.6558964656854394,   0.7015524687068222,   0.7444943022260685,
	    0.7845558329003993,   0.821582070859336,    0.8554297694299461,
	    0.8859679795236131,   0.9130785566557919,   0.936656618944878,
	    0.9566109552428079,   0.972864385106692,    0.9853540840480058,
	    0.9940319694320907,   0.998864044200716,
a2407c6582c2cf51f5f976acd6bb76be|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|179|5|V|cpp
	    sum 
f74981d10260c1b23b8d616865b6eeea|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|185|10|v|cpp
	0.0;
428b4f1bc0c4a0c8d555f7f3a1eec104|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|181|38|v|cpp
	GAUSS_LEG_NS[i];
da2bc62ccb9e20feecb5278a6a8ce69c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|184|12|v|cpp
	GAUSS_LEG_WS[i]
fc9251b60c384276894ad1a94648f91b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|197|2|v|cpp
	 return 0.0; }
d804c1e674c4d15ab0ce4b11a6e1ae7e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|198|18|v|cpp
	pow(mh, 2);
085e3121c4584e482b687b4966bc6757|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|199|10|v|cpp
	pow(lamS, 2)
893066299bbd841cafd4c12275581d08|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|201|58|v|cpp
	pow(mh, 2)
a68ee324e86f5c59dcf8bc0f975612fd|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|199|17|v|cpp
	(s - (mf - ms) * (mf - ms))
73c7bf5da5ae24b3d7659eefa02c2004|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|213|1|V|cpp
	      gamma_integrand_sf_sf(w, kTOP_QUARK_MASS, 3.0) + 
5fbde29075f2dff4fad53b1c9acfeff3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|215|32|v|cpp
	kTOP_QUARK_MASS, 3.0) + 
454fa04cdbe0d54b94e6fe23d0df46c8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|220|1|V|cpp
	      gamma_integrand_sf_sf(w, kMUON_MASS, 3.0) + 
c68e93c8ec41586916f2f08a42d5c07d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|221|32|v|cpp
	kMUON_MASS
b405b206679041cbf22f6275e654b063|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|230|61|v|cpp
	, &error
6d40ebaa7ee3b8067d35cada69d6fdcf|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/CMakeLists.txt|41|16|v|cmake
	test_m test_m.cpp)
d5f2acdbdd1522d567c9873c2dab53ad|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/CMakeLists.txt|42|23|v|cmake
	test_m
e51e6369781da2ee07f29cd28769a6d1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|5|3|V|cpp
	  aut
6ad57ed727f87fe6fee1ce27df5e6f42|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|12|1|V|cpp
	  std::cout << "gamma(T=1.0) = " << gam << std::endl;
e849ed9dec91593d2773207573aa40fe|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|12|37|v|cpp
	model.gamma(1.0)
37b9b57de827625049c10320200fb83d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|12|1|V|cpp
	  std::cout << "gamma(T=1.0) = " << model.gamma(1.0) << std::endl;
30f8fa59a2624b3e49a0876fca465a94|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|20|1|V|cpp
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTAU_MASS = 1776.86e-3;
	static constexpr double kUP_QUARK_MASS = 2.16e-3;
	static constexpr double kDOWN_QUARK_MASS = 4.67e-3;
	static constexpr double kSTRANGE_QUARK_MASS = 93e-3;
	static constexpr double kCHARM_QUARK_MASS = 1.27;
	static constexpr double kBOTTOM_QUARK_MASS = 4.18;
	static constexpr double kTOP_QUARK_MASS = 172.9;
e9bf91074dadd8d6ccb38d52dfce88c0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|200|1|V|cpp
	  double temp1 = mf * mf;
	  double temp2 = kHIGGS_MASS * kHIGGS_MASS;
8c162151c15abe630a1c1b0d4e8c80e0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|202|1|V|cpp
	  return lam_hs * lam_hs * ncol * temp1 *
	         ((4.0 * kCM2 * (2.0 * kCM2 - 2.0 * temp1 + temp2)) / (4 * kCM2 + temp2) +
	          (2.0 * temp1 - temp2) * log(1.0 + (4.0 * kCM2) / temp2));
233167f06af5f873e0a0795be19961ca|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|10|1|V|cpp
	  double gam = model.gamma(1.0);
68ab5cd040aa1b757d954ef755310b0a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|12|1|V|cpp
	  std::cout << "gamma(T=10.0) = " << model.gamma(10.0) << std::endl;
add5e65c655e53aa0b2bf37a3776bd3a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|8|1|V|cpp
	  ScalarSinglet model{57.0, 1.0};
c5f9141712415cc97920d722314c93f4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|10|1|V|cpp
	  std::cout << "gamma(T=0.1) = " << model.gamma(0.1) << std::endl;
	  std::cout << "gamma(T=1.0) = " << model.gamma(1.0) << std::endl;
7a2b2870fd448d5ac54bf2fa15ea2a0d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/tests/test_scalar_singlet.cpp|20|24|v|cpp
	T=0.1
c15775d00251716f69460ad325de9100|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|20|1|V|cpp
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTAU_MASS = 1776.86e-3;
	static constexpr double kUP_QUARK_MASS = 2.16e-3;
	static constexpr double kDOWN_QUARK_MASS = 4.67e-3;
	static constexpr double kSTRANGE_QUARK_MASS = 93e-3;
	static constexpr double kCHARM_QUARK_MASS = 1.27;
	static constexpr double kBOTTOM_QUARK_MASS = 4.18;
	static constexpr double kTOP_QUARK_MASS = 172.9;
	static constexpr double kW_BOSON_MASS = 80.379;
	static constexpr double kZ_BOSON_MASS = 91.1876;
	static constexpr double kHIGGS_MASS = 125.10;
97b1cae1ac7790f5bb2234ed3a2cd4c2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|6|1|V|cpp
	static constexpr double kG_FERMI = 1.1663787e-5;
	static constexpr double kHIGGS_VEV = 246.21965;
	static constexpr double kALPHA_EM = 1.0 / 137.0; // at p^2 = 0
	static constexpr double kSIN_THETA_WEAK = 0.480853;
	static constexpr double kSIN_THETA_WEAK_SQRD = 0.23122;
	static constexpr double kCOS_THETA_WEAK = 0.876801;
d7cb2172305805f24f66f6b1133dad97|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/constants.hpp|41|1|V|cpp
	static constexpr double kHIGGS_WIDTH = 4.07e-3;
97cfdd9c3c7bf38d59eb4c70914fc784|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|42|1|V|cpp
	  double gefft(double T);
5e729300c9b687a1c88d654ec5700d4a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|42|1|V|cpp
	  /**
	   * Compute the degrees of freedom factor that appears in the Boltzmann
	   * equation.
	   */
c6ed8b30a212943edb73a340fea7edc4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|49|18|v|cpp
	degrees of freedom factor that appears in the Boltzmann
9957502135e088070096ece3c2de8601|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|50|4|V|cpp
	   * equation.
cbbd6535995f1f13f0aa89f6754cb87e|file:///Users/loganmorrison/CLionProjects/DarkSUN/darksun/apps/CMakeLists.txt|8|1|V|cmake
	# Specify path to SUNDIALS header files
	SET(SUNDIALS_INC_DIR
	        /usr/local/Cellar/sundials/4.1.0_1/include
	        CACHE STRING
	        "Location of SUNDIALS header files")
	
	# Add path to SUNDIALS header files
	INCLUDE_DIRECTORIES(${SUNDIALS_INC_DIR})
	
	# Set search path for SUNDIALS libraries
	SET(SUNDIALS_LIB_DIR /usr/local/Cellar/sundials/4.1.0_1/lib)
	
	# Find the SUNDIALS solver's library
	FIND_LIBRARY(SUNDIALS_CVODE_SOLVER_LIB
	        sundials_cvode ${SUNDIALS_LIB_DIR}
	        DOC "CVODE library")
	
	# Find the SUNDIALS solver's library
	FIND_LIBRARY(SUNDIALS_AKCODE_SOLVER_LIB
	        sundials_arkode ${SUNDIALS_LIB_DIR}
	        DOC "ARKode library")
	
	# Find the NVECTOR library
	FIND_LIBRARY(SUNDIALS_NVEC_LIB
	        sundials_nvecserial ${SUNDIALS_LIB_DIR}
	        DOC "NVECTOR library")
	
	# Set additional libraries
	SET(SUNDIALS_EXTRA_LIB -lm CACHE STRING "Additional libraries")
	
	# List of all libraries
	SET(SUNDIALS_LIBS
	        ${SUNDIALS_CVODE_SOLVER_LIB}
	        ${SUNDIALS_AKCODE_SOLVER_LIB}
	        ${SUNDIALS_NVEC_LIB}
	        ${SUNDIALS_EXTRA_LIB})
	
b99bf72eb77498d9b09fe5972fced3fd|file:///Users/loganmorrison/CLionProjects/DarkSUN/darksun/apps/CMakeLists.txt|4|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(EIGEN3 REQUIRED)
	
	# Specify path to SUNDIALS header files
	SET(SUNDIALS_INC_DIR
	        /usr/local/Cellar/sundials/4.1.0_1/include
	        CACHE STRING
	        "Location of SUNDIALS header files")
	
	# Add path to SUNDIALS header files
	INCLUDE_DIRECTORIES(${SUNDIALS_INC_DIR})
	
	# Set search path for SUNDIALS libraries
	SET(SUNDIALS_LIB_DIR /usr/local/Cellar/sundials/4.1.0_1/lib)
	
	# Find the SUNDIALS solver's library
	FIND_LIBRARY(SUNDIALS_CVODE_SOLVER_LIB
	        sundials_cvode ${SUNDIALS_LIB_DIR}
	        DOC "CVODE library")
	
	# Find the SUNDIALS solver's library
	FIND_LIBRARY(SUNDIALS_AKCODE_SOLVER_LIB
	        sundials_arkode ${SUNDIALS_LIB_DIR}
	        DOC "ARKode library")
	
	# Find the NVECTOR library
	FIND_LIBRARY(SUNDIALS_NVEC_LIB
	        sundials_nvecserial ${SUNDIALS_LIB_DIR}
	        DOC "NVECTOR library")
	
	# Set additional libraries
	SET(SUNDIALS_EXTRA_LIB -lm CACHE STRING "Additional libraries")
	
	# List of all libraries
	SET(SUNDIALS_LIBS
	        ${SUNDIALS_CVODE_SOLVER_LIB}
	        ${SUNDIALS_AKCODE_SOLVER_LIB}
	        ${SUNDIALS_NVEC_LIB}
	        ${SUNDIALS_EXTRA_LIB})
	
	include_directories(${Boost_INCLUDE_DIRS})
1183770faf6b42a179e26848b3a09d7a|file:///Users/loganmorrison/CLionProjects/DarkSUN/darksun/tests/CMakeLists.txt|141|1|V|cmake
	        ${SUNDIALS_LIBS}
8e718a1e22c6a5ddfb8106b6d31f38c3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|73|1|V|cpp
	  N_Vector f = N_VNew_Serial(n);
e1695f475f47378032ab7e811c464d0f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|80|1|V|cpp
	  for (size_t i = 1; i <= n; i++){
	    NV_Ith_S(f, i) = feq( 
	  }
0b539afaf6c44c3fc7ab1dc5b962fe9e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|79|1|V|cpp
	  // Initial the distribution
	  for (size_t i = 1; i <= n; i++){
088124ac0880af53c5f6208ee78baf90|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|78|3|V|cpp
	  // Initial the distribution
f95606228b35d7745bb6f2abc4b18bcb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|15|1|V|cpp
	static int dfdx(realtype x, N_Vector f, N_Vector df, void *data){
	
	}
43722b7b25891272f1945408756990e4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|15|12|v|cpp
	dfdx
e286439883e59d10241a7bfcf39d1484|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|15|1|V|cpp
	static int dudt(realtype x, N_Vector f, N_Vector df, void *data){
	  FullBoltzmanModel 
	}
	
	static int dfdu(realtype x, N_Vector f, N_Vector df, void *data){
	
	}
8d777f385d3dfec8815d20f7496026dc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|72|55|v|cpp
	data
0f8d6fb56fe6cdf55ad0114ec5b51dbb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|72|30|v|cpp
	struct
ee5415ab9db7ed2930997665b80b51ed|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|70|14|v|cpp
	model->dm_mass()
87f83be532b014034b4eb35cef73e575|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|69|1|V|cpp
	  double mx = model->dm_mass();
673478b13aa9ab48c0020db5cdda8f42|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|23|1|V|cpp
	  N_Vector feqv = nullptr;
daf8700f436730584e34896aab1ff717|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|24|12|v|cpp
	feqv
41bb72e39efb174a609a6e50b9c7129d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|78|3|V|cpp
	  N_S
052548f93d6c60c5cbe73e0c29769b22|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|79|28|v|cpp
	SUNBandMatrix
279e7838cba797343f36e352bf7b8c90|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|79|3|V|cpp
	  auto scattering_matrix = SUNDenseMatrix(n, n);
ad23e0e53d04479788267beb37a5c216|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|81|1|V|cpp
	      NV_Ith_S(f, i) += 0.0;
b8d75c88da0377ba15a1775b92e0f5ec|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|78|3|V|cpp
	  auto qs 
0a6d66e461255b0fa9f9823f2df1f84b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|84|29|v|cpp
	T * NV_Ith_S(model->qs, i)
4ec64d14ea4b5a70c6ed9c3cb9835d81|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|85|11|v|cpp
	NV_Ith_S(model->feqv, i)
1cd0a3fea10944701755c95590592445|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|85|39|v|cpp
	NV_Ith_S(model->feqv, k)
f5c87d76da68de21de750a62bbd58510|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|86|21|v|cpp
	model->feqv
9ee3e4c41e4553dc875a24f832cdfefa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|86|12|v|cpp
	NV_Ith_S(f, k)
e153c23ad4489a0a8a5421f8f133fbb4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|88|7|v|cpp
	NV_Ith_S(df, i) +=
d166f1e401dbdd08e86a63bf01ee643b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|91|49|v|cpp
	NV_Ith_S(model->qs, i),
c48dcfb98b2c4970e481f28e6dadba84|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|91|49|v|cpp
	NV_Ith_S(model->qs, i)
2f15dc77f49133b6f787c2cd7558ddf6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|84|1|V|cpp
	    double qi = NV_Ith_S(model->qs, i);
3bf13a7955b5c18cfecac2ca19e1a4af|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|93|49|v|cpp
	NV_Ith_S(model->qs, k)) *
8af26a14161c1e9f1ccd79e647b1bbd2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|84|26|v|cpp
	model->qs
749df130752d776a4b56f1e51cfcbcde|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|84|1|V|cpp
	    double fi = NV_Ith_S(f, i);
1d8d5d82b779017ac47cfe584be51a6b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|96|13|v|cpp
	NV_Ith_S(f, i) * NV_Ith_S(f, k)
809a31f152810dd7a1408bf4d3760d5f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|85|1|V|cpp
	    double feqi = NV_Ith_S(f, i);
3ad8e03684b690b4b0a28e286eca4d08|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|97|13|v|cpp
	NV_Ith_S(model->feqv, i) * NV_Ith_S(model->feqv, k)
af01be5efdddf1c170eb6c043e1bf1a4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|96|12|v|cpp
	pow(qi, 2)
32aab4fc17e4069b11a301fbb73df69f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|108|5|V|cpp
	    double 
6ba7a9886bf911b3fc21dfe048753b51|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|104|1|V|cpp
	    NV_Ith_S(df, i) +=
02abc18c3b46fbd7cfee6bbcd0986b79|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|111|5|V|cpp
	    return 0;
d3dcfdacc8be8d338ac4a9f56fb146a0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|114|17|v|cpp
	realtype x, N_Vector f, N_Vector df, void *data
7d4af9a49716bfde7ab1c5411c7c930f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|95|26|v|cpp
	qk * qk * model->sigmav_avg(T * qi, T * qk) *
	                          (feqi * feqk - fi * fk)
471385761463baa7276a9957e7d825c0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|94|32|v|cpp
	pre * dq *
7c29b91cd158728c63f4f8b93378cb39|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|100|5|V|cpp
	    double gam = model->gamma(T);
8c97ad78b8dd75d780f9b6cc614cd909|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|110|2|V|cpp
	    double gt = model->gefft(T);
9d126d9528f7288d0b265c96288feea0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|76|1|V|cpp
	  FullBoltzmanModel *model = (class FullBoltzmanModel *)data;
	  size_t n = *model->n;
	  double dq = *model->dq;
	  double mx = model->dm_mass();
	  double gx = model->dm_dof();
	  double T = mx / x;
	  double ht = model->hubblet(T);
	  double pre = pow(mx, 3) * gx / (ht * pow(x, 4) * 2.0 * M_PI * M_PI);
	  double gam = model->gamma(T);
	  double gt = model->gefft(T);
	
	  for (size_t i = 1; i <= n; i++) {
	    NV_Ith_S(df, i) += 0.0;
	    double fi = NV_Ith_S(f, i);
	    double feqi = NV_Ith_S(f, i);
	    double qi = NV_Ith_S(model->qs, i);
	
	    // Integrate the scattering term
	    for (size_t k = 1; k <= n; k++) {
	      double wgt = (k == 1 || k == n) ? 0.5 : 1.0;
	      double fk = NV_Ith_S(f, k);
	      double feqk = NV_Ith_S(f, k);
	      double qk = NV_Ith_S(model->qs, k);
	      NV_Ith_S(df, i) += wgt * qk * qk * model->sigmav_avg(T * qi, T * qk) *
	                         (feqi * feqk - fi * fk);
	    }
	    NV_Ith_S(df, i) *= pre * dq;
	
	    // Compute elastic term
	    double xq = sqrt(x * x + pow(NV_Ith_S(model->qs, i), 2));
	    double dfdq = 0.0;
	    double d2fdq = 0.0;
	    NV_Ith_S(df, i) +=
	        (gam / (2.0 * ht * x)) *
	        (xq * d2fdq + (qi + 2.0 * xq / qi + qi / xq) * dfdq + 3.0 * fi);
	    // Expansion term
	    NV_Ith_S(df, i) += gt * qi / x * dfdq;
	  }
	  return 0;
c26ba559a5f34d46a49fafed87946fb7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|123|1|V|cpp
	  return 0;
1de0a74a12d655287b91783ab3ec286e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|121|17|v|cpp
	realtype 
2836befe0153cd6f6aec07f2350d0822|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|136|7|v|cpp
	NV_Ith_S
8fb822071da58045a432d69514c35ddf|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|160|35|V|cpp
	                                  (feqi * feqk - fi * fk);
e45e95e808003ac4ba722c6a80704679|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|164|7|V|cpp
	      double xq = sqrt(x * x + pow(NV_Ith_S(model->qs, i), 2));
fc50c189fa5b1492b0e587d70ecd4e2b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|143|1|V|cpp
	      double fi = NV_Ith_S(f, i);
	      double feqi = NV_Ith_S(f, i);
	      double qi = NV_Ith_S(model->qs, i);
d98bce59033a31e5997693d18ab3eb9e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|106|12|v|cpp
	dfdq 
d12d8a6dd336878812088a60c9b3a244|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|107|12|v|cpp
	d2fdq 
fe70129aaffb4b20e2495fd0c9b6c62b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|112|38|v|cpp
	dfdq
16ee9c8d1d12a53e80430be0305220a4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|167|7|v|cpp
	SM_ELEMENT_D(Jf, i, j)
b58425ba523b5259491ced63fd4dcdd3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|171|7|v|cpp
	NV_Ith_S(df, i)
a560fd241ca36fc41135cf259ea8079b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|106|5|V|cpp
	    //
dcc8c0727394f035cada56c58621298e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|106|1|V|cpp
	    double d1 = 0.0;
	    double d2 = 0.0;
040a1f4758ed7fde6e50bc218a30947a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|104|1|V|cpp
	    // Finite difference of df/dq
81e220ff8c7726a853ff8a5b1a978bc5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|104|1|V|cpp
	    // Finite difference of df/dq
	    double d1 = 0.0;
	    // Finite difference of d^2f/dq^2
	    double d2 = 0.0;
4888a9897c928b9f6e33f3c92af72c89|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|168|1|V|cpp
	      double Jd1 = 0.0;
	      double Jd2 = 0.0;
ee7ca1095450e1cfa9d5a18a7625c67b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|167|1|V|cpp
	      // Jacobian of finite difference of df/dq
d423f13307d27e8017b69585bc21e796|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|141|30|v|cpp
	pow(NV_Ith_S(model->qs, i), 2)
1fff0092e7480d6ec2901d465a1e8052|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|206|43|v|cpp
	mx / xmin
210f06a7f63b3bcd7d8af977178c837e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|49|3|v|cpp
	NV_Ith_S(dv, 0)
96aa5653e272bb33a2a7676cfde36c2f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|49|21|v|cpp
	-11.0 / 6 * NV_Ith_S(v, 0)
aa85ac787fa83cc27aaa3f08a624d02d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|49|1|V|cpp
	  NV_Ith_S(dv, 0) = (
	      -11.0 / 6 * NV_Ith_S(v, 0) +
	      -11.0 / 6 * NV_Ith_S(v, 1)
	      -11.0 / 6 * NV_Ith_S(v, 2)
	      -11.0 / 6 * NV_Ith_S(v, 3)
	  );
07345ead3095b2317e876de60ae07567|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|51|7|v|cpp
	-11.0 / 6
d47db888e69c80da04584efe4518d8d0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|56|8|v|cpp
	11.0 / 6
982dc0506f8591c692cc8cd00dac8bf4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|58|8|v|cpp
	11.0 / 6 
45475593bd851c0b50d518578eedcc60|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|49|1|V|cpp
	  NV_Ith_S(dv, 0) = (
	      -11.0 / 6 * NV_Ith_S(v, 0)
	      + 3.0 * NV_Ith_S(v, 1)
	      - 3.0/2.0 * NV_Ith_S(v, 2)
	      + 1.0 / 3.0 * NV_Ith_S(v, 3)
	  );
	  NV_Ith_S(dv, 1) = (
	      -1.0 / 3.0 * NV_Ith_S(v, 0)
	      - 1.0 / 2.0 * NV_Ith_S(v, 1)
	      + 1.0 * NV_Ith_S(v, 2)
	      - 1.0/6.0 * NV_Ith_S(v, 3)
	  );
09232bd93eeb5dbe95a6f98ab2b61e75|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|62|1|V|cpp
	      -11.0 / 6 * NV_Ith_S(v, n-4)
	      + 3.0 * NV_Ith_S(v, n-3)
	      - 3.0/2.0 * NV_Ith_S(v, n-2)
	      + 1.0 / 3.0 * NV_Ith_S(v, n-1)
cb2f164ed4024f1d43c21d3ab62e8f17|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|68|1|V|cpp
	      -1.0 / 3.0 * NV_Ith_S(v, 0)
	      - 1.0 / 2.0 * NV_Ith_S(v, 1)
	      + 1.0 * NV_Ith_S(v, 2)
	      - 1.0/6.0 * NV_Ith_S(v, 3)
74b25d76edf71c5a25ffc005b6d8bcc2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|63|7|v|cpp
	+ 3.0
b048c676ebda482a79788924275611c3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|68|9|v|cpp
	1.0 / 6
581a9f13f759991b8360042da939844c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|70|12|v|cpp
	/2.0
fde8e24a2656cb25081e9be95a9dd564|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|67|1|V|cpp
	  NV_Ith_S(dv, n-1) = (
	      -1.0 / 3.0 * NV_Ith_S(v, n-4)
	      + 3.0 / 2.0 * NV_Ith_S(v, n-3)
	      - 3.0 * NV_Ith_S(v, n-2)
	      + 11.0 / 6.0 * NV_Ith_S(v, n-1)
	  );
cbaf1c6cb82bd5b35ffcbe78fd2051bf|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|78|1|V|cpp
	        + 11.0 / 6.0 * NV_Ith_S(v, i+1)
fd22aae42621026a04b95a62e4566847|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|75|10|v|cpp
	1.0 / 3.0
c213dff252c1187a0458ce271435a4e3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|76|11|v|cpp
	3.0 / 2.0
8978cf6022ac45a3f1f746c85b1e0db7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|77|9|V|cpp
	        - 3.0 * NV_Ith_S(v, i)
e57c6e67a3b0f7a7922967e078d58190|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|77|11|v|cpp
	11.0 / 6.0
82ed576b80d6911ac201473e4ecceab5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|48|1|V|cpp
	/**
	 * Compute the finite difference derivative of a vector.
	 */
	void finite_diff(N_Vector v, N_Vector dv, size_t n, double h) {
	  NV_Ith_S(dv, 0) = (-11.0 / 6 * NV_Ith_S(v, 0) + 3.0 * NV_Ith_S(v, 1) -
	                     3.0 / 2.0 * NV_Ith_S(v, 2) + 1.0 / 3.0 * NV_Ith_S(v, 3));
	  NV_Ith_S(dv, 1) = (-1.0 / 3.0 * NV_Ith_S(v, 0) - 1.0 / 2.0 * NV_Ith_S(v, 1) +
	                     1.0 * NV_Ith_S(v, 2) - 1.0 / 6.0 * NV_Ith_S(v, 3));
	  NV_Ith_S(dv, n - 2) =
	      (-1.0 / 6.0 * NV_Ith_S(v, n - 4) - 1.0 * NV_Ith_S(v, n - 3) +
	       1.0 / 2.0 * NV_Ith_S(v, n - 2) + 1.0 / 3.0 * NV_Ith_S(v, n - 1));
	  NV_Ith_S(dv, n - 1) =
	      (-1.0 / 3.0 * NV_Ith_S(v, n - 4) + 3.0 / 2.0 * NV_Ith_S(v, n - 3) -
	       3.0 * NV_Ith_S(v, n - 2) + 11.0 / 6.0 * NV_Ith_S(v, n - 1));
	  for (size_t i = 2; i < n - 2; i++) {
	    NV_Ith_S(dv, i) =
	        (1.0 / 12.0 * NV_Ith_S(v, i - 2) - 2.0 / 3.0 * NV_Ith_S(v, i - 1) +
	         2.0 / 3.0 * NV_Ith_S(v, i + 1) - 1.0 / 12.0 * NV_Ith_S(v, i + 2));
	  }
	}
250f85350178e4b5522eb8219fd22d9e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|81|8|v|cpp
	
	                     
0c959f96b21cfd088d1f068aa7f8b81e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|80|9|v|cpp
	1.0 / 2.0
52d500a1fbc8d0f47de2d1f3a1fb03ef|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|82|9|v|cpp
	1.0 / 6.0
0fd16a509c49e4d691d0033f7575c8d9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|84|9|v|cpp
	 1.0 / 6.0
b0884ce8d2bae75ae5cc36fe264b5929|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|95|12|v|cpp
	1.0 / 12.0
89f5eded7a86abdd2b00f6a22015a351|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|96|12|v|cpp
	2.0 / 3.0
6c553ab21f23edea7a3b3ca0f0572a53|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|77|1|V|cpp
	      - 14.0/3.0 * NV_Ith_S(v, 3));
2c8176a1b0859cf78db5c2452dd570dc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|78|9|v|cpp
	14.0/3.0
bf9962ca7e99d2c4b66b9962703e589b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|83|1|V|cpp
	      +  * NV_Ith_S(v, 3));
2912900d171706c48709488796289be1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|88|1|V|cpp
	       +  * NV_Ith_S(v, n - 2) 
594d9c36fa4e8f1cbb353a4cd3be192e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|101|1|V|cpp
	         +  * NV_Ith_S(v, i + 1) 
6364bf120d6cf58ec85a405b7dde2445|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|104|45|v|cpp
	(h *;
872fa1e091de28a984a82420a6deaf13|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|48|1|V|cpp
	/**
	 * Compute the finite difference derivative of a vector.
	 */
	void finite_diff(N_Vector v, N_Vector dv, size_t n, double h) {
	  NV_Ith_S(dv, 0) = (-11.0 / 6 * NV_Ith_S(v, 0) + 3.0 * NV_Ith_S(v, 1) -
	                     3.0 / 2.0 * NV_Ith_S(v, 2) + 1.0 / 3.0 * NV_Ith_S(v, 3)) /
	                    h;
	  NV_Ith_S(dv, 1) = (-1.0 / 3.0 * NV_Ith_S(v, 0) - 1.0 / 2.0 * NV_Ith_S(v, 1) +
	                     1.0 * NV_Ith_S(v, 2) - 1.0 / 6.0 * NV_Ith_S(v, 3)) /
	                    h;
	  NV_Ith_S(dv, n - 2) =
	      (-1.0 / 6.0 * NV_Ith_S(v, n - 4) - 1.0 * NV_Ith_S(v, n - 3) +
	       1.0 / 2.0 * NV_Ith_S(v, n - 2) + 1.0 / 3.0 * NV_Ith_S(v, n - 1)) /
	      h;
	  NV_Ith_S(dv, n - 1) =
	      (-1.0 / 3.0 * NV_Ith_S(v, n - 4) + 3.0 / 2.0 * NV_Ith_S(v, n - 3) -
	       3.0 * NV_Ith_S(v, n - 2) + 11.0 / 6.0 * NV_Ith_S(v, n - 1)) /
	      h;
	  for (size_t i = 2; i < n - 2; i++) {
	    NV_Ith_S(dv, i) =
	        (1.0 / 12.0 * NV_Ith_S(v, i - 2) - 2.0 / 3.0 * NV_Ith_S(v, i - 1) +
	         2.0 / 3.0 * NV_Ith_S(v, i + 1) - 1.0 / 12.0 * NV_Ith_S(v, i + 2)) /
	        h;
	  }
	}
c2a4dc7404dbf49b5287b2ee79865eae|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|77|22|v|cpp
	N_Vector v, 
a098ae63d2f18fab52cbdcad2d768b36|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|77|22|v|cpp
	N_Vector
1f0c99b296db307a9cec7eaf330b86a6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|9|1|V|cpp
	#include <sunmatrix/sunmatrix_dense.h>
cd374155a6c43f7c98f00c1fe451d63c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|80|1|V|cpp
	  SM_ELEMENT_D(Jdv, 0, 0) = ;
af91225bc28ddef5ea29554b67eeec98|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|80|1|V|cpp
	  SM_ELEMENT_D(Jdv, 0, 0) = ;
	  SM_ELEMENT_D(Jdv, 0, 1) = ;
	  SM_ELEMENT_D(Jdv, 0, 2) = ;
	  SM_ELEMENT_D(Jdv, 0, 3) = ;
ad7e8c2a1781b9e0769350e65ef6e339|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|80|1|V|cpp
	  SM_ELEMENT_D(Jdv, 0, 0) = ;
	  SM_ELEMENT_D(Jdv, 0, 1) = ;
	  SM_ELEMENT_D(Jdv, 0, 2) = ;
	  SM_ELEMENT_D(Jdv, 0, 3) = ;
	  
	  SM_ELEMENT_D(Jdv, 1, 0) = ;
	  SM_ELEMENT_D(Jdv, 1, 1) = ;
	  SM_ELEMENT_D(Jdv, 1, 2) = ;
	  SM_ELEMENT_D(Jdv, 1, 3) = ;
f6df74b50c6520fbde323d93c9635eea|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|102|1|V|cpp
	  NV_Ith_S(dv, 0) = (-11.0 / 6 * NV_Ith_S(v, 0) + 3.0 * NV_Ith_S(v, 1) -
	                     3.0 / 2.0 * NV_Ith_S(v, 2) + 1.0 / 3.0 * NV_Ith_S(v, 3)) /
	                    h;
90411bb649c35bf32a2a371cd299ccd7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|81|35|V|cpp
	  NV_Ith_S(dv, 0) = ( * NV_Ith_S(v, 0) + 3.0 * NV_Ith_S(v, 1) -
	                     3.0 / 2.0 * NV_Ith_S(v, 2) + 1.0 / 3.0 * NV_Ith_S(v, 3)) /
	                    h;
1d0bc7e79cf539129be73be80355bf7f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|104|1|V|cpp
	  NV_Ith_S(dv, 1) = (-1.0 / 3.0 * NV_Ith_S(v, 0) - 1.0 / 2.0 * NV_Ith_S(v, 1) +
	                     1.0 * NV_Ith_S(v, 2) - 1.0 / 6.0 * NV_Ith_S(v, 3)) /
	                    h;
afe6ce1d986d2f3d0293d9589c20b0fc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|104|1|V|cpp
	  NV_Ith_S(dv, n - 2) =
	      (-1.0 / 6.0 * NV_Ith_S(v, n - 4) - 1.0 * NV_Ith_S(v, n - 3) +
	       1.0 / 2.0 * NV_Ith_S(v, n - 2) + 1.0 / 3.0 * NV_Ith_S(v, n - 1)) /
	      h;
9ec39addbfd9552e6d5e40de638e1d33|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|104|1|V|cpp
	  NV_Ith_S(dv, n - 1) =
	      (-1.0 / 3.0 * NV_Ith_S(v, n - 4) + 3.0 / 2.0 * NV_Ith_S(v, n - 3) -
	       3.0 * NV_Ith_S(v, n - 2) + 11.0 / 6.0 * NV_Ith_S(v, n - 1)) /
	      h;
6aa252b147159db7ed826277ebdcb2cf|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|96|1|V|cpp
	
	NV_Ith_S(dv, n - 1) =
	    (-1.0 / 3.0 * NV_Ith_S(v, n - 4) + 3.0 / 2.0 * NV_Ith_S(v, n - 3) -
	     3.0 * NV_Ith_S(v, n - 2) + 11.0 / 6.0 * NV_Ith_S(v, n - 1)) /
	    h;
6e1061b7db20eb7579a76c9cb8ffaa61|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|97|1|V|cpp
	  SM_ELEMENT_D(Jdv, n-1, 0) = -1.0/3.0/h;
	  SM_ELEMENT_D(Jdv, n-1, 1) = 3.0/2.0/h;
	  SM_ELEMENT_D(Jdv, n-1, 2) = -3.0/h;
	  SM_ELEMENT_D(Jdv, n-1, 3) = 11.0/6.0/h;
67ebeb94b938eff0c536e958de8a6645|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|106|31|v|cpp
	-1.0/3.0/h;
7009ea467ba1d24158a3a0a5afa6ce59|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|107|3|V|cpp
	  SM_ELEMENT_D(Jdv, i, i-1) = 3.0/2.0/h;
8221a3042fdc75c9e669afb48d5f0e06|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|107|31|v|cpp
	3.0/2.0/h;
634fe1d66125a93f2ca406844590ad7e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|108|31|v|cpp
	-3.0/h;
09684ff7bbb7ba9a0418f41d537bbb20|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|109|31|v|cpp
	11.0/6.0/h;
77e158608d4a35574444fa22bfdddf05|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|110|1|V|cpp
	    NV_Ith_S(dv, i) =
	        (1.0 / 12.0 * NV_Ith_S(v, i - 2) - 2.0 / 3.0 * NV_Ith_S(v, i - 1) +
	         2.0 / 3.0 * NV_Ith_S(v, i + 1) - 1.0 / 12.0 * NV_Ith_S(v, i + 2)) /
	        h;
d3b1f5ececaa24f31f5171a206f88777|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|75|1|V|cpp
	/**
	 * Compute the finite difference derivative of a vector.
	 */
	void finite_diff_jac(SUNMatrix Jdv, size_t n, double h) {
	
	  SM_ELEMENT_D(Jdv, 0, 0) = -11.0 / 6 / h;
	  SM_ELEMENT_D(Jdv, 0, 1) = 3.0 / h;
	  SM_ELEMENT_D(Jdv, 0, 2) = -3.0 / 2.0 / h;
	  SM_ELEMENT_D(Jdv, 0, 3) = 1.0 / 3.0 / h;
	
	  SM_ELEMENT_D(Jdv, 1, 0) = -1.0 / 3.0 / h;
	  SM_ELEMENT_D(Jdv, 1, 1) = -1.0 / 2.0 / h;
	  SM_ELEMENT_D(Jdv, 1, 2) = 1.0 / h;
	  SM_ELEMENT_D(Jdv, 1, 3) = -1.0 / 6.0 / h;
	
	  SM_ELEMENT_D(Jdv, n - 2, 0) = -1.0 / 6.0 / h;
	  SM_ELEMENT_D(Jdv, n - 2, 1) = -1.0 / h;
	  SM_ELEMENT_D(Jdv, n - 2, 2) = 1.0 / 2.0 / h;
	  SM_ELEMENT_D(Jdv, n - 2, 3) = 1.0 / 3.0 / h;
	
	  SM_ELEMENT_D(Jdv, n - 1, 0) = -1.0 / 3.0 / h;
	  SM_ELEMENT_D(Jdv, n - 1, 1) = 3.0 / 2.0 / h;
	  SM_ELEMENT_D(Jdv, n - 1, 2) = -3.0 / h;
	  SM_ELEMENT_D(Jdv, n - 1, 3) = 11.0 / 6.0 / h;
	
	  for (size_t i = 2; i < n - 2; i++) {
	
	    SM_ELEMENT_D(Jdv, i, i - 2) = 1.0 / 12.0 / h;
	    SM_ELEMENT_D(Jdv, i, i - 1) = -2.0 / 3.0 / h;
	    SM_ELEMENT_D(Jdv, i, i + 1) = 2.0 / 3.0 / h;
	    SM_ELEMENT_D(Jdv, i, i + 2) = -1.0 / 12.0 / h;
	  }
	}
7a19264934a5b53f2554aad2519d5952|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|150|1|V|cpp
	  SM_ELEMENT_D(Jdv, 0, 3) = 1.0 / 3.0 / h;
9e88376224ba3b772444fcdf06f77176|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|156|1|V|cpp
	  SM_ELEMENT_D(Jdv, 1, 3) = -1.0 / 6.0 / h;
69735adad5928ddd5cd601d3e123a5a4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|162|1|V|cpp
	  SM_ELEMENT_D(Jdv, n - 2, 3) = 1.0 / 3.0 / h;
8a00b4c63011fdc1eb7d12979aa1dbbc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|168|1|V|cpp
	  SM_ELEMENT_D(Jdv, n - 1, 3) = 11.0 / 6.0 / h;
57a2ac30626dd009c8a57b46556cf182|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|174|1|V|cpp
	    SM_ELEMENT_D(Jdv, i, i - 1) = -2.0 / 3.0 / h;
0b2618f1b5451c5aac18f23f5d189439|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|29|v|cpp
	-11.0 / 6 / h;
dd37a429e89284098b2a257d262ae144|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|148|28|v|cpp
	 3.0 / h;
219e33e83864f454a1a2df8749a59297|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|149|28|v|cpp
	 -3.0 / 2.0 / h;
f0ee9a3927d8220e63bd0e336dc32296|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|150|28|v|cpp
	 1.0 / 3.0 / h;
f5ec41425f78455ccc0a2f8ece27c512|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|153|28|v|cpp
	 -1.0 / 3.0 / h;
746977359f818879853d4d3900b291fb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|154|28|v|cpp
	 -1.0 / 2.0 / h;
6fb8dae5db1bb462789d80fcec3485c3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|155|28|v|cpp
	 1.0 / h;
7fe6870aa7c977700c24153cc5e5d324|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|156|28|v|cpp
	 -1.0 / 6.0 / h;
4aae59e5717f6558e3c8950222d0b8a6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|160|34|v|cpp
	 -1.0 / h;
5aa542b536bb8171c1fb9217d6d10940|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|161|34|v|cpp
	 1.0 / 2.0 / h;
e52c8b7f0d6a79e780b122045a365040|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|166|34|v|cpp
	 3.0 / 2.0 / h;
658d2b2146e57dc48a42f61f490ff489|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|167|34|v|cpp
	 -3.0 / h;
89948b23b91f5611cb6d415bd4407f87|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|168|34|v|cpp
	 11.0 / 6.0 / h;
cc3fe84bc5dfa5548a05396f0ab48b66|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|173|34|v|cpp
	 1.0 / 12.0 / h;
d8043d08ad770973e1fc7b867ca6fd68|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|174|34|v|cpp
	 -2.0 / 3.0 / h;
22174e865110c69f42da207df95f99a2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|176|34|v|cpp
	 2.0 / 3.0 / h;
50c5c8ab501311e974cb87bc91690523|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|177|34|v|cpp
	 -1.0 / 12.0 / h;
ab9701e155ca27011d1f65d2d376f9d1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|1|V|cpp
	  # Use forward derivatives for first two entries
0065170fcd47813933213112fe1c5344|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|150|5|V|cpp
	    # Use backwards derivatives for last two entries
7b635f706126a3652190790aa255f3d6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|149|1|V|cpp
	    //dv[n-1,n-4:n] = [-(1/12),1/3,1/2,-(5/3),11/12]
	    //dv[n,n-4:n] = [11/12,-(14/3),19/2,-(26/3),35/12]
6845d7274d45f55cb0c6df9959dcdd95|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|1|V|cpp
	    //dv[1,1:5] = [35/12,-(26/3),19/2,-(14/3),11/12]
	    //dv[2,1:5] = [11/12,-(5/3),1/2,1/3,-(1/12)]
466d1a66d0511eb71379d48415e03d03|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|154|2|V|cpp
	  //dv[2,1:5] = [11/12,-(5/3),1/2,1/3,-(1/12)]
c1db926db4dd9be9a5cf76a2f778a390|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|168|3|V|cpp
	  //dv[n,n-4:n] = [11/12,-(14/3),19/2,-(26/3),35/12]
201b8924c0640d8803308c6292e9880b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|150|1|V|cpp
	        dv[i,i-2:i+2] = [-(1/12),4/3,-(5/2),4/3,-(1/12)]
6b3b4de7ee5e58ed78d5dea63e5493e4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|148|1|V|cpp
	    # use central difference of all other points
	    for i = 3:n-2
	        dv[i,i-2:i+2] = [-(1/12),4/3,-(5/2),4/3,-(1/12)]
	    end
51d4818dea005cbac0ba1b5f94ba11dc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|18|v|cpp
	35/12
65a68eea459b22d9011d27cda6c11288|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|19|v|cpp
	-(26/3)
8d1f2dc59d06892a2ab24b83f9838cd7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|20|v|cpp
	19/2
13694b85e29ef577a4e9d75372eb396e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|21|v|cpp
	-(14/3)
1291ce3769b5fc562fb97e5b57c373ef|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|22|v|cpp
	11/12
5298a0ec88931d4e7db6b0beeaefa8d7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|147|3|V|cpp
	  //dv[1,1:5] = [,,,,]
98d9a546fceb07e6a2feb6b7a44bd822|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|153|19|v|cpp
	-(5/3)
63ae7f869ebe83e19411aee8d6ed4494|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|153|22|v|cpp
	-(1/12)
e4af605a9f2f87043d4904073f55adee|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|153|3|V|cpp
	  //dv[2,1:5] = [,,,,]
dc38c395218b4c49021472e1600a6646|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|159|3|V|cpp
	  //dv[n-1,n-4:n] = [,,,,]
284d402e03187015bcae303de4d4201a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|165|3|V|cpp
	  //dv[n,n-4:n] = [,,,,]
e391c5844dcd3ef85a9b98eab3c3f008|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|172|26|v|cpp
	-(5/2)
619a768f146dd8c22c3c93883b9b9ff5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|172|5|V|cpp
	    //dv[i,i-2:i+2] = [,,,,]
9e371e60dd138ce8723434fc46d46ce8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|148|30|v|cpp
	26.0 / 3.0
8cf6f99697a62373f86a2b112e82fa60|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|150|30|v|cpp
	14 / 3
06a5dd4b5b46a25075090e3ec766b2b0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|154|30|v|cpp
	5 / 3.0
2b772de4adfb4d59c43fd6b8a7d62f33|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|157|30|v|cpp
	1 / 12
f0c4f8c9ae591d76d6fb7bdd127e1a9d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|162|38|v|cpp
	5 / 3
ee44fe0ede50482b0c514d5a77309783|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|165|3|v|cpp
	SM_ELEMENT_D(Jdv, n - 1, n - 5) = 11.0 / 12.0;
	  SM_ELEMENT_D(Jdv, n - 1, n - 4) = -(1
cf51c04af75ec44ef964793fc7f4a961|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|168|38|v|cpp
	26 / 3
c706335a6cb05270651dc234ae53b219|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|174|36|v|cpp
	5 / 2
3618e801a2bcedb28c372ba074615e07|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|114|3|v|cpp
	NV_Ith_S(dv, 0) +=
b3467679e4442df1e60ef42c72d11d2c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|122|3|v|cpp
	NV_Ith_S(dv, 1) +=
6f9fe9f645a791ef378a0f171a78f103|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|126|3|v|cpp
	-1.0 / 12.0 * NV_Ith_S(v, n - 5) + 1.0 / 3.0 * NV_Ith_S(v, n - 4) +
	       1.0 / 2.0 * NV_Ith_S(v, n - 3) - 5.0 / 3.0 * NV_Ith_S(v, n - 2) +
	       11.0 / 12.0 * NV_Ith_S(v, n - 1)
2072f6816b743eaaa202d63b05221752|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|126|3|v|cpp
	NV_Ith_S(dv, n - 2) +=
9aafea83a5305e4cfb364a2d7aa07b55|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|132|3|v|cpp
	+11.0 / 12.0 * NV_Ith_S(v, n - 5) - 14.0 / 3.0 * NV_Ith_S(v, n - 4) +
	       19.0 / 2.0 * NV_Ith_S(v, n - 3) - 26.0 / 3.0 * NV_Ith_S(v, n - 2) +
	       35.0 / 12.0 * NV_Ith_S(v, n - 1)
25f00e1cf3d70908d4451821368bef3c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|132|3|v|cpp
	NV_Ith_S(dv, n - 1) +=
19f1c0376089d403bcd09039108eb953|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|121|3|v|cpp
	NV_Ith_S(dv, 1)
e51ca49fccaaf769d7093927512a6d62|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|128|3|v|cpp
	NV_Ith_S(dv, n - 2)
84638f21d14bf80bd0ba9d8d3c9a7d89|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|142|46|v|cpp
	v, i - 2
c7cab44e0f35afa80117c47998a2c78c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|142|5|v|cpp
	-1.0 / 12.0 * NV_Ith_S(v, i - 2) + 4.0 / 3.0 * NV_Ith_S(v, i - 1) -
	         5.0 / 2.0 * NV_Ith_S(v, i + 0) + 4.0 / 3.0 * NV_Ith_S(v, i + 1) -
	         1.0 / 12.0 * NV_Ith_S(v, i + 2)
790f6309b9fc0aa4f4106d3fa2e006fa|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|142|5|v|cpp
	NV_Ith_S(dv, i) +=
a836d3066f4bfdce4411ca5a5b1ac882|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|142|5|v|cpp
	NV_Ith_S(dv, i)
bbbaba24cc36b40f3b2d991b6faefcf7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/utils.hpp|135|3|v|cpp
	NV_Ith_S(dv, n - 1)
f00fb2b69b337ff08a3aedb8cd8db74a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|26|1|V|cpp
	  N_Vector d2f = nullptr;
9cc2cd598f3521db37a22f84eae7ef99|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|26|1|V|cpp
	  N_Vector df = nullptr;
	  N_Vector d2f = nullptr;
1e031432f010ca788d1337b2215fc8ab|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|28|3|v|cpp
	N_Vector df = nullptr;
0d7e3c086dea635a9f6f86782db25ea4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|91|1|V|cpp
	  finite_diff(f, model->df, n, dq);
d33781922e9490a315eeff33d559b62a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|92|3|v|cpp
	finite_diff
b5e760f217e93ff461832882da1ea52f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|111|5|V|cpp
	    double d1 = 0.0;
30c84d3fbb3577b6bdf4514c1d2d599a|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|111|5|V|cpp
	    // Finite difference of d^2f/dq^2
5df7ddd8a3340a53963a2d7529e54125|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|111|5|V|cpp
	    double d2 = 0.0;
83fa3ef06d22e7d4221b052ae601ed8d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|112|17|v|cpp
	NV_Ith_S(model->df, i);
70ee45d22a05341e8e4c831556bf6f45|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|175|20|v|cpp
	SM_ELEMENT_D(model->Jdf, i, j);
397f8854331af11609b49ebc7039c9ea|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|178|7|V|cpp
	      ;
3816ebe12460156a27ba0260772011e3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|176|7|V|cpp
	      // Jacobian of finite difference of d^2f/dq^2
859dac8223b9472b9a04ab9a62f93f21|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|179|1|V|cpp
	      double Jfi = (i == j) ? 1.0 : 0.0;
4918c5c4e42c82ae2c6aec381958ebec|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|200|3|V|cpp
	  qs = N_VNew_Serial(n);
1f7222d6192e6a0f2267c00e06e6f90d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|201|1|V|cpp
	  df = N_VNew_Serial(n);
d7615ddd254de660f2808c66c5ed2391|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|203|1|V|cpp
	  Jdf = SUNDenseMatrix(n, n);
a92b398a182818df99cd6b27460c1dbc|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|207|1|V|cpp
	  finite_diff_jac(Jdf, n, dq);
08139c4b33f222a872abf5b36d175cb6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|214|10|v|cpp
	qstep 
93b29251ea3c02956bcb91e456c9fdd4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|216|34|v|cpp
	qstep;
d9130d05a97f5070289e51e43d3d1b13|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|206|1|V|cpp
	  // Fill jacobians of df
	  finite_diff_jac(Jdf, n, *dq);
	  second_finite_diff_jac(Jdf, n, *dq);
33295ff8bc7556fc38cd38290b8cbdea|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|206|1|V|cpp
	  void *cvode_mem;
	  N_Vector f = N_VNew_Serial(n);
74dab130140ceef4b5665a6609d2a29e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|213|1|V|cpp
	  // Initial the distribution
	  double Tstart = mx / xmin;
	  for (size_t i = 0; i < n; i++) {
	    NV_Ith_S(f, i) = feq(NV_Ith_S(qs, i), Tstart);
	  }
8994f474f542280833346836f13ea8bd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/cosmology/standard_model.hpp|8|1|V|cpp
	#include <vector>
	#include <cmath>
	#include <boost/math/interpolators/cubic_b_spline.hpp>
976addb54463c60fce587063d5c2c2cb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/standard_model.hpp|1|9|v|cpp
	KIN_RECOUP_STANDARD_MODEL_HPP
f6051e0243bb14743b3c0e4885afeee6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|77|1|V|cpp
	double FullBoltzmanModel::gefft(double T){
	}
0e93def7c1af44700e224e5c2cb2a9c3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|78|46|v|cpp
	.sqrt(
a33ee6a7e5256a83543d11266b336333|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|6|1|V|cpp
	#include <kin_recoup/utils.hpp>
bee68f42563dd0f8c10fd0b8b7935bf2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|7|22|v|cpp
	utils.hpp>
f9818a7d20a059a0403ee401d0855333|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|82|31|v|cpp
	.powi(
b52eb9748d2756a93ff479ee43a6f48b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|227|3|V|cpp
	  void *cvode_mem;
204ed396f5c2c3f9014e80756287dc16|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|110|1|V|c
	static int check_retval(void *returnvalue, const char *funcname, int opt);
83a73d2a8ec38e8e61a4f9294b685613|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|114|1|V|c
	static int check_ans(N_Vector y, realtype t, realtype rtol, N_Vector atol);
7fc2e375b7810fdbbd99b5d8b8c54435|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|101|1|V|c
	static void PrintOutput(realtype t, realtype y1, realtype y2, realtype y3);
6b237eaf041132b3edb7371db69b820a|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|102|1|V|c
	static void PrintRootInfo(int root_f1, int root_f2);
36cfeb0cb78a4aa1cc08840ff8e8339b|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|106|1|V|c
	static void PrintFinalStats(void *cvode_mem);
5ea923e8e4b780112aadc1ee03cbdfb6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|101|1|V|cpp
	static int dudt(realtype x, N_Vector f, N_Vector df, void *data) {
7f0427507dd502e56c922dc55a079ece|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|154|1|V|cpp
	static int dfdu(double x, N_Vector f, N_Vector Jx, SUNMatrix Jf, void *data,
	                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
bb174d45bb302f3ea0c447fa96a0e657|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|101|1|V|cpp
	/**
	 * Compute the derivative of the DM phase-space density function.
	 */
	static int dudt(realtype x, N_Vector f, N_Vector df, void *data) {
	  FullBoltzmanModel *model = (class FullBoltzmanModel *)data;
	  size_t n = *model->n;
	  double dq = *model->dq;
	  double mx = model->dm_mass();
	  double gx = model->dm_dof();
	  double T = mx / x;
	  double ht = model->hubblet(T);
	  double pre = pow(mx, 3) * gx / (ht * pow(x, 4) * 2.0 * M_PI * M_PI);
	  double gam = model->gamma(T);
	  double gt = model->gefft(T);
	
	  finite_diff(f, model->df, n, dq);
	  second_finite_diff(f, model->d2f, n, dq);
	
	  for (size_t i = 0; i < n; i++) {
	    NV_Ith_S(df, i) = 0.0;
	    double fi = NV_Ith_S(f, i);
	    double feqi = NV_Ith_S(f, i);
	    double qi = NV_Ith_S(model->qs, i);
	
	    // Integrate the scattering term
	    for (size_t k = 0; k < n; k++) {
	      double wgt = (k == 0 || k == n - 1) ? 0.5 : 1.0;
	      double fk = NV_Ith_S(f, k);
	      double feqk = NV_Ith_S(f, k);
	      double qk = NV_Ith_S(model->qs, k);
	      NV_Ith_S(df, i) += wgt * qk * qk * model->sigmav_avg(T * qi, T * qk) *
	                         (feqi * feqk - fi * fk);
	    }
	    NV_Ith_S(df, i) *= pre * dq;
	
	    // Finite difference of df/dq
	    double d1 = NV_Ith_S(model->df, i);
	    // Finite difference of d^2f/dq^2
	    double d2 = NV_Ith_S(model->d2f, i);
	
	    // Compute elastic term
	    double xq = sqrt(x * x + qi * qi);
	    NV_Ith_S(df, i) +=
	        (gam / (2.0 * ht * x)) *
	        (xq * d2 + (qi + 2.0 * xq / qi + qi / xq) * d1 + 3.0 * fi);
	    // Expansion term
	    NV_Ith_S(df, i) += gt * qi / x * d1;
	  }
	  return 0;
	}
	
	/**
	 * Compute the Jacobian of the derivative of the DM phase-space density
	 * function.
	 */
	static int dfdu(double x, N_Vector f, N_Vector Jx, SUNMatrix Jf, void *data,
	                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
	  FullBoltzmanModel *model = (class FullBoltzmanModel *)data;
	  size_t n = *model->n;
	  double dq = *model->dq;
	  double mx = model->dm_mass();
	  double gx = model->dm_dof();
	  double T = mx / x;
	  double ht = model->hubblet(T);
	  double pre = pow(mx, 3) * gx / (ht * pow(x, 4) * 2.0 * M_PI * M_PI);
	  double gam = model->gamma(T);
	  double gt = model->gefft(T);
	
	  for (size_t i = 0; i < n; i++) {
	    double fi = NV_Ith_S(f, i);
	    double feqi = NV_Ith_S(f, i);
	    double qi = NV_Ith_S(model->qs, i);
	    double xq = sqrt(x * x + qi * qi);
	
	    for (size_t j = 0; j < n; j++) {
	      SM_ELEMENT_D(Jf, i, j) = 0.0;
	
	      // Integrate the scattering term
	      for (size_t k = 0; k < n; k++) {
	        double wgt = (k == 0 || k == n - 1) ? 0.5 : 1.0;
	        double fk = NV_Ith_S(f, k);
	        double feqk = NV_Ith_S(f, k);
	        double qk = NV_Ith_S(model->qs, k);
	
	        double d = 0.0;
	        if (i == j && i == k) {
	          d = fk + fi;
	        } else if (i == j) {
	          d = fk;
	        } else if (i == k) {
	          d = fi;
	        }
	
	        SM_ELEMENT_D(Jf, i, j) +=
	            -wgt * qk * qk * model->sigmav_avg(T * qi, T * qk) * d;
	      }
	      SM_ELEMENT_D(Jf, i, j) *= pre * dq;
	
	      // Compute the derivatives of f, df/dq and d^2f/dq^2
	      double Jfi = (i == j) ? 1.0 : 0.0;
	      double Jd1 = SM_ELEMENT_D(model->Jdf, i, j);
	      double Jd2 = SM_ELEMENT_D(model->Jd2f, i, j);
	
	      // Compute elastic term
	      SM_ELEMENT_D(Jf, i, j) +=
	          (gam / (2.0 * ht * x)) *
	          (xq * Jd2 + (qi + 2.0 * xq / qi + qi / xq) * Jd1 + 3.0 * Jfi);
	      // Expansion term
	      SM_ELEMENT_D(Jf, i, j) += gt * qi / x * Jd1;
	    }
	  }
	  return 0;
	}
31aef9d88a11515f55e7892f9da70677|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|376|1|V|c
	static int check_retval(void *returnvalue, const char *funcname, int opt)
	{
	  int *retval;
	
	  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
	  if (opt == 0 && returnvalue == NULL) {
	    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
		    funcname);
	    return(1); }
	
	  /* Check if retval < 0 */
	  else if (opt == 1) {
	    retval = (int *) returnvalue;
	    if (*retval < 0) {
	      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with retval = %d\n\n",
		      funcname, *retval);
	      return(1); }}
	
	  /* Check if function returned NULL pointer - no memory allocated */
	  else if (opt == 2 && returnvalue == NULL) {
	    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
		    funcname);
	    return(1); }
	
	  return(0);
	}
f8fbe0d7279ad20d3b91d1725ba18992|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|309|1|V|c
	static void PrintOutput(realtype t, realtype y1, realtype y2, realtype y3)
	{
	#if defined(SUNDIALS_EXTENDED_PRECISION)
	  printf("At t = %0.4Le      y =%14.6Le  %14.6Le  %14.6Le\n", t, y1, y2, y3);
	#elif defined(SUNDIALS_DOUBLE_PRECISION)
	  printf("At t = %0.4e      y =%14.6e  %14.6e  %14.6e\n", t, y1, y2, y3);
	#else
	  printf("At t = %0.4e      y =%14.6e  %14.6e  %14.6e\n", t, y1, y2, y3);
	#endif
	
	  return;
	}
0d6c5d87976d5cdba0b742c7bd8ff4ae|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|307|1|V|cpp
	  printf("At t = %0.4e      y =%14.6e  %14.6e  %14.6e\n", t, y1, y2, y3);
8d9d7b4b302b0fcaee1935d0a42216cd|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|1|V|cpp
	#if defined(SUNDIALS_EXTENDED_PRECISION)
6100ed25d0d09fd7a91801d4f1683e59|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|3|V|cpp
	  printf("At t = %0.4Le      y =%14.6Le  %14.6Le  %14.6Le\n", t, y1, y2, y3);
9968fe26491818018953b13704c28233|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|1|V|cpp
	#elif defined(SUNDIALS_DOUBLE_PRECISION)
8c16a47c9f89996ed2113d6695f8a8cb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|1|V|cpp
	#else
f2ee5aca71a929254acb780763f41937|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|1|V|cpp
	#endif
a44038263322e7056c907e539e14d9ee|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|333|1|V|c
	static void PrintFinalStats(void *cvode_mem)
	{
	  long int nst, nfe, nsetups, nje, nfeLS, nni, ncfn, netf, nge;
	  int retval;
	
	  retval = CVodeGetNumSteps(cvode_mem, &nst);
	  check_retval(&retval, "CVodeGetNumSteps", 1);
	  retval = CVodeGetNumRhsEvals(cvode_mem, &nfe);
	  check_retval(&retval, "CVodeGetNumRhsEvals", 1);
	  retval = CVodeGetNumLinSolvSetups(cvode_mem, &nsetups);
	  check_retval(&retval, "CVodeGetNumLinSolvSetups", 1);
	  retval = CVodeGetNumErrTestFails(cvode_mem, &netf);
	  check_retval(&retval, "CVodeGetNumErrTestFails", 1);
	  retval = CVodeGetNumNonlinSolvIters(cvode_mem, &nni);
	  check_retval(&retval, "CVodeGetNumNonlinSolvIters", 1);
	  retval = CVodeGetNumNonlinSolvConvFails(cvode_mem, &ncfn);
	  check_retval(&retval, "CVodeGetNumNonlinSolvConvFails", 1);
	
	  retval = CVodeGetNumJacEvals(cvode_mem, &nje);
	  check_retval(&retval, "CVodeGetNumJacEvals", 1);
	  retval = CVodeGetNumLinRhsEvals(cvode_mem, &nfeLS);
	  check_retval(&retval, "CVodeGetNumLinRhsEvals", 1);
	
	  retval = CVodeGetNumGEvals(cvode_mem, &nge);
	  check_retval(&retval, "CVodeGetNumGEvals", 1);
	
	  printf("\nFinal Statistics:\n");
	  printf("nst = %-6ld nfe  = %-6ld nsetups = %-6ld nfeLS = %-6ld nje = %ld\n",
		 nst, nfe, nsetups, nfeLS, nje);
	  printf("nni = %-6ld ncfn = %-6ld netf = %-6ld nge = %ld\n \n",
		 nni, ncfn, netf, nge);
	}
b68bfb9ff4e047f9e7532632760f1dfd|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|164|1|V|c
	  retval = CVodeInit(cvode_mem, f, T0, y);
0c28f6b0f343147317a30f9c64642d51|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|159|1|V|c
	  if (check_retval((void *)cvode_mem, "CVodeCreate", 0)) return(1);
cab8111fd0b710a336c898e539090e34|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|104|1|v|cpp
	void
dfbd2a9f13850d6c3b497f91b693fcb7|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|161|1|V|c
	  /* Call CVodeInit to initialize the integrator memory and specify the
	   * user's right hand side function in y'=f(t,y), the inital time T0, and
	   * the initial dependent variable vector y. */
0b42cbdbb7b38a5603aefbb4fb480487|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|167|1|V|c
	  /* Call CVodeSVtolerances to specify the scalar relative tolerance
	   * and vector absolute tolerances */
	  retval = CVodeSVtolerances(cvode_mem, reltol, abstol);
	  if (check_retval(&retval, "CVodeSVtolerances", 1)) return(1);
ce18d61b69238da85311e73c8b2b1871|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|176|1|V|c
	  /* Create dense SUNMatrix for use in linear solves */
	  A = SUNDenseMatrix(NEQ, NEQ);
	  if(check_retval((void *)A, "SUNDenseMatrix", 0)) return(1);
	
	  /* Create dense SUNLinearSolver object for use by CVode */
	  LS = SUNLinSol_Dense(y, A);
	  if(check_retval((void *)LS, "SUNLinSol_Dense", 0)) return(1);
	
	  /* Call CVodeSetLinearSolver to attach the matrix and linear solver to CVode */
	  retval = CVodeSetLinearSolver(cvode_mem, LS, A);
	  if(check_retval(&retval, "CVodeSetLinearSolver", 1)) return(1);
	
	  /* Set the user-supplied Jacobian routine Jac */
	  retval = CVodeSetJacFn(cvode_mem, Jac);
	  if(check_retval(&retval, "CVodeSetJacFn", 1)) return(1);
db3977dfd03fd0d256e68d3f4c9dc832|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|127|1|V|c
	  SUNMatrix A;
	  SUNLinearSolver LS;
20c63017bd0981c9c2fa8085b8bf4889|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|109|21|v|cpp
	1e-8;
dbbfd75fe9975c65fa264acd4ce80cd5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|109|27|v|cpp
	Empty_Serial
d72eb575688cbfa521d350af12808774|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|198|1|V|c
	    retval = CVode(cvode_mem, tout, y, &t, CV_NORMAL);
	    PrintOutput(t, Ith(y,1), Ith(y,2), Ith(y,3));
	
	    if (retval == CV_ROOT_RETURN) {
	      retvalr = CVodeGetRootInfo(cvode_mem, rootsfound);
	      if (check_retval(&retvalr, "CVodeGetRootInfo", 1)) return(1);
	      PrintRootInfo(rootsfound[0],rootsfound[1]);
	    }
	
	    if (check_retval(&retval, "CVode", 1)) break;
	    if (retval == CV_SUCCESS) {
	      iout++;
	      tout *= TMULT;
	    }
	
	    if (iout == NOUT) break;
6142791ed3d37ad95cbbe81200a230a4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|173|5|V|cpp
	    r
d687ba08fd2d68d45941d21f23dc7210|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|174|1|V|cpp
	  double x = xmin;
8fee031b61092657fa6474c0ef478763|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|178|31|v|cpp
	tout
9e9f7018db94e8f50a0aecf8e5b77ebd|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|179|5|V|cpp
	    PrintOutput(t, Ith(y,1), Ith(y,2), Ith(y,3));
bc21991771de21a1fff4363d42277256|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|180|1|V|cpp
	      std::cout << "x = " << x << std::endl;
9305cd789d3cc588d220e8c7f6e47b45|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|178|43|v|cpp
	<< std::endl;
2cf21e9137b1a73b90fdb16253f0e61e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|180|41|v|cpp
	<< x
e1a23c352be4fed41391ba1b3e97983e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|185|7|V|cpp
	      retvalr = CVodeGetRootInfo(cvode_mem, rootsfound);
c42f2dd14c5cd42fcaa283b4dbc03511|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|185|7|V|cpp
	      if (check_retval(&retvalr, "CVodeGetRootInfo", 1))
019299cfceb21a103859f6f94bf15c3b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|185|9|V|cpp
	        return (1);
6b8e12f141203885cf320c5d5420a985|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|184|1|V|cpp
	    if (retval == CV_ROOT_RETURN) {
	      PrintRootInfo(rootsfound[0], rootsfound[1]);
	    }
1545a9180ab7646d1d1b00fe8ca0f27f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|188|7|v|cpp
	tout *= TMULT;
7dd819d05b82f86944ffd3ef268378d2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|193|17|v|cpp
	NOUT
a9fae6b915b566961135a2f84fe33fe1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|193|9|v|cpp
	iout
bd1e52984782133bfa08881ce5ab3d82|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|361|1|v|cpp
	static void PrintOutput(realtype t, realtype y1, realtype y2, realtype y3) {
	  printf("At t = %0.4e      y =%14.6e  %14.6e  %14.6e\n", t, y1, y2, y3);
	  return;
	}
13dfb84692e912aaec094389d795ff23|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|216|1|V|c
	  /* Print some final statistics */
	  PrintFinalStats(cvode_mem);
30c9cdca5c4b3f3c1e9230d3a3c2230a|file:///Users/loganmorrison/Documents/coding/sundials-5.2.0/examples/cvode/serial/cvRoberts_dns.c|222|1|V|c
	  /* Free y and abstol vectors */
	  N_VDestroy(y);
	  N_VDestroy(abstol);
	
	  /* Free integrator memory */
	  CVodeFree(&cvode_mem);
	
	  /* Free the linear solver memory */
	  SUNLinSolFree(LS);
	
	  /* Free the matrix memory */
	  SUNMatDestroy(A);
	
	  return(retval);
f455ed990d6afe9a5b367a571e146df8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|203|1|V|cpp
	  N_VDestroy(f);
e1c00733e5d2a7462611b06951adb8de|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|204|1|V|cpp
	  N_VDestroy(qs);
90d0e38d235e26101ce065944b7520d7|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|205|1|V|cpp
	  N_VDestroy(df);
f9e56ebce39922855a79210b33b76839|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|206|1|V|cpp
	  N_VDestroy(d2f);
9011339b8aa068157b7743e2ad89724c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|216|1|V|cpp
	  SUNMatDestroy(A);
61810f56c2d7207378fc0964fd61c7f6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/main.cpp|5|14|v|cpp
	return 0; }
76a83ef58feea635f1bb17f4649eb21c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|39|1|V|cpp
	  N_Vector qs = nullptr;
	  double *dq = nullptr;
	  N_Vector feqv = nullptr;
	  N_Vector df = nullptr;
	  N_Vector d2f = nullptr;
	  SUNMatrix Jdf = nullptr;
	  SUNMatrix Jd2f = nullptr;
	  size_t *n = nullptr;
aa08cbf07ff606a1fa1b47eb466ac5c1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|46|14|v|cpp
	nullptr;
57f956e230756752d569e9e593fb42b0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|115|1|V|cpp
	  // Allocate memory for qs and dfs
	  N_Vector f = N_VNew_Serial(n);
	  qs = N_VNew_Serial(n);
	  feqv = N_VNew_Serial(n);
	  df = N_VNew_Serial(n);
	  d2f = N_VNew_Serial(n);
	  Jdf = SUNDenseMatrix(n, n);
	  Jd2f = SUNDenseMatrix(n, n);
ff5703406d2717edd09f22fdf3f558e9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|110|3|V|cpp
	  N_Vector abstol = N_VNew_Serial(n);
1783dbdf4558bde8c8d2397c22fe465c|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|109|3|V|cpp
	  double reltol = 1e-6;
90e66c593caa63614be2d2ceb47e9ea6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|154|1|V|cpp
	  if (check_retval(&retval, "CVodeSVtolerances", 1))
	    return (1);
116b86c3e29afb633998a6f17a5f8a08|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|150|1|V|cpp
	  int retval = CVodeSetUserData(cvode_mem,)
	  if (check_retval(&retval, "CVodeSVtolerances", 1))
	    return (1);
f27e31f267bc8f2e56ad8ba5fc91bdb1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|150|16|v|cpp
	CVodeSetUserData
e5494b704fa1b4cae944502c874aea9d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|151|30|v|cpp
	CVodeSVtolerances
707063b541f472aeb83ce1bf40531567|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|43|4|v|cpp
	 return 1.0; 
03b7a696481953e67eb43872f0b40c54|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|181|3|V|cpp
	  double xout = xmin;
690364cab64fcd85b66437c06796ed86|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|181|14|v|cpp
	xout
aee03db911ece647b5b56f047f4c3f16|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|184|1|V|cpp
	  double dx = (xmax - xmin) / 100.0;
4a9aa532b3ce7e1cf0e54f1b01226610|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|283|5|V|cpp
	    std::cout << "NV_Ith_S(df, i) = " << NV_Ith_S(df, i) << std::endl;
84f907dad0d5c31566eefa89edc0c43e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|306|5|V|cpp
	    double feqi = NV_Ith_S(model->feqv, i);
c4aec61a73b5f028f71d365a51e2f3a8|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|316|5|V|cpp
	        double feqk = NV_Ith_S(model->feqv, k);
f845b8e6e462545a218a72672d8bf771|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|339|11|v|cpp
	gam / (2.0 * ht * x)
d0d35a37f8344469a201aae1ee2d1ab2|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/CMakeLists.txt|6|1|V|cmake
	set(CMAKE_CXX_FLAGS_RELEASE "-O3")
9faa6d9631fd5fbcb5a8c6ba044a5cb3|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|188|1|V|cpp
	    std::cout << "x = " << x << "\n f = ";
	    for (size_t i = 0; i < n; i++) {
	      std::cout << NV_Ith_S(f, i) << " ";
	    }
	    std::cout << std::endl;
f1100fbdc505e80f2be5db52c35cf02b|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|192|1|V|cpp
	  std::cout << std::endl;
5703f441b323e4ec7b1b87ef3b386cb9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|201|1|V|cpp
	    std::cout << std::endl;
0e6252eceac26d64bb0dd6d690a858b0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|123|1|V|cpp
	    NV_Ith_S(abstol, i) = 1e-10;
c28e4b4a5aef8b74cab4ceccfa923c2e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|123|3|V|cpp
	  for (size_t i = 0; i < n; i++) {
6acb4a72b03f136242037635ea450e30|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|221|3|V|cpp
	  N_VDestroy(abstol);
ca747adf1071f3f65c9872cfe56c849d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|1|9|v|cpp
	KIN_RECOUP_TOY_HPP
8cd7285bb7e57b81cf1edbe7b6854588|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|11|25|v|cpp
	default;
1853ed572775f2a676ff3ad9b97df232|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|13|1|V|cpp
	  double gamma(double T) override {
	    double x = mx / T;
	    return 100.0 * pow(10.0 / x, 3);
	  }
02da03d773e352b8b728d9d6579bdba0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|18|5|V|cpp
	    double x = mx / T;
7f5cb1a0c9f801e9da37430e607ae540|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|20|12|v|cpp
	100.0 * pow(10.0 / x, 3);
f72b0ea3cb2b03fb5e20116fd81ce9fe|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|10|1|V|cpp
	  double c0 = 0.0;
4592c3bb309aaffbeac61820276b4117|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|22|5|V|cpp
	    return c0 + c1 * (1
d6d012649a4e54b1ec49e63cfc254536|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|10|1|V|cpp
	  double c0 = 1e-9;
	  double c1 = 1e-8;
f171efa5d0ae5be51088473fd64cf6f9|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/main.cpp|2|1|V|cpp
	#include <kin_recoup/scalar_singlet.hpp>
6579e87c116fc3eefffecb2e4d47d7c4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/apps/main.cpp|3|22|v|cpp
	scalar_singlet.hpp>
4e888881b70ca79307cb282ed382073e|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|60|22|v|cpp
	double q, double T
02f28c391a9663706678a235402326f5|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|136|47|v|cpp
	, Tstart);
a1cf227520391b3869b8463ad7e2bd98|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|263|1|V|cpp
	    double feqi = model->feq(x, NV_Ith_S(model->qs, i));
7e5005b1ced6e08cbd3e20411336f0a0|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|270|1|V|cpp
	      double feqk = NV_Ith_S(model->feqv, k);
c3e78d8cb0aa4bc31edce1920965b95f|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|270|1|V|cpp
	      double feqk = model->feq(x, NV_Ith_S(model->qs, k));
86ccdd92077b6566261db8081d87ab5d|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|113|3|V|cpp
	  feqv = N_VNew_Serial(n);
16d12473b5e879a6d7b8a59637b6d614|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|216|3|V|cpp
	  N_VDestroy(feqv);
5172d9f7886e262a4550c630d3a401ac|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|42|32|v|cpp
	, double T
df8392beef604a7df98e90e09c7e1981|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|43|5|V|cpp
	    double x = ms / T;
1349744b225a25965e1c8e0746d399c6|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|43|16|v|cpp
	sqrt(q * q + x * x)
80893653b967e0216eb958b46b5b3a34|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/scalar_singlet.hpp|43|5|V|cpp
	    double e = sqrt(q * q + x * x);
9dcc7980dd9690af675ee11dee921e16|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|11|12|v|cpp
	 = 1e-9;
936dd2c7fe5c224a76f38e61be179711|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|12|12|v|cpp
	 = 1e-8;
85f20f9012022ffe28c4e0e28d281b12|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|282|20|v|cpp
	* ht
1aacf5dd6d9632fa16a2ad4dd2a320e4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|286|1|V|cpp
	    std::cout << NV_Ith_S(df, i) << std::endl;
896e20d7e35cc0ed9c708d1c3da75079|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|347|20|v|cpp
	NV_Ith_S(, i)
f9628d01d40eeba0d8bb74cbcb648eef|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|343|24|v|cpp
	ht *
9e7594d91274042d7602cedd691595b1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|347|7|V|cpp
	      std::cout << SM_ELEMENT_D(Jf, i, j) << std::endl;
37923f2878dafedbb0f8ce765af7f623|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/full_boltz_model.hpp|177|31|v|cpp
	100.0;
8cdb19bb7c5736ead6e213d537b0864a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|4|1|V|rust
	pub mod simple_boltz;
32eccfff60b8b9f92a6d1583f72324c8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|5|9|v|rust
	simple_boltz
0754a8923153f31f2acb2c7382b7ce0a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|8|1|V|rust
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate
	    fn gamma(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, ki: f64, kj: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
b6dc202a437f20a7968ec59141cc2239|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/toy.hpp|25|1|V|cpp
	    return c0 +
	           c1 * (1.0 -
	                 pow(x, 4) /
	                     (q1 * q2 * sqrt((x * x + q1 * q1) * (x * x + q2 * q2))) *
	                     atanh(q1 * q2 /
	                           sqrt((x * x + q1 * q1) * (x * x + q2 * q2))));
df9b0daff2f081b4c1cdee09e679062f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|18|1|V|rust
	        c0 + c1 *
8d8a001ff172c13ee46c739939b93796|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|21|37|v|rust
	(x * x + q1 * q1) * (x * x + q2 * q2)
2336439e2f8d827b4b37b2775856bf99|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|37|v|rust
	 * temp
dd9a5ede2b253edf3b1d08e1c4b63c7f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|78|1|V|rust
	        let k = temp * q;
1f216fbade4037c6f2b1a84cee79135a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|34|1|V|rust
	#[allow(dead_code)]
	fn full() -> std::io::Result<()> {
	    let ms = HIGGS_MASS / 2.0 - 1.0;
	    let lam = 1e-3;
	    let model = ScalarSinglet::new(ms, lam);
	
	    let sol = integrate_full_boltzmann(model, 50, (1.0, 100.0));
	    println!("retcode = {:?}", sol.retcode);
	    let mut file = std::fs::File::create("analysis/full_boltz_data.dat")?;
	    for (t, u) in sol {
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
	    }
	    Ok(())
	}
1eaab97eff1833bd9c7e7340509ed91c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|54|5|V|rust
	    let ms = HIGGS_MASS / 2.0 - 1.0;
204544647a73c482cd75238050d3b1a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|54|5|V|rust
	    let lam = 1e-3;
316967751d6b74615a05cf0fd786abd9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|54|17|v|rust
	ScalarSinglet::new(ms, lam);
5144f65b7a4bd73b4343e94687bcb616|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|9|1|V|julia
	    dv[1] = sum(v[1:4] .* [-(11/6),3,-(3/2),1/3])
	    dv[2] = sum(v[1:4] .* [-(1/3),-(1/2),1,-(1/6)])
5a3a33ec15e885692ea73cddd379ca96|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|14|v|rust
	25.0 / 12.0
10e79e0eb62cdf82a4337e30b5cbd3bd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|62|v|rust
	4.0 / 3.0
576516335d9ba2a24d3fcfbd193a5b25|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|13|v|rust
	-11.0 / 6.0 * v[0] + 3.0 * v[1] - 3.0 / 2.0 * v[2] + 1.0 / 3.0 * v[3];
e4ed37c1c728b6ab658c7e727613c869|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|13|v|rust
	-25.0 / 12.0 * v[0] + 4.0 * v[1] - 3.0 * v[2] + 4.0 / 3.0 * v[3] - 1.0 / 4.0 * v[4];
	
54b1abfccd9a71694e7d77d189368345|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|13|1|V|julia
	    dv[n-1] = sum(v[n-3:n] .* [1/6,-1,1/2,1/3])
	    dv[n] = sum(v[n-3:n] .* [-(1/3),3/2,-3,11/6])
be8d49b1aadc7e91c06678c958d6d501|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|153|17|v|rust
	25.0 / 12.0 * v[n - 2] - 4.0 * v[n - 3] + 3.0 * v[n - 4] - 4.0 / 3.0 * v[n - 5]
9a8b54815d116212cdcc158afa3436a6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|154|16|V|rust
	        + 1.0 / 4.0 * v[n - 6];
cbc7b2ecba1175f4559dc64c909477d9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|154|17|v|rust
	25.0 / 12.0 * v[n - 1] - 4.0 * v[n - 2] + 3.0 * v[n - 3] - 4.0 / 3.0 * v[n - 4]
b77ab952cde6b45753ad6ed0533f92b9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|16|V|rust
	        + 1.0 / 4.0 * v[n - 5];
e9499827d35b35477dcf01fa97552456|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	    //dv[n-1] = sum(v[n-3:n] .* [1/6,-1,1/2,1/3])
0ff26c77d26341e177d130a7b955576d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|152|62|v|rust
	.dot(&v.slice(s![]));
6f52f503001e6178cb52f6936f33fdd5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|31|v|rust
	* v[0]
2050fdc18f66359cfa13894873aa7a30|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|31|v|rust
	 * v[0]
89d046a9a21d29e86096add02ff85feb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|9|27|v|julia
	[-(11/6),3,-(3/2),1/3]
274574185f79b51c81405875c898d6b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|19|v|rust
	[-11.0 / 6.0,  3.0 * v[1] - 3.0 / 2.0 * v[2] + 1.0 / 3.0 * v[3]
3bf8208c23fea3283281176562bfe832|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|10|27|v|julia
	[-(1/3),-(1/2),1,-(1/6)]
bf9571f280415c22e90a6e6ee42d368c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|19|v|rust
	[-1.0 / 3.0, - 1.0 / 2.0 * v[1] + 1.0 * v[2] - 1.0 / 6.0 * v[3]
c7c33f8e5c50d524457b1e05a7729144|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|47|v|rust
	1.0/6.0
976163b083f5720b46a57d5550eb63b8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|37|v|rust
	3.0/2.0
ae8eebe4d0ef0543f574def8d66dee14|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|32|v|rust
	1.0/2.0
5cfffa4ccf7732e49c84f3878c98136a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|21|v|rust
	1.0/3.0
66a0e183d8f3b66f1130540cc98e2e72|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|21|v|rust
	11.0/6.0
78d3fce5162f61afbbc5d8a196886cdd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|152|62|v|rust
	.dot(&v.slice(s![-4..]))
c7ec528da238a0e9e3cd7ce5ab671099|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|18|35|v|julia
	[1/12,-(2/3),0,2/3,-(1/12)]
2b63f55f94f10bdcf17e8381129b0cfe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|17|v|rust
	1.0 / 12.0 * v[i - 2] - 2.0 / 3.0 * v[i - 1] + 2.0 / 3.0 * v[i + 1]
	            - 1.0 / 12.0 * v[i + 2];
b563c15bd1e73dc9a9cfeb5c92367d71|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|152|62|v|rust
	.dot(&v.slice(s![-4..]));
92ac50ee8994142db8d01a60b86538ac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|5|v|rust
	// use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![1.0/12.0,-(2.0/3
89abf5b5a363654c8b176aa07acb7f2a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|34|v|rust
	2.0/3.0
30f704bf6c597cff1bddd74e2e6131f3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|157|55|v|rust
	1/12
9e7edc95b8b4944da1e3c0720ba742db|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|151|1|V|rust
	    //dv[n] = sum(v[n-3:n] .* [-(1/3),3/2,-3,11/6])
6808d6fbc7ca6482b719bcf5d5fe5527|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|143|1|V|rust
	    //dv[1] = sum(v[1:4] .* [-(11/6),3,-(3/2),1/3])
835e8536b99e4457872db28c66ecba11|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|143|1|V|rust
	    //dv[2] = sum(v[1:4] .* [-(1/3),-(1/2),1,-(1/6)])
3aba2a8365bec5b19451b6ac41d9441d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|13|v|rust
	15.0 / 4.0 * v[0] - 77.0 / 6.0 * v[1] + 107.0 / 6.0 * v[2] - 13.0 * v[3]
a141d4a93ec458afd2eb51d31a3df018|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|13|v|rust
	15.0 / 4.0 * v[1] - 77.0 / 6.0 * v[2] + 107.0 / 6.0 * v[3] - 13.0 * v[4]
5e580d7f1ee6e68f7e5c7aed48a9e17a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|12|V|rust
	        + 61.0 / 12.0 * v[5]
4c7036716c140d1b17d0bda1ff80d842|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|12|V|rust
	        - 5.0 / 6.0 * v[6];
0393bde046661f80b226dddaf0156791|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|215|17|v|rust
	-15.0 / 4.0 * v[n - 2] + 77.0 / 6.0 * v[n - 3] - 107.0 / 6.0 * v[n - 4]
c460d3120c0ac1be767009bbf536011e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|16|V|rust
	        + 13.0 * v[n - 5]
09a0cceff6211b69a42fc3c7026b75af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|16|V|rust
	        - 61.0 / 12.0 * v[n - 6]
02d549cb558161ccf4f5895cfb7ccc42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|16|V|rust
	        + 5.0 / 6.0 * v[n - 7];
6fa82fe0ef62c81e8f511eb892b68899|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|17|v|rust
	-15.0 / 4.0 * v[n - 1] + 77.0 / 6.0 * v[n - 2] - 107.0 / 6.0 * v[n - 3]
6507ea645fd6cbff4d9116d531a51992|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|217|16|V|rust
	        + 13.0 * v[n - 4]
3890dca9a47fb7a2fe1b84aa4c5029e5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|217|16|V|rust
	        - 61.0 / 12.0 * v[n - 5]
ede40e9f916b08018d274d229a7d31a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|217|16|V|rust
	        + 5.0 / 6.0 * v[n - 6];
c122f6df88e4f622f035db0d25394e38|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|220|17|v|rust
	-1.0 / 12.0 * v[i - 2] + 4.0 / 3.0 * v[i - 1] - 5.0 / 2.0 * v[i]
8fd90b6c464d163ed147254eea751bb1|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|32|1|V|julia
	    dv[1] = sum(v[1:5] .* [35/12,-(26/3),19/2,-(14/3),11/12])
	    dv[2] = sum(v[1:5] .* [11/12,-(5/3),1/2,1/3,-(1/12)])
	
	    # Use backwards derivatives for last two entries
	    dv[n-1] = sum(v[n-4:n] .* [-(1/12),1/3,1/2,-(5/3),11/12])
	    dv[n] = sum(v[n-4:n] .* [11/12,-(14/3),19/2,-(26/3),35/12])
49c3ebc514caefff34349bf2fbb62268|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|27|v|rust
	[35/12,-(26/3),19/2,-(14/3),11/12]
9286ed32d5eeb75391612bd02bfbb924|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|27|v|rust
	[11/12,-(5/3),1/2,1/3,-(1/12)]
3a357b41a596d23830eed013e8bc61af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|18|V|rust
	    dv[1] = sum(v[1:5] .* [35/12,-(26/3),19/2,-(14/3),11/12])
91989dfd61ea441e44b66da05b9ccb1f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|18|V|rust
	    dv[2] = sum(v[1:5] .* [11/12,-(5/3),1/2,1/3,-(1/12)])
726fffd96d995e608642570656890082|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|31|v|rust
	[-(1/12),1/3,1/2,-(5/3),11/12]
580cc396047711922c6494d2f6863513|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|29|v|rust
	[11/12,-(14/3),19/2,-(26/3),35/12]
d78970a8f60de8a3ba4c53b144bae3a4|file:///Users/loganmorrison/Documents/research/KineticRecoupling/julia/utils.jl|41|35|v|julia
	[-(1/12),4/3,-(5/2),4/3,-(1/12)]
24ec517f14b8a1521600ecfb875b73ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|31|V|rust
	    dv[n-1] = sum(v[n-4:n] .* )
35abb865fd8d0db536fa7848e9d07f76|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|29|V|rust
	    dv[n] = sum(v[n-4:n] .* )
74d498492903bdbddd2a3d766ae11f7b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|143|60|v|rust
	.dot(&v.slice(s![..5]));
d6ba22c2e5a97f4ac67b7875a85aada3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|53|v|rust
	.dot(&v.slice(s![..5]))
bb6f337fbbd58b1d3b31e635b8a8c74d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|27|v|rust
	26/3
119acd42a6af27bbc63249dcbab51041|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|38|v|rust
	14/3
cbfc0f0f35ea44da0166ccfd43ca1948|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|232|1|V|rust
	    .dot(&v.slice(s![..5]));
03a859eff3efa7674e4096bb09219916|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|236|43|v|rust
	5.0 / 2.0
519c60830fca97a287d11d7344463c4b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|145|1|V|rust
	    // Use backwards derivatives for last two entries
52f804597f0055b9a040ce83ebcb2eb2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0].dot(&v.slice(s![..5]));
	    dv[0] = array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0].dot(&v.slice(s![..5]));
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![1.0 / 6.0, -1.0, 1.0 / 2.0, 1.0 / 3.0].dot(&v.slice(s![-4..]));
	    dv[n - 1] = array![-1.0 / 3.0, 3.0 / 2.0, -3.0, 11.0 / 6.0].dot(&v.slice(s![-4..]));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0]
	            .dot(&v.slice(s![i - 2..i + 3]));
	    }
e28fdb1bec613619cb76093dce265c00|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|1|V|rust
	        dv[i] = array![1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0]
	            .dot(&v.slice(s![i - 2..i + 3]));
ed428a4b0c15f572fb6d6db9c287d16d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|6|V|rust
	    // use central difference of all other points
dd1945cc0b0064af401e6d05ae3e050e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|6|V|rust
	    for i in 2..(n - 2) {
4b43512b4d281de74f009b8d293c30e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|6|V|rust
	        dv[i] = array![1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0]
516d7b089d68792c9d11895e5f70f211|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|6|V|rust
	            .dot(&v.slice(s![i - 2..i + 3]));
eb5cef571f7e02b4e48b64f061b3d581|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|165|15|v|rust
	array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0]
399ce8ccd864726379bdb4de66474c7c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|1|V|rust
	    dv.slice_mut(s![0, ..5])
	        .assign(array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0]);
59080ebda9a413dbc663964e1f5ee2cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|166|15|v|rust
	array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0]
3a2e79530c98bc2cab321f6be08bf34d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|1|V|rust
	    dv.slice_mut(s![0, ..5])
	        .assign(array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0]);
	    dv.slice_mut(s![1, ..5])
	        .assign(array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0]);
cf865ca04a8a042d3a12fd99cd7e67db|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|168|19|v|rust
	array![1.0 / 6.0, -1.0, 1.0 / 2.0, 1.0 / 3.0]
08e6defa8148c0f71364438e3c42f5b8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|19|v|rust
	array![-1.0 / 3.0, 3.0 / 2.0, -3.0, 11.0 / 6.0]
39962b1852e71f273ee9272de200a8b7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|185|1|V|rust
	    dv[[0, 0]] = -25.0 / 12.0;
	    dv[[0, 1]] = 4.0;
	    dv[[0, 2]] = -3.0;
	    dv[[0, 3]] = 4.0 / 3.0;
	    dv[[0, 4]] = -1.0 / 4.0;
	
	    dv[[1, 1]] = -25.0 / 12.0;
	    dv[[1, 2]] = 4.0;
	    dv[[1, 3]] = -3.0;
	    dv[[1, 4]] = 4.0 / 3.0;
	    dv[[1, 5]] = -1.0 / 4.0;
3786809abcfe3d11836fc05a178ad426|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|184|1|V|rust
	    dv[[n - 1, n - 1]] = 25.0 / 12.0;
	    dv[[n - 1, n - 2]] = -4.0;
	    dv[[n - 1, n - 3]] = 3.0;
	    dv[[n - 1, n - 4]] = -4.0 / 3.0;
	    dv[[n - 1, n - 5]] = 1.0 / 4.0;
	
	    dv[[n - 2, n - 2]] = 25.0 / 12.0;
	    dv[[n - 2, n - 3]] = -4.0;
	    dv[[n - 2, n - 4]] = 3.0;
	    dv[[n - 2, n - 5]] = -4.0 / 3.0;
	    dv[[n - 2, n - 6]] = 1.0 / 4.0;
6eb9f5aff1c435c235feadeb93d5654b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|171|15|v|rust
	array![1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0]
b8e58ae88c9fb31d779dfc77c575b874|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|165|1|V|rust
	    //dv[0] = array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0].dot(&v.slice(s![..5]));
	    //dv[0] = array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0].dot(&v.slice(s![..5]));
	
	    //dv[n - 2] = array![1.0 / 6.0, -1.0, 1.0 / 2.0, 1.0 / 3.0].dot(&v.slice(s![-4..]));
	    //dv[n - 1] = array![-1.0 / 3.0, 3.0 / 2.0, -3.0, 11.0 / 6.0].dot(&v.slice(s![-4..]));
	
	    //dv[i] = array![1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0]
	    //         .dot(&v.slice(s![i - 2..i + 3]));
	    //
6b49df90fcf6229fcd47fcd266ae1fef|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|197|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = array![
	        35.0 / 12.0,
	        -26.0 / 3.0,
	        19.0 / 2.0,
	        -14.0 / 3.0,
	        11.0 / 12.0
	    ]
	    .dot(&v.slice(s![..6]));
	    dv[1] =
	        array![11.0 / 12.0, -5.0 / 3.0, 1.0 / 2.0, 1.0 / 3.0, -1.0 / 12.0].dot(&v.slice(s![..6]));
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] =
	        array![-1.0 / 12.0, 1.0 / 3.0, 1.0 / 2.0, -5.0 / 3.0, 11.0 / 12.0].dot(&v.slice(s![-5..]));
	    dv[n - 1] = array![
	        11.0 / 12.0,
	        -14.0 / 3.0,
	        19.0 / 2.0,
	        -26.0 / 3.0,
	        35.0 / 12.0
	    ]
	    .dot(&v.slice(s![-5..]));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![-1.0 / 12.0, 4.0 / 3.0, -5.0 / 2.0, 4.0 / 3.0, -1.0 / 12.0]
	            .dot(&v.slice(s![i - 2..i + 3]));
	    }
7d814bfe291aa578cee0f55ea5e9cf53|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|244|5|V|rust
	    .dot(&v.slice(s![..6]));
5ac4e605480a4f22824786e260c14d99|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|244|10|V|rust
	    dv[1] =
0c82042f69064f25a88ff9f6af647e73|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|237|5|v|rust
	dv[0] = 
b9ea987d8145079c0c12c0fa9123e965|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|247|5|V|rust
	    dv[n - 2] =
9d949ff34fceb25d2a7e9374a1780ab9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|248|5|v|rust
	dv[n - 1] = 
f1570dcd77ee48a2feb2ea93c17e6c56|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|255|5|V|rust
	    .dot(&v.slice(s![-5..]));
f855f86d8d3c7349d2ae035ab52ecf82|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|256|9|v|rust
	dv[i] = a
ce642c31a6c5527db90671842be6a147|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|165|1|V|rust
	    dv.slice_mut(s![0, ..6])
	        .assign(array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0]);
	    dv.slice_mut(s![1, ..6])
	        .assign(array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0]);
	
	    dv.slice_mut(s![n - 2, -5..])
	        .assign(array![1.0 / 6.0, -1.0, 1.0 / 2.0, 1.0 / 3.0]);
	    dv.slice_mut(s![n - 1, -5..])
	        .assign(array![-1.0 / 3.0, 3.0 / 2.0, -3.0, 11.0 / 6.0]);
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3]).assign(array![
	            1.0 / 12.0,
	            -2.0 / 3.0,
	            0.0,
	            2.0 / 3.0,
	            -1.0 / 12.0
	        ]);
	    }
461a5e496658d138084ea7ca989fa8bd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|258|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[[0, 0]] = 15.0 / 4.0;
	    dv[[0, 1]] = -77.0 / 6.0;
	    dv[[0, 2]] = 107.0 / 6.0;
	    dv[[0, 3]] = -13.0;
	    dv[[0, 4]] = 61.0 / 12.0;
	    dv[[0, 6]] = -5.0 / 6.0;
	
	    dv[[1, 1]] = 15.0 / 4.0;
	    dv[[1, 2]] = -77.0 / 6.0;
	    dv[[1, 3]] = 107.0 / 6.0;
	    dv[[1, 3]] = -13.0;
	    dv[[1, 5]] = 61.0 / 12.0;
	    dv[[1, 6]] = -5.0 / 6.0;
	
	    dv[[n - 1, n - 1]] = -15.0 / 4.0;
	    dv[[n - 1, n - 2]] = 77.0 / 6.0;
	    dv[[n - 1, n - 3]] = -107.0 / 6.0;
	    dv[[n - 1, n - 4]] = 13.0;
	    dv[[n - 1, n - 5]] = -61.0 / 12.0;
	    dv[[n - 1, n - 6]] = 5.0 / 6.0;
	
	    dv[[n - 2, n - 2]] = -15.0 / 4.0;
	    dv[[n - 2, n - 3]] = 77.0 / 6.0;
	    dv[[n - 2, n - 5]] = -107.0 / 6.0;
	    dv[[n - 2, n - 6]] = 13.0;
	    dv[[n - 2, n - 7]] = -61.0 / 12.0;
	    dv[[n - 2, n - 8]] = 5.0 / 6.0;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[[i, i - 2]] = -1.0 / 12.0;
	        dv[[i, i - 1]] = 4.0 / 3.0;
	        dv[[i, i]] = -5.0 / 2.0;
	        dv[[i, i + 1]] = 4.0 / 3.0;
	        dv[[i, i + 2]] = -1.0 / 12.0;
	    }
b5e01b457034af3e2a39a5c0ef0d6e40|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|237|1|V|rust
	    array![
	        35.0 / 12.0,
	        -26.0 / 3.0,
	        19.0 / 2.0,
	        -14.0 / 3.0,
	        11.0 / 12.0
	    ];
290487a15f9c437c5e7fb4a2593e1b1e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|236|1|V|rust
	    // Use forward derivatives for first two entries
	    array![
	        35.0 / 12.0,
	        -26.0 / 3.0,
	        19.0 / 2.0,
	        -14.0 / 3.0,
	        11.0 / 12.0
	    ];
8de7dbc7b0155fa9b947123ae74a7ac6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|236|1|V|rust
	    array![11.0 / 12.0, -5.0 / 3.0, 1.0 / 2.0, 1.0 / 3.0, -1.0 / 12.0];
956782fc2202399ff05513917e3de818|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|239|1|V|rust
	    array![-1.0 / 12.0, 1.0 / 3.0, 1.0 / 2.0, -5.0 / 3.0, 11.0 / 12.0];
705420f31fe4713fb38bd5468fe28242|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|239|5|v|rust
	array![
	        11.0 / 12.0,
	        -14.0 / 3.0,
	        19.0 / 2.0,
	        -26.0 / 3.0,
	        35.0 / 12.0
	    ];
bc6796b3b6a20f7a3adfdf9a66ee054e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|241|1|V|rust
	    array![-1.0 / 12.0, 4.0 / 3.0, -5.0 / 2.0, 4.0 / 3.0, -1.0 / 12.0];
64a2608ac5a4dcb7eb1f4577da4f54e5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|273|1|v|rust
	array![
	            1.0 / 12.0,
	            -2.0 / 3.0,
	            0.0,
	            2.0 / 3.0,
	            -1.0 / 12.0
	        ]
90bb4829f67deaebefb638310ab60f1a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|9|v|rust
	deriv +
b415ba38efb2ecf22939ffe50430f2b4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|9|v|rust
	gam / (2.0 * x/* * ht */)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f)
2b44d2cb71b69725d1fcd37f21fa4034|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|25|v|rust
	gt * &qs / x * &df
b5178fdb64d8580f0f248a8cff9a8434|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|69|1|V|rust
	        let gam = p.gamma(x);
	        let xq = qs.mapv(|q| (x * x + q * q).sqrt());
	        let df = first_deriv_vec(f.view(), dq);
	        let d2f = second_deriv_vec(f.view(), dq);
ade811a67ab7685af1a57de976fa20a2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|65|17|v|rust
	scattering_matrix[[i, k]]
76cfe3a66d4c70e73d401563d422d6f3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|30|V|rust
	        let mut scattering_matrix = Array2::<f64>::zeros((n, n));
878e997e2d6471564786f137e2e3a029|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|72|12|V|rust
	        deriv.assign(&(pre * dq * scattering_matrix.dot(&wgts)));
4f4da9f3495758cf548039fb6ab5562a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|74|1|V|rust
	        deriv += &(gam / (2.0 * x/* * ht */)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f))
906ab934f8fc3fabfb7bbd731a1fbc72|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|75|1|V|rust
	        // Compute the elastic scattering term
	        deriv += &(gam / (2.0 * x/* * ht */)
	            * (&xq * &d2f + (&qs + &(2.0 * &xq / &qs) + &qs / &xq) * &df + 3.0 * &f))
	            .slice(s![..-1]);
100d9553273d3dc213bf69a4299a59d2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|37|v|rust
	2.0 * &xq / &qs
8b226d5d637442b976d165a8f4506a28|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|74|29|V|rust
	            .slice(s![..-1]);
abfaa3f7554df406ea95928cde758861|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|61|1|V|rust
	            let qi = qs[i];
2e0866752720579a94eb22695f413f30|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|62|22|v|rust
	qs[i];
06106b5f98504b68f105223dd553deb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|1|V|rust
	        // Compute the other term (not sure what this is physically. Expansion?)
	        let gt = gefft(temp);
	        deriv += &(gt * &qs / x * &df).slice(s![..-1]);
e93dff01d55a51e110181a2a5f3082a3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|79|41|v|rust
	.slice(s![..-1]);v
1cbf9d938d9d8b899a6eb347ca8c0dbc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|62|1|V|rust
	            let deriv[i] = 0.0;
1d31dc437297969f2a0e7d3c4d7d0c37|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|69|1|V|rust
	                let qk = qs[k];
27c4186e9cf46f36e660f83cad3cfa63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|64|1|V|rust
	            let feqi = feq[i];
423f7151517fb2e787804004b1c08abc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|70|1|V|rust
	                let feqk = feq[k];
71c25b2f6d754a6cc4a0c15ead614e40|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|81|17|V|rust
	                // Compute the other term (not sure what this is physically. Expansion
b2f98b5fa432d5b317871e44e80308f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|74|9|v|rust
	_toy()
510dff23e338af06e33a44c80455d79f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|16|V|rust
	                dbg!(deriv[i]);
36101a67d34923fdbc16be759f8c529e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|84|1|V|rust
	                println!("deriv[i]", deriv[i]);
7a4bded4ab5fdcd7ef9c991a85395197|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|82|27|v|rust
	deriv[i]
2a58fa037d3fb547f23c959b9f401951|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|85|28|V|rust
	                println!("{}", deriv[i]);
7f4d591d72700a67b15118cfe776ebf7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|32|v|rust
	[i])
3c98df7f37c8fba6406484ff9e25992f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|80|35|V|rust
	                println!("{}", dfi);
c2b7b03e717c3413e7d2c27625fd05a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|75|35|V|rust
	            println!("{}", deriv[i]);
836fda1686bfbfb57937049d07d2e140|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|194|13|v|rust
	sum +=
aad22a92c0384121cc34e07b2b624e1c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|195|23|v|rust
	std::num::FpCategory
fd81383d28484d5726068715deb1a6e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|196|23|v|rust
	std::num::FpCategory 
9e57a69723c66e07fda393817ae45472|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|196|24|v|rust
	.category()
d4711583e9e417a5e88f79c493e3daca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|212|13|v|rust
	 / 12.0
c7403542e1d7e42ea91b0d81d90ced16|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|9|v|rust
	-26.0 / 3.0,
86d70ee3706219e3dd9ddfbcf927283d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|214|9|v|rust
	19.0 / 2.0,
1754a23ff1a8ddadb502c68e83eba06d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|215|9|v|rust
	-14.0 / 3.0,
15f3f48b9b20560e3e8f58a4a7c7d618|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|14|v|rust
	/ 12.0
67c502308a48727d7c52a90963d6df51|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|208|1|V|rust
	((((35.0 * g[0] - 104.0 * g[1]) + 114.0 * g[2]) - 56.0 * g[3]) +
	             11.0 * g[4]) / 12.0 / c_tmp;
40f3e1e306a512be2664ec5f9984337d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|221|14|v|rust
	/ 12.0, 
54cde6d16a039252c1162de6cf4ea807|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|222|9|v|rust
	-5.0 / 3.0, 
cc8d60e24c5a519098ad90b9254b05b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|223|9|v|rust
	1.0 / 2.0, 
720e0a1a259a19ec3a8cbfea4711b174|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|224|9|v|rust
	1.0 / 3.0, 
0e132e3b7f6aa1a5dbb05f2a8b772ba4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|225|9|v|rust
	-1.0 / 12.0
57b52ac5229d0a7f3394ad4d267f3a87|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|217|43|V|rust
	    ((((11.0 * g[0] - 20.0 * g[1]) + 6.0 * g[2]) + 4.0 * g[3]) - g[4]) /
	    12.0 / c_tmp;
b97bc8ce43b1ee8c3430af9644ef9281|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|215|9|v|rust
	-1.0 / 12.0, 
3758cd1a7e3772d75c172eaf5ee65ff8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|8|v|rust
	 1.0 / 3.0, 
85db31bbc78e5cfc4d0b59881570dbf0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|219|9|v|rust
	11.0 / 12.0
3204d858574637affc460b2bb7b94f56|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|214|8|V|rust
	              g[100]) / 12.0 / c_tmp;
cf47497ca2783b20430178a2e1642661|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|213|8|V|rust
	    //b_d2[99] = ((((-g[96] + 4.0 * g[97]) + 6.0 * g[98]) - 20.0 * g[99]) + 11.0 *
7ac4581d10c9e9dff5c9506933c09886|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|225|9|v|rust
	11.0 / 12.0,
f7d5646dfa5041befc73146243e13605|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|229|9|v|rust
	35.0 / 12.0
8323f1e9eeb7b8ce9b8cf37d0aef4de5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|214|19|V|rust
	  b_d2[100] = ((((11.0 * g[96] - 56.0 * g[97]) + 114.0 * g[98]) - 104.0 * g[99])
c5006814bef362ce6349f1d47f84c129|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|214|19|V|rust
	               + 35.0 * g[100]) / 12.0 / c_tmp;
6bc0e6f5ba3df75b3ee22190a0e26354|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|223|17|v|rust
	 / 12.0, 
cc8ebdbedcc1824c470f7dffb884dcb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|227|17|v|rust
	 / 12.0]
b4ccf6ab874308fd76f21802161591ce|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|224|13|v|rust
	4.0 / 3.0, 
02aba3b07e1fe1e8b1767382471fd740|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|225|13|v|rust
	-5.0 / 2.0, 
6396ed1e0adb930beeff12d1a2f4da05|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|219|17|V|rust
	    //hb_d2[i + 2] = ((((-g[i] + 16.0 * g[i + 1]) - 30.0 * g[i + 2]) + 16.0 * g[i +
c8f270ef64a20e8bb6c3a95040facf3c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|219|17|V|rust
	                    3]) - g[i + 4]) / 12.0 / c_tmp;
58d41e39e73f0f66d3424668d015735c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|80|v|rust
	(12.0 * h2
ec1aaf9b1fa85cc21302d58312ac1b69|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|211|73|v|rust
	/ (12.0 * h2);
ff4bfb81271bbc857a2c7f70a602ba58|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|216|82|v|rust
	 / (12.0 * h2);
47965750c6e3b6c60713fb878c17edc7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|226|48|v|rust
	(12.0 * h2);
b1e42dabf82311b00727a89d1089d09c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|223|7|v|rust
	 / (h * h)
3eb08597665985f4ba87287f284fc297|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|26|v|rust
	/ 6.0
9c7d4c9ec47244cb5b0239745cbf5e2a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|37|v|rust
	 / 2.0
115569fa284744e119b209da52decd16|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|42|v|rust
	 / 3.0
1aee71d7fa0aa90a29ce22cc324f80cc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|156|41|v|rust
	 / 6.0
37f7c35d9d1e777a9edd56eba04ee50a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|148|22|V|rust
	    // this function requires the vector to be at least of length 6 or dv[1]
2ff0fce629ecb6c5870fb19c131b5a56|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|148|17|V|rust
	    // will fail.
edc0b35dbd0456335b68cd9acf454abe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|148|17|V|rust
	    assert!(n >= 6);
f05b6b6f41831e4d7c705041419780fc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|152|1|V|rust
	    dv[0] = array![-11.0, 18.0, -9.0, 2.0].dot(&v.slice(s![..4])) / den;
	    dv[1] = array![-2.0, -3.0, 6.0, -1.0].dot(&v.slice(s![..4])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![1.0, -6.0, 3.0, 2.0].dot(&v.slice(s![-4..])) / den;
	    dv[n - 1] = array![-2.0, 9.0, -18.0, 11.0].dot(&v.slice(s![-4..])) / den;
15ff47416e384b16ccc712bc97a238c2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|161|1|V|rust
	        dv[i] = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
51cf8f3f9fe3fc06df4cacce0949cfb5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|43|v|rust
	.dot(&v.slice(s![..4])) / den;
4cf81538f185e45f5491f66aa2e97392|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|178|44|v|rust
	.dot(&v.slice(s![-4..])) / den;
1bbcf78bfc7bf0ef84061a2f158fb1a2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|178|7|v|rust
	[n - 2]
4c95496b7bd2c82d2ba6e39dd94311c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|179|7|v|rust
	[n - 1]
85453d0b05b00339282468b54e696b50|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|178|8|v|rust
	row_mut
ce6dc970d1b031bbb65588a5401ecfff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|178|8|v|rust
	slice_mut(s![0,..4])
f1f625206280d0d3ff5252b7349e7f9f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|174|7|v|rust
	.row_mut(0)
cd564125d89e0606ad1f04e41972073c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|175|7|v|rust
	.row_mut(1)
3b5fb5043dcd8e2dae8057651eadf733|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|178|7|v|rust
	.slice_mut(s![n-2,-4..])
52b6af3a0a1e4f58d3efda377e7e428c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|179|7|v|rust
	.row_mut(n-1)
ace969aaad2984788d9e0c4fd420b50d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|179|7|v|rust
	.slice_mut(s![n-1,-4..])
c40987b5ba3eeb393b6e25d63994022e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|180|7|v|rust
	.row_mut(i)
f1aecc4944c9ce544ecd34a591b30406|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|180|1|V|rust
	    dv.slice_mut(s![i,1-2..1+3]) = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
bcd4f7d3df805ac2b1312ca908096e49|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|180|1|V|rust
	    dv.slice_mut(s![i,1-2..1+3]) = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
	
	    dv.slice_mut(s![0, ..4])
	        .assign(&array![-11.0 / 6.0, 3.0, -3.0 / 2.0, 1.0 / 3.0]);
	    dv.slice_mut(s![1, ..4])
	        .assign(&array![-1.0 / 3.0, -1.0 / 2.0, 1.0, -1.0 / 6.0]);
	
	    dv.slice_mut(s![n - 2, -4..])
	        .assign(&array![1.0 / 6.0, -1.0, 1.0 / 2.0, 1.0 / 3.0]);
	    dv.slice_mut(s![n - 1, -4..])
	        .assign(&array![-1.0 / 3.0, 3.0 / 2.0, -3.0, 11.0 / 6.0]);
af0feebee9c18ecac7c36e915f13fd23|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|183|73|v|rust
	.dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
5a1c2681dc994f5d317c520dba5db0f7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|184|1|V|rust
	        dv.slice_mut(s![i, i - 2..i + 3]).assign(&array![
	            1.0 / 12.0,
	            -2.0 / 3.0,
	            0.0,
	            2.0 / 3.0,
	            -1.0 / 12.0
	        ]);
954f256e1259c108fe6fee57c447a134|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|199|1|V|rust
	    assert!(n >= 7);
639e4eadbdd352b24bd2d0282cfad5a1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|197|1|V|rust
	    // this function requires the vector to be at least of length 7 or dv[1]
e167c1978cd00f61735a4dc688b3eadb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|198|1|V|rust
	    let mut dv = Array1::<f64>::zeros(n);
	    let den = 12.0 * h * h;
	    // Use forward derivatives for first two entries
	    dv[0] = array![35.0, -104.0, 114.0, -56.0, 11.0,].dot(&v.slice(s![..5])) / den;
	    dv[1] = array![11.0, -20.0, 6.0, 4.0, -1.0,].dot(&v.slice(s![..5])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![-1.0, 4.0, 6.0, -20.0, 11.0].dot(&v.slice(s![-5..])) / den;
	    dv[n - 1] = array![11.0, -56.0, 114.0, -104.0, 35.0,].dot(&v.slice(s![-5..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![-1.0, 16.0, -30.0, 16.0, -1.0,].dot(&v.slice(s![i - 2..i + 3])) / den;
	    }
435d6458b11e885bb5dba3dba91c4099|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|218|1|V|rust
	    // this function requires the vector to be at least of length 7 or dv[1]
	    // will fail.
	    assert!(n >= 7);
	    let mut dv = Array2::<f64>::zeros((n, n));
88c311a8749d2a8bc54fd5259d459937|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|233|7|v|rust
	.slice_mut(s![0, ..5]).assign(&
c3e7e3ce9c3c03125378b4945f7ebe95|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|221|10|v|rust
	.slice = 
4b888edc59fd7449a44a5a74728c9fac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|221|10|v|rust
	.slice_mut(s![0, ..5]).assign(&(
3c2d18593515e2f7ada9e76d136a1b84|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|233|1|V|rust
	    dv.slice_mut(s![0, ..5]).assign(&array![
	        35.0 / 12.0,
	        -26.0 / 3.0,
	        19.0 / 2.0,
	        -14.0 / 3.0,
	        11.0 / 12.0
	    ]);
	    dv.slice_mut(s![1, ..5]).assign(&array![
	        11.0 / 12.0,
	        -5.0 / 3.0,
	        1.0 / 2.0,
	        1.0 / 3.0,
	        -1.0 / 12.0
	    ]);
87a47ad58487380d74a0d44261bc26fc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|7|v|rust
	.slice_mut(s![n - 2, -5..]).assign(&
ad0a2de855f9bee517af4430abf01a6e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|225|7|v|rust
	[n - 2] = 
6e10621ebd04438a517a99747c7329c1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|225|78|v|rust
	.dot(&v.slice(s![-5..])) / den;
dde0c0709ca4b7ab600e75669c3b821f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|1|V|rust
	    dv.slice_mut(s![n - 2, -5..]).assign(&array![
	        -1.0 / 12.0,
	        1.0 / 3.0,
	        1.0 / 2.0,
	        -5.0 / 3.0,
	        11.0 / 12.0
	    ]);
c8843ab80b9964de20b898f13b775abd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|7|v|rust
	.slice_mut(s![n - 1, -5..]).assign(&
0f7998378e90bc787ae6ef1f29cd9085|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|226|7|v|rust
	[n - 1] = 
62d482f2d80d6d07fe61614f92e925f2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|234|1|V|rust
	    dv.slice_mut(s![n - 1, -5..]).assign(&array![
	        11.0 / 12.0,
	        -14.0 / 3.0,
	        19.0 / 2.0,
	        -26.0 / 3.0,
	        35.0 / 12.0
	    ]);
3d733d17e317004af011b58eed88db0a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|237|11|v|rust
	.slice_mut(s![i, i - 2..i + 3]).assign(&
0b6c6905849338ef0f7ff2f0c5643d9a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|230|11|v|rust
	[i] = 
ba44e72eb2b3807e855c7eb28f94faa1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|230|89|v|rust
	.dot(&v.slice(s![i - 2..i + 3])) / den;
67559796ff5e166d71a5868085a75a65|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|232|1|V|rust
	
	
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3]).assign(&array![
	            -1.0 / 12.0,
	            4.0 / 3.0,
	            -5.0 / 2.0,
	            4.0 / 3.0,
	            -1.0 / 12.0
	        ]);
	    }
bc832e30b0197a4f240e0524763ba92d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|172|1|V|rust
	    // Use forward derivatives on first two entries
fa16e2c6242bc85f5b09579ea2710832|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|152|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = array![-11.0, 18.0, -9.0, 2.0].dot(&v.slice(s![..4])) / den;
	    dv[1] = array![-2.0, -3.0, 6.0, -1.0].dot(&v.slice(s![..4])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![1.0, -6.0, 3.0, 2.0].dot(&v.slice(s![-4..])) / den;
	    dv[n - 1] = array![-2.0, 9.0, -18.0, 11.0].dot(&v.slice(s![-4..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
46ef80bb8244e39b8de571c45d0fc3f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|146|1|V|rust
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn first_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    let mut dv = Array1::<f64>::zeros(n);
	    let den = 6.0 * h;
	
	    // Use forward derivatives for first two entries
	    dv[0] = array![-11.0, 18.0, -9.0, 2.0].dot(&v.slice(s![..4])) / den;
	    dv[1] = array![-2.0, -3.0, 6.0, -1.0].dot(&v.slice(s![..4])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![1.0, -6.0, 3.0, 2.0].dot(&v.slice(s![-4..])) / den;
	    dv[n - 1] = array![-2.0, 9.0, -18.0, 11.0].dot(&v.slice(s![-4..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
	    }
	
	    dv
	}
	
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn jac_first_deriv_vec(n: usize, h: f64) -> Array2<f64> {
	    let mut dv = Array2::<f64>::zeros((n, n));
	    let den = 6.0 * h;
	
	    // Use forward derivatives for first two entries
	    dv.slice_mut(s![0, ..4])
	        .assign(&(array![-11.0, 18.0, -9.0, 2.0] / den));
	    dv.slice_mut(s![1, ..4])
	        .assign(&(array![-2.0, -3.0, 6.0, -1.0] / den));
	
	    // Use backwards derivatives for last two entries
	    dv.slice_mut(s![n - 2, -4..])
	        .assign(&(array![1.0, -6.0, 3.0, 2.0] / den));
	    dv.slice_mut(s![n - 1, -4..])
	        .assign(&(array![-2.0, 9.0, -18.0, 11.0] / den));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3])
	            .assign(&(array![1.0, -8.0, 0.0, 8.0, -1.0] / (2.0 * den)));
	    }
	
	    dv
	}
	
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn second_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	
	    let mut dv = Array1::<f64>::zeros(n);
	    let den = 12.0 * h * h;
	    // Use forward derivatives for first two entries
	    dv[0] = array![35.0, -104.0, 114.0, -56.0, 11.0,].dot(&v.slice(s![..5])) / den;
	    dv[1] = array![11.0, -20.0, 6.0, 4.0, -1.0,].dot(&v.slice(s![..5])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![-1.0, 4.0, 6.0, -20.0, 11.0].dot(&v.slice(s![-5..])) / den;
	    dv[n - 1] = array![11.0, -56.0, 114.0, -104.0, 35.0,].dot(&v.slice(s![-5..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![-1.0, 16.0, -30.0, 16.0, -1.0,].dot(&v.slice(s![i - 2..i + 3])) / den;
	    }
	
	    dv
	}
	
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn jac_second_deriv_vec(n: usize, h: f64) -> Array2<f64> {
	    let mut dv = Array2::<f64>::zeros((n, n));
	    let den = 12.0 * h * h;
	    // Use forward derivatives for first two entries
	    dv.slice_mut(s![0, ..5])
	        .assign(&(array![35.0, -104.0, 114.0, -56.0, 11.0,] / den));
	    dv.slice_mut(s![0, ..5])
	        .assign(&(array![11.0, -20.0, 6.0, 4.0, -1.0,] / den));
	
	    // Use backwards derivatives for last two entries
	    dv.slice_mut(s![n - 2, -5..])
	        .assign(&(array![-1.0, 4.0, 6.0, -20.0, 11.0] / den));
	    dv.slice_mut(s![n - 1, -5..])
	        .assign(&(array![11.0, -56.0, 114.0, -104.0, 35.0,] / den));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3])
	            .assign(&(array![-1.0, 16.0, -30.0, 16.0, -1.0,] / den));
	    }
	
	    dv
	}
7fe42154acbb23a3c2f88de59ac3b5bc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|2|14|v|rust
	ArrayView1;
3ddf0fdf2631a76c93226d48c03f2ca8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|15|13|v|rust
	array![-11.0, 18.0, -9.0, 2.0]
aad6909ce5a9984878eef08c84cccee2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|5|1|V|rust
	    static ref dv0: Array1<f64> = array![-11.0, 18.0, -9.0, 2.0];
d87768b2d87a400c260bea78c75e672c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|17|13|v|rust
	array![-2.0, -3.0, 6.0, -1.0]
6ca20f14e05c9a9fb4cb0e1c6c04f5de|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|7|1|V|rust
	    static ref dvnm2 : Array1<f64> = array![-2.0, -3.0, 6.0, -1.0];
ccdf53cbc0099b001b41e7a88a9b7733|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|23|17|v|rust
	array![-2.0, 9.0, -18.0, 11.0]
1ed1e200d8a35fc7de311e4d4c01c012|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|28|17|v|rust
	array![1.0, -8.0, 0.0, 8.0, -1.0]
bf2eca8445c6793e768e7542a8401d44|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|23|17|v|rust
	array![1.0, -6.0, 3.0, 2.0]
9bc303709e9fedb9f9505ad17e1c8eac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|5|35|v|rust
	array![-11.0, 18.0, -9.0, 2.0] / 6.0
f91852ca49730aa1f16f647b021d1411|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|4|62|V|rust
	const dvv: Array1<f64> = array![-11.0, 18.0, -9.0, 2.0] / 6.0;
abe701d1f3aa267d3a348d1d8e672c71|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|19|13|v|rust
	array![-11.0, 18.0, -9.0, 2.0].dot(&
8c555163576c3f6d99b64af1b000078e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|19|1|V|rust
	    dv[0] = v.slice(s![..4]).dot(&(*dv0)) / den;
6c390377869f31fd9b73e5ecbebfdbad|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|21|39|V|rust
	    dv[1] = array![-2.0, -3.0, 6.0, -1.0].dot(&v.slice(s![..4])) / den;
45b92f7bc6a7f0f98d59550f2565fa4d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|19|1|V|rust
	    dv[0] = v.slice(s![..4]).dot(&(*dv0)) / den;
	    dv[1] = v.slice(s![..4]).dot(&(*dv1)) / den;
b5cf954aebed7c3ea1bc483d0c1fd763|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|23|1|V|rust
	    dv[n - 2] = array![1.0, -6.0, 3.0, 2.0].dot(&v.slice(s![-4..])) / den;
	    dv[n - 1] = array![-2.0, 9.0, -18.0, 11.0].dot(&v.slice(s![-4..])) / den;
3242e63ec58d8ae5510bde13a342ece8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|23|1|V|rust
	    dv[n - 2] = v.slice(s![-4..]).dot(&(*dvnm2)) / den;
b0848a742051307f4976ed98f3ecb4c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|28|28|v|rust
	 -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
a03671513f2edd3ccae7be12e025818f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|24|1|V|rust
	    dv[n - 1] = v.slice(s![-4..]).dot(&(*dvnm1)) / den;
9dbffb82a97e2ea1b7578d4fdb29e6e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|28|1|V|rust
	        dv[i] = array![1.0,
f69fdffb82267fca1be8c6913635b318|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|28|12|v|rust
	n - 1
bb5a7b6ff67e5e224f8cf658e6d3667a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|28|46|v|rust
	dvnm1
c94b1ed4d833f5e9650b4bf4eff790bb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|5|1|V|rust
	    static ref dv0: Array1<f64> = array![-11.0, 18.0, -9.0, 2.0] / 6.0;
	    static ref dv1: Array1<f64> = array![-2.0, -3.0, 6.0, -1.0] / 6.0;
	    static ref dvnm2: Array1<f64> = array![1.0, -6.0, 3.0, 2.0] / 6.0;
	    static ref dvnm1: Array1<f64> = array![-2.0, 9.0, -18.0, 11.0] / 6.0;
	    static ref dvc: Array1<f64> = array![1.0, -8.0, 0.0, 8.0, -1.0] / 12.0;
a681c1c7afb720a91c58f58f7385d8c0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|10|1|V|rust
	    // Second derivative of f[0]
e550fc0c91eee83077013516d7732e3d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|12|1|V|rust
	    // Second derivative of f[1]
6bade3565a8a6881f184ec92dfececc8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|14|1|V|rust
	    // Second derivative of f[n-2]
c22cf8376b1893dcfcef0649fe1a7d87|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|5|8|v|rust
	Second
ed031b0314caae6855d026987b21548a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|5|1|V|rust
	    // First derivative of f[0]
92610d49cb14348a2a36a4825bd19ef0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|7|1|V|rust
	    // First derivative of f[1]
872d5d325e389dda89264c98c23d71ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|9|1|V|rust
	    // First derivative of f[n-2]
d67bb337cc9b72b09c5723412aa8e532|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|11|1|V|rust
	    // First derivative of f[n-1]
7fbd681f0bd905cc518e45336e9178ab|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|82|13|v|rust
	array![35.0, -104.0, 114.0, -56.0, 11.0,]
f0fc762123de926761cd3c24e66ecb88|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|85|13|v|rust
	array![11.0, -20.0, 6.0, 4.0, -1.0,]
0ca39f38a05279539ebb7fd24b950f38|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|88|17|v|rust
	array![-1.0, 4.0, 6.0, -20.0, 11.0]
2e775ae6e121fa8e9e5586138011d203|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|89|17|v|rust
	array![11.0, -56.0, 114.0, -104.0, 35.0,]
2cc587c9128f9d0250f67cb5f16bb87d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|93|17|v|rust
	array![-1.0, 16.0, -30.0, 16.0, -1.0,]
01e8f7647deddc8fd20a2a97cf47992b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|35|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = v.slice(s![..4]).dot(&(*dv0)) / den;
	    dv[1] = v.slice(s![..4]).dot(&(*dv1)) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = v.slice(s![-4..]).dot(&(*dvnm2)) / den;
	    dv[n - 1] = v.slice(s![-4..]).dot(&(*dvnm1)) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = v.slice(s![i - 2..i + 3]).dot(&(*dvc)) / den;
	    }
67802c69ea0b0edf3058a15d2dfb8932|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|83|1|V|rust
	    // Use forward derivatives for first two entries
	    dv[0] = array![35.0, -104.0, 114.0, -56.0, 11.0,].dot(&v.slice(s![..5])) / den;
	    dv[1] = array![11.0, -20.0, 6.0, 4.0, -1.0,].dot(&v.slice(s![..5])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![-1.0, 4.0, 6.0, -20.0, 11.0].dot(&v.slice(s![-5..])) / den;
	    dv[n - 1] = array![11.0, -56.0, 114.0, -104.0, 35.0,].dot(&v.slice(s![-5..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![-1.0, 16.0, -30.0, 16.0, -1.0,].dot(&v.slice(s![i - 2..i + 3])) / den;
	    }
2958ac6aa988ea9205577ca1273b8c84|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|82|15|v|rust
	12.0 * 
a98cb455212164b8a5aea5ed7c06df63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|33|15|V|rust
	    let den = 6.0 * h;
c4f1de88e66016ee6255c2f2cd2aba37|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|6|29|v|rust
	array!
8a1ccae9dd87abbe99bf4ac7999f4f63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|66|32|v|rust
	(2.0 * 
5090fc52c9b869eea5daa5ee2ceb0778|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|4|26|V|rust
	const dvv : Array1<f64> = 
	
	lazy_static! {
	    static ref dv0: Array1<f64> = array![-11.0, 18.0, -9.0, 2.0] / 6.0;
	    static ref dv1: Array1<f64> = array![-2.0, -3.0, 6.0, -1.0] / 6.0;
	    static ref dvnm2: Array1<f64> = array![1.0, -6.0, 3.0, 2.0];
	    static ref dvnm1: Array1<f64> = array![-2.0, 9.0, -18.0, 11.0];
	    static ref dvc: Array1<f64> = array![1.0, -8.0, 0.0, 8.0, -1.0];
	}
b1194dc0e7fd1207292ed45cc9b07fed|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|15|36|v|rust
	* hubblet(temp)
91f5e4ba0806c2900089547b00c3e623|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|1|25|v|rust
	hubblet
6235d23d4e9de1191a44cb3eccc8dac3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|70|13|v|rust
	/ (48.0 * (std::f64::consts::PI * self.ml).powi(3) * 2.0 * self.ml / x)
8ece9bc17f566c2a837c65378d59d64f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|70|19|v|rust
	/ (48.0 * (std::f64::consts::PI * self.ml).powi(3) * 2.0 * self.ml / x) / crate::
c673646fe6635c19de3df7d8a6edfe45|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|39|56|v|rust
	* self.g()
b2004a6ea1220ec022bd61b317db39ea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|176|9|v|rust
	self.gk_gamma.integrate(f, 0.0, f64::INFINITY).val
3dbd01b36ea972ab54c6276206b603d9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|177|12|v|rust
	crate::full_boltz::hubblet(self.ms / x)
ced3e9cc7220f5cb16f0aeecc8c174f3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|39|54|V|rust
	        let pre = 1.0 / (48.0 * (self.ms * PI).powi(3)) / 8.0;
e6df4dcba9e7a1256375d75da728a85d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|3|9|V|rust
	use std::f64::consts::PI;
3ac340832f29c11538fbe2d6f75e8bcc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|31|8|v|rust
	update
427c976a57db4267647982865976256e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|31|18|v|rust
	_dudt
854ae625d022824e9715c2ad7ded526f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|65|1|V|rust
	            let qi = qs[i];
	            let fi = f[i];
	            let feqi = feq[i];
	
	            deriv[i] = 0.0;
	            // Integrate the scattering matrix using trapizoid rule
	            for k in 0..n {
	                let qk = qs[k];
	                let feqk = feq[k];
	                let fk = f[k];
	                deriv[i] += wgts[k] * qk * qk * p.sigmav(x, qi, qk) * (feqi * feqk - fi * fk);
	            }
	            deriv[i] *= pre * dq;
	            // We skip these terms at the end since df/dx(qf) = 0.0;
	            if i != n - 1 {
	                // Compute the elastic scattering term
	                let xq = (x * x + qi * qi).sqrt();
	                let dfi = df[i];
	                deriv[i] += gam / (2.0 * x)
	                    * (xq * d2f[i] + (qi + 2.0 * xq / qi + qi / xq) * dfi + 3.0 * fi);
	                // Compute the expansion term
	                deriv[i] += gt * qi / x * dfi;
	            }
bc7ccfc5f903635c903a850d76f75c3b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|34|16|v|rust
	feq[i];
3f73edc8465eb2a4e2465d56b860a68e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|34|5|V|rust
	    let feqi = p.feq(
8cd67a3e6e57f464cc90b60ce5be099a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|34|16|v|rust
	p.feq(
8342aebf88462d7f2bc6d0c072e82649|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|36|5|v|rust
	deriv[i] = 0.0;
d1d054ac5ed1c4d61b498b0c4890f2a2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|1|V|rust
	                jac[[i, j]] = 0.0;
	                // Integrate the jacobian of the scattering matrix using
	                // trapizoid rule
	                for k in 0..n {
	                    jac[[i, j]] += -qs[k].powi(2)
	                        * p.sigmav(x, qs[i], qs[k])
	                        * wgts[k]
	                        * pre
	                        * dq
	                        * if i == j && i == k {
	                            f[k] + f[i]
	                        } else if i == j {
	                            f[k]
	                        } else if i == k {
	                            f[i]
	                        } else {
	                            0.0
	                        }
	                }
	                if i != n - 1 {
	                    let xq = (x * x + qi * qi).sqrt();
	                    jac[[i, j]] += gam / (2.0 * x)
	                        * (xq * j_d2f[[i, j]]
	                            + (qi + 2.0 * xq / qi + qi / xq) * j_df[[i, j]]
	                            + 3.0 * if i == j { 1.0 } else { 0.0 });
	                    jac += gt * qi / x * j_df[[i, j]];
	                }
	            }
d292b06a46756cc22afa5ac6581b6059|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|1|V|rust
	                jac[[i, j]] = 0.0;
	                // Integrate the jacobian of the scattering matrix using
	                // trapizoid rule
	                for k in 0..n {
	                    jac[[i, j]] += -qs[k].powi(2)
	                        * p.sigmav(x, qs[i], qs[k])
	                        * wgts[k]
	                        * pre
	                        * dq
	                        * if i == j && i == k {
	                            f[k] + f[i]
	                        } else if i == j {
	                            f[k]
	                        } else if i == k {
	                            f[i]
	                        } else {
	                            0.0
	                        }
	                }
	                if i != n - 1 {
	                    let xq = (x * x + qi * qi).sqrt();
	                    jac[[i, j]] += gam / (2.0 * x)
	                        * (xq * j_d2f[[i, j]]
	                            + (qi + 2.0 * xq / qi + qi / xq) * j_df[[i, j]]
	                            + 3.0 * if i == j { 1.0 } else { 0.0 });
	                    jac += gt * qi / x * j_df[[i, j]];
	                }
b3fdef053263b3972c0e82322d9f021f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|73|8|v|rust
	[[i, j]] = 0.0;
07935debf7b35116237ee100e6a0fd47|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|32|1|V|rust
	    i: usize,
	    n: usize,
	    x: f64,
	    f: ArrayView1<f64>,
	    feq: ArrayView1<f64>,
	    qs: ArrayView1<f64>,
	    dq: f64,
	    dfi: f64,
	    d2fi: f64,
	    pre: f64,
	    gam: f64,
	    gt: f64,
	    p: T,
60675798341ed6afa491f448c234f880|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|32|1|V|rust
	    i: usize,
	    n: usize,
	    x: f64,
	    f: ArrayView1<f64>,
	    feq: ArrayView1<f64>,
	    qs: ArrayView1<f64>,
	    dq: f64,
	    dfi: f64,
	    d2fi: f64,
	    pre: f64,
	    gam: f64,
	    gt: f64,
	    p: &T,
abe08045e203d6ff78c2b02dd59e25c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|92|12|v|rust
	[[i, j]]
9c7a34d0f42e8993c5df4101282b7ce9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|113|34|v|rust
	[[i, j]];
2c6bb4d1bc712b6b237af491ce47b8f9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|78|5|V|rust
	    feq: ArrayView1<f64>,
877b67d45ab284a2c625f8034191097b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            deriv[i] = 0.0;
14f36e0bbd98cf518641bfad7d7c9708|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                let fk = f[k];
817fd2c631c610ae03529164373f775f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            let fi = f[i];
ca4c03b516f0127bc9ea46e8e3eb85b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            for k in 0..n {
efbff48e3b6958a82a3b5b13bddf87b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                // Compute the elastic scattering term
03e7d73746d38aa62a92caa4a5db0312|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                deriv[i] += gam / (2.0 * x)
49050fd46e005dc3825eb9f9666f6bb4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            deriv[i] *= pre * dq;
dc2fd99920786affa1bc8eb5830d9262|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                    * (xq * d2f[i] + (qi + 2.0 * xq / qi + qi / xq) * dfi + 3.0 * fi);
3c6ea154ebfa0ece80bb7b0bb28829cd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            // We skip these terms at the end since df/dx(qf) = 0.0;
2abb17344a8acac735d560f740157f3a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                deriv[i] += wgts[k] * qk * qk * p.sigmav(x, qi, qk) * (feqi * feqk - fi * fk);
79943058538b3c46fe9d6ebdca739eb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                // Compute the expansion term
b7225328bea37de9c131b1daae99998e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            // Integrate the scattering matrix using trapizoid rule
c1c197693746af5d33244139d80cdacc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	            if i != n - 1 {
b3d9efa3663d992caa738b6b7e15bfe6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                let dfi = df[i];
964c6b2eface21b51a0a7a3f05ec8641|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|150|1|V|rust
	                deriv[i] += gt * qi / x * dfi;
661bfbd83eadf1cce9956e1f57a6d0ba|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|72|1|V|rust
	pub fn compute_j_dfi<T: FullBoltzmann>(
	    i: usize,
	    j: usize,
	    n: usize,
	    x: f64,
	    f: ArrayView1<f64>,
	    qs: ArrayView1<f64>,
	    dq: f64,
	    j_df: f64,
	    j_d2f: f64,
	    pre: f64,
	    gam: f64,
	    gt: f64,
	    p: &T,
ee0226a9094d001beae7f731d0f6b72d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|205|1|v|rust
	pub fn 
341c762fd2baae5b08560c33ce4881eb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|205|27|v|rust
	<T: FullBoltzmann>(
8d44c1676bc070d1ff69b9aacb822123|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|206|6|v|rust
	: usize,
dc3ce08c4e007ba2622c59bbf6d07e98|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|209|6|v|rust
	: f64,
68cc514c184abc7f17e06bba8beb88e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|210|6|v|rust
	: ArrayView1<f64>,
4d0faa1dbb574ff78270a81eda2d7f98|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|218|6|v|rust
	: &T,
ad8fe3edf73ee88eea79d257a300e2e5|term://.//2146%3A/bin/zsh|5|1|V|floaterm
	  [60] SSL peer certificate or SSH remote key was not OK (Cert verify failed: BADCERT_NOT_TRUSTED)
7158a9c59cb3c19289e05768aaa298cd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|149|23|v|rust
	_mut
d238893de76fe44f71c37540c7aa8724|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|149|18|v|rust
	_iter();
8039b601488899c06826f5860c43262f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|139|23|v|rust
	<usize>::range(0, n, 1);
dabce53df3dfd9b42bb2947472c7b334|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|139|23|v|rust
	<usize>::
befd123f1beb9a5383d94bf44118ac63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|155|9|V|rust
	        deriv.par_map_inplace();
00ebecf1e235eb12a00885c765296b08|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|153|37|v|rust
	par_map_inplace(
9ad2f1e5891971947dfdb2dcb3e15288|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|160|24|v|rust
	compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                feq.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	
acd73eb2fadd0edabad9f712280170a8|untitled:5|1|1|V|
	`T` cannot be shared between threads safely
4c08fc37f1409dbe4f135ba55be4ba62|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|13|v|rust
	:Array1<usize>
0135ab609546361d1ee8e0a685f9f859|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|22|v|rust
	::<usize>
df9742d14fddc55ddf811a31fef6411b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|40|v|rust
	.collect()
dda1d5ae5b32d8e6a80680ebf741b700|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|171|1|V|rust
	        for i in 0..n {
	            deriv[i] = compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                feq.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	        }
b0d1b75ef0c05d4848061299763f6384|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|153|1|V|rust
	        Zip::from(deriv).and(&iarr).par_apply(|d, &i| {
	            *d = compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                feq.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	        });
8920e63d4f2037cfa06f0020f005650c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|76|1|V|rust
	    let now = Instant::now();
b8a222c2684af8e44db3ea0c645b2be6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|154|1|V|rust
	            *d = compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                feq.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
b50dfe13cebb3d4611ad20e9620e23b4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|171|13|v|rust
	*d = 
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
b3950ddd005a972fab9b856029239638|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//            
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
b3950ddd005a972fab9b856029239638|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//            
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
fe722df4735615c4ec346883455ce58a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|9|v|rust
	//                
20ee444fe391d594b8d6c0d6201cefea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|140|1|V|rust
	    let iarr = Array1::from_iter((0..n).map(|i: usize| i));
eadc365d61370bd0813c20f218c6f8bc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|5|V|rust
	    let ijarr = Array2::from_iter((0..n).zip(0..n).map(|i: usize, j:usize| i));
d2298875cb82f214ab3398f6025e213c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|25|v|rust
	from_iter((0..n).map(|i: usize| i));
0036ab356a54d2f8b1fd6419fa7ebaee|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|142|5|V|rust
	    for i in 0..n{
7cfad6f9ed093438d5e715cfc4566fe5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|142|9|V|rust
	        for j in 0..n{
7f02a01e8d7223bbb7592f9d937bbf87|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|142|13|V|rust
	            ijarr[[i,j]] =  
1a0b73b273e014fa9dda754d6d9f772d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|141|1|V|rust
	    let mut ijarr = Array2::<(usize, usize)>::zeros((n,n));
d98a07f84921b24ee30f86fd8cd85c3c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|208|14|v|rust
	from
a94950f723b0b422a11f1ec09169dcdc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|208|26|v|rust
	.and(&iarr)
27771bee10310496656018bc4f76fe8d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|214|17|V|rust
	                feq.view(),
dd5163722f0645eb275306a9dbd2b489|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|227|31|v|rust
	compute_j_dfi(
	                    i,
	                    j,
	                    n,
	                    x,
	                    f.view(),
	                    qs.view(),
	                    dq,
	                    j_df[[i, j]],
	                    j_d2f[[i, j]],
	                    pre,
	                    gam,
	                    gt,
	                    p,
	                );
	
a7d2377aeedd7d0eea33896c54ea2174|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|209|18|v|rust
	compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	
ba7a919d2ea68dc3e3943c792258d853|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|207|26|v|rust
	.and(jac)
53d3da00112aa3cf1bd243f678de4cd1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|169|1|V|rust
	        // Construct scattering matrix:
	        //        for i in 0..n {
	        //            let qi = qs[i];
	        //            let fi = f[i];
	        //            let feqi = feq[i];
	        //
	        //            deriv[i] = 0.0;
	        //            // Integrate the scattering matrix using trapizoid rule
	        //            for k in 0..n {
	        //                let qk = qs[k];
	        //                let feqk = feq[k];
	        //                let fk = f[k];
	        //                deriv[i] += wgts[k] * qk * qk * p.sigmav(x, qi, qk) * (feqi * feqk - fi * fk);
	        //            }
	        //            deriv[i] *= pre * dq;
	        //            // We skip these terms at the end since df/dx(qf) = 0.0;
	        //            if i != n - 1 {
	        //                // Compute the elastic scattering term
	        //                let xq = (x * x + qi * qi).sqrt();
	        //                let dfi = df[i];
	        //                deriv[i] += gam / (2.0 * x)
	        //                    * (xq * d2f[i] + (qi + 2.0 * xq / qi + qi / xq) * dfi + 3.0 * fi);
	        //                // Compute the expansion term
	        //                deriv[i] += gt * qi / x * dfi;
	        //            }
	        //        }
14caf88ef105777665e200cacadb83e9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|196|1|V|rust
	        //        for i in 0..n {
	        //            for j in 0..n {
	        //                jac[[i, j]] = compute_j_dfi(
	        //                    i,
	        //                    j,
	        //                    n,
	        //                    x,
	        //                    f.view(),
	        //                    qs.view(),
	        //                    dq,
	        //                    j_df[[i, j]],
	        //                    j_d2f[[i, j]],
	        //                    pre,
	        //                    gam,
	        //                    gt,
	        //                    p,
	        //                );
	        //            }
	        //        }
	
	        //        for i in 0..n {
	        //            let qi = qs[i];
	        //            for j in 0..n {
	        //                jac[[i, j]] = 0.0;
	        //                // Integrate the jacobian of the scattering matrix using
	        //                // trapizoid rule
	        //                for k in 0..n {
	        //                    jac[[i, j]] += -qs[k].powi(2)
	        //                        * p.sigmav(x, qs[i], qs[k])
	        //                        * wgts[k]
	        //                        * pre
	        //                        * dq
	        //                        * if i == j && i == k {
	        //                            f[k] + f[i]
	        //                        } else if i == j {
	        //                            f[k]
	        //                        } else if i == k {
	        //                            f[i]
	        //                        } else {
	        //                            0.0
	        //                        }
	        //                }
	        //                if i != n - 1 {
	        //                    let xq = (x * x + qi * qi).sqrt();
	        //                    jac[[i, j]] += gam / (2.0 * x)
	        //                        * (xq * j_d2f[[i, j]]
	        //                            + (qi + 2.0 * xq / qi + qi / xq) * j_df[[i, j]]
	        //                            + 3.0 * if i == j { 1.0 } else { 0.0 });
	        //                    jac += gt * qi / x * j_df[[i, j]];
	        //                }
	        //            }
	        //        }
c6d5545251b6c458210d9d210ac6303d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|151|1|V|rust
	        // Construct the derivative in parallel
f5693b66cae823cb61065f13c4cc3ff2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|49|1|V|rust
	    let qi = qs[i];
	    let fi = f[i];
	    let feqi = feq[i];
	
	    let mut deriv = 0.0;
	    // Integrate the scattering matrix using trapizoid rule
	    for k in 0..n {
	        let qk = qs[k];
	        let feqk = feq[k];
	        let fk = f[k];
	        let wgt = if k == 0 || k == n - 1 { 0.5 } else { 1.0 };
	        deriv += wgt * qk * qk * p.sigmav(x, qi, qk) * (feqi * feqk - fi * fk);
	    }
	    deriv *= pre * dq;
	    // We skip these terms at the end since df/dx(qf) = 0.0;
	    if i != n - 1 {
	        // Compute the elastic scattering term
	        let xq = (x * x + qi * qi).sqrt();
	        let dfi = dfi;
	        deriv += gam / (2.0 * x) * (xq * d2fi + (qi + 2.0 * xq / qi + qi / xq) * dfi + 3.0 * fi);
	        // Compute the expansion term
	        deriv += gt * qi / x * dfi;
	    }
	    deriv
44778f7c02054f5a6bd340bcd6dc2a7f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|166|13|v|rust
	deriv 
89d2a1280e2abe456488ef9f74873987|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|1|V|rust
	            deriv
8bf67b8edc5f8d16e3e9b45f0354ad45|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|91|1|V|rust
	    let qi = qs[i];
	    // Integrate the jacobian of the scattering matrix using
	    // trapizoid rule
	    for k in 0..n {
	        jac += -qs[k].powi(2)
	            * p.sigmav(x, qi, qs[k])
	            * if k == 0 || k == n - 1 { 0.5 } else { 1.0 }
	            * pre
	            * dq
	            * if i == j && i == k {
	                f[k] + f[i]
	            } else if i == j {
	                f[k]
	            } else if i == k {
	                f[i]
	            } else {
	                0.0
	            }
	    }
	    if i != n - 1 {
	        let xq = (x * x + qi * qi).sqrt();
	        jac += gam / (2.0 * x)
	            * (xq * j_d2f
	                + (qi + 2.0 * xq / qi + qi / xq) * j_df
	                + 3.0 * if i == j { 1.0 } else { 0.0 });
	        jac += gt * qi / x * j_df;
	    }
	    jac
85f7bf6869c66c92d772fd24df081b45|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|189|1|V|rust
	            *d = compute_j_dfi(
	                i,
	                j,
	                n,
	                x,
	                f.view(),
	                qs.view(),
	                dq,
	                j_df[[i, j]],
	                j_d2f[[i, j]],
	                pre,
	                gam,
	                gt,
	                p,
	            );
5bc965bfb6ad5137d15a109144f12cbf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|193|17|v|rust
	jac 
ac13d628a990283057edf55980c87a05|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|1|V|rust
	            jac
15bdd0d69a7ff62fe48d0ad599666d03|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|9|28|V|rust
	use std::iter::FromIterator;
2c5517db7bc397f9b14ae357a7ce54ff|file:///Users/loganmorrison/.zshrc|78|12|v|zsh
	clang
0c6319ed01e5139c92b171c11069e592|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|21|v|rust
	pow(mx1,2);
673212c9daeb17272c88090e77316255|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|6|v|rust
	pow(CE,2)
b83251d332c5b28463c6b8d83a7d652b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|6|v|rust
	self.ce*self.ce
cb7d13b30ca3e72c7cf2e316f98edcab|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|24|v|rust
	pow(CM,2)
8e17f1e485cf9261ef0e4ace9138aac2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|6|v|rust
	self.ce*self.ce + self.cm*self.cm
dccae2d38247ed6ac96e6f96c312583d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|2|v|rust
	pow(,2)
bfcaa4220ec396b556cdf18d2408644b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|25|v|rust
	pow(mx2,2)
3245c4c55741bcc0316898cf9aafc9c6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp2 
33f7846cc41f50aa4f66bc6a12dc1470|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp3 
c49fbcb7cf3458f52840734fff956303|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp7 
dce28d3e5320c9d8e9f03f8f0b80f4d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp4 
7b57246805b9819a4d82d28def1221b8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp9 
e80f86650df7b66ef5420ccb896c959e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp14 
717d1f9fd8c10613045f89fe13af132a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp16 
4c325d6446ff4ae0a2b1b9b215e9b20b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp8 
64177be7a3440ac07c4c7508fe7fc415|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp18 
5d481a6f416a42a9f5c56ec5ef3ad118|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp11 
794823373f50ad4c21ba95f4452a5217|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp22 
d9f3d535dee238004ba4aae97c2d49ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp20 
a203bd19f42706fc24abe7809e7a60f6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp12 
2f79a520ca127b2ef6c2bad947f6f4e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp15 
e7d29daaa41b44fd83b6ff51694358af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp6 
9dc4cd5d770c432d6ed4bb35aa19478a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp10 
b5a6cae9ac1ccd076d1654d91505bac6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp19 
f6484ed805b671caa41f8c0227918f6e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp21 
d75c38bac74c5bbc72100e18ba4b627c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp5 
ad3667c5a00833266ad0b0c838b9f9ca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp17 
a60aa38a56367c3ff0e91eebb56efa55|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|31|2|v|rust
	temp13 
6ee9de5bcb322333aee96a197d0de1fd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|10|1|V|rust
	double temp1 = pow(self.mh,2);
		let temp2 = self.mh.powi(4);
		let temp3 = pow(\[CapitalGamma]2,2);
		let temp4 = pow(self.mh,6);
		let temp5 = pow(\[CapitalGamma]2,4);
		let temp6 = pow(self.mh,8);
		let temp7 = pow(\[CapitalGamma]2,6);
		let temp8 = pow(\[CapitalGamma]2,8);
		let temp9 = pow(self.ml,22);
		let temp10 = pow(self.ml,20);
		let temp11 = pow(self.ml,18);
		let temp12 = pow(self.ml,14);
		let temp13 = pow(self.ml,16);
		let temp14 = pow(self.ml,10);
		let temp15 = pow(self.ml,12);
		let temp16 = pow(self.ml,2);
		let temp17 = pow(self.mh,14);
		let temp18 = pow(self.ml,8);
		let temp19 = pow(self.ml,4);
		let temp20 = pow(self.mh,12);
		let temp21 = pow(self.ml,6);
		let temp22 = pow(self.mh,10);
		return (-32.45754950482635*pow(pow(self.ce,2) + \
	pow(self.cm,2),2)*self.ml*(1.*pow(self.ml,24) + \
	temp10*(-12.0007615469535*temp2 - 1.1905852503515555*temp1*temp3) + \
	temp11*(7.641319605581533*temp2*temp3 + 19.898762060179028*temp4) + \
	temp12*temp4(1.7897498038935273*temp2 + \
	4.1684254808759515*temp1*temp3 + 1.9462334860250163*temp5) + \
	temp13*(-11.414855233918326*temp3*temp4 - \
	1.6010970105120443*temp2*temp5 - 12.467396623471172*temp6) + \
	temp14*temp6*(-0.1079523422726262*temp2*temp3 - \
	0.02977906093195527*temp4 - 0.08679177841900824*temp1*temp5 - \
	0.013647101669860403*temp7) + \
	temp15*temp4*(1.108026054078599*temp2*temp3 + \
	0.7806802190081772*temp4 + 0.3582558653595606*temp1*temp5 - \
	0.0009534152186711247*temp7) + \
	temp16*temp17*(-0.000558720685673454*temp3*temp4 - \
	0.0008365635231064942*temp2*temp5 - 0.00013993308898564458*temp6 - \
	0.0005566973451352051*temp1*temp7 - 0.00013892141871652016*temp8) + \
	pow(self.mh,16)*(3.1140372055450233e-6*temp3*temp4 + \
	4.671055808317535e-6*temp2*temp5 + 7.785093013862558e-7*temp6 + \
	3.1140372055450233e-6*temp1*temp7 + 7.785093013862558e-7*temp8) + \
	temp18*temp6*(-0.10574194826490885*temp3*temp4 - \
	0.06331559116795209*temp2*temp5 - 0.05108166970564063*temp6 - \
	0.008440231186479056*temp1*temp7 + 0.00021508142220481792*temp8) + \
	temp19*temp20*(0.005851265540037877*temp3*temp4 + \
	0.008526258728342704*temp2*temp5 + 0.0015032510976430392*temp6 + \
	0.005511725227143937*temp1*temp7 + 0.0013334809411960694*temp8) + \
	temp21*temp22*(0.026262184045166236*temp3*temp4 + \
	0.02999394258342669*temp2*temp5 + 0.008391818416742554*temp6 + \
	0.014754591095245462*temp1*temp7 + 0.0026310141402424497*temp8) + \
	1.0700709030468367*temp1*temp9))/(-4.361507001205805*temp1*temp10 + \
	temp11*(7.9867135173273205*temp2 + 0.8250088274827271*temp1*temp3) + \
	temp13*(-2.605539507631433*temp2*temp3 - 8.010001920767477*temp4) + \
	temp15*temp4*(-1.5029592840574617*temp2 - \
	2.205272718034752*temp1*temp3 - 0.372259997215811*temp5) + \
	temp12*(3.3991601364330726*temp3*temp4 + \
	0.0055692466598470484*temp2*temp5 + 4.726806698203919*temp6) + \
	temp14*temp4*(0.4698950789118628*temp2*temp3 + \
	0.10850491329292072*temp4 + 0.3644787337638716*temp1*temp5 - \
	0.015413912949517213*temp7) + \
	temp18*temp6*(0.11021942233524269*temp2*temp3 + \
	0.0436179490344449*temp4 + 0.06697928944503216*temp1*temp5 + \
	0.0003640673831980007*temp7) + \
	temp19*temp22*(-0.00318355951248573*temp3*temp4 - \
	0.003771674127639666*temp2*temp5 - 0.0009621589204664859*temp6 - \
	0.0018413053996880848*temp1*temp7 - 0.00029103186406766326*temp8) + \
	temp16*temp20*(-0.0007078316177068222*temp3*temp4 - \
	0.001026399576760126*temp2*temp5 - 0.00018284921272672343*temp6 - \
	0.0006607011513066793*temp1*temp7 - 0.00015928397952665195*temp8) + \
	temp21*temp6*(0.021045974149958735*temp3*temp4 + \
	0.012206710787485992*temp2*temp5 + 0.009961114540199573*temp6 + \
	0.0011085286282825908*temp1*temp7 - 0.00001332254944423919*temp8) + \
	temp17*(0.000036087060530203105*temp3*temp4 + \
	0.000054130590795304665*temp2*temp5 + 9.021765132550776e-6*temp6 + \
	0.000036087060530203105*temp1*temp7 + 9.021765132550776e-6*temp8) + \
	1.*temp9);*
b99c8c0cb660529cfa4c15126f967b8c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|10|1|V|rust
	    #[allow(dead_code)]
	    pub(super) fn c1(&self) -> f64{
	        0.0
	    }
2c46f4910f59ac93cb960ea2e0cb2c19|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|1|1|V|rust
	use super::DipoleDm;
	
	impl DipoleDm {
	    #[allow(dead_code)]
	    pub(super) fn c0(&self) -> f64 {
	        let temp1 = self.ml * self.ml;
	        let temp2 = self.ce * self.ce + self.cm * self.cm;
	        temp2 * temp2 * temp1 * (3.0 * self.mh * self.mh + 131. * temp1)
	    }
	    #[allow(dead_code)]
	    pub(super) fn c1(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c2(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c3(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c4(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c5(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c6(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        0.0
	    }
	}
3315996259e7d972c359491d23b5aee6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|11|1|V|rust
	    #[allow(dead_code)]
	    pub(super) fn c1(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c2(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c3(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c4(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c5(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c6(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        0.0
	    }
a5ade2723b97ba52bc4a57a4b7633e94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|1|1|V|rust
	pub mod coeff1;
5ef27a01b2c478063397d66d207ff03c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|1|1|V|rust
	use super::DipoleDm;
	
	impl DipoleDm {
	    #[allow(dead_code)]
	    pub(super) fn c0(&self) -> f64 {
	        let temp1 = self.ml * self.ml;
	        let temp2 = self.ce * self.ce + self.cm * self.cm;
	        temp2 * temp2 * temp1 * (3.0 * self.mh * self.mh + 131. * temp1)
	    }
	}
6c5f5ad983889cd6c0c684c7f235cdbb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|1|V|rust
	    #[allow(dead_code)]
	    pub(super) fn c0(&self) -> f64 {
	        let temp1 = self.ml * self.ml;
	        let temp2 = self.ce * self.ce + self.cm * self.cm;
	        temp2 * temp2 * temp1 * (3.0 * self.mh * self.mh + 131. * temp1)
	    }
	    #[allow(dead_code)]
	    pub(super) fn c1(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c2(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c3(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c4(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c5(&self) -> f64 {
	        0.0
	    }
	    #[allow(dead_code)]
	    pub(super) fn c6(&self) -> f64 {
	        0.0
	    }
e7cd2de0f571fe6d434bd39fbb1cbf89|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|6|1|V|rust
	        let temp1 = self.ml * self.ml;
	        let temp2 = self.ce * self.ce + self.cm * self.cm;
	        temp2 * temp2 * temp1 * (3.0 * self.mh * self.mh + 131. * temp1)
e05dfba6780a7823928676c81bd7685d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|28|33|v|rust
	self.ce.powi(2) + 
	self.cm.powi(2)
1bbe55d21e903a42d090bc5a506004cd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|29|55|v|rust
	pow(self.ml,24)
3da78e9c8a8e4d2b2660693dc42078d1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|45|1|v|rust
	pow(self.mh,16)
bd8a2337e2ccceebd4800002e610b807|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|145|1|V|rust
	        5
1ee13014735c19e0a54dc5cb6afe5444|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|28|1|V|rust
	        let temp23 = self.ce.powi(2) + self.cm.powi(2);
ad2e12eee45b0cb0e21c9a74b9dd3f82|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|30|33|v|rust
	pow(pow(self.ce,2) +
	pow(self.cm,2),2)
73545878d26c44336f743adb669ef7f9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|30|68|v|rust
	pow(self.ml,28)
740950a60aa794133a71fe97f0dd8d60|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|31|22|v|rust
	pow(self.ml,26)
b28c9ecfe21621f0744163d6988a8ff2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|49|1|v|rust
	pow(self.mh,18)
2f714181db7ac9f26ab766613ef4dbf3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff6.rs|30|29|v|rust
	pow(self.ml,30)
e746fa10f8709a47665e2f961ee4e6bd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|1|1|V|rust
	pub mod coeff0;
	pub mod coeff1;
	pub mod coeff2;
50a05ceb522b91efd3511acf01d49465|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|6|1|V|rust
	pub mod coeff5;
4cc2fe321486c73c81bb34b905d63b02|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|4|1|V|rust
	pub mod coeff3;
12891c3687395be7e726cc8d494bdc45|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|1|V|rust
	        let den = (3*Power(Lambda,4)*(Power(MDM2,4) + Power(MDM2,2)*(-2*Power(MDM1,2) + Power(\[CapitalGamma]2,2) - 4*MDM1*\[Omega]) + Power(Power(MDM1,2) + 2*MDM1*\[Omega],2)))/Power(\[Omega],8)
dd4fe0cc913f704600b97d1f5dd285de|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|12|v|rust
	Power
04a7da3c5b04cad85da1eebb92315b8b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|12|v|rust
	Lambda
73f7af55086313c80585d2d20b9154dc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|32|v|rust
	Power(MDM2,4)
71ff4a1b0d99bd3ffaf2ac04451d781c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|48|v|rust
	Power(MDM1,2)
f7372fd55d7db5289b6638b031bd512b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|60|v|rust
	MDM1
086fb501a509d1d96d132d9573afbe60|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|75|v|rust
	Power(MDM2,2)
dae4582093c67ff4077e2e25e99067dc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|109|v|rust
	\[CapitalGamma]
8411b6e8f2aa8e5bf052617f66fc9f16|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|109|v|rust
	self.width_h
83af1f679c47d592f41de097deed003f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|9|104|v|rust
	ower(self.width_h,2)
e9a70720e97e7c3bea5aa816b537e592|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|9|9|v|rust
	3.0
	            * self.lam.powi(4)
	            * (mh2 * mh2
	                + (ml2 * ml2 + 2 * self.ml * w).powi(2)
	                + mh2 * (-2 * ml2 - 4.0 * self.ml * w + wid2))
3496f43d1195e328a6c3a3d929efbdf1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|26|1|V|rust
	    pub c0:f64,
2556f97de450f0ed110d797372256287|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|26|1|V|rust
	    pub c0:f64,
	    pub c1:f64,
	    pub c2:f64,
78bb4eb2b9153eb5a1d50ac2d63fc46d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|71|1|V|rust
	            c0:0.0,
54340449b4303ddb2a692a60bbf4b166|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|79|9|V|rust
	        model.c1
02fbb3134db6ef6c05331d5093488deb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff0.rs|3|1|V|rust
	impl DipoleDm {
7d2f6eda50b58b847b99d8139dc124c0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff0.rs|5|1|v|rust
	&self
a9e09f52ecd858f90294b2d66daed2b6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff0.rs|1|1|V|rust
	use super::DipoleDm;
1b727c92d36007aad19163a26a6623b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|5|30|v|rust
	&self)
7a36878eae0ece1ec0fff8a82cbb3078|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff1.rs|5|30|v|rust
	ml: f64, mh: f64, lam: f64, ce: f64, cm: f64, width_h: f64
e8273910c864852e1938b8b1038c1e1f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff6.rs|1|1|V|rust
	use super::DipoleDm;
	
	impl DipoleDm {
8bcb1f1937b82d9edb4642bf43418c25|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|71|16|v|rust
	0.0,
2e8ecd4633b9259dad8285b999390861|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|71|17|v|rust
	DipoleDm::compute_c0(ml, mh, lam, ce, cm),
4581bb8613eb1d39f8abeb28c057edb5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|53|1|V|rust
	            let ce2: f64 = ce * ce;
	            let cm2: f64 = cm * cm;
	            let m22: f64 = mh * mh;
	            let m12: f64 = ml * ml;
	            let m23: f64 = m22 * mh;
	            let lam2: f64 = lam * lam;
	            (ce2 + cm2) * (m22 - m12).powi(3) / (8.0 * std::f64::consts::PI * lam2 * m23)
678f0c706fc42f0de2e1c1ade683d87c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|6|1|V|rust
	pub mod coeff6;
97a80df4a0b919fd4e2758bae50651f7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|7|9|v|rust
	coeff6
7731f610671060f66dae5f2136a2ff07|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|54|9|v|rust
	let mut model = 
ab3dec5192f705c24c018d8c505a70a8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|1|V|rust
	        let pade_num = (self.c0 + self.c1 * w + self.c2 * w*w);
0f466ba65d91d43b84f052ae4bc58eae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|24|v|rust
	self.c0 + self.c1 * w + self.c2 * w * w
35314dfde8f713252b04a71873f9653f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|16|24|v|rust
	1.0 + self.c4 * w + self.c5 * w * w + self.c6 * w * w * w
24beb5cc4bc6c146cc7655fadab67c94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|6|1|V|rust
	        let w2 = w * w;
76a878361aea9823168de1e726294e62|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|18|v|rust
	w * w
656f0676b64d224adaee388a9fedd3d6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|19|60|v|rust
	 * w;
c7eedeaf94320398d6920ffab3aab5cb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|20|55|v|rust
	 * w
1eac6b87aa6a0268e10bda7bbcf7eb55|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|23|34|v|rust
	(w * temp / 2.0).sinh().powi(2)
18513ec4c8e0914506db1a89797a2925|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|23|27|v|rust
	32.0 / 
62b3a367c89b990084826db4621419e1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|76|1|V|rust
	        let pre = 1.0 / (48.0 * (std::f64::consts::PI * self.ml).powi(3) * 2.0 * self.ml / x);
	        let f = |w: f64| self.gamma_integrand(w, x);
	        let gam = self.gk_gamma.integrate(&f, 0.0, f64::INFINITY).val;
	
	        pre * gam / crate::full_boltz::hubblet(self.ml / x)
e7c1122fa691dddc828e90e4c5a1e458|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|119|1|V|rust
	        println!("{}", model.gamma_hinv(1.0));
1540be3d0f0b4975de6991d56d9f4c8e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|123|19|v|rust
	/ crate::full_boltz::hubblet(model.ml / x)
5157efa8088bc2acf3164bfaa26b3ace|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|123|22|v|rust
	pre *
cabbc1042e505994ab1d736febc4732d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|123|1|V|rust
	        println!("{}", gam);
e6c266ce30a746e4bde76a152acd2672|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|128|1|V|rust
	        println!("{}", model.c5);
dca2901010171b023ca2a9d72e07c3bf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|6|1|V|rust
	        let temp1 = mh.powi(2);
	        let temp2 = mh.powi(4);
	        let temp3 = width_h.powi(2);
	        let temp4 = mh.powi(6);
	        let temp5 = width_h.powi(4);
	        let temp6 = mh.powi(8);
	        let temp7 = width_h.powi(6);
	        let temp8 = ml.powi(4);
	        let temp9 = ml.powi(2);
	        let temp10 = width_h.powi(8);
	        let temp11 = ml.powi(22);
	        let temp12 = ml.powi(18);
	        let temp13 = ml.powi(20);
	        let temp14 = ml.powi(16);
	        let temp15 = ml.powi(14);
	        let temp16 = ml.powi(10);
	        let temp17 = mh.powi(10);
	        let temp18 = ml.powi(12);
	        let temp19 = ml.powi(8);
	        let temp20 = ml.powi(6);
	        let temp21 = mh.powi(12);
	        let temp22 = width_h.powi(10);
	        let temp23 = mh.powi(14);
	        let temp24 = ce.powi(2) + cm.powi(2);
	        (3.1825835732329984e-12
	            * temp24
	            * temp24
	            * (2.27068164983364e14 * temp15 * temp15
	                - 1.120543782772604e15 * temp18 * temp18 * temp8 * temp1
	                + temp18
	                    * temp18
	                    * (2.313020728396157e15 * temp2 + 2.77457864945796e14 * temp1 * temp3)
	                + temp11 * (-9.54044271851608e14 * temp2 * temp3 - 2.544451123923362e15 * temp4)
	                + temp12
	                    * temp4
	                    * (-4.3124745813338e14 * temp2
	                        - 6.94173004953456e14 * temp1 * temp3
	                        - 1.75739434623084e14 * temp5)
	                + temp13
	                    * (1.241514586585123e15 * temp3 * temp4
	                        + 7.8187745202208e13 * temp2 * temp5
	                        + 1.537277358543761e15 * temp6)
	                + temp14
	                    * temp4
	                    * (8.9965036039536e13 * temp2 * temp3 - 5.45076313778e11 * temp4
	                        + 8.6655115431403e13 * temp1 * temp5
	                        + 5.84959365344e11 * temp7)
	                + temp15
	                    * temp6
	                    * (3.5019195611552e13 * temp2 * temp3
	                        + 1.538903889986e13 * temp4
	                        + 1.844793565233e13 * temp1 * temp5
	                        + 5.88904442688e11 * temp7)
	                + temp16
	                    * temp17
	                    * (-7.3482137976e10 * temp10
	                        - 4.461034742224e12 * temp3 * temp4
	                        - 4.516748004584e12 * temp2 * temp5
	                        - 1.43273740238e12 * temp6
	                        - 1.561932802716e12 * temp1 * temp7)
	                + temp18
	                    * temp6
	                    * (-7.800090048e9 * temp10
	                        + 9.795723883554e12 * temp3 * temp4
	                        + 4.210648039077e12 * temp2 * temp5
	                        + 5.670540777486e12 * temp6
	                        + 1.75893866961e11 * temp1 * temp7)
	                + temp4
	                    * temp4
	                    * temp4
	                    * (1.944162e7 * temp1 * temp10
	                        + 3.888324e6 * temp17
	                        + 3.8883240000000005e6 * temp22
	                        + 3.888324e7 * temp4 * temp5
	                        + 1.944162e7 * temp3 * temp6
	                        + 3.888324e7 * temp2 * temp7)
	                + temp17
	                    * temp19
	                    * (1.10918112624e11 * temp1 * temp10 - 3.31479154319e11 * temp17
	                        + 419904. * temp22
	                        - 3.92500844067e11 * temp4 * temp5
	                        - 7.4879084592e11 * temp3 * temp6
	                        + 1.35728540254e11 * temp2 * temp7)
	                + temp20
	                    * temp21
	                    * (8.2917025164e10 * temp1 * temp10
	                        + 1.34118356862e11 * temp17
	                        + 2.519424e6 * temp22
	                        + 6.50320595586e11 * temp4 * temp5
	                        + 4.84881839928e11 * temp3 * temp6
	                        + 3.8247161826e11 * temp2 * temp7)
	                + temp23
	                    * (-8.124271236e9 * temp1 * temp10 - 8.335306467e9 * temp17
	                        + 8.066304e6 * temp22
	                        - 4.9443263541e10 * temp4 * temp5
	                        - 3.3154389549e10 * temp3 * temp6
	                        - 3.2756517999e10 * temp2 * temp7)
	                    * temp8
	                + temp6
	                    * temp6
	                    * (8.0575452e7 * temp1 * temp10
	                        + 3.9160476e7 * temp17
	                        + 1.0353744e7 * temp22
	                        + 2.76377832e8 * temp4 * temp5
	                        + 1.66995648e8 * temp3 * temp6
	                        + 2.18764368e8 * temp2 * temp7)
	                    * temp9))
	            / ((temp2 + temp1 * temp3 + temp8 - 2. * temp1 * temp9)
	                * (1. * temp11 - 4.361507001205805 * temp1 * temp13
	                    + temp12 * (7.9867135173273205 * temp2 + 0.8250088274827271 * temp1 * temp3)
	                    + temp14 * (-2.605539507631433 * temp2 * temp3 - 8.010001920767477 * temp4)
	                    + temp18
	                        * temp4
	                        * (-1.5029592840574617 * temp2
	                            - 2.205272718034752 * temp1 * temp3
	                            - 0.372259997215811 * temp5)
	                    + temp15
	                        * (3.3991601364330726 * temp3 * temp4
	                            + 0.0055692466598470484 * temp2 * temp5
	                            + 4.726806698203919 * temp6)
	                    + temp16
	                        * temp4
	                        * (0.4698950789118628 * temp2 * temp3
	                            + 0.10850491329292072 * temp4
	                            + 0.3644787337638716 * temp1 * temp5
	                            - 0.015413912949517213 * temp7)
	                    + temp19
	                        * temp6
	                        * (0.11021942233524269 * temp2 * temp3
	                            + 0.0436179490344449 * temp4
	                            + 0.06697928944503216 * temp1 * temp5
	                            + 0.0003640673831980007 * temp7)
	                    + temp23
	                        * (9.021765132550776e-6 * temp10
	                            + 0.000036087060530203105 * temp3 * temp4
	                            + 0.000054130590795304665 * temp2 * temp5
	                            + 9.021765132550776e-6 * temp6
	                            + 0.000036087060530203105 * temp1 * temp7)
	                    + temp20
	                        * temp6
	                        * (-0.00001332254944423919 * temp10
	                            + 0.021045974149958735 * temp3 * temp4
	                            + 0.012206710787485992 * temp2 * temp5
	                            + 0.009961114540199573 * temp6
	                            + 0.0011085286282825908 * temp1 * temp7)
	                    + temp17
	                        * (-0.00029103186406766326 * temp10
	                            - 0.00318355951248573 * temp3 * temp4
	                            - 0.003771674127639666 * temp2 * temp5
	                            - 0.0009621589204664859 * temp6
	                            - 0.0018413053996880848 * temp1 * temp7)
	                        * temp8
	                    + temp21
	                        * (-0.00015928397952665195 * temp10
	                            - 0.0007078316177068222 * temp3 * temp4
	                            - 0.001026399576760126 * temp2 * temp5
	                            - 0.00018284921272672343 * temp6
	                            - 0.0006607011513066793 * temp1 * temp7)
	                        * temp9))
f4f5fe9030f541c8741059062d281d4e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|91|1|V|rust
	- 0.00018284921272672343*temp6 - 
ba3b41936a8459929a5e695cab054a7e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff2.rs|31|15|v|rust
	pow(pow(ce, 2) + pow(self.cm, 2), 2)
94ba1ab8e6faaffffea6b203f5bb073d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff4.rs|6|1|V|rust
	        let temp1 = mh.powi(2);
	        let temp2 = mh.powi(4);
	        let temp3 = width_h.powi(2);
	        let temp4 = mh.powi(6);
	        let temp5 = width_h.powi(4);
	        let temp6 = mh.powi(8);
	        let temp7 = width_h.powi(6);
	        let temp8 = ml.powi(4);
	        let temp9 = ml.powi(2);
	        let temp10 = width_h.powi(8);
	        let temp11 = ml.powi(22);
	        let temp12 = ml.powi(20);
	        let temp13 = ml.powi(16);
	        let temp14 = ml.powi(18);
	        let temp15 = ml.powi(12);
	        let temp16 = ml.powi(14);
	        let temp17 = ml.powi(10);
	        let temp18 = ml.powi(8);
	        let temp19 = mh.powi(10);
	        let temp20 = mh.powi(12);
	        let temp21 = mh.powi(14);
	        let temp22 = width_h.powi(10);
	        let temp23 = ml.powi(6);
	        return (-0.2477675534719569
	            * temp15
	            * temp15
	            * temp9
	            * -3.6723166232003694
	            * temp15
	            * temp15
	            * temp1
	            + temp11 * (24.11167981379115 * temp2 + 4.047220841207445 * temp1 * temp3)
	            + temp12 * (-23.32834502994125 * temp2 * temp3 - 58.97385751813322 * temp4)
	            + temp13
	                * temp4
	                * (-60.177109167181726 * temp2
	                    - 68.18531162181159 * temp1 * temp3
	                    - 13.553076070785304 * temp5)
	            + temp14
	                * (54.82199484865789 * temp3 * temp4
	                    + 3.9917235937761437 * temp2 * temp5
	                    + 77.53274159411194 * temp6)
	            + temp15
	                * temp6
	                * (-16.56324067920996 * temp2 * temp3
	                    - 5.8284597337858965 * temp4
	                    - 12.759822964300024 * temp1 * temp5
	                    - 1.916680929621818 * temp7)
	            + temp16
	                * temp4
	                * (47.51380719775822 * temp2 * temp3
	                    + 27.175511950633876 * temp4
	                    + 19.005945410279388 * temp1 * temp5
	                    + 0.41921310116139454 * temp7)
	            + temp18
	                * temp19
	                * (0.002928197949629355 * temp10
	                    + 0.5620427152889594 * temp3 * temp4
	                    + 0.7499120967711878 * temp2 * temp5
	                    + 0.12579255090239144 * temp6
	                    + 0.31659013033424904 * temp1 * temp7)
	            + temp17
	                * temp6
	                * (-0.061472716639672735 * temp10
	                    + 0.9583724656569121 * temp3 * temp4
	                    + 2.4049235497319623 * temp2 * temp5
	                    - 0.10367730958901374 * temp6
	                    + 1.2815660429788 * temp1 * temp7)
	            + temp6
	                * temp6
	                * (0.0003187564316525108 * temp1 * temp10
	                    + 0.00006375128633050216 * temp19
	                    + 0.00006375128633050216 * temp22
	                    + 0.0006375128633050216 * temp4 * temp5
	                    + 0.0003187564316525108 * temp3 * temp6
	                    + 0.0006375128633050216 * temp2 * temp7)
	            + temp19
	                * temp23
	                * (0.008532886719445491 * temp1 * temp10 + 0.06242024493702055 * temp19
	                    - 0.00010658039555391352 * temp22
	                    + 0.21432524433335223 * temp4 * temp5
	                    + 0.1964199658169303 * temp3 * temp6
	                    + 0.08896499056844191 * temp2 * temp7)
	            + temp20
	                * (-0.011433969025205066 * temp1 * temp10
	                    - 0.003773748281006013 * temp19
	                    - 0.001816007392948649 * temp22
	                    - 0.031095092775044048 * temp4 * temp5
	                    - 0.01730719168937716 * temp3 * temp6
	                    - 0.027179610998929318 * temp2 * temp7)
	                * temp8
	            + temp21
	                * (-0.005165292370461583 * temp1 * temp10
	                    - 0.0012482520195193705 * temp19
	                    - 0.0009792600877355532 * temp22
	                    - 0.011406552468058436 * temp4 * temp5
	                    - 0.005972268165813035 * temp3 * temp6
	                    - 0.010868568604490801 * temp2 * temp7)
	                * temp9)
	            / (ml
	                * (temp2 + temp1 * temp3 + temp8 - 2. * temp1 * temp9)
	                * (1. * temp11 - 4.361507001205805 * temp1 * temp12
	                    + temp14 * (7.9867135173273205 * temp2 + 0.8250088274827271 * temp1 * temp3)
	                    + temp13 * (-2.605539507631433 * temp2 * temp3 - 8.010001920767477 * temp4)
	                    + temp15
	                        * temp4
	                        * (-1.5029592840574617 * temp2
	                            - 2.205272718034752 * temp1 * temp3
	                            - 0.372259997215811 * temp5)
	                    + temp16
	                        * (3.3991601364330726 * temp3 * temp4
	                            + 0.0055692466598470484 * temp2 * temp5
	                            + 4.726806698203919 * temp6)
	                    + temp17
	                        * temp4
	                        * (0.4698950789118628 * temp2 * temp3
	                            + 0.10850491329292072 * temp4
	                            + 0.3644787337638716 * temp1 * temp5
	                            - 0.015413912949517213 * temp7)
	                    + temp18
	                        * temp6
	                        * (0.11021942233524269 * temp2 * temp3
	                            + 0.0436179490344449 * temp4
	                            + 0.06697928944503216 * temp1 * temp5
	                            + 0.0003640673831980007 * temp7)
	                    + temp21
	                        * (9.021765132550776e-6 * temp10
	                            + 0.000036087060530203105 * temp3 * temp4
	                            + 0.000054130590795304665 * temp2 * temp5
	                            + 9.021765132550776e-6 * temp6
	                            + 0.000036087060530203105 * temp1 * temp7)
	                    + temp23
	                        * temp6
	                        * (-0.00001332254944423919 * temp10
	                            + 0.021045974149958735 * temp3 * temp4
	                            + 0.012206710787485992 * temp2 * temp5
	                            + 0.009961114540199573 * temp6
	                            + 0.0011085286282825908 * temp1 * temp7)
	                    + temp19
	                        * (-0.00029103186406766326 * temp10
	                            - 0.00318355951248573 * temp3 * temp4
	                            - 0.003771674127639666 * temp2 * temp5
	                            - 0.0009621589204664859 * temp6
	                            - 0.0018413053996880848 * temp1 * temp7)
	                        * temp8
	                    + temp20
	                        * (-0.00015928397952665195 * temp10
	                            - 0.0007078316177068222 * temp3 * temp4
	                            - 0.001026399576760126 * temp2 * temp5
	                            - 0.00018284921272672343 * temp6
	                            - 0.0006607011513066793 * temp1 * temp7)
	                        * temp9));
9bab4abfcc81e9c74028a76f2dae89c9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/coeff6.rs|6|1|V|rust
	        let temp1 = mh.powi(2);
	        let temp2 = mh.powi(4);
	        let temp3 = width_h.powi(2);
	        let temp4 = mh.powi(6);
	        let temp5 = width_h.powi(4);
	        let temp6 = mh.powi(8);
	        let temp7 = width_h.powi(6);
	        let temp8 = ml.powi(4);
	        let temp9 = ml.powi(2);
	        let temp10 = width_h.powi(8);
	        let temp11 = ml.powi(20);
	        let temp12 = ml.powi(22);
	        let temp13 = ml.powi(16);
	        let temp14 = ml.powi(18);
	        let temp15 = ml.powi(12);
	        let temp16 = mh.powi(10);
	        let temp17 = ml.powi(14);
	        let temp18 = ml.powi(10);
	        let temp19 = ml.powi(8);
	        let temp20 = mh.powi(12);
	        let temp21 = width_h.powi(10);
	        let temp22 = mh.powi(14);
	        let temp23 = width_h.powi(12);
	        let temp24 = ml.powi(6);
	        (0.6173489105097649 * temp11 * temp18
	            + 17.096212051113838 * temp17 * temp17 * temp1
	            + temp24 * temp11 * (-128.79313435429884 * temp2 + 2.610721539086631 * temp1 * temp3)
	            + temp15 * temp15 * (26.401599921120102 * temp2 * temp3 + 383.9513165685215 * temp4)
	            + temp11
	                * temp4
	                * (627.1781887233356 * temp2 + 344.2179451966183 * temp1 * temp3
	                    - 2.190980414593478 * temp5)
	            + temp12
	                * (-162.4393912777501 * temp3 * temp4 + 5.300615660537958 * temp2 * temp5
	                    - 630.8032925214926 * temp6)
	            + temp13
	                * temp6
	                * (204.65830073067514 * temp2 * temp3
	                    + 128.9666653401595 * temp4
	                    + 45.589170916233186 * temp1 * temp5
	                    - 13.561088832231516 * temp7)
	            + temp14
	                * temp4
	                * (-366.37867703105417 * temp2 * temp3
	                    - 380.11228017333303 * temp4
	                    - 26.394856748020114 * temp1 * temp5
	                    + 5.219184014155243 * temp7)
	            + temp15
	                * temp16
	                * (-2.2106975637170687 * temp10 - 1.4824880698768577 * temp3 * temp4
	                    + 2.814851592976904 * temp2 * temp5
	                    - 2.0010872503678123 * temp6
	                    + 0.08511488841571709 * temp1 * temp7)
	            + temp17
	                * temp6
	                * (1.8637096053955895 * temp10
	                    - 49.091250433112165 * temp3 * temp4
	                    - 27.154893900703833 * temp2 * temp5
	                    - 16.276680665930765 * temp6
	                    + 8.5950573986226 * temp1 * temp7)
	            + temp16
	                * temp18
	                * (-0.37288220751712753 * temp1 * temp10 - 0.15501120691523837 * temp16
	                    + 0.0008531055301728275 * temp21
	                    + 1.1160569047768425 * temp4 * temp5
	                    + 0.5152228834944935 * temp3 * temp6
	                    + 0.07208750131981025 * temp2 * temp7)
	            + temp19
	                * temp20
	                * (0.04295817673606699 * temp1 * temp10
	                    + 0.33699519687039564 * temp16
	                    + 0.016487812124633225 * temp21
	                    + 0.9929376408832321 * temp4 * temp5
	                    + 0.9969703395038093 * temp3 * temp6
	                    + 0.3594328628612523 * temp2 * temp7)
	            + temp4
	                * temp4
	                * temp4
	                * (0.0020674699408436206 * temp10 * temp2
	                    + 0.0001378313293895747 * temp20
	                    + 0.0008269879763374482 * temp1 * temp21
	                    + 0.0001378313293895747 * temp23
	                    + 0.0008269879763374482 * temp16 * temp3
	                    + 0.0020674699408436206 * temp5 * temp6
	                    + 0.0027566265877914937 * temp4 * temp7)
	            + temp20
	                * temp24
	                * (0.06775718626070751 * temp10 * temp2 - 0.0015662789711910605 * temp20
	                    + 0.015566098876552156 * temp1 * temp21
	                    - 0.00021019105872397185 * temp23
	                    + 0.01509890636513403 * temp16 * temp3
	                    + 0.07089106497527252 * temp5 * temp6
	                    + 0.10620677596437882 * temp4 * temp7)
	            + temp22
	                * (-0.042751254954492786 * temp10 * temp2
	                    - 0.0018508295674635063 * temp20
	                    - 0.01665433253538535 * temp1 * temp21
	                    - 0.002571690475451212 * temp23
	                    - 0.013770888903434529 * temp16 * temp3
	                    - 0.039146950414554266 * temp5 * temp6
	                    - 0.05589550397314189 * temp4 * temp7)
	                * temp8
	            + temp6
	                * temp6
	                * (-0.022827698100226886 * temp10 * temp2
	                    - 0.0019613409629437345 * temp20
	                    - 0.008471837605697844 * temp1 * temp21
	                    - 0.0013020993285508217 * temp23
	                    - 0.011108804143269493 * temp16 * temp3
	                    - 0.02612390627219145 * temp5 * temp6
	                    - 0.03263440291494556 * temp4 * temp7)
	                * temp9)
	            / (ml.powi(3)
	                * (temp2 + temp1 * temp3 + temp8 - 2. * temp1 * temp9).powi(2)
	                * (-4.361507001205805 * temp1 * temp11
	                    + 1. * temp12
	                    + temp14 * (7.9867135173273205 * temp2 + 0.8250088274827271 * temp1 * temp3)
	                    + temp13 * (-2.605539507631433 * temp2 * temp3 - 8.010001920767477 * temp4)
	                    + temp15
	                        * temp4
	                        * (-1.5029592840574617 * temp2
	                            - 2.205272718034752 * temp1 * temp3
	                            - 0.372259997215811 * temp5)
	                    + temp17
	                        * (3.3991601364330726 * temp3 * temp4
	                            + 0.0055692466598470484 * temp2 * temp5
	                            + 4.726806698203919 * temp6)
	                    + temp18
	                        * temp4
	                        * (0.4698950789118628 * temp2 * temp3
	                            + 0.10850491329292072 * temp4
	                            + 0.3644787337638716 * temp1 * temp5
	                            - 0.015413912949517213 * temp7)
	                    + temp19
	                        * temp6
	                        * (0.11021942233524269 * temp2 * temp3
	                            + 0.0436179490344449 * temp4
	                            + 0.06697928944503216 * temp1 * temp5
	                            + 0.0003640673831980007 * temp7)
	                    + temp22
	                        * (9.021765132550776e-6 * temp10
	                            + 0.000036087060530203105 * temp3 * temp4
	                            + 0.000054130590795304665 * temp2 * temp5
	                            + 9.021765132550776e-6 * temp6
	                            + 0.000036087060530203105 * temp1 * temp7)
	                    + temp24
	                        * temp6
	                        * (-0.00001332254944423919 * temp10
	                            + 0.021045974149958735 * temp3 * temp4
	                            + 0.012206710787485992 * temp2 * temp5
	                            + 0.009961114540199573 * temp6
	                            + 0.0011085286282825908 * temp1 * temp7)
	                    + temp16
	                        * (-0.00029103186406766326 * temp10
	                            - 0.00318355951248573 * temp3 * temp4
	                            - 0.003771674127639666 * temp2 * temp5
	                            - 0.0009621589204664859 * temp6
	                            - 0.0018413053996880848 * temp1 * temp7)
	                        * temp8
	                    + temp20
	                        * (-0.00015928397952665195 * temp10
	                            - 0.0007078316177068222 * temp3 * temp4
	                            - 0.001026399576760126 * temp2 * temp5
	                            - 0.00018284921272672343 * temp6
	                            - 0.0006607011513066793 * temp1 * temp7)
	                        * temp9))
0597442cc21df154aa62bdedb3c89600|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|15|9|v|rust
	Mass of the lighter DM particle.
68628c1d964db8f638b4e0b657d37590|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|18|9|v|rust
	mh: f64,
e8bdc752e955c1437a6dbd1331c662c3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|17|9|v|rust
	Mass of the heavier DM particle.
e31eb6262e90c1687895422cea9999b0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|28|1|V|rust
	    pub(super) c1: f64,
	    pub(super) c2: f64,
	    pub(super) c4: f64,
	    pub(super) c5: f64,
	    pub(super) c6: f64,
ce493395fafe065b442a76920052cffc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|41|35|v|rust
	mh - ml
13f7b27fcfeabe95c54d06e202b97b7c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|91|31|v|rust
	+ self.mh * self.mh).sqrt();
1a39bd045c67c83802b4b2f600325242|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|91|22|v|rust
	(kt * kt 
585d24626a9fc4f33995df344e6a0d60|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|126|31|v|rust
	c.c0
9c7c7be570dc041100fa29fd8924eee3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|131|31|v|rust
	model.c1
408797c5ba13b57d1d2f7a087a045d5c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|131|31|v|rust
	model.c4
e0c4450dafa4faa976bed702fd7af633|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|131|31|v|rust
	model.c2
b156dd81eadd030324a55e01b4e3efc8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|131|31|v|rust
	model.c5
914bc0d9c0518701ebeb85a98735e7f0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|131|31|v|rust
	model.c6
68fca59768ea9845d2b7ebb7107fce7b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|28|1|V|rust
	    /// Unitless mass splitting parameter: eps = dm/mx
	    pub(super) eps: f64,
11234250cca9dc7365f0bae235eb79a4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|30|18|v|rust
	mass splitting parameter: eps = dm/mx
140a3ae4c934017e755051e245406131|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|32|1|V|rust
	    /// Coefficients using in computing gamma
	    pub(super) gam_coeffs: [f64; 6],
189d66b123a609f406f9d101d39b79b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|128|1|V|rust
	        println!("width = {:e}", model.width_h);
	        println!("c0 = {:e}", coeffs[0]);
	        println!("c1 = {:e}", coeffs[1]);
	        println!("c2 = {:e}", coeffs[2]);
	        println!("c4 = {:e}", coeffs[3]);
	        println!("c5 = {:e}", coeffs[4]);
	        println!("c6 = {:e}", coeffs[5]);
134e4569808fbca4fd840f8ca1d1d20c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|126|5|V|rust
	        let coeffs = model.get_gam_coeffs();
2ec6c3734b6e37cb1142f3331efbf30a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|73|1|V|rust
	    pub fn get_gam_coeffs(&self) -> [f64; 6] {
	        self.gam_coeffs.clone()
	    }
de0740fd5a2576f4a003a340308a5aac|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|22|v|rust
	Power(
508a0e889849ffc889999549ff3d3ed3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|21|v|rust
	(w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w.powi(3)));
	
dd7e7dd2a1a998fb9c33b7552659d18b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|97|v|rust
	\[Lambda]
7cd04ceb9912d56bd54cca659ba16329|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|30|v|rust
	Power(self.ce,2) + Power(self.cm,2)
65ee93d1af193fa327a0e5a15bffa006|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|1|V|rust
	    fn gamma_integrand_schannel(&self, w: f64) -> (f64, f64) {
	        let wterm = (w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w).powi(3));
	        let coeff = (8.0
	            * (self.ce * self.ce + self.cm * self.cm).powi(2)
	            * self.mx.powi(4)
	            * self.udm.powi(6))
	            / (3.0 * self.ulam.powi(4));
	
	    }
a624ffa248223d6d0f26bb309f3d1e68|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|57|v|rust
	(f64, f64)
cf1dbd70a1935f35ebcc54778e76af17|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|1|V|rust
	        let wterm = (w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w).powi(3));
10879be7607220c5df1beb97a2b57fad|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|5|9|v|rust
	let coeff = 
d6ed040c070f4e26b5546b5e38df029d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|39|v|rust
	&self, w: f64
c2a02366d35cfeb1323c42e527ff589c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|54|v|rust
	, f64)
c860c10ef42ebcafd07b217a70317add|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|33|1|V|rust
	    pub(super) gam_coeffs_ss: f64,
2a7b8e2221a94da830a655a36fd76c1a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|10|1|V|rust
	        let coeff = (8.0
	            * (self.ce * self.ce + self.cm * self.cm).powi(2)
	            * self.mx.powi(4)
	            * self.udm.powi(6))
	            / (3.0 * self.ulam.powi(4));
866e47474678bbc051a12b225b194244|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|9|v|rust
	let wterm =
a8661d9a79c88e7ef9fc4fac8ef4e4f8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|1|V|rust
	    fn gamma_integrand_schannel_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        (8.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(6)) / (3.0 * ulam.powi(4))
	    }
	    fn gamma_integrand_schannel(&self, w: f64) -> f64 {
	        self.gam_coeff_ss * (w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w).powi(3))
	    }
c485d2ed5cc4ce64fcccca710c7a0bb7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|25|v|rust
	channel
3daa94f2adde184e237dbe9c82bafba0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|25|v|rust
	channe
faa99a9f6c4ca4a15a6bd5f8ad735d40|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|11|24|v|rust
	schannel_coeff
f4ac57c16727dc4aeb8bdf564b85c855|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|14|24|v|rust
	schannel
c17f4f5309697068e709d8e1f5d94e8a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|12|1|V|rust
	        (8.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(6)) / (3.0 * ulam.powi(4))
0bb297fb34ea34508871e97582731425|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|12|18|v|rust
	Power(CE,2)
7afa43335dd91d914adb3025d41b6ac9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|12|25|v|rust
	 Power(CM,2)
10bba648c116141ab6ecf127f6c48bb5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|12|66|v|rust
	Power(\[Lambda]
c1a9258b40b2dd83c1488befd747962a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|11|1|V|rust
	    fn gamma_integrand_tt_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(4)) / (3.0 * ulam.powi(4))
	    }
618cde8027fdfb111383fa6809bf0f8f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|19|1|V|rust
	        (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(4)) / (3.0 * ulam.powi(4))
d71b0a612e2faecd0a3c4d39f134e411|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|19|26|v|rust
	Power(CM,2)
fbf6202699b2f6ecc87ee66e2a8960c5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|19|36|v|rust
	(MDM1
dd4be9ae4590b4892f70bf186194b613|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|1|V|rust
	        self.gam_coeff_ss * (w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w).powi(3))
9018e62b32ce447f74b7a06217701fc1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|14|1|V|rust
	    fn gamma_integrand_tt(&self, w: f64) -> f64 {
	    }
aae1dfbab11611fff4e4f0adec6095a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|13|v|rust
	,2);
d49f056878e616e56679696e0be6c6bd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|17|14|v|rust
	pow(temp2,2);
13ff1bd761f09eec4d1e2146ecf23b14|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|21|14|v|rust
	pow(temp6,2);
54fdeefda39af0a561f8f4a72428561c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|1|V|rust
	        let udm = self.udm; let temp1 = w*w;
		let temp2 = 2.0 + udm;
		let temp3 = temp2 * temp2;
		let temp4 = 2.0*udm*w;
		let temp5 = 1.0 + temp4;
		let temp6 = 1.0 + udm;
		let temp7 = temp6*temp6;
		let temp8 = 2.0*temp7*w;
		let temp9 = 5.0*temp1*udm;
		let temp10 = 2.0 + temp8 + temp9 + udm;
		return (temp1*udm*(-12*temp2.powi(4) - 6*temp1*temp3*(2 + \
	3*temp2*udm)*(-1 + 8*temp2*udm) - 12*pow(temp2,3)*(1 + 6*temp2*udm)*w \
	- 6*temp3*udm*(-13 + 4*temp2*udm*(7 + 4*temp2*udm))*pow(w,3) - \
	2*temp2*udm*(3 + 5*temp2*udm*(-17 + 12*temp2*udm))*pow(w,4) + \
	2*udm*(6 + temp2*udm*(-15 + 62*temp2*udm))*pow(w,5) + pow(udm,2)*(58 \
	- 37*temp2*udm)*pow(w,6) + \
	70*pow(udm,3)*pow(w,7)))/(temp10*pow(temp5,3)) + 6*temp3*(-temp1 + \
	temp3 + temp2*w)*log(pow(temp10,2)/(pow(temp5,2)*pow(2 + udm + \
	2*w,2)));
2da2e6673d4e23559c06254ced20ded4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|15|14|v|rust
	pow(w,2);
5a514b79c1c7b99af115da7929397a96|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|34|23|v|rust
	pow(w, 3)
d20baa06f5a47be1aa2d6e96a0810690|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|38|23|v|rust
	pow(w, 4)
f4f20aee251c57301d31faf8de8abb2f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|59|14|v|rust
	pow(temp3,2);
218b822fac567b266595930c9a69744c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|64|14|v|rust
	pow(temp8,-2);
e2530108153a226256146b89746dbfd6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|82|1|V|rust
	        let w2 = w * w;
	        let w8 = w2 * w2 * w2 * w2;
	        let temp = self.ml / x;
	
	        let ml2 = self.ml * self.ml;
	        let mh2 = self.mh * self.mh;
	        let wid2 = self.width_h * self.width_h;
	        let den = 3.0
	            * self.lam.powi(4)
	            * (mh2 * mh2
	                + (ml2 * ml2 + 2.0 * self.ml * w).powi(2)
	                + mh2 * (-2.0 * ml2 - 4.0 * self.ml * w + wid2));
	
	        let pade_num = self.c0 + self.c1 * w + self.c2 * w2;
	        let pade_den = 1.0 + self.c4 * w + self.c5 * w2 + self.c6 * w2 * w;
	        let pade = pade_num / pade_den;
1f1633fb9771a6816d19d2c90afe4b56|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|82|1|V|rust
	        let ss = self.gamma_integrand_ss(w);
08cc0b189806b22ca42923d6c912561b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|87|27|v|rust
	(2.0 * temp) / ((w / temp).cosh() - 1.0)
9e8fb0dacf10386ad650b16ff1336d8b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|88|9|v|rust
	w8 * pade / den / (2.0 * temp) / ((w / temp).cosh() - 1.0)
9863142ff2f262cab437091c15c8a46a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|88|10|v|rust
	ss * self.gam_coeff_ss
2f873958224bdd2e7b4d3250eafc62e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|83|1|V|rust
	        let ss = self.gamma_integrand_ss(w);
	        let tt = self.gamma_integrand_tt(w);
	        let st = self.gamma_integrand_st(w);
502ea3617790b0c5eeb5226ee582bbb4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|86|24|v|rust
	gamma_integrand_ss(w);
b847b69723367abbef379e7b99681bcf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|86|1|V|rust
	        let css = self.gam_coeff_ss;
287f065515f50085bb1dfdf77cc1088a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|89|9|V|rust
	        let ctt = self.gamma_integrand_tt(w);
544f60dae70b887cbccf748c5e15a4d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|89|9|V|rust
	        let cst = self.gamma_integrand_st(w);
d0cb45669f12f5d59ae1b03407057886|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|91|15|v|rust
	self.gam_coeff_ss
e28b6847fea94b7695f03046d9bfd0f5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|91|26|v|rust
	self.gam_coeff_tt
f6aa6e3d269464c45874dcd2d1469395|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|91|37|v|rust
	self.gam_coeff_st
467def3afb67080ad9ec3266d20a0777|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|126|1|V|rust
	                */
1fa9c52e2dc37c089274ee737f145eea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|67|1|V|rust
	            gam_coeffs: [
	                DipoleDm::compute_c0(mx, dm, lam, ce, cm),
	                DipoleDm::compute_c1(mx, dm, lam, ce, cm, width_h),
	                DipoleDm::compute_c2(mx, dm, lam, ce, cm, width_h),
	                DipoleDm::compute_c4(mx, dm, lam, ce, cm, width_h),
	                DipoleDm::compute_c5(mx, dm, lam, ce, cm, width_h),
	                DipoleDm::compute_c6(mx, dm, lam, ce, cm, width_h),
	            ],
a53cff7922cc3224c2b07005848c1581|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|33|1|V|rust
	    pub(super) gam_coeff_ss: f64,
	    pub(super) gam_coeff_tt: f64,
	    pub(super) gam_coeff_st: f64,
ca27f2679d604ac7ea4f17d69b499d65|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|67|5|v|rust
	pub(super) 
02ea71a942faf1039f6dc1e4e8e3f84c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|13|1|V|rust
	    pub(super) fn gamma_integrand_tt_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(4)) / (3.0 * ulam.powi(4))
	    }
c8a2b7671c6edf196ca2df87ee3731a0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|8|1|V|rust
	    fn gamma_integrand_ss_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        (8.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(6)) / (3.0 * ulam.powi(4))
	    }
0cc52a8b60f03680c79478947f6ad6d5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|52|1|V|rust
	    fn gamma_integrand_st_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(2) * (2.0 + udm * (2.0 + udm)))
	            / (3.0 * ulam.powi(4))
	    }
e8b0f9e0ddb619774416c085366a1dc5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|3|40|v|rust
	mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64
5cad1788bb3d9438d409c48505a5473a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|67|93|v|rust
	: f64
5ab84270f4ed012c03d2b8b51841b86b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|67|27|v|rust
	gamma_integrand_ss_coeff(mx, udm, ulam, ce, cm)
5d7bd92fe0d41c2789295fe3e35e68e5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|68|27|v|rust
	gamma_integrand_ss_coeff(mx, udm, ulam, ce, cm),
6e5f98cdb32409dcae55eabf399d0f7e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|57|1|V|rust
	        let udm = dm / mx;
21d69c0f9c618c0c4ec371237938f63e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|1|13|V|rust
	pub mod coeff0;
	pub mod coeff1;
	pub mod coeff2;
	pub mod coeff4;
	pub mod coeff5;
	pub mod coeff6;
0634e3dee2b02e11a47641e1a4942f12|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|6|1|V|rust
	        let ce2: f64 = ce * ce;
	        let cm2: f64 = cm * cm;
	        let m22: f64 = mh * mh;
	        let m12: f64 = ml * ml;
	        let m23: f64 = m22 * mh;
	        let lam2: f64 = lam * lam;
	        (ce2 + cm2) * (m22 - m12).powi(3) / (8.0 * std::f64::consts::PI * lam2 * m23)
d042a04e5ff6bcd810a18c27b5320130|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|6|34|v|rust
	\[Epsilon]
9389e2bac7e95ced6b75e610b00d02bc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|6|28|v|rust
	Power(udm,2)
303a547d033703a9e3465325f4287d3d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|6|91|v|rust
	Power(\[Lambda],2)
93dd4550efb3a3850c658bd485557ce3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|5|35|v|rust
	ml: f64, mh: f64, lam
4cc2dab79d5a1c2ed28c5b8c475cfd53|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|52|1|V|rust
	        let udm = dm / mx;
	        let ulam = lam / mx;
f04d34883201f2d8caa62aa3511cb9b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|121|1|V|rust
	        println!("{:e}", gam);
df0a4e4732ce82322723d67d9c66ff0e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|90|53|v|rust
	/ temp
01f75b07e0b0a735b8e6f82ccb18e5e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|90|47|v|rust
	x * w / self.mx
c24501c4d2e24f8c0d3f23ec5dd6899c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|90|44|v|rust
	 / x
ffa380403a1a9dc759eada23e784ef1e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|83|9|V|rust
	        let temp = self.mx / x;
2682ff6294598799c29cabf3a50e423b|term://.//68995%3A/bin/zsh|9313|1|V|floaterm
	8.759779106424347e1
c2ccb23f85453664bd38deead2fd6d8a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|90|1|V|rust
	        let css = self.gam_coeff_ss;
	        let ctt = self.gam_coeff_tt;
	        let cst = self.gam_coeff_st;
92afbd3fe88882fb32138dbd839db34c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|93|13|v|rust
	* css 
c50d47df6bb7edbafab81d9bc444f0b7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|93|17|v|rust
	 * ctt
5c444f0054921f4156a64514804ace4d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|93|22|v|rust
	 * cst
faede4d7cf55929ce68ecd6660630a53|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|88|18|v|rust
	0.0; //
ce7562324867ace7b3e2a8250fac9fa2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|20|1|V|rust
	        let udm = self.udm;
	        let temp1 = w * w;
	        let temp2 = 2.0 + udm;
	        let temp3 = temp2 * temp2;
	        let temp4 = 2.0 * udm * w;
	        let temp5 = 1.0 + temp4;
	        let temp6 = 1.0 + udm;
	        let temp7 = temp6 * temp6;
	        let temp8 = 2.0 * temp7 * w;
	        let temp9 = 5.0 * temp1 * udm;
	        let temp10 = 2.0 + temp8 + temp9 + udm;
	        self.gam_coeff_tt
	            * (temp1
	                * udm
	                * (-12.0 * temp2.powi(4)
	                    - 6.0 * temp1 * temp3 * (2.0 + 3. * temp2 * udm) * (-1. + 8. * temp2 * udm)
	                    - 12.0 * temp2.powi(3) * (1.0 + 6. * temp2 * udm) * w
	                    - 6.0
	                        * temp3
	                        * udm
	                        * (-13. + 4. * temp2 * udm * (7. + 4. * temp2 * udm))
	                        * w
	                        * w
	                        * w
	                    - 2. * temp2
	                        * udm
	                        * (3. + 5. * temp2 * udm * (-17. + 12. * temp2 * udm))
	                        * temp1
	                        * temp1
	                    + 2. * udm * (6. + temp2 * udm * (-15. + 62. * temp2 * udm)) * w.powi(5)
	                    + udm.powi(2) * (58. - 37. * temp2 * udm) * w.powi(6)
	                    + 70. * udm.powi(3) * w.powi(7)))
	            / (temp10 * temp5.powi(3))
	            + 6. * temp3
	                * (-1. * temp1 + temp3 + temp2 * w)
	                * (temp10.powi(2) / (temp5.powi(2) * (2. + udm + 2. * w).powi(2))).ln()
caeea7905e4cbadb5a4b7f5587a87809|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|49|38|v|rust
	pow(t
d143d0527339a430e6a9b32849e2678d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|1|v|rust
	    (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(4)) / (3.0 * ulam.powi(4))
187a3939ac20f09e029266b0bdfee5db|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|3|15|v|rust
	gamma_integrand_ss_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64)
d8e49dc132f49abbc7981f534b720caf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|5|v|rust
	4.0 * udm * udm * 
3ad363582f588307624152ca4ce7480f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|11|1|V|rust
	    (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(2) * (2.0 + udm * (2.0 + udm)))
	        / (3.0 * ulam.powi(4))
f963546fcd5843941150b31a8a26d2fe|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|60|1|V|rust
	        let temp1 = 2. + udm;
	        let temp2 = w * w;
	        let temp3 = 1. + udm;
	        let temp4 = temp3 * temp3;
	        let temp5 = 2. * w;
	        let temp6 = 2. + temp5 + udm;
	        let temp7 = 2. * udm * w;
	        let temp8 = 1. + temp7;
	        let temp9 = 1.0 / (temp8 * temp8);
	        let temp10 = 2. * temp4 * w;
	        self.gam_coeff_st
	            * (-1.
	                * temp2
	                * temp9
	                * udm
	                * (6. * temp1.powi(2)
	                    + 3. * temp2 * (8. + temp1 * udm * (23. + 8. * temp1 * udm))
	                    + 24. * temp1 * temp4 * w
	                    + 42. * temp4 * udm * w.powi(3)
	                    + 2. * udm.powi(2) * w.powi(4))
	                + 3. * temp6.powi(2)
	                    * (2. + temp10 + udm)
	                    * ((temp9 * (2. + temp10 + udm + 5. * temp2 * udm).powi(2)) / temp6.powi(2))
	                        .ln())
	            / (-2. + temp5 - 1. * udm)
1cafeb0909abae80a76e83ee66ddb3e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|59|9|V|rust
	        let udm = self.udm;
55940518c236fc3a423b1f5723a999dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|85|5|V|rust
	    //fn gamma(&self, x: f64) -> f64;
f02845f52c33fee746415db9597fb4f5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|87|18|v|rust
	0.0; 
73adf591d556d7b79bfffdfb1a410362|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|5|1|V|rust
	        /* let mh = self.mh;
	            let ml = self.ml;
	            let width_h = self.width_h;
	            if cme >= 2.0 * self.ml {
	                let temp1: f64 = self.ml.powi(2);
	                let temp2: f64 = cme.powi(2);
	                let temp3: f64 = -2.0 * temp1;
	                let temp4: f64 = mh.powi(2);
	                let temp5: f64 = 2.0 * temp4;
	                let temp6: f64 = temp2 + temp3 + temp5;
	                let temp7: f64 = -4.0 * temp1;
	                let temp8: f64 = temp2 + temp7;
	                let temp9: f64 = -cme;
	                let temp10: f64 = temp8.sqrt();
	                let temp11: f64 = temp10 + temp9;
	                let temp12: f64 = ml.powi(4);
	                let temp13: f64 = 36.0 * temp12;
	                let temp14: f64 = mh.powi(4);
	                let temp15: f64 = 36.0 * temp14;
	                let temp16: f64 = 9.0 * temp4;
	                let temp17: f64 = 2.0 * temp2;
	                let temp18: f64 = temp16 + temp17;
	                let temp19: f64 = -8.0 * temp1 * temp18;
	                let temp20: f64 = cme.powi(3);
	                let temp21: f64 = cme + temp10;
	                let temp22: f64 = self.width_h.powi(2);
	                let temp23: f64 = temp2 + temp22;
	                let temp24: f64 = -12.0 * temp23 * temp4;
	                let temp25: f64 = ml.powi(8);
	                let temp26: f64 = ml.powi(6);
	                let temp27: f64 = -4.0 * temp26 * temp4;
	                let temp28: f64 = mh.powi(6);
	                let temp29: f64 = -6.0 * temp22 * temp4;
	                let temp30: f64 = width_h.powi(4);
	                let temp31: f64 = temp14 + temp29 + temp30;
	                let temp32: f64 = temp14 * temp31;
	                let temp33: f64 = -temp10;
	                let temp34: f64 = cme + temp33;
	                let temp35: f64 = cme * temp34;
	                let temp36: f64 = temp3 + temp35 + temp5;
	                let temp37: f64 = 1.0 / temp36;
	                let temp38: f64 = 2.0 * mh * temp37 * width_h;
	                let temp39: f64 = temp38.atan();
	                let temp40: f64 = cme.powi(4);
	                let temp41: f64 = 3.0 * temp14;
	                let temp42: f64 = -7.0 * temp22 * temp4;
	                let temp43: f64 = temp41 + temp42;
	                let temp44: f64 = 2.0 * temp12 * temp43;
	                let temp45: f64 = -5.0 * temp14 * temp22;
	                let temp46: f64 = temp28 + temp45;
	                let temp47: f64 = -4.0 * temp1 * temp46;
	                let temp48: f64 = temp25 + temp27 + temp32 + temp44 + temp47;
	                let temp49: f64 = cme * temp21;
	                let temp50: f64 = temp3 + temp49 + temp5;
	                let temp51: f64 = 1.0 / temp50;
	                let temp52: f64 = 2.0 * mh * temp51 * width_h;
	                let temp53: f64 = temp52.atan();
	                let temp54: f64 = -temp4;
	                let temp55: f64 = temp1 + temp54;
	                let temp56: f64 = -(temp22 * temp4);
	                let temp57: f64 = temp14 + temp56;
	                let temp58: f64 = 6.0 * temp12 * temp57;
	                let temp59: f64 = -3.0 * temp14 * temp22;
	                let temp60: f64 = temp28 + temp59;
	                let temp61: f64 = -4.0 * temp1 * temp60;
	                let temp62: f64 = temp25 + temp27 + temp32 + temp58 + temp61;
	                let temp63: f64 = 2.0 * temp1;
	                let temp64: f64 = -2.0 * temp1 * temp4;
	                let temp65: f64 = temp12 + temp14 + temp56 + temp64;
	                let temp66: f64 = -2.0 * temp4;
	                let temp67: f64 = cme * temp10;
	                ((self.ce.powi(2) + self.cm.powi(2)).powi(2)
	                    * (-12.0 * temp2 * temp39 * temp48
	                        + 48.0 * temp1 * temp22 * temp4 * temp40 * temp53
	                        + 12.0 * temp2 * temp48 * temp53
	                        + 24.0 * temp39 * temp55 * temp62
	                        - 24.0 * temp53 * temp55 * temp62
	                        - (mh
	                            * cme
	                            * temp11
	                            * (temp13 + temp15 + temp19 + temp11 * temp20 + temp24)
	                            * temp6
	                            * width_h)
	                            / 2.0
	                        - (mh
	                            * cme
	                            * temp21
	                            * (temp13 + temp15 + temp19 - temp20 * temp21 + temp24)
	                            * temp6
	                            * width_h)
	                            / 2.0
	                        + 48.0
	                            * temp1
	                            * temp22
	                            * temp4
	                            * temp40
	                            * ((2.0 * mh * width_h) / (-temp2 + temp63 + temp66 + temp67)).atan()
	                        + 6.0
	                            * mh
	                            * ((temp12 - 4.0 * temp1 * temp4 - temp4 * (temp22 + temp4)) * temp40
	                                + 8.0 * temp55.powi(2) * temp65
	                                - 4.0 * temp2 * (temp54 + temp63) * temp65)
	                            * width_h
	                            * ((temp12 + temp14 + (temp20 * temp21) / 2.0
	                                - temp1 * (cme * (2.0 * cme + temp10) + temp5)
	                                + temp4 * (temp2 + temp22 + temp67))
	                                / (temp12
	                                    + temp14
	                                    + (temp20 * temp34) / 2.0
	                                    + (-(cme * temp10) + temp2 + temp22) * temp4
	                                    + temp1 * (cme * (-2.0 * cme + temp10) + temp66)))
	                                .ln()))
	                    / (96.0
	                        * self.lam.powi(4)
	                        * mh
	                        * std::f64::consts::PI
	                        * cme.powi(2)
	                        * temp6
	                        * temp8
	                        * width_h)
	                    0.0
	            } else {
	                0.0
	            }
	        */
1bbfa9363aac051b04ba34d9cbad4b67|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|4|1|V|rust
	    /// Compute the annihilation cross-section for dark matter into photons.
	    pub fn sigma_xx_to_gg(&self, cme: f64) -> f64 {
	        0.0
	    }
c51ea9c805f9822e0b6996d89686ae68|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|8|1|V|rust
	    /// Compute the annihilation cross-section for dark matter into photons.
	    pub fn sigma_hh_to_gg(&self, cme: f64) -> f64 {
	        0.0
	    }
0b3db3d98994fab60cc1ad048a3bca20|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|8|1|V|rust
	    /// Compute the annihilation cross-section for the heavy-dark matter into photons.
	    pub fn sigma_hh_to_gg(&self, cme: f64) -> f64 {
	        0.0
	    }
d6bc6b35cb70e6feb97e2763ffb82fe6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|6|21|v|rust
	pow(q,2)
d4c0ac5d2418d94ba20ac4f7708da5e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|40|21|v|rust
	pow(m_ce, 2) + pow(m_cm, 2)
5b0b366af7e9ba09e32ac7f278aa9a70|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|53|23|v|rust
	pow(m_m1, 2)
a33a3d52c6ed1f392fa013b47b101349|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|53|48|v|rust
	pow(q, 2)
25c398e7d57d7f71b68c2acea41c818a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|68|14|v|rust
	pow(q,2);
c98f72b1133e36b03a88e9c5ee6ee8b0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|84|39|v|rust
	pow(self.cm, 2)
236288fa6393e4a59e376add6b4ab0ce|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|84|21|v|rust
	pow(self.ce, 2)
78137263c7e52fccb4259910beb6dc4b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|108|1|V|rust
	    pub fn sigma_12_to_12(&self, cme: f64) -> f64 {}
20a7b1bfb3523879bd014bb23c729be1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|109|1|V|rust
	    pub fn sigma_12_to_ww(&self, cme: f64) -> f64 {}
0c929c5390f719428ca4cea39ecca994|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|114|14|v|rust
	pow(udm,2);
4c870e4c5a44d31d90cc4c4e5490f3fb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|115|14|v|rust
	pow(q,4);
9a55feacbc8d85d8fed29677d7e463d8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|130|15|v|rust
	pow(self.ce,4);
99fe791607ef184f6ab6a803585b558e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|132|15|v|rust
	pow(self.cm,4);
84f68177d5d7ece7a54a11f14a5a1b65|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|2|1|V|rust
	use haliax_constants::electroweak::ALPHA_EM;
ca6739f058c1a63aa283a9c5ad13d0f0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|3|23|v|rust
	electroweak
edf3540ca8806e380bba8d606c914728|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|3|31|v|rust
	ALPHA_EM
c4a455f6552b89ffba4bca6c2449d3dc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|176|14|v|rust
	pow(mw,2);
1f80b5bc9463746cc7f3c35f21acf5ca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|185|19|v|rust
	pow(m_cm, 2)
9438316ab5da2ca978a834b02cd85dc9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|200|21|v|rust
	pow(q, 2);
04998ea1bbc8e6b975964cf2b7e061a2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|202|21|v|rust
	pow(q, 4);
494c327020229cdfed42c5cff5050339|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|204|21|v|rust
	pow(temp5, 2);
6ac25b159ca25f9bf74633fd00d92941|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|170|1|V|rust
	    /// Compute the cross section for x1 + x2 -> w+ + w-.
ffaed026181f24cf4f7bbee6ca980dda|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|1|v|rust
	    (8.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(6)) / (3.0 * ulam.powi(4))
bf466a0f676d1b03cf11e6b944bbe42e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|4|1|V|rust
	(8*pow(pow(self.ce,2) + pow(self.cm,2),2)*pow(self.mx,4)*pow(self.udm,6))/(3.*pow(\[Lambda],4)
a4ced94119b5858b56828997ae9f1108|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|17|v|rust
	and_ss_coeff(mx, udm, ulam, ce, cm) / (4.0 * udm * udm)
40a860bc1967aa5e8b40dee5db5bb511|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|24|v|rust
	(cm,2)
37d71ff456a7b282d7a09691a3cca2d3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|7|12|v|rust
	pow(ce,2)
d449be05d7a7f0422682dfc293efea62|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|11|1|V|rust
	    gamma_integrand_ss_coeff(mx, udm, ulam, ce, cm) * (2.0 + 2.0 * udm + udm * udm)
	        (2*pow(pow(ce,2) + pow(cm,2),2)*pow(mx,6)*pow(udm,2)*(1 + pow(1 + udm,2)))/(3.*pow(ulam,4))/ (4.0 * udm + udm)
bb27f782ff13d15d6e0adec357e0f1cd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|11|20|v|rust
	pow(cm,2)
a6f29bae5258d029bb4ff6a0a4efe2aa|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|116|18|v|rust
	000.0;
88b60fa61d5978cf25a2de5ec878e910|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|10|1|V|rust
	//use ndarray::prelude::*;
e02d2ae03de9d493df2b6b2d2813d302|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|17|v|rust
	Duration
79d792e0f9c22f7c05cbf783cdf073a2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|54|1|V|rust
	#[allow(dead_code)]
	fn full_toy() -> std::io::Result<()> {
	    let model = ToyModel {
	        mx: 100.0,
	        c0: 1e-9,
	        c1: 1e-8,
	    };
	
	    let sol = integrate_full_boltzmann(model, 100, (15.0, 100.0));
	    println!("retcode = {:?}", sol.retcode);
	    let mut file = std::fs::File::create("analysis/full_boltz_data.dat")?;
	    for (t, u) in sol {
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
	    }
	    Ok(())
	}
317335803f95972ccd69891f34e58d12|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|74|17|v|rust
	ToyModel 
539273fe5dcd38769454666a38941120|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|75|9|v|rust
	mx: 100.0,
f66067fc55c375a874b53a44f04bec7f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|75|1|V|rust
	        
	        c0: 1e-9,
	        c1: 1e-8,
	    };
51e9640c132bbb1357b7774943c9e0e6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|99|9|v|rust
	let sig = dbg!(
12cc57e46f93b095207fb0a052209b96|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|100|11|V|rust
	        sig
e55ed2752aa8197b7f2373c151a7583e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|79|9|v|rust
	let gaminv = dbg!(
afad07b6459db46b122e4107802fbbda|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|80|14|V|rust
	        gaminv
aa345096cd68378d377379822653a140|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/coup_boltz.hpp|1|1|V|cpp
	#ifndef KIN_RECOUP_COUP_BOLTZ_HPP
2bc4c29feee49a8a5108f2e1b1bf9cfb|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/coup_boltz.hpp|8|1|V|cpp
	  virtual sigmav() = 0;
99d8d743c77e8883afaec774bf25e610|file:///Users/loganmorrison/Documents/research/KineticRecoupling/cpp/kin_recoup/include/kin_recoup/coup_boltz.hpp|9|1|V|cpp
	  virtual sigmav_neq() = 0;
38a85ed8984f31f118387dbcc5207391|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/coup_boltz.rs|2|1|V|rust
	    fn sigmav() -> f64;
4da533b42361423f0ee1160abdb1adcb|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/coup_boltz.rs|2|1|V|rust
	    fn sigmav() -> f64;
	    fn sigmav2() -> f64;
d60b768802922f573f5e79aa350a3216|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/coup_boltz.rs|2|8|v|rust
	sigmav
a67a14d3bbf8745fe084174cbbc6e0ce|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|3|1|V|rust
	pub struct ToyModel {
	    pub mx: f64,
	    pub c0: f64,
	    pub c1: f64,
	}
5b6aa4754a2f27569e431a06bfe5fcf6|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|6|52|v|rust
	term 
9cab25204829cf9d0c74079778fcb1b1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|6|1|V|rust
	    /// Coefficient of the temperature-independent piece of the scattering term
c2b713cc94b0113cd71f1766ed9c877d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|117|1|V|rust
	pub struct ScalarSinglet {
	    pub ms: f64,
	    pub lam_hs: f64,
	    pub(super) gk_gamma: GaussKronrodIntegrator,
	    pub(super) gk_tcs: GaussKronrodIntegrator,
	}
105a82a2646b448f3f7206eece697593|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|24|5|V|rust
	    // Integrator 
ef5c2eb242b3f9e571336760841e9611|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|24|5|V|rust
	    pub(super) gk_tcs: GaussKronrodIntegrator,
9899dbeb8b7f913d045ce58ac2f193da|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|9|1|V|rust
	pub struct DipoleDm {
	    /// Mass of the lighest dark particle
	    pub mx: f64,
	    /// Mass splitting between lighest and heavy dark particles
	    pub dm: f64,
	    /// Cut-off scale.
	    pub lam: f64,
	    /// Electric dipole coefficient.
	    pub ce: f64,
	    /// Magnetic dipole coefficient.
	    pub cm: f64,
	    /// Decay width of heavy dark particle
	    pub width_h: f64,
	
	    /// Unitless mass splitting parameter: udm = dm/mx
	    pub(super) udm: f64,
	    /// Unitless cutoff scale: ulam = lam/mx
	    pub(super) ulam: f64,
	    /// Coefficients of s*s, t*t and s*t channel contributions to gamma
	    pub(super) gam_coeff_ss: f64,
	    pub(super) gam_coeff_tt: f64,
	    pub(super) gam_coeff_st: f64,
	    /// Integrator for computing gamma
	    pub(super) gk_gamma: GaussKronrodIntegrator,
	    /// Integrator for computing sigmav
	    pub(super) gk_sig: GaussKronrodIntegrator,
	}
95048bef75b6f36b3dee29b188418455|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|43|1|V|rust
	    /// Unitless mass splitting parameter: udm = dm/mx
	    pub(super) udm: f64,
	    /// Unitless cutoff scale: ulam = lam/mx
	    pub(super) ulam: f64,
	    /// Coefficients of s*s, t*t and s*t channel contributions to gamma
	    pub(super) gam_coeff_ss: f64,
	    pub(super) gam_coeff_tt: f64,
	    pub(super) gam_coeff_st: f64,
4e54e0a651cd33e749dc4220cc6c9e77|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|45|1|V|rust
	    /// Integrator for computing sigmav
	    pub(super) gk_sig: GaussKronrodIntegrator,
4d07d1ebb799ae9e1c859304db4b5148|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|1|1|V|rust
	pub mod gamma;
2ae28320f8b02550ae2507f76140ff4f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|2|1|V|rust
	pub mod sigma;
e773536932c61c7ee11944cefde49e30|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|3|9|v|rust
	sigma
992b3dc43a3f60373b07913d77499421|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|1|1|V|rust
	pub mod gamma;
	pub mod sigma;
466eccc67b341c88b49ecdf7d2fd07e7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/gamma.rs|1|1|V|rust
	use super::DipoleDm;
	
	pub(super) fn gamma_integrand_ss_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	    (8.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(6)) / (3.0 * ulam.powi(4))
	}
	pub(super) fn gamma_integrand_tt_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	    (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(4) * udm.powi(4)) / (3.0 * ulam.powi(4))
	}
	
	pub(super) fn gamma_integrand_st_coeff(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	    (2.0 * (ce * ce + cm * cm).powi(2) * mx.powi(6) * udm.powi(2) * (1.0 + (1.0 + udm).powi(2)))
	        / (3.0 * ulam.powi(4))
	}
	impl DipoleDm {
	    fn gamma_integrand_ss(&self, w: f64) -> f64 {
	        self.gam_coeff_ss * (w.powi(8) * (6.0 + self.udm * (-2.0 - self.udm + 14.0 * w)))
	            / ((2.0 + self.udm - 2.0 * w).powi(2) * (1.0 + 2.0 * self.udm * w).powi(3))
	    }
	    fn gamma_integrand_tt(&self, w: f64) -> f64 {
	        let t1 = w.powi(2);
	        let t2 = 2.0 + self.udm;
	        let t3 = t2.powi(2);
	        let t4 = 2.0 * w * self.udm;
	        let t5 = 1.0 + t4;
	        let t6 = 5.0 * t1 * self.udm;
	        let t7 = 1.0 + self.udm;
	        let t8 = t7.powi(2);
	        let t9 = 2.0 * t8 * w;
	        let t10 = 2.0 + t6 + t9 + self.udm;
	        self.gam_coeff_tt
	            * (t1
	                * self.udm
	                * (-12.0 * t2.powi(4)
	                    + 70.0 * w.powi(7) * self.udm.powi(3)
	                    + w.powi(6) * self.udm.powi(2) * (58.0 - 37.0 * t2 * self.udm)
	                    - 12.0 * t2.powi(3) * w * (1.0 + 6.0 * t2 * self.udm)
	                    - 6.0 * t1 * t3 * (2.0 + 3.0 * t2 * self.udm) * (-1.0 + 8.0 * t2 * self.udm)
	                    - 6.0
	                        * t3
	                        * w.powi(3)
	                        * self.udm
	                        * (-13.0 + 4.0 * t2 * self.udm * (7.0 + 4.0 * t2 * self.udm))
	                    - 2.0
	                        * t2
	                        * w.powi(4)
	                        * self.udm
	                        * (3.0 + 5.0 * t2 * self.udm * (-17.0 + 12.0 * t2 * self.udm))
	                    + 2.0
	                        * w.powi(5)
	                        * self.udm
	                        * (6.0 + t2 * self.udm * (-15.0 + 62.0 * t2 * self.udm))))
	            / (t10 * t5.powi(3))
	            + 6.0
	                * t3
	                * (-t1 + t3 + t2 * w)
	                * (t10.powi(2) / (t5.powi(2) * (2.0 + 2.0 * w + self.udm).powi(2))).ln()
	    }
	    fn gamma_integrand_st(&self, w: f64) -> f64 {
	        let t1 = 1.0 + self.udm;
	        let t2 = t1.powi(2);
	        let t3 = 2.0 + self.udm;
	        let t4 = w.powi(2);
	        let t5 = 2.0 * w;
	        let t6 = 2.0 + t5 + self.udm;
	        let t7 = 2.0 * w * self.udm;
	        let t8 = 1.0 + t7;
	        let t9 = t8.powi(-2);
	        let t10 = 2.0 * t2 * w;
	        self.gam_coeff_st
	            * (-(t4
	                * t9
	                * self.udm
	                * (6.0 * t3.powi(2)
	                    + 24.0 * t2 * t3 * w
	                    + 42.0 * t2 * w.powi(3) * self.udm
	                    + 2.0 * w.powi(4) * self.udm.powi(2)
	                    + 3.0 * t4 * (8.0 + t3 * self.udm * (23.0 + 8.0 * t3 * self.udm))))
	                + 3.0
	                    * t6.powi(2)
	                    * (2.0 + t10 + self.udm)
	                    * ((t9 * (2.0 + t10 + self.udm + 5.0 * t4 * self.udm).powi(2)) / t6.powi(2))
	                        .ln())
	            / (-2.0 + t5 - self.udm)
	    }
	    #[allow(dead_code)]
	    pub(super) fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        let ss = self.gamma_integrand_ss(w);
	        let tt = 0.0; //self.gamma_integrand_tt(w);
	        let st = 0.0; //self.gamma_integrand_st(w);
	        let temp_fac = x / (2.0 * self.mx) / ((w * x * self.udm).cosh() - 1.0);
	        let jac = self.udm * self.mx;
	
	        (ss + tt + st) * temp_fac * jac
	    }
	}
2464c9ced0a5491f10b6f135c79a72f0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/sigma.rs|1|1|V|rust
	use super::DipoleDm;
	use haliax_constants::electroweak::ALPHA_EM;
	use haliax_constants::masses::W_BOSON_MASS;
	
	impl DipoleDm {
	    /// Compute the annihilation cross-section for dark matter into photons.
	    pub fn sigma_11_to_gg(&self, cme: f64) -> f64 {
	        let q = cme / self.mx;
	        let udm = self.udm;
	        let ulam = self.ulam;
	        let temp1 = q * q;
	        let temp2 = 2.0 + udm;
	        let temp3 = -4.0 + temp1;
	        let temp4 = 2.0 * temp2 * udm;
	        let temp5 = temp3.sqrt();
	        let temp6 = -(q * temp5);
	        let temp7 = temp1 + temp4 + temp6;
	        let temp8 = 1.0 / temp7;
	        let temp9 = udm.powi(4);
	        let temp10 = temp2.powi(4);
	        let temp11 = udm.powi(5);
	        let temp12 = temp2.powi(5);
	        let temp13 = q * temp5;
	        let temp14 = temp1 + temp13 + temp4;
	        let temp15 = 1.0 / temp14;
	        let temp16 = temp1 + temp4;
	        let temp17 = udm.powi(2);
	        let temp18 = q.powi(4);
	        let temp19 = q.powi(3);
	        let temp20 = temp2.powi(2);
	        let temp21 = -36.0 * temp17 * temp20;
	        let temp22 = 6.0 * udm;
	        let temp23 = 3.0 * temp17;
	        let temp24 = 7.0 + temp22 + temp23;
	        let temp25 = 4.0 * temp1 * temp24;
	        let temp26 = -(temp19 * temp5);
	        let temp27 = 2.0 * udm;
	        let temp28 = -1.0 + temp17 + temp27;
	        let temp29 = temp19 * temp5;
	        let temp30 = 2.0 * temp17 * temp20;
	        let temp31 = 2.0 * temp1 * temp28;
	        return ((self.ce * self.ce + self.cm + self.cm).powi(2)
	            * (96.0 * temp11 * temp12 * temp15
	                + q * temp16 * (temp18 + temp21 + temp25 + temp26) * (-q + temp5)
	                + q * temp16 * (temp18 + temp21 + temp25 + temp29) * (q + temp5)
	                - 96.0 * temp11 * temp12 * temp8
	                + 48.0 * temp1 * temp10 * temp15 * temp9
	                - 48.0 * temp1 * temp10 * temp8 * temp9
	                + 12.0
	                    * (4.0 * temp1 * temp17 * temp20 * temp28 + 8.0 * temp10 * temp9
	                        - temp18
	                            * (4.0 + 10.0 * temp17 + temp9 + 12.0 * udm + 4.0 * udm.powi(3)))
	                    * ((temp18 + temp29 + temp30 + temp31 + 2.0 * q * temp2 * temp5 * udm)
	                        / (temp18 + temp26 + temp30 + temp31 - 2.0 * q * temp2 * temp5 * udm))
	                        .ln()))
	            / (192.
	                * self.mx
	                * self.mx
	                * std::f64::consts::PI
	                * q
	                * q
	                * temp16
	                * temp3
	                * ulam.powi(4));
	    }
	    /// Compute the annihilation cross-section for the heavy-dark matter into
	    /// photons.
	    pub fn sigma_22_to_gg(&self, cme: f64) -> f64 {
	        let q = cme / self.mx;
	        let temp1 = 1.0 + self.udm;
	        let temp2 = q * q;
	        let temp3 = 2.0 + self.udm;
	        let temp4 = self.udm.powi(2);
	        let temp5 = temp3.powi(2);
	        let temp6 = self.mx.powi(6);
	        let temp7 = self.udm.powi(4);
	        let temp8 = temp3.powi(4);
	        let temp9 = 2.0 * temp3 * self.udm;
	        let temp10 = q.powi(4);
	        let temp11 = temp3 * self.udm;
	        let temp12 = -2.0 * temp3 * self.udm;
	        let temp13 = temp1.powi(2);
	        let temp14 = -4.0 * temp13;
	        let temp15 = temp14 + temp2;
	        let temp16 = temp15.sqrt();
	        return ((self.ce * self.ce + self.cm * self.cm).powi(2)
	            * ((q
	                * temp6
	                * ((q - 2.0 * temp1) * (2.0 + q + 2.0 * self.udm)).sqrt()
	                * (q.powi(6) - 24.0 * temp7 * temp8
	                    + 4.0 * temp2 * temp4 * temp5 * (-1.0 + temp9)
	                    + temp10 * (14.0 + (8.0 + temp11) * temp3 * self.udm)))
	                / (3.0 * (temp2 + temp4 * temp5))
	                + (temp6
	                    * (8.0 * temp7 * temp8 - 4.0 * temp2 * temp4 * temp5 * (1.0 + temp9)
	                        + temp10 * (-4.0 + (-2.0 + temp11) * temp3 * self.udm))
	                    * ((temp12 + q * temp16 + temp2).powi(2)
	                        / (temp12 - q * temp16 + temp2).powi(2))
	                    .ln())
	                    / (temp12 + temp2)))
	            / (16.0
	                * self.mx.powi(8)
	                * std::f64::consts::PI
	                * q.powi(2)
	                * temp15
	                * self.ulam.powi(4));
	    }
	    /// Compute the annihilation cross-section for the light and heavy dark
	    /// matter into photons.
	    pub fn sigma_12_to_12(&self, cme: f64) -> f64 {
	        let q = cme / self.mx;
	        let udm = self.udm;
	
	        let temp1 = q * q;
	        let temp2 = udm * udm;
	        let temp3 = temp1 * temp1;
	        let temp4 = 41.0 * temp3;
	        let temp5 = 28.0 * temp2;
	        let temp6 = udm.powi(3);
	        let temp7 = udm.powi(4);
	        let temp8 = 9.0 * temp7;
	        let temp9 = 37.0 * temp2;
	        let temp10 = 1.0 + udm;
	        let temp11 = temp10 * temp10;
	        let temp12 = -4.0 * temp11;
	        let temp13 = temp1 + temp12;
	        let temp14 = 2.0 * udm;
	        let temp15 = 2.0 + temp14 + temp2;
	        let temp16 = self.ce * self.ce;
	        let temp17 = self.cm * self.cm;
	        let temp18 = temp16 * temp16;
	        let temp19 = 2.0 * temp3;
	        let temp20 = temp17 * temp17;
	        let temp21 = 2.0 + udm;
	        let temp22 = temp21.powi(2);
	        let temp23 = 5.0 * temp2;
	        let temp24 = -4.0 + temp1;
	        let temp25 = 4.0 * udm;
	        let temp26 = temp13 * temp24;
	        let temp27 = temp26.sqrt();
	        ((2.0
	            * temp16
	            * temp17
	            * (-74.0 * temp1 * temp15
	                + temp4
	                + 8.0 * (-8.0 + temp5 + 36.0 * temp6 + temp8 - 16.0 * udm))
	            + temp18
	                * (temp4 + 8.0 * (10.0 + temp5 + 18.0 * temp6 + temp8 + 20.0 * udm)
	                    - 2.0 * temp1 * (56.0 + temp9 + 56.0 * udm))
	            + temp20
	                * (temp4 - 2.0 * temp1 * (92.0 + temp9 + 2.0 * udm)
	                    + 8.0 * (82.0 + 136.0 * temp2 + 54.0 * temp6 + temp8 + 164.0 * udm)))
	            / (temp13 / temp24).sqrt()
	            + (12.0
	                * temp2
	                * temp22
	                * (2.0
	                    * temp16
	                    * temp17
	                    * (-5.0 * temp1 * temp15 + 6.0 * temp15 * temp15 + temp19)
	                    + temp18 * (temp19 + 6.0 * temp15 * temp2 - temp1 * (4.0 + temp23 + temp25))
	                    + temp20
	                        * (temp19 + 6.0 * temp15 * temp22 - temp1 * (16.0 + temp23 + 16.0 * udm)))
	                * ((4.0 - temp1 + 2.0 * temp2 + temp25 + temp27).powi(2)
	                    / (-4.0 + temp1 - 2.0 * temp2 + temp27 - 4.0 * udm).powi(2))
	                .ln())
	                / (temp13 * (temp1 - 2.0 * temp15)))
	            / (192.0 * self.mx * self.mx * std::f64::consts::PI * q * q * self.ulam.powi(4))
	    }
	    /// Compute the cross section for chi1 + chi2 -> w+ + w-.
	    pub fn sigma_12_to_ww(&self, cme: f64) -> f64 {
	        let q = cme / self.mx;
	        let mw = W_BOSON_MASS / self.mx;
	
	        let temp1 = q * q;
	        let temp2 = mw * mw;
	        let temp3 = temp1 * temp1;
	        let temp4 = self.ulam.powi(2);
	        let temp5 = 2.0 + self.ulam;
	        let temp6 = temp5 * temp5;
	        let temp7 = -2.0 * temp4 * temp6;
	        -(ALPHA_EM
	            * (temp1 - 4.0 * temp2).sqrt()
	            * (48.0 * mw.powi(6) - q.powi(6) + 68.0 * mw.powi(4) * temp1 - 16.0 * temp2 * temp3)
	            * (self.ce * self.ce * (temp3 + temp7 + temp1 * (-4.0 + temp4 - 4.0 * self.ulam))
	                + self.cm * self.cm * (temp3 + temp7 + temp1 * (8.0 + temp4 + 8.0 * self.ulam))))
	            / (96.0
	                * self.mx
	                * self.mx
	                * mw.powi(4)
	                * q.powi(5)
	                * (temp3 + temp4 * temp6 - 2.0 * temp1 * (2.0 + temp4 + 2.0 * self.ulam)).sqrt()
	                * self.ulam.powi(2))
	    }
	    /// Compute the cross section for chi1 + chi2 -> f + fbar.
	    pub fn sigma_12_to_ff(&self, cme: f64, massf: f64, ncol: f64, qf: f64) -> f64 {
	        let q = cme / self.mx;
	        let mf = massf / self.mx;
	
	        let temp1 = mf * mf;
	        let temp2 = q * q;
	        let temp3 = self.udm.powi(2);
	        let temp4 = temp2 * temp2;
	        let temp5 = 2.0 + self.udm;
	        let temp6 = temp5 * temp5;
	        let temp7 = -2.0 * temp3 * temp6;
	        (ALPHA_EM
	            * (-4.0 * temp1 + temp2).sqrt()
	            * (2.0 * temp1 + temp2)
	            * (self.ce * self.ce * (temp4 + temp7 + temp2 * (-4.0 + temp3 - 4.0 * self.udm))
	                + self.cm * self.cm * (temp4 + temp7 + temp2 * (8.0 + temp3 + 8.0 * self.udm))))
	            / (6.0
	                * self.mx.powi(2)
	                * q.powi(5)
	                * (temp4 + temp3 * temp6 - 2.0 * temp2 * (2.0 + temp3 + 2.0 * self.udm)).sqrt()
	                * self.ulam.powi(2))
	    }
	}
c1ca3645714c1a06354ad353003ee13f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm/width.rs|1|1|V|rust
	use super::DipoleDm;
	
	impl DipoleDm {
	    #[allow(dead_code)]
	    pub(super) fn compute_width_h(mx: f64, udm: f64, ulam: f64, ce: f64, cm: f64) -> f64 {
	        ((ce * ce + cm * cm)
	            * mx
	            * ((udm * udm * (2.0 + udm).powi(2)) / (1.0 + udm).powi(2)).powf(1.5))
	            / (8. * std::f64::consts::PI * ulam * ulam)
	    }
	}
06d6997eaa018fef075aa771b00a6a30|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/cross_sections.rs|1|1|V|rust
	use super::ScalarSinglet;
	use haliax_constants::prelude::*;
	
	impl ScalarSinglet {
	    #[allow(dead_code)]
	    pub(super) fn sigma_ss_ff(&self, cme: f64, mf: f64, ncol: f64) -> f64 {
	        if cme > 2.0 * mf && cme > 2.0 * self.ms {
	            let s = cme * cme;
	            let mh = HIGGS_MASS;
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = 1.0 / s;
	            let temp3: f64 = mh.powi(2);
	            (self.lam_hs.powi(2)
	                * ncol
	                * (s - 4.0 * temp1)
	                * temp1
	                * temp2
	                * (1.0 - 4.0 * temp1 * temp2).sqrt())
	                / (16.0
	                    * std::f64::consts::PI
	                    * (1.0 - 4.0 * self.ms * self.ms * temp2).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
	        } else {
	            0.0
	        }
	    }
	    #[allow(dead_code)]
	    pub(super) fn sigma_ss_ww(&self, cme: f64) -> f64 {
	        if cme > 2.0 * W_BOSON_MASS && cme > 2.0 * self.ms {
	            let s = cme * cme;
	            let mw = W_BOSON_MASS;
	            let mh = HIGGS_MASS;
	
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = mw.powi(2);
	            let temp3: f64 = mh.powi(2);
	            (ALPHA_EM.powi(2)
	                * self.lam_hs.powi(2)
	                * std::f64::consts::PI
	                * temp1
	                * (12.0 * mw.powi(4) + s.powi(2) - 4.0 * s * temp2)
	                * (1.0 - 4.0 * temp1 * temp2).sqrt()
	                * HIGGS_VEV.powi(4))
	                / (16.0
	                    * mw.powi(4)
	                    * SIN_THETA_WEAK_SQRD.powi(2)
	                    * (1.0 - 4.0 * self.ms * self.ms * temp1).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
	        } else {
	            0.0
	        }
	    }
	    #[allow(dead_code)]
	    pub(super) fn sigma_ss_zz(&self, cme: f64) -> f64 {
	        if cme > 2.0 * Z_BOSON_MASS && cme > 2.0 * self.ms {
	            let s = cme * cme;
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = Z_BOSON_MASS.powi(2);
	            let temp3: f64 = HIGGS_MASS.powi(2);
	            (ALPHA_EM.powi(2)
	                * self.lam_hs.powi(2)
	                * std::f64::consts::PI
	                * temp1
	                * (12.0 * Z_BOSON_MASS.powi(4) + s.powi(2) - 4.0 * s * temp2)
	                * (1.0 - 4.0 * temp1 * temp2).sqrt()
	                * HIGGS_VEV.powi(4))
	                / (16.0
	                    * COS_THETA_WEAK.powi(4)
	                    * Z_BOSON_MASS.powi(4)
	                    * SIN_THETA_WEAK_SQRD.powi(2)
	                    * (1.0 - 4.0 * self.ms * self.ms * temp1).sqrt()
	                    * ((-s + temp3).powi(2) + temp3 * HIGGS_WIDTH.powi(2)))
	        } else {
	            0.0
	        }
	    }
	    #[allow(dead_code)]
	    pub(super) fn sigma_ss_hh(&self, cme: f64) -> f64 {
	        if cme > 2.0 * HIGGS_MASS && cme > 2.0 * self.ms {
	            let s: f64 = cme * cme;
	            let temp1: f64 = 1.0 / s;
	            let temp2: f64 = self.lam_hs.powi(2);
	            let temp3: f64 = HIGGS_MASS.powi(2);
	            let temp4: f64 = self.ms.powi(2);
	            let temp5: f64 = HIGGS_MASS.powi(4);
	            let temp6: f64 = -s;
	            let temp7: f64 = temp3 + temp6;
	            let temp8: f64 = temp7.powi(2);
	            let temp9: f64 = HIGGS_WIDTH.powi(2);
	            let temp10: f64 = temp3 * temp9;
	            let temp11: f64 = temp10 + temp8;
	            let temp12: f64 = 1.0 / temp11;
	            let temp13: f64 = -temp3;
	            let temp14: f64 = s + temp13;
	            let temp15: f64 = HIGGS_VEV.powi(2);
	            let temp16: f64 = 2.0 * temp3;
	            let temp17: f64 = -4.0 * temp3;
	            let temp18: f64 = s + temp17;
	            let temp19: f64 = -4.0 * temp4;
	            let temp20: f64 = s + temp19;
	            let temp21: f64 = temp18 * temp20;
	            let temp22: f64 = 1.0 / temp21.sqrt();
	            return (temp1
	                * temp2
	                * (1.0 - 4.0 * temp1 * temp3).sqrt()
	                * (1.0
	                    + 3.0 * temp12 * (2.0 * s * temp3 + temp5)
	                    + (2.0 * temp2 * HIGGS_VEV.powi(4))
	                        / (s * temp4 - 4.0 * temp3 * temp4 + temp5)
	                    - (8.0
	                        * self.lam_hs
	                        * temp12
	                        * temp15
	                        * temp22
	                        * (temp14 * (-s * s + self.lam_hs * temp14 * temp15 + 4.0 * temp5)
	                            + temp3 * (self.lam_hs * temp15 + temp16 + temp6) * temp9)
	                        * (1.0 / (temp22 * (s - 2.0 * temp3))).atanh())
	                        / (temp16 + temp6)))
	                / (16.0 * std::f64::consts::PI * (1.0 - 4.0 * temp1 * temp4).sqrt());
	        } else {
	            0.0
	        }
	    }
	    pub fn sigma_ss(&self, cme: f64) -> f64 {
	        self.sigma_ss_ff(cme, TOP_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, CHARM_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, UP_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, BOTTOM_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, STRANGE_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, DOWN_QUARK_MASS, 3.0)
	            + self.sigma_ss_ff(cme, TAU_MASS, 1.0)
	            + self.sigma_ss_ff(cme, MUON_MASS, 1.0)
	            + self.sigma_ss_ff(cme, ELECTRON_MASS, 1.0)
	            + self.sigma_ss_zz(cme)
	            + self.sigma_ss_ww(cme)
	            + self.sigma_ss_hh(cme)
	    }
	}
a537f2c22b2058940a4caa41770a61dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet/gamma.rs|1|1|V|rust
	use super::ScalarSinglet;
	use haliax_constants::prelude::*;
	
	impl ScalarSinglet {
	    pub(super) fn gamma_integrand_sf_sf(&self, w: f64, mf: f64, ncol: f64) -> f64 {
	        let ms = self.ms;
	        let mh = HIGGS_MASS;
	
	        if w >= mf {
	            let temp1: f64 = mf.powi(2);
	            let temp2: f64 = mh.powi(2);
	            let temp3: f64 = ms.powi(2);
	            let temp4: f64 = mh.powi(-2);
	            let temp5: f64 = 2.0 * w;
	            let temp6: f64 = ms + temp5;
	            let temp7: f64 = -4.0 * temp3;
	            let temp8: f64 = temp2 + temp7;
	            let temp9: f64 = temp1 * temp8;
	            let temp10: f64 = w.powi(2);
	            let temp11: f64 = 4.0 * ms * temp10;
	            let temp12: f64 = temp2 * temp6;
	            let temp13: f64 = temp11 + temp12;
	            let temp14: f64 = ms * temp13;
	            let temp15: f64 = temp14 + temp9;
	
	            (self.lam_hs.powi(2)
	                * ncol
	                * temp1
	                * ((4.0 * (-4.0 * temp1 + temp2) * temp3 * temp4 * (mf - w) * (mf + w)) / temp15
	                    + ((temp15 * temp4) / (temp1 + ms * temp6)).ln()))
	                / 2.0
	        } else {
	            0.0
	        }
	    }
	    pub(super) fn gamma_integrand(&self, w: f64, x: f64) -> f64 {
	        let temp = x / self.ms;
	        let temp_fac = 1.0 / (2.0 * temp) / (1.0 + (w / temp).cosh());
	        let mut sum = 0.0;
	
	        sum += self.gamma_integrand_sf_sf(w, TOP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, CHARM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, UP_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, DOWN_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, STRANGE_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, BOTTOM_QUARK_MASS, 3.0);
	        sum += self.gamma_integrand_sf_sf(w, ELECTRON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, MUON_MASS, 0.0);
	        sum += self.gamma_integrand_sf_sf(w, TAU_MASS, 0.0);
	        temp_fac * sum
	    }
	}
c9c8c607dd616e74dd8cb32de5c8a926|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/dipole_dm.rs|5|1|V|rust
	use crate::full_boltz::FullBoltzmann;
	use cyphus_integration::prelude::*;
	use gamma::*;
	
	pub struct DipoleDm {
	    /// Mass of the lighest dark particle
	    pub mx: f64,
	    /// Mass splitting between lighest and heavy dark particles
	    pub dm: f64,
	    /// Cut-off scale.
	    pub lam: f64,
	    /// Electric dipole coefficient.
	    pub ce: f64,
	    /// Magnetic dipole coefficient.
	    pub cm: f64,
	    /// Decay width of heavy dark particle
	    pub width_h: f64,
	
	    /// Unitless mass splitting parameter: udm = dm/mx
	    pub(super) udm: f64,
	    /// Unitless cutoff scale: ulam = lam/mx
	    pub(super) ulam: f64,
	    /// Coefficients of s*s, t*t and s*t channel contributions to gamma
	    pub(super) gam_coeff_ss: f64,
	    pub(super) gam_coeff_tt: f64,
	    pub(super) gam_coeff_st: f64,
	    /// Integrator for computing gamma
	    pub(super) gk_gamma: GaussKronrodIntegrator,
	    /// Integrator for computing sigmav
	    pub(super) gk_sig: GaussKronrodIntegrator,
	}
	
	impl DipoleDm {
	    pub fn new(mx: f64, dm: f64, lam: f64, ce: f64, cm: f64) -> DipoleDm {
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .singular_points(vec![1.0])
	            .build();
	        let gk_sig = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
	
	        let udm = dm / mx;
	        let ulam = lam / mx;
	        let width_h = DipoleDm::compute_width_h(mx, udm, ulam, ce, cm);
	
	        DipoleDm {
	            mx,
	            dm,
	            lam,
	            ce,
	            cm,
	            udm,
	            ulam,
	            gk_gamma,
	            gk_sig,
	            width_h,
	            gam_coeff_ss: gamma_integrand_ss_coeff(mx, udm, ulam, ce, cm),
	            gam_coeff_tt: gamma_integrand_tt_coeff(mx, udm, ulam, ce, cm),
	            gam_coeff_st: gamma_integrand_st_coeff(mx, udm, ulam, ce, cm),
	        }
	    }
	}
	
	impl FullBoltzmann for DipoleDm {
	    fn gamma_hinv(&self, x: f64) -> f64 {
	        let pre = 1.0 / (48.0 * (std::f64::consts::PI * self.mx).powi(3) * 2.0 * self.mx / x);
	        let f = |w: f64| self.gamma_integrand(w, x);
	        let gam = self.gk_gamma.integrate(&f, 0.0, f64::INFINITY).val;
	
	        pre * gam / crate::full_boltz::hubblet(self.mx / x)
	    }
	    fn feq(&self, x: f64, q: f64) -> f64 {
	        let e = (q * q + x * x).sqrt(); // energy / temperature
	        1.0 / (e.exp() + 1.0)
	    }
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        let temp = self.mx / x;
	        let k = temp * q;
	        let kt = temp * qt;
	        let f = |theta: f64| -> f64 {
	            let e1 = (k * k + self.mx * self.mx).sqrt();
	            let e2 = (kt * kt + self.mx * self.mx).sqrt();
	            // (E1;k).(E2;kt)
	            let dot = e1 * e2 - k * kt * theta;
	
	            let vmol = (dot * dot - self.mx.powi(4)).sqrt() / (e1 * e2);
	            let cme = 2.0 * self.mx * self.mx + 2.0 * dot;
	            self.sigma_11_to_gg(cme) * vmol
	        };
	        self.gk_sig.integrate(f, -1.0, 1.0).val / 2.0
	    }
	    fn dm_mass(&self) -> f64 {
	        self.mx
	    }
	    fn g(&self) -> f64 {
	        2.0
	    }
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_gamma() {
	        let model = DipoleDm::new(100.0, 0.1, 1e4, 1.0, 1.0);
	        let x = 1.0;
	        //let pre = 1.0 / (48.0 * (std::f64::consts::PI * model.ml).powi(3) * 2.0 * model.ml / x);
	        let f = |w: f64| model.gamma_integrand(w, x);
	        let gam = model.gk_gamma.integrate(&f, 0.0, f64::INFINITY);
	        println!("{:e}", model.width_h);
	        println!("{:e}", gam.val);
	    }
	}
33671287cda15641f9b34b108d12bfb0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/scalar_singlet.rs|3|1|V|rust
	
	use cyphus_integration::prelude::*;
	use cyphus_specfun::bessel::CylBesselK;
	use haliax_constants::masses::HIGGS_MASS;
	use lazy_static::lazy_static;
	use std::num::FpCategory;
	
	lazy_static! {
	    static ref GAUSS_LEG_NS: [f64; 50] = [
	        -0.998866404420071,
	        -0.9940319694320907,
	        -0.9853540840480058,
	        -0.972864385106692,
	        -0.9566109552428079,
	        -0.936656618944878,
	        -0.9130785566557919,
	        -0.8859679795236131,
	        -0.8554297694299461,
	        -0.821582070859336,
	        -0.7845558329003993,
	        -0.7444943022260685,
	        -0.7015524687068222,
	        -0.6558964656854394,
	        -0.6077029271849502,
	        -0.5571583045146501,
	        -0.5044581449074642,
	        -0.44980633497403877,
	        -0.39341431189756515,
	        -0.33550024541943735,
	        -0.276288193779532,
	        -0.21600723687604176,
	        -0.1548905899981459,
	        -0.09317470156008614,
	        -0.03109833832718888,
	        0.03109833832718888,
	        0.09317470156008614,
	        0.1548905899981459,
	        0.21600723687604176,
	        0.276288193779532,
	        0.33550024541943735,
	        0.39341431189756515,
	        0.44980633497403877,
	        0.5044581449074642,
	        0.5571583045146501,
	        0.6077029271849502,
	        0.6558964656854394,
	        0.7015524687068222,
	        0.7444943022260685,
	        0.7845558329003993,
	        0.821582070859336,
	        0.8554297694299461,
	        0.8859679795236131,
	        0.9130785566557919,
	        0.936656618944878,
	        0.9566109552428079,
	        0.972864385106692,
	        0.9853540840480058,
	        0.9940319694320907,
	        0.998864044200716,
	    ];
	    static ref GAUSS_LEG_WS: [f64; 50] = [
	        0.0029086225531551016,
	        0.006759799195745375,
	        0.010590548383650852,
	        0.01438082276148563,
	        0.018115560713489423,
	        0.021780243170124725,
	        0.025360673570012402,
	        0.028842993580535152,
	        0.03221372822357803,
	        0.03545983561514616,
	        0.038568756612587685,
	        0.04152846309014772,
	        0.04432750433880324,
	        0.04695505130394836,
	        0.049400938449466275,
	        0.05165570306958109,
	        0.05371062188899619,
	        0.05555774480621255,
	        0.057189925647728415,
	        0.058600849813222416,
	        0.05978505870426544,
	        0.06073797084177024,
	        0.06145589959031668,
	        0.061936067420683256,
	        0.0621766166553472,
	        0.0621766166553472,
	        0.061936067420683256,
	        0.06145589959031668,
	        0.06073797084177024,
	        0.05978505870426544,
	        0.058600849813222416,
	        0.057189925647728415,
	        0.05555774480621255,
	        0.05371062188899619,
	        0.05165570306958109,
	        0.049400938449466275,
	        0.04695505130394836,
	        0.04432750433880324,
	        0.04152846309014772,
	        0.038568756612587685,
	        0.03545983561514616,
	        0.03221372822357803,
	        0.028842993580535152,
	        0.025360673570012402,
	        0.021780243170124725,
	        0.018115560713489423,
	        0.01438082276148563,
	        0.01059048383650852,
	        0.006759799195745375,
	        0.00290862255315510165,
	    ];
	}
	
	pub struct ScalarSinglet {
	    pub ms: f64,
	    pub lam_hs: f64,
	    pub(super) gk_gamma: GaussKronrodIntegrator,
	    pub(super) gk_tcs: GaussKronrodIntegrator,
	}
	
	impl ScalarSinglet {
	    pub fn new(ms: f64, lam: f64) -> ScalarSinglet {
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
	
	        let resonance = HIGGS_MASS / ms;
	        let threshold = 2.0 * HIGGS_MASS / ms;
	
	        let singular_points = if threshold > 2.0 {
	            if resonance > 2.0 {
	                vec![resonance, threshold]
	            } else {
	                vec![threshold]
	            }
	        } else {
	            vec![]
	        };
	        let gk_tcs = GaussKronrodIntegratorBuilder::default()
	            .singular_points(singular_points)
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
	
	        ScalarSinglet {
	            ms,
	            lam_hs: lam,
	            gk_gamma,
	            gk_tcs,
	        }
	    }
	}
	
	impl crate::full_boltz::FullBoltzmann for ScalarSinglet {
	    fn dm_mass(&self) -> f64 {
	        self.ms
	    }
	    fn g(&self) -> f64 {
	        1.0
	    }
	    fn feq(&self, x: f64, q: f64) -> f64 {
	        let e = (q * q + x * x).sqrt(); // energy / temperature
	        1.0 / (e.exp() - 1.0)
	    }
	    /// Compute the momentum exchange rate between the DM and SM.
	    fn gamma_hinv(&self, x: f64) -> f64 {
	        let f = |w: f64| self.gamma_integrand(w, x);
	        let pre = 1.0 / (48.0 * (self.ms * std::f64::consts::PI).powi(3)) / 8.0;
	        let int = self.gk_gamma.integrate(f, 0.0, f64::INFINITY).val;
	        let ht = crate::full_boltz::hubblet(self.ms / x);
	        pre * int / ht
	    }
	    /// Compute sigma*vmol averaged over angles of two incoming DM particles with
	    /// three-momenta which have magnitudes k1 and k2.
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        let temp = self.ms / x;
	        let k1 = q * temp;
	        let k2 = qt * temp;
	        let ms2 = self.ms * self.ms;
	        let e1 = (k1 * k1 + ms2).sqrt();
	        let e2 = (k2 * k2 + ms2).sqrt();
	
	        let mut sum = 0.0;
	
	        for (theta, wgt) in (*GAUSS_LEG_NS).iter().zip((*GAUSS_LEG_WS).iter()) {
	            // p1.p2
	            let dot = e1 * e2 - k1 * k2 * theta;
	            // Moler velocity
	            let vmol = (dot * dot - self.ms.powi(4)).sqrt() / (e1 * e2);
	            // s = (p1 + p2)^2
	            let cme = (2.0 * ms2 + 2.0 * dot).sqrt();
	            let t = wgt * vmol * self.sigma_ss(cme);
	            sum += if t.classify() == FpCategory::Nan {
	                0.0
	            } else {
	                t
	            };
	        }
	        sum / 2.0
	    }
	}
	
	impl crate::simple_boltz::SimpleBoltzmann for ScalarSinglet {
	    fn mass(&self) -> f64 {
	        self.ms
	    }
	    fn thermal_cross_section(&self, x: f64) -> f64 {
	        let m = self.ms;
	        let denom = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (denom * denom);
	        let integrand = |z: f64| -> f64 {
	            let z2 = z * z;
	            let sig = self.sigma_ss(m * z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	
	        pf * self.gk_tcs.integrate(integrand, 2.0, f64::INFINITY).val
	    }
	}
aec3b0cca54ba7faa38d7070014a27fc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|34|13|V|rust
	            udm,
bf5a0a525e316013e6c385be0ba194dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|34|13|V|rust
	            ulam,
8832e447a9666af518a3196c04efce02|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|37|13|V|rust
	            gam_coeff_ss: gamma_integrand_ss_coeff(mx, udm, ulam, ce, cm),
6e90ca275b47e012c04ba2aafa4af040|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|37|13|V|rust
	            gam_coeff_tt: gamma_integrand_tt_coeff(mx, udm, ulam, ce, cm),
5d4a075ea21ebc398a95e8a1f56cbb42|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|37|13|V|rust
	            gam_coeff_st: gamma_integrand_st_coeff(mx, udm, ulam, ce, cm),
5c4a80625f0abd20a77e395b83055858|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|48|1|V|rust
	    pub(super) gam_coeff_ss:f64,
181ce62bfe5b6602a91daa4edf621c7d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|48|1|V|rust
	    /// Coefficient of the s-channel contribution to gamma
c7c7716b55d7048e96c9a6b5b77452e2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|52|28|v|rust
	s-channel
f3cd9b11ce547533ae91cc3a5e4200dd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|53|38|V|rust
	    // Integrator for computing gamma
	    pub(super) gk_gamma: GaussKronrodIntegrator,
	    // Integrator for thermal cross section
	    pub(super) gk_sig: GaussKronrodIntegrator,
b87f58a047486c7d3c194a3c9e99ca48|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|26|1|V|rust
	    // Integrator used to compute the momentum transfer term.
	    pub(super) gk_gamma: GaussKronrodIntegrator,
cd4abbba07a961b9379e1adbe8fba530|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|34|1|V|rust
	            gk_gamma,
	            gk_sig,
143752ecffd549e3d38073b0d88dee18|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|12|1|V|rust
	        let gk_gamma = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .singular_points(vec![1.0])
	            .build();
b6b3562bcd676c3aab91392ccdc06af8|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models.rs|5|1|V|rust
	use cyphus_integration::prelude::GaussKronrodIntegrator;
10f6980a9e490e95b1274a42185a38ab|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm/gamma.rs|59|1|V|rust
	        let udm = self.dm / self.mx;
79f056143aea8ab8d9cdc70bd9ff9048|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm/sigma.rs|112|9|V|rust
	        let udm = udm;
a8fabfde7e43d3715a79ecc2790b8d1a|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm/sigma.rs|70|1|V|rust
	        let udm = self.dm / self.mx;
	        let ulam = self.lam / self.mx;
fa6b278bb4407e275f2f36a4e6e51ad7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm/sigma.rs|11|1|V|rust
	        let udm = udm;
	        let ulam = ulam;
0cde4b7212b7c0c4d4808587002afa59|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm/sigma.rs|10|1|V|rust
	        let ulam = self.lam / self.mx;
7511437a8e0fbd9bf1f1c8d5fa7d3f37|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|3|1|V|rust
	pub mod dipole_dm;
e090c76184cc01bfb4f4e69df4053ca3|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/deriv_utils.rs|1|1|V|rust
	//! This submodule contains various function for computing the finite
	//! difference derivatives of a discrete vector:
	//!     df/dq     ~ sum(a[i] f[i])
	//!     d^2f/dq^2 ~ sum(b[i] f[i])
	//! where the coefficients `a` and `b` are determined by the stencil and
	//! derivative order. We use the following stencils:
	//!
	//! for first derivatives:
	//!     left-most point:          s = [0, 1, 2, 3]      (forward)
	//!     next-to-left-most point:  s = [-1, 0, 1, 2]     (forward)
	//!     next-to-right-most point: s = [-2, -1, 0, 1]    (backward)
	//!     right-most point:         s = [-3, -2, -1, 0]   (backward)
	//!     all other:                s = [-2, -1, 0, 1, 2] (central)
	//! for second derivatives:
	//!     left-most point:          s = [0, 1, 2, 3, 4]     (forward)
	//!     next-to-left-most point:  s = [-1, 0, 1, 2, 3]    (forward)
	//!     next-to-right-most point: s = [-3, -2, -1, 0, 1]  (backward)
	//!     right-most point:         s = [-4, -3, -2, -1, 0] (backward)
	//!     all other:                s = [-2, -1, 0, 1, 2]   (central)
	//! These stencils lead to the following finite-difference coefficients:
	//!     left-most point:          a[0]=-11/6, a[1]=3, a[2]=3/2, a[3]=1/3
	//!     next-to-left-most point:  a[0]=-1/3, a[1]=-1/2, a[2]=1, a[3]=-1/6
	//!     next-to-right-most point:
	//!     right-most point:         
	//!     all other:                
	//!     
	//!
	use ndarray::prelude::*;
	
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn first_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	    let mut dv = Array1::<f64>::zeros(n);
	    let den = 6.0 * h;
	
	    // Use forward derivatives for first two entries
	    dv[0] = array![-11.0, 18.0, -9.0, 2.0].dot(&v.slice(s![..4])) / den;
	    dv[1] = array![-2.0, -3.0, 6.0, -1.0].dot(&v.slice(s![..4])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![1.0, -6.0, 3.0, 2.0].dot(&v.slice(s![-4..])) / den;
	    dv[n - 1] = array![-2.0, 9.0, -18.0, 11.0].dot(&v.slice(s![-4..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![1.0, -8.0, 0.0, 8.0, -1.0].dot(&v.slice(s![i - 2..i + 3])) / (2.0 * den);
	    }
	
	    dv
	}
	
	/// Construct the first derivative vector from `v` using a 5-pt stencil.
	pub fn jac_first_deriv_vec(n: usize, h: f64) -> Array2<f64> {
	    let mut dv = Array2::<f64>::zeros((n, n));
	    let den = 6.0 * h;
	
	    // Use forward derivatives for first two entries
	    dv.slice_mut(s![0, ..4])
	        .assign(&(array![-11.0, 18.0, -9.0, 2.0] / den));
	    dv.slice_mut(s![1, ..4])
	        .assign(&(array![-2.0, -3.0, 6.0, -1.0] / den));
	
	    // Use backwards derivatives for last two entries
	    dv.slice_mut(s![n - 2, -4..])
	        .assign(&(array![1.0, -6.0, 3.0, 2.0] / den));
	    dv.slice_mut(s![n - 1, -4..])
	        .assign(&(array![-2.0, 9.0, -18.0, 11.0] / den));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3])
	            .assign(&(array![1.0, -8.0, 0.0, 8.0, -1.0] / (2.0 * den)));
	    }
	
	    dv
	}
	
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn second_deriv_vec(v: ArrayView1<f64>, h: f64) -> Array1<f64> {
	    let n = v.len();
	
	    let mut dv = Array1::<f64>::zeros(n);
	    let den = 12.0 * h * h;
	    // Use forward derivatives for first two entries
	    dv[0] = array![35.0, -104.0, 114.0, -56.0, 11.0,].dot(&v.slice(s![..5])) / den;
	    dv[1] = array![11.0, -20.0, 6.0, 4.0, -1.0,].dot(&v.slice(s![..5])) / den;
	
	    // Use backwards derivatives for last two entries
	    dv[n - 2] = array![-1.0, 4.0, 6.0, -20.0, 11.0].dot(&v.slice(s![-5..])) / den;
	    dv[n - 1] = array![11.0, -56.0, 114.0, -104.0, 35.0,].dot(&v.slice(s![-5..])) / den;
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv[i] = array![-1.0, 16.0, -30.0, 16.0, -1.0,].dot(&v.slice(s![i - 2..i + 3])) / den;
	    }
	
	    dv
	}
	
	/// Construct the second derivative vector from `v` using a 5-pt stencil.
	pub fn jac_second_deriv_vec(n: usize, h: f64) -> Array2<f64> {
	    let mut dv = Array2::<f64>::zeros((n, n));
	    let den = 12.0 * h * h;
	    // Use forward derivatives for first two entries
	    dv.slice_mut(s![0, ..5])
	        .assign(&(array![35.0, -104.0, 114.0, -56.0, 11.0,] / den));
	    dv.slice_mut(s![0, ..5])
	        .assign(&(array![11.0, -20.0, 6.0, 4.0, -1.0,] / den));
	
	    // Use backwards derivatives for last two entries
	    dv.slice_mut(s![n - 2, -5..])
	        .assign(&(array![-1.0, 4.0, 6.0, -20.0, 11.0] / den));
	    dv.slice_mut(s![n - 1, -5..])
	        .assign(&(array![11.0, -56.0, 114.0, -104.0, 35.0,] / den));
	
	    // use central difference of all other points
	    for i in 2..(n - 2) {
	        dv.slice_mut(s![i, i - 2..i + 3])
	            .assign(&(array![-1.0, 16.0, -30.0, 16.0, -1.0,] / den));
	    }
	
	    dv
	}
5118e873d937da63c67fbdae6f9a50ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/scalar_singlet.rs|8|1|V|rust
	use lazy_static::lazy_static;
	use std::num::FpCategory;
	
	lazy_static! {
	    static ref GAUSS_LEG_NS: [f64; 50] = [
	        -0.998866404420071,
	        -0.9940319694320907,
	        -0.9853540840480058,
	        -0.972864385106692,
	        -0.9566109552428079,
	        -0.936656618944878,
	        -0.9130785566557919,
	        -0.8859679795236131,
	        -0.8554297694299461,
	        -0.821582070859336,
	        -0.7845558329003993,
	        -0.7444943022260685,
	        -0.7015524687068222,
	        -0.6558964656854394,
	        -0.6077029271849502,
	        -0.5571583045146501,
	        -0.5044581449074642,
	        -0.44980633497403877,
	        -0.39341431189756515,
	        -0.33550024541943735,
	        -0.276288193779532,
	        -0.21600723687604176,
	        -0.1548905899981459,
	        -0.09317470156008614,
	        -0.03109833832718888,
	        0.03109833832718888,
	        0.09317470156008614,
	        0.1548905899981459,
	        0.21600723687604176,
	        0.276288193779532,
	        0.33550024541943735,
	        0.39341431189756515,
	        0.44980633497403877,
	        0.5044581449074642,
	        0.5571583045146501,
	        0.6077029271849502,
	        0.6558964656854394,
	        0.7015524687068222,
	        0.7444943022260685,
	        0.7845558329003993,
	        0.821582070859336,
	        0.8554297694299461,
	        0.8859679795236131,
	        0.9130785566557919,
	        0.936656618944878,
	        0.9566109552428079,
	        0.972864385106692,
	        0.9853540840480058,
	        0.9940319694320907,
	        0.998864044200716,
	    ];
	    static ref GAUSS_LEG_WS: [f64; 50] = [
	        0.0029086225531551016,
	        0.006759799195745375,
	        0.010590548383650852,
	        0.01438082276148563,
	        0.018115560713489423,
	        0.021780243170124725,
	        0.025360673570012402,
	        0.028842993580535152,
	        0.03221372822357803,
	        0.03545983561514616,
	        0.038568756612587685,
	        0.04152846309014772,
	        0.04432750433880324,
	        0.04695505130394836,
	        0.049400938449466275,
	        0.05165570306958109,
	        0.05371062188899619,
	        0.05555774480621255,
	        0.057189925647728415,
	        0.058600849813222416,
	        0.05978505870426544,
	        0.06073797084177024,
	        0.06145589959031668,
	        0.061936067420683256,
	        0.0621766166553472,
	        0.0621766166553472,
	        0.061936067420683256,
	        0.06145589959031668,
	        0.06073797084177024,
	        0.05978505870426544,
	        0.058600849813222416,
	        0.057189925647728415,
	        0.05555774480621255,
	        0.05371062188899619,
	        0.05165570306958109,
	        0.049400938449466275,
	        0.04695505130394836,
	        0.04432750433880324,
	        0.04152846309014772,
	        0.038568756612587685,
	        0.03545983561514616,
	        0.03221372822357803,
	        0.028842993580535152,
	        0.025360673570012402,
	        0.021780243170124725,
	        0.018115560713489423,
	        0.01438082276148563,
	        0.01059048383650852,
	        0.006759799195745375,
	        0.00290862255315510165,
	    ];
	}
b4176860353597fcbe93ad4cc2f7e836|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/utilities/integration.rs|3|1|V|rust
	use std::num::FpCategory;
db7392b039259926ed14a71f418a6b1b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|12|v|rust
	deriv_utils
f75369b9e0ef2282b4d10e367e4ee2a9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/utils.rs|1|9|v|rust
	derivatives
2bcbb458e26c05021e0a90a32c677535|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|8|9|v|rust
	utlities;
16a13a3ba91b630a84fa4eeb7ecddef2|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|2|1|V|rust
	pub mod deriv_utils;
b265e0bd7289194b451911f7813927d5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|12|v|rust
	utlities::derivatives::*;
3cac9f6673cbc0ecb865ea2c849b71ea|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/utils.rs|1|9|v|rust
	differentiate;
b4dcc019d86a1afccd11ea402b0b3848|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/utils.rs|2|9|v|rust
	integrate;
83c8bc48febad1d5bcebbf52d7662f35|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|19|v|rust
	differentiate::*;
d452857fc29867199916bae3ab66255c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/scalar_singlet.rs|11|1|V|rust
	lazy_static! {
	    static ref GAUSS_LEG_NS: [f64; 50] = [
	        -0.998866404420071,
	        -0.9940319694320907,
	        -0.9853540840480058,
	        -0.972864385106692,
	        -0.9566109552428079,
	        -0.936656618944878,
	        -0.9130785566557919,
	        -0.8859679795236131,
	        -0.8554297694299461,
	        -0.821582070859336,
	        -0.7845558329003993,
	        -0.7444943022260685,
	        -0.7015524687068222,
	        -0.6558964656854394,
	        -0.6077029271849502,
	        -0.5571583045146501,
	        -0.5044581449074642,
	        -0.44980633497403877,
	        -0.39341431189756515,
	        -0.33550024541943735,
	        -0.276288193779532,
	        -0.21600723687604176,
	        -0.1548905899981459,
	        -0.09317470156008614,
	        -0.03109833832718888,
	        0.03109833832718888,
	        0.09317470156008614,
	        0.1548905899981459,
	        0.21600723687604176,
	        0.276288193779532,
	        0.33550024541943735,
	        0.39341431189756515,
	        0.44980633497403877,
	        0.5044581449074642,
	        0.5571583045146501,
	        0.6077029271849502,
	        0.6558964656854394,
	        0.7015524687068222,
	        0.7444943022260685,
	        0.7845558329003993,
	        0.821582070859336,
	        0.8554297694299461,
	        0.8859679795236131,
	        0.9130785566557919,
	        0.936656618944878,
	        0.9566109552428079,
	        0.972864385106692,
	        0.9853540840480058,
	        0.9940319694320907,
	        0.998864044200716,
	    ];
	    static ref GAUSS_LEG_WS: [f64; 50] = [
	        0.0029086225531551016,
	        0.006759799195745375,
	        0.010590548383650852,
	        0.01438082276148563,
	        0.018115560713489423,
	        0.021780243170124725,
	        0.025360673570012402,
	        0.028842993580535152,
	        0.03221372822357803,
	        0.03545983561514616,
	        0.038568756612587685,
	        0.04152846309014772,
	        0.04432750433880324,
	        0.04695505130394836,
	        0.049400938449466275,
	        0.05165570306958109,
	        0.05371062188899619,
	        0.05555774480621255,
	        0.057189925647728415,
	        0.058600849813222416,
	        0.05978505870426544,
	        0.06073797084177024,
	        0.06145589959031668,
	        0.061936067420683256,
	        0.0621766166553472,
	        0.0621766166553472,
	        0.061936067420683256,
	        0.06145589959031668,
	        0.06073797084177024,
	        0.05978505870426544,
	        0.058600849813222416,
	        0.057189925647728415,
	        0.05555774480621255,
	        0.05371062188899619,
	        0.05165570306958109,
	        0.049400938449466275,
	        0.04695505130394836,
	        0.04432750433880324,
	        0.04152846309014772,
	        0.038568756612587685,
	        0.03545983561514616,
	        0.03221372822357803,
	        0.028842993580535152,
	        0.025360673570012402,
	        0.021780243170124725,
	        0.018115560713489423,
	        0.01438082276148563,
	        0.01059048383650852,
	        0.006759799195745375,
	        0.00290862255315510165,
	    ];
	}
5c555fb430248cbce1cd455f58fcfe94|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/scalar_singlet.rs|15|1|V|rust
	        let resonance = HIGGS_MASS / ms;
	        let threshold = 2.0 * HIGGS_MASS / ms;
	
	        let singular_points = if threshold > 2.0 {
	            if resonance > 2.0 {
	                vec![resonance, threshold]
	            } else {
	                vec![threshold]
	            }
	        } else {
	            vec![]
	        };
	        let gk_tcs = GaussKronrodIntegratorBuilder::default()
	            .singular_points(singular_points)
	            .epsrel(1e-8)
	            .epsabs(0.0)
	            .key(2)
	            .build();
02f89c6763630fa36ab0e5654733ec3b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/scalar_singlet.rs|15|13|V|rust
	            gk_tcs,
03848fc5e2516dc3040bbe7d2a659743|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|4|1|V|rust
	pub mod scalar_singlet;
ff1665a72b0fadd46fb8f9854eae6c3c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|8|5|v|rust
	dipole_dm::*;
88f8ec4622e46269bf056a29b04ffbd0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|11|1|V|rust
	use scalar_singlet::*;
6204ead93a658c2ae42c3dfe03e643af|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|14|1|V|rust
	use toy::*;
880c3fb9e772579e1f998c7e07345697|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/toy.rs|1|1|V|rust
	use crate::full_boltz::FullBoltzmann;
	
	pub struct ToyModel {
	    pub mx: f64,
	    pub c0: f64,
	    pub c1: f64,
	}
	
	impl FullBoltzmann for ToyModel {
	    fn feq(&self, x: f64, q: f64) -> f64 {
	        (-(x * x + q * q).sqrt()).exp()
	    }
	    fn gamma_hinv(&self, temp: f64) -> f64 {
	        let x = self.mx / temp;
	        100.0 * (10.0 / x).powi(3)
	    }
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64 {
	        let t = (x * x + q * q) * (x * x + qt * qt);
	        self.c0 + self.c1 * (1.0 - x.powi(4) / (q * qt * t.sqrt()) * (q * qt / t.sqrt()).atanh())
	    }
	    fn dm_mass(&self) -> f64 {
	        self.mx
	    }
	    fn g(&self) -> f64 {
	        1.0
	    }
	}
7de11beb5b46e5c90dbe11f685311737|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/toy.rs|3|1|V|rust
	pub struct ToyModel { pub mx: f64,
	    pub c0: f64,
	    pub c1: f64,
	}
2436619acd33c1b1ae7de3eeaea2a459|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|5|1|V|rust
	pub mod toy;
6ab2d249e95ea40a8bb3c7268f69edbd|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|5|1|V|rust
	pub mod utils;
2b3583e6e17721c54496bd04e57a0c15|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|6|9|v|rust
	utils
1b3231655cebb7a1f783eddf27d254ca|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/toy.rs|4|24|v|rust
	super
06277043be9738b9ebd5bc004a04598b|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|11|1|V|rust
	pub trait FullBoltzmann {
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate divided by ht
	    fn gamma_hinv(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
	}
0c6157bbbeec08a7fec915531a873d27|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|6|1|V|rust
	pub trait SimpleBoltzmann {
	    fn thermal_cross_section(&self, x: f64) -> f64;
	    fn mass(&self) -> f64;
	}
4540aef2cc4cf2c77ab3c59420401a63|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/coup_boltz.rs|1|1|V|rust
	pub trait CoupledBoltzmann {
	    fn sigmav(&self, x: f64) -> f64;
	    fn sigmav2(&self, x: f64) -> f64;
	    fn sigmav_neq(&self, x: f64) -> f64;
	    fn sigmav2_neq(&self, x: f64) -> f64;
	}
bc565c2d3054ebc377590588fd152389|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/full_boltz.rs|1|1|V|rust
	use crate::utils::derivatives::*;
	use cyphus_diffeq::prelude::*;
	use haliax_constants::cosmology::M_PLANK;
	use haliax_thermal_functions::prelude::*;
	use ndarray::parallel::prelude::*;
	use ndarray::prelude::*;
	use ndarray::Zip;
	use std::f64::consts::PI;
	use std::iter::FromIterator;
	
	pub trait FullBoltzmann {
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate divided by ht
	    fn gamma_hinv(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
	}
	
	pub fn gefft(temp: f64) -> f64 {
	    sm_sqrt_gstar(temp) * sm_geff(temp).sqrt() / sm_heff(temp) - 1.0
	}
	
	pub fn hubblet(temp: f64) -> f64 {
	    let h = (4.0 * PI.powi(3) * sm_geff(temp) / 45.0).sqrt() * temp * temp / M_PLANK;
	    h / (1.0 + gefft(temp))
	}
	
	pub fn compute_dfi<T: FullBoltzmann>(
	    i: usize,
	    n: usize,
	    x: f64,
	    f: ArrayView1<f64>,
	    feq: ArrayView1<f64>,
	    qs: ArrayView1<f64>,
	    dq: f64,
	    dfi: f64,
	    d2fi: f64,
	    pre: f64,
	    gam: f64,
	    gt: f64,
	    p: &T,
	) -> f64 {
	    let qi = qs[i];
	    let fi = f[i];
	    let feqi = feq[i];
	
	    let mut deriv = 0.0;
	    // Integrate the scattering matrix using trapizoid rule
	    for k in 0..n {
	        let qk = qs[k];
	        let feqk = feq[k];
	        let fk = f[k];
	        let wgt = if k == 0 || k == n - 1 { 0.5 } else { 1.0 };
	        deriv += wgt * qk * qk * p.sigmav(x, qi, qk) * (feqi * feqk - fi * fk);
	    }
	    deriv *= pre * dq;
	    // We skip these terms at the end since df/dx(qf) = 0.0;
	    if i != n - 1 {
	        // Compute the elastic scattering term
	        let xq = (x * x + qi * qi).sqrt();
	        let dfi = dfi;
	        deriv += gam / (2.0 * x) * (xq * d2fi + (qi + 2.0 * xq / qi + qi / xq) * dfi + 3.0 * fi);
	        // Compute the expansion term
	        deriv += gt * qi / x * dfi;
	    }
	    deriv
	}
	
	pub fn compute_j_dfi<T: FullBoltzmann>(
	    i: usize,
	    j: usize,
	    n: usize,
	    x: f64,
	    f: ArrayView1<f64>,
	    qs: ArrayView1<f64>,
	    dq: f64,
	    j_df: f64,
	    j_d2f: f64,
	    pre: f64,
	    gam: f64,
	    gt: f64,
	    p: &T,
	) -> f64 {
	    let mut jac = 0.0;
	    let qi = qs[i];
	    // Integrate the jacobian of the scattering matrix using
	    // trapizoid rule
	    for k in 0..n {
	        jac += -qs[k].powi(2)
	            * p.sigmav(x, qi, qs[k])
	            * if k == 0 || k == n - 1 { 0.5 } else { 1.0 }
	            * pre
	            * dq
	            * if i == j && i == k {
	                f[k] + f[i]
	            } else if i == j {
	                f[k]
	            } else if i == k {
	                f[i]
	            } else {
	                0.0
	            }
	    }
	    if i != n - 1 {
	        let xq = (x * x + qi * qi).sqrt();
	        jac += gam / (2.0 * x)
	            * (xq * j_d2f
	                + (qi + 2.0 * xq / qi + qi / xq) * j_df
	                + 3.0 * if i == j { 1.0 } else { 0.0 });
	        jac += gt * qi / x * j_df;
	    }
	    jac
	}
	
	pub fn integrate_full_boltzmann<T: FullBoltzmann + Sync>(
	    model: T,
	    n: usize,
	    xspan: (f64, f64),
	) -> OdeSolution {
	    let qs: Array1<f64> = Array::linspace(1e-6, 50.0, n);
	    let dq = qs[1] - qs[0];
	    // Weight vector for integration. We will use trapizoid rule.
	    let mut wgts = Array1::<f64>::ones(n);
	    wgts[0] /= 0.5;
	    wgts[n - 1] /= 0.5;
	
	    // Extract parameters that don't change
	    let mx = model.dm_mass();
	    let g = model.g();
	    // Construct the jacobian of the df
	    let j_df = jac_first_deriv_vec(n, dq);
	    let j_d2f = jac_second_deriv_vec(n, dq);
	
	    // Construct function for RHS of ODE.
	    let dudt = |deriv: ArrayViewMut1<f64>, f: ArrayView1<f64>, x: f64, p: &T| {
	        let temp = mx / x;
	        let ht = hubblet(temp);
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let feq = qs.mapv(|q| p.feq(x, q));
	        let gam = p.gamma_hinv(x);
	        let gt = gefft(temp);
	        let df = first_deriv_vec(f.view(), dq);
	        let d2f = second_deriv_vec(f.view(), dq);
	
	        // Construct the derivative in parallel
	        Zip::indexed(deriv).par_apply(|i, d| {
	            *d = compute_dfi(
	                i,
	                n,
	                x,
	                f.view(),
	                feq.view(),
	                qs.view(),
	                dq,
	                df[i],
	                d2f[i],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	        });
	    };
	
	    // Construct function for the Jacobian of the RHS of ODE.
	    let dfdu = |jac: ArrayViewMut2<f64>, f: ArrayView1<f64>, x: f64, p: &T| {
	        let temp = mx / x;
	        let ht = hubblet(temp);
	        let gt = gefft(temp);
	        let pre = mx.powi(3) * g / (ht * x.powi(4) * 2.0 * std::f64::consts::PI.powi(2));
	        let gam = p.gamma_hinv(x);
	
	        Zip::indexed(jac).par_apply(|(i, j), d| {
	            *d = compute_j_dfi(
	                i,
	                j,
	                n,
	                x,
	                f.view(),
	                qs.view(),
	                dq,
	                j_df[[i, j]],
	                j_d2f[[i, j]],
	                pre,
	                gam,
	                gt,
	                p,
	            );
	        });
	    };
	
	    // Construct the initial condition (i.e. the initial phase space)
	    let mut finit = Array1::<f64>::zeros(n);
	    for (i, q) in qs.iter().enumerate() {
	        finit[i] = model.feq(xspan.0, *q);
	    }
	
	    let mut integrator = OdeIntegratorBuilder::default(&dudt, finit, xspan, Radau5, model)
	        .abstol(1e-100)
	        .reltol(1e-6)
	        .dfdu(&dfdu)
	        .build();
	    integrator.integrate();
	    integrator.sol
	}
fe407c01608a31a38ed639d77f7b29d4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/simple_boltz.rs|1|1|V|rust
	use cyphus_diffeq::prelude::*;
	use haliax_constants::prelude::*;
	use haliax_thermal_functions::prelude::*;
	use ndarray::prelude::*;
	
	pub trait SimpleBoltzmann {
	    fn thermal_cross_section(&self, x: f64) -> f64;
	    fn mass(&self) -> f64;
	}
	
	pub fn integrate_simple_boltzmann<T: SimpleBoltzmann>(
	    model: T,
	    xmin: f64,
	    xmax: f64,
	) -> OdeSolution {
	    let mx = model.mass();
	    let dudt = |mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64, p: &T| {
	        let x: f64 = logx.exp();
	        let temp: f64 = mx / x;
	        let s: f64 = sm_entropy_density(temp);
	        let n = neq(temp, mx, 2.0, 1);
	        let weq: f64 = (n / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = p.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        dw[0] = pf * sigmav * (ww.exp() - (2.0 * weq - ww).exp());
	    };
	    let dfdu = |mut df: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64, p: &T| {
	        let x: f64 = logx.exp();
	        let temp: f64 = mx / x;
	        let s: f64 = sm_entropy_density(temp);
	
	        let n = neq(temp, mx, 2.0, 1);
	        let weq: f64 = (n / s).ln();
	        let ww: f64 = w[0];
	
	        let pf: f64 = -(std::f64::consts::PI / 45.0).sqrt() * M_PLANK * sm_sqrt_gstar(temp) * temp;
	        let sigmav: f64 = p.thermal_cross_section(x);
	
	        // dW_e / dlogx
	        df[[0, 0]] = pf * sigmav * (ww.exp() + (2.0 * weq - ww).exp());
	    };
	    let temp = mx / xmin;
	    let n = neq(temp, mx, 2.0, 1);
	    let uinit = array![(n / sm_entropy_density(temp)).ln()];
	    let tspan = (xmin.ln(), xmax.ln());
	
	    let mut integrator = OdeIntegratorBuilder::default(&dudt, uinit, tspan, Radau5, model)
	        .dfdu(&dfdu)
	        .reltol(1e-7)
	        .abstol(1e-7)
	        .build();
	    integrator.integrate();
	    integrator.sol
	}
ce3e0410152d5e5dea2d3f6f6f39eba1|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/simple.rs|6|1|V|rust
	
	pub trait SimpleBoltzmann {
	    fn thermal_cross_section(&self, x: f64) -> f64;
	    fn mass(&self) -> f64;
	}
c813708d46c3f9dc0970bee8e7eb079c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz.rs|5|1|V|rust
	pub trait FullBoltzmann {
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate divided by ht
	    fn gamma_hinv(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
	}
	
	pub trait SimpleBoltzmann {
	    fn thermal_cross_section(&self, x: f64) -> f64;
	    fn mass(&self) -> f64;
	}
	
	pub trait CoupledBoltzmann {
	    fn sigmav(&self, x: f64) -> f64;
	    fn sigmav2(&self, x: f64) -> f64;
	    fn sigmav_neq(&self, x: f64) -> f64;
	    fn sigmav2_neq(&self, x: f64) -> f64;
	}
de21c69b3d2159579bbf64a092d4559e|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/full.rs|11|1|V|rust
	pub trait FullBoltzmann {
	    /// Equillibrium phase-space distribution evaluated at momentum `q` and
	    /// x = m / T.
	    fn feq(&self, x: f64, q: f64) -> f64;
	    /// Momentum exchange rate divided by ht
	    fn gamma_hinv(&self, x: f64) -> f64;
	    /// velocity-weighted  cross  section  averaged  over angles
	    fn sigmav(&self, x: f64, q: f64, qt: f64) -> f64;
	    /// Dark matter mass
	    fn dm_mass(&self) -> f64;
	    /// Dark matter d.o.f.
	    fn g(&self) -> f64;
	}
	
f7fb8834685b8137987056bccd97efe5|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/full.rs|5|1|V|rust
	use ndarray::parallel::prelude::*;
a94885cc54309e2d6096f100c378163f|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|2|1|V|rust
	pub mod coup_boltz;
4cbe96e260d6eac25c97214b5ee47200|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|2|1|V|rust
	pub mod full_boltz;
23fd79cb99ce7886843aa387cfa769ae|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|5|1|V|rust
	use full_boltz::*;
2deb18134d90ca9ab024b22f16f2ceab|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|6|12|v|rust
	full_boltz
7fe1952910cd64008e9227b1a050511c|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|6|1|V|rust
	use crate::boltz::traits::FullBoltzmann;
37d67bf54dc7da59c3fcca306f8d96b4|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz.rs|4|1|V|rust
	pub mod traits;
e6abb0b66a8d567b2b564f275f8e036d|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/full.rs|1|1|v|rust
	use crate::utils::derivatives::*;
	use cyphus_diffeq::prelude::*;
	use haliax_constants::cosmology::M_PLANK;
	use haliax_thermal_functions::prelude::*;
	use ndarray::prelude::*;
	use ndarray::Zip;
	use std::f64::consts::PI;
	
	use super::traits::FullBoltzmann;
	
	pub fn gefft(temp: f64) -> f64 {
	    sm_sqrt_gstar(temp) * sm_geff(temp).sqrt() / sm_heff(temp) - 1.0
	}
	
	pub fn hubblet(temp: f64) -> f64 {
	    let h = (4.0 * PI.powi(3) * sm_geff(temp) / 45.0).sqrt() * temp * temp / M_PLANK;
	    h / (1.0 + gefft(temp))
	}
ff954ebedd299f63d3bbe657fb785307|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/helper.rs|1|1|V|rust
	use crate::utils::derivatives::*;
2c786b3e29533bace5df6f849281da34|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/helper.rs|3|1|V|rust
	use ndarray::Zip;
9a50bf99ef110fd6467842f462011c60|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/helper.rs|5|1|V|rust
	use super::traits::FullBoltzmann;
616a97755b2580062893e0aed034badc|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|7|27|v|rust
	FullBoltzmann;
62007a03c2129686432e823cd1a39911|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/dipole_dm.rs|55|21|v|rust
	crate::full_boltz::
545d6ab5c858c0052a699b2e3fc70ef7|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/models/scalar_singlet.rs|73|6|v|rust
	crate::simple_boltz::
f85048e6b8f81625bb3859c34fdf9347|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/main.rs|8|1|V|rust
	use simple_boltz::*;
78941483d935e28bf2a6846046bd2217|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz.rs|4|1|V|rust
	//! - full:
1cae0a925d1cbfbf57e3c4570430ab9e|file:///Users/loganmorrison/Downloads/blackhawk_v1.2/parameters.txt|6|8|v|text
	1e+10									# lowest BH mass in g (larger than the Planck mass)
463bd6848338067fa7f6a1fc43563327|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/.gitignore|1|1|V|conf
	# Generated by Cargo
	# will have compiled files and executables
	/target/
	
	# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
	# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
	Cargo.lock
	
	# These are backup files generated by rustfmt
	**/*.rs.bk
	
	
	#Added by cargo
	
	/target
456d7d63a233d40f3f748b755fbe476c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/.gitignore|1|1|V|conf
	# Prerequisites
	*.d
	
	# Compiled Object files
	*.slo
	*.lo
	*.o
	*.obj
	
	# Precompiled Headers
	*.gch
	*.pch
	
	# Compiled Dynamic libraries
	*.so
	*.dylib
	*.dll
	
	# Fortran module files
	*.mod
	*.smod
	
	# Compiled Static libraries
	*.lai
	*.la
	*.a
	*.lib
	
	# Executables
	*.exe
	*.out
	*.app
	
	bin/
	cmake-build-debug/
	.idea/
	rundata/
	
	
4551aa2ca23f43efb20a82728d0b31d2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/.gitignore|18|1|V|conf
	/target
19a7d912772e09a5ecaf4f20565c934f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/.gitignore|16|1|V|conf
	#Added by cargo
09d5b90eeb5b02264b2c2908b03f52d3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|1|1|V|rust
	fn main() {
	    println!("Hello, world!");
	}
a046d12adc3dba19090458e94bee68b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|13|1|V|rust
	    pub mu_eta:f64,
ec525a763cf7322c4b49580acd41c297|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|13|1|V|rust
	    /// Prefactor of the eta mass defined such that 
	    /// meta = mu_eta * lamc / sqrt(n)
0b95a9b0fc4554ef754321f3832aa734|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|16|26|v|rust
	eta 
d87b03dffaa2e4de8cbee3f3da0879c7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|17|33|v|rust
	 / sqrt(n)
1e1337a0144801323c2d1174758fc09a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|209|20|v|cpp
	Exponential supression factor for initial delta density
a1739230aea8f6262d6c867220826bb1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|24|1|V|rust
	pub struct 
06819da72eee33c292ce82c89b25b3ff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|25|1|V|rust
	pub struct DarkSun{
	}
f670395192e4caf35f0ed9b357f30026|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|25|1|V|rust
	    pub xi_bbn:f64,
0419720c38b15ca5490ef1069480ecc2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|26|1|V|rust
	    pub xi_cmb:f64,
80433c6111936206fac85d6c852a1aaf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|27|9|v|rust
	xi_cmb
6fbd7b07ee0a759c885108f33cd73182|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|27|1|V|rust
	    pub rd_eta:f64,
062aeaa3718e45551db03e37a30cc05a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|29|1|V|rust
	    pub dneff_cmb:f64,
914836cc1eab14d00f11b85666eb3ca0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|31|1|V|rust
	    pub eta_si_per_mass:f64,
a4cdc6599c23287ec90417be6d4a1c14|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|23|1|V|rust
	    pub xi_fo: f64,
	    pub tsm_fo: f64,
	    pub xi_bbn: f64,
	    pub xi_cmb: f64,
	    pub rd_eta: f64,
	    pub rd_del: f64,
	    pub dneff_cmb: f64,
	    pub dneff_bbn: f64,
	    pub eta_si_per_mass: f64,
	    pub del_si_per_mass: f64,
3225a10b07f1580f10dee4abc3779e6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|2|19|v|rust
	Parameters
fbccd1d0e72da3734e6c3de48978a59d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|2|16|v|rust
	DarkSunInput,
a43c1b0aa53a0c908810c06ab1ff3967|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|2|9|v|rust
	input
2a11bbb929ecdfaa5af02e40b1b6b5ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|31|1|V|rust
	    /// Value of xi = Td / Tsm when the eta freezes out.
84fa6d4011ffc343a9a3d518dcf51ca2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|33|18|v|rust
	xi = Td / 
38dba1976adef1ce6ed8d95e1682e389|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|35|1|V|rust
	    /// Value of xi = Td / Tsm at BBN.
23704cd377e3eaeafde1d52224abd31d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|37|35|v|rust
	BBN.
7b9b5db2f84b2b0f770a2ade65b18afc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|39|1|V|rust
	    /// Relic density of the eta.
b8a0ec6dd10fc463334d107325810f21|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|41|30|v|rust
	eta.
537b7defd0444be280d42a4186afe77a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|43|9|v|rust
	Delta 
a5edf4532bcaae3d55c527a438bb4241|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|43|1|V|rust
	    /// dNeff at CMB.
6736c34705e60332650732ac9a120763|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|45|18|v|rust
	CMB.
68f806cc972239b25296ad0657a71804|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|47|1|V|rust
	    /// Value of sigma_eta / meta.
f0030b358f75ca4ce11c11fffce8000f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|11|1|V|toml
	cyphus-interpolation = { path = "../../cyphus-interpolation"}
99fc7d04ab95c4985645644c4cb64338|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|13|1|V|toml
	haliax-constants = { path = "../../haliax-constants"
626d61a04193d3cd590ca0686e408d4a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|14|44|v|toml
	haliax
049310b488736f37a1083284714bb434|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|14|44|v|toml
	-constants
f4534ab94b249b9ad56896ebd62d0be6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|15|7|v|toml
	-thermal-functions
b52a1b65da49d9c9a2d342ed192fdced|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|15|27|v|toml
	haliax-thermal-functions
5c4d7add50d4c384b429b3d8579b6506|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|17|1|V|rust
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    /// Confinement scale.
	    pub lamc: f64,
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    pub c: f64,
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
5049a0c0d76448285d12027b1605b856|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|31|15|v|rust
	n:usize, lamc:f64, c:f64,
b233a76241fcf8720de7a3f4840c408c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|32|1|V|rust
	        n: usize,
	        lamc: f64,
	        c: f64,
	        lec1: f64,
	        lec2: f64,
	        adel: f64,
	        mu_eta: f64,
	        mu_delta: f64,
8a442f8918b463e4d719e06e80262305|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|80|1|V|rust
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: f64,
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: f64,
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: f64,
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: f64,
	    /// Relic density of the eta.
	    pub rd_eta: f64,
	    /// Relic density of the delta.
	    pub rd_del: f64,
	    /// dNeff at CMB.
	    pub dneff_cmb: f64,
	    /// dNeff at BBN.
	    pub dneff_bbn: f64,
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: f64,
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: f64,
	    /// Solution to the Boltzmann equation.
	    pub sol: OdeSolution,
a41a74165df7f688cac0faf0305c41c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|80|1|V|rust
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	    /// Solution to the Boltzmann equation.
	    pub sol: Option<OdeSolution>,
dafc8c77e307835a1d0bf8c9a4a4f49f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|52|13|V|rust
	            https://github.com/LoganAMorrison/darksun.git
c5446d6b122b1eb47ae04715738c6038|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|53|5|V|rust
	    /// Value of Tsm when the eta freezes out.
ebcf1728e7a1d3108a505bcb6827e718|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|55|5|V|rust
	    /// Value of xi = Td / Tsm at CMB.
ecb11a5294e239bd5f53046361f88cce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|57|5|V|rust
	    /// Relic density of the delta.
1440c07a8cc07a7c31e6efcf59a65b29|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|59|5|V|rust
	    /// dNeff at BBN.
e4af5e4f1aa6d504f87f59982cef0584|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|60|5|V|rust
	    /// Value of sigma_eta / m_eta.
c32070c9f8571c170da2eddff0ea0fbb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|61|5|V|rust
	    /// Value of sigma_del / m_del.
fa85f293f55f97ca1d59120b3bbbd2a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|62|5|V|rust
	    /// Solution to the Boltzmann equation.
4cbe2a50c2130f9b6856fb4005e9f528|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|52|12|v|rust
	Option<f64>,
ef9dec8a3952225cb89632294d204c75|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|62|10|v|rust
	Option<OdeSolution>,
e0a6754202fa227468169afaa8c976c4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|9|1|V|rust
	    /// Order of the SU(N) gauge group.
	    pub n: Option<usize>,
	    /// Confinement scale.
	    pub lamc: Option<f64>,
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    pub c: Option<f64>,
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: Option<f64>,
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: Option<f64>,
	    /// Exponential supression factor for initial delta density
	    pub adel: Option<f64>,
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: Option<f64>,
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: Option<f64>,
bd5b687835b8961103f2e1fea429a055|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|67|5|V|rust
	    /// Order of the SU(N) gauge group.
fdf5c6b26751e297007610b8826a1741|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|68|5|V|rust
	    /// Confinement scale.
fd8b6f7eaf23528a54c410b888c67129|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|69|5|V|rust
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
ffe6343f2930aeb37d284762333638d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|69|5|V|rust
	    /// defined such that M ~ exp(-c*n)
2750bd8c5fe88decc1082419cd1bb2ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|70|5|V|rust
	    /// Low-energy constants in 4-pt eta interaction
96731bbfaab22313963894e3c8a49564|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|71|5|V|rust
	    /// Low-energy constant in the 6-pt eta interaction
6f22edb507c3282dcc3b9349dbbe5481|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|72|5|V|rust
	    /// Exponential supression factor for initial delta density
0271f1d3c4c66cea2c37ce897e0e3b69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|73|5|V|rust
	    /// Prefactor of the eta mass defined such that
c60c69669a7b50fc19f3c047ef5f549e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|73|5|V|rust
	    /// meta = mu_eta * lamc / sqrt(n).
05bce18b18a0353e84b5978cb9346cfe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|74|5|V|rust
	    /// Prefactor of the delta mass defined such that
06fbf645a7512dc7919cb682c92dabdb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|74|5|V|rust
	    /// mdel = mu_del * lamc * n.
baa22d12874b4d3c300cb744f542ab03|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|67|12|v|rust
	Option<usize>,
5d996a1ec06d9fdae13dd0b97defdfc2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|66|21|v|rust
	DarkSunBuilder 
20c4a5869cc243ab14d317d0abf7ecf8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|82|9|V|rust
	        DarkSunBuilder
3d2271202090fa5d7ecdaed84652a619|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|81|1|V|rust
	    pub fn n(mut self, n: usize) -> DarkSunBuilder {
	        self.n = Some(n);
	        self
	    }
7dc349ff7c4e948fad3463f6cb87ef8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|85|1|V|rust
	    pub fn lamc(mut self, lamc: f64) -> DarkSunBuilder {
	        self.lamc = Some(lamc);
	        self
	    }
4d63f3b3d95a113b2ffe035a3c384cd8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|89|12|v|rust
	lamc
1ad1f18e1ccb3cd7420e2c2e1c7023f5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|89|1|V|rust
	    pub fn c(mut self, c: f64) -> DarkSunBuilder {
	        self.c = Some(c);
	        self
	    }
7636422f4662e968f1292e34bfb80c0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|93|1|V|rust
	    pub fn lec1(mut self, lec1: f64) -> DarkSunBuilder {
	        self.lec1 = Some(lec1);
	        self
	    }
d9130f134c9d52a3c8c1a1a45ec53675|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|97|1|V|rust
	    pub fn lec2(mut self, lec2: f64) -> DarkSunBuilder {
	        self.lec2 = Some(lec2);
	        self
	    }
312c1573f80dc213d2831695d0ec7ba9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|101|12|v|rust
	lec2
4b82809e3c66e8dfcfdedfeecb24ac95|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|101|1|V|rust
	    pub fn adel(mut self, adel: f64) -> DarkSunBuilder {
	        self.adel = Some(adel);
	        self
	    }
94c93d4f9686cfeae29e9cbc3230cbf9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|105|12|v|rust
	adel
c4ceec02440bae1d1a480413f79f392a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|105|1|V|rust
	    pub fn mu_eta(mut self, mu_eta: f64) -> DarkSunBuilder {
	        self.mu_eta = Some(mu_eta);
	        self
	    }
5b36424b705facb0076bede08bdd7f04|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|51|1|V|rust
	        let output = DarkSunOutput {
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	            sol: None,
	        };
	        DarkSun { params, output }
2d31d497ab47c16d9d336c79bd378082|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|41|1|V|rust
	        let params = DarkSunParameters {
	            n,
	            lamc,
	            c,
	            lec1,
	            lec2,
	            adel,
	            mu_eta,
	            mu_del,
	        };
08e94e034a54e479c5dadeddbc139623|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|114|9|V|rust
	        if self.n
26f31c4aecd9881d5f3e0e369a2725cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|116|1|V|rust
	            Err("N is required to build a DarkSun object.")
6c67289b461917cf01de7ba952896ce3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|123|18|v|rust
	: self.c.unwrap_or(1.0),
b8e7583390e72f3976d7019ad10d815d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|149|1|V|rust
	#[derive(Debug, Clone, Copy)]
5347b43af36099b484d91cd31cacfe1f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|205|9|V|rust
	        let model = DarkSun::builder().n(10).lamc(
c87a8ca60f0891b79d192fa86f019916|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|66|12|v|rust
	builder
054b4f3ea543c990f6b125f41af6ebf7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|12|v|rust
	Option
93348ad1e651307220989d5718788fcc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|68|16|v|rust
	None,
2116c789ee91b9583fd166078aafde5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|81|1|V|rust
	    pub fn n(mut self, n: usize) -> DarkSunBuilder {
	        self.n = Some(n);
	        self
	    }
	    pub fn lamc(mut self, lamc: f64) -> DarkSunBuilder {
	        self.lamc = Some(lamc);
	        self
	    }
3880f86b496e8a75d3bdcfd66c750e07|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|106|1|V|rust
	        // n and lamc are required to be set.
	        if self.n.is_none() {
	            Err("N is required to build a DarkSun object.".to_owned())
	        } else if self.lamc.is_none() {
	            Err("Lambda is required to build a DarkSun object.".to_owned())
	        } else {
81d936139200f6c467b0c61130178173|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|107|22|v|rust
	.unwrap(),
8c2e5eb2371b617ab6eba7206b72406a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|105|41|v|rust
	, String
a14b28229dbc926f72e16681ba9dc22a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|105|27|v|rust
	Result<
41cf8650ad8d16080b04762fb08533a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|190|9|V|rust
	        println!(
43e0a125f01375e44004ca437d01e839|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|109|1|V|rust
	            c: self.c.unwrap_or(1.0),
	            lec1: self.lec1.unwrap_or(1.0),
	            lec2: self.lec2.unwrap_or(1.0),
	            adel: self.adel.unwrap_or(1.0),
	            mu_eta: self.mu_eta.unwrap_or(1.0),
	            mu_del: self.mu_del.unwrap_or(1.0),
81f19923824ef1e54286fa146e5cccc4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|194|15|v|rust
	 self.c.unwrap_or(1.0),
ef1a11e2b624d0c6d9944d740daaaf98|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|195|18|v|rust
	 self.lec1.unwrap_or(1.0),
01a08092355595802731b9e767bfb0a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|196|18|v|rust
	 self.lec2.unwrap_or(1.0),
afcbd22665148ffa90827352c08e7112|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|197|18|v|rust
	 self.adel.unwrap_or(1.0),
2e717b8ab6d8ecd7341bd74b6bc08192|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|198|20|v|rust
	 self.mu_eta.unwrap_or(1.0),
ff28d88e88083e675e32ae2aff9287e5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|199|20|v|rust
	 self.mu_del.unwrap_or(1.0),
1cc6fec6a905c0c36d7df9bc26e3e272|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|193|1|V|rust
	        assert_eq!(model.params.n, default.params.n);
46c743e360526bf00bb6c2d525b8a1a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|196|1|V|rust
	        assert_eq!(model.params.lec1, default.params.lec1);
3e7aa7c26705e4918405f126ff9debf4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|199|1|V|rust
	        assert_eq!(model.params.mu_eta, default.params.mu_eta);
c99c2ec4b28b12999e274e5c77922b45|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|193|36|v|rust
	default.params.n);
abef4bc5f933e12f6c4c5c3864cd61d7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|194|39|v|rust
	default.params.lamc);
f35336c5a77b7b1a578bfb87da6daf01|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|195|36|v|rust
	default.params.c
b97db2dd2f2ef6fd1ac8712081ded171|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|196|39|v|rust
	lec1
e0d587b62058568c00d44192941c00ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|199|41|v|rust
	mu_eta
757d04bfae20b2b5e31f027c26602013|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|191|9|V|rust
	        let default = DarkSun::new(n, lamc, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);
c6f11cabfbcc3ad2f69209a51ae6635e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|200|9|V|rust
	        println!("{:?}", model.params);
231eeabcaa424dac4025d62d3eee3513|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|191|1|V|rust
	        let model = DarkSun::default(10, 1e-3).build();
	        assert_eq!(model.params.n, n);
	        assert_eq!(model.params.lamc, lamc);
	        assert_eq!(model.params.c, 1.0);
	        assert_eq!(model.params.lec1, 1.0);
	        assert_eq!(model.params.lec2, 1.0);
	        assert_eq!(model.params.adel, 1.0);
	        assert_eq!(model.params.mu_eta, 1.0);
	        assert_eq!(model.params.mu_del, 1.0);
78e4be89821897c1f1f85d184936407b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|44|1|V|cpp
	    /**
	     * Compute the upper bound on xi assuming Td is known.
	     * @param Td Temperature of the dark bath
	     * @return Upper bound on xi
	     */
	    double xi_upper_bound_const_td(double Td) const;
	
	    /**
	     * Compute the lower bound on xi assuming Td is known.
	     * @param Td Temperature of the dark bath
	     * @return Lower bound on xi
	     */
	    double xi_lower_bound_const_td(double Td) const;
	
	    /**
	     * Compute the upper bound on xi assuming Tsm is known.
	     * @param Tsm Temperature of the standard model bath
	     * @return Upper bound on xi
	     */
	    double xi_upper_bound_const_tsm(double Tsm) const;
	
	    /**
	     * Compute the lower bound on xi assuming Tsm is known.
	     * @param Tsm Temperature of the standard model bath
	     * @return Lower bound on xi
	     */
	    double xi_lower_bound_const_tsm(double Tsm) const;
	
9db31c54fda81ea7d692feac0445bd46|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|3|1|V|rust
	    * @param Td Temperature of the dark bath
	    * @return Upper bound on xi
	    */
80d54b6501532101c260d0c2577abaa4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|4|1|V|rust
	    * @param Td Temperature of the dark bath
	    * @return Lower bound on xi
	    */
becbdcf1a7149636a653657152c1651e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|7|1|V|rust
	    * @param Tsm Temperature of the standard model bath
	    * @return Upper bound on xi
	    */
754ff4212c11e65401e7830ee5e9f754|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|9|5|V|rust
	    * @param Tsm Temperature of the standard model bath
a1f7865155afafe3653b2a213d924bcf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|9|5|V|rust
	    * @return Lower bound on xi
155f18a0325cba32c4323137992dd5e7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|9|5|V|rust
	    */
b476a87b3cef705b565a1395ddd2a05c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|4|1|V|rust
	cyphus_specfun::la
f8fff7f633388fc623a4048d73bc0163|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|2|21|v|rust
	lambert_w::L;
5b7ebeeaa5acfe1eeea5a9e9845b152d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/compute_xi.rs|2|21|v|rust
	prelude
33adc4fe8c87debc05e03fc75c98c0e4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|1|9|v|rust
	compute_xi;
86ccec3d9ff0e9c0514506e982cdc08b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|4|1|v|rust
	impl
2bccdb2bfb07042b2fd642e5bc48ef5a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|4|11|v|rust
	DarkSun 
db46b75cc790c6bf439d643c1d6cb241|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|83|1|V|cpp
	    * Compute the entropic dof of the dark sector
e4ead47353a8de7112c68dce13e80538|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|90|1|V|cpp
	     * Compute xi = Td/Tsm assuming Td is known
f5488e974ae0870df29c5718840e5134|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|8|1|V|rust
	    /// Compute xi = Td/Tsm assuming Td is known
	    fn compute_xi_const_td(&self, td:f64) -> f64;
ce11c5bf4c0a41afee348e4d21092f22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|5|1|V|rust
	    /// Compute the entropic dof of the dark sector.
	    fn dark_heff(&self, td: f64) -> f64;
818d398dcee9cde13b861951d8ceaeca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|8|8|v|rust
	dark_heff
5c2145b226dc6e34604cd03beaf1a4b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|8|20|v|rust
	, : f64
4eafad39a451b653adafda6b69b08bf7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|8|5|V|rust
	    fn xi_inf(&self) -> f64;
2f3dd73057b6ed6cfacaf973df012d66|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|7|1|V|rust
	    /// Compute the entropic dof of the dark sector.
911a34215e40946d4da97ab8f2e073a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|6|1|V|rust
	    fn dark_heff(&self, td: f64) -> f64;
	
d723663a2ff7218b8d935f3fd85e9b27|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|110|1|V|cpp
	    double hd = dark_heff(Td);
	    return cbrt(m_hd_inf / hd * SM_HEFF_0 / SM_HEFF_INF) * m_xi_inf;
17f741579469104222501515354e2c53|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|24|9|v|rust
	cbrt
b23faa1131621342890dfbebb0420ba0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|24|51|v|rust
	m_xi_inf;
9b2c7285dddbab0c96ed719f272173b9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|24|42|v|rust
	SM_HEFF_INF
cb142214e08240a0b774a7c529820608|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|4|1|V|rust
	const SM_HEFF_INF:f64 = 0.0;
a354c646d738506c44fca542596a3dcb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|120|1|V|cpp
	    double hd = dark_heff(Td);
	    return cbrt(m_hd_inf / hd) * m_xi_inf;
2027357ff9694e710bd51ad15793bdb7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|31|15|v|rust
	emented!()
b3403fad842de2e2d5b05e5741fac56b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|31|1|V|rust
	        unimpl
	            emented!()
ad57706ffb8bc871fe1160cf9e45263e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|32|31|v|rust
	m_xi_inf
ced8b0e7bbf5bbb9f886f8bab7d985ae|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|130|1|V|cpp
	    return cbrt(sm_heff(Tsm) * m_hd_inf / m_sum_g / SM_HEFF_INF) * m_xi_inf;
9ad25e5c94ab26756faa935152a508c5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|40|v|rust
	m_sum_g
9c977bcf7a685ea63688f0ef86d091a8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|29|v|rust
	m_hd_inf
a88ea0b70acc992893eb492bbd90ed73|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|29|v|rust
	m_hd_inf / Self.SUM_G / SM_HEFF_INF) * Self::XI_INF
ee9307a6ff7d18672bdbcbf76a704634|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|140|1|V|cpp
	        return cbrt(sm_heff(Tsm) * m_hd_inf / m_gl / SM_HEFF_INF) * m_xi_inf;
4e7e9592eae2cedd3bef37f3bf0e4a01|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|45|36|v|rust
	m_gl
d43e4b99479d2194a4a53c9bba8f12d9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|144|1|V|cpp
	        double xl = m_ml / Tsm;
	        double hsm = sm_heff(Tsm);
	
	        double lw_arg_num = pow(45.0 * m_gl * SM_HEFF_INF * xl * xl * xl, 2);
	        double lw_arg_den = pow(4.0 * m_hd_inf * hsm * m_xi_inf, 2) * pow(M_PI, 7);
	        return 2.0 * xl / lambert_w0(lw_arg_num / lw_arg_den);
855d1abd99dcc4b4460ede8115706b6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|47|18|v|rust
	m_ml
b8103ae76ef3483be884218ff365708f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|51|33|v|rust
	m_hd_inf * hsm * m_xi_inf, 2) * pow(M_PI, 7);
e05b0f73e63cd526ab6eaed7ec8daaa0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|52|27|v|rust
	lambert_w0
6e63efa38b5291de8e8dc8c2c8df4e39|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|184|1|V|cpp
	    double ub = xi_upper_bound_const_tsm(Tsm);
	    double lb = xi_lower_bound_const_tsm(Tsm);
	    double hsm = sm_heff(Tsm);
	
	    double c1 = hsm * m_hd_inf * pow(m_xi_inf, 3) / SM_HEFF_INF;
19a55bdc28a49bc126ffb3a460f0fa9e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|184|1|V|cpp
	    double ub = xi_upper_bound_const_tsm(Tsm);
	    double lb = xi_lower_bound_const_tsm(Tsm);
	    double hsm = sm_heff(Tsm);
bc1ac5b51aef4f50e0312774385db083|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|160|1|V|cpp
	    double hd = dark_heff(Td);
	
	    double lb = xi_lower_bound_const_td(Td);
	    double ub = xi_upper_bound_const_td(Td);
	
	    double c1 = m_hd_inf * pow(m_xi_inf, 3) / SM_HEFF_INF;
af4f5e73ee37c4527d51f1e4c58e57c7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|19|1|V|rust
	        let ub = self.xi_upper_bound_const_tsm(tsm);
	        let lb = self.xi_lower_bound_const_tsm(tsm);
	        let hsm = sm_heff(tsm);
17aeee6c6261a3a2054e5064e0f9d2ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|22|33|v|rust
	pow(m_xi_inf
d2108394cbc65834d7919dfdf7e319e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|25|18|v|rust
	hd * 
6e55847a92d64e52f0a1f1c1773f22fd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|25|27|v|rust
	xi * xi * xi
2ee42254f62c5f9d845a8d50e9670227|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|24|1|V|rust
	        let mut fa = hd * lb.powi(3) - sm_heff(td / lb) * c1;
2ba6075b2a7fbebc31ada898ac776fa3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|18|8|v|rust
	compute_xi_const_td
c19c55408881a6e448a9637b72374360|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|22|9|V|rust
	        let c1 = Self::HD_INF * Self::XI_INF.powi(3) / SM_HEFF_INF;
73ec20fbc2e15d765785ebe1f0239546|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|31|17|V|rust
	                a.swa
686b9634690b088d344a040e5a998bac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|27|22|v|rust
	hd * a.powi(3) - sm_heff(td / a) * c1
4d9920f61cab68fdebe74a7c6ddf73ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|29|22|v|rust
	hd * a.powi(3) - sm_heff(td / a) * c1;
1fd62ae362361ba97d797d74707c5e7b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|30|22|v|rust
	hd * b.powi(3) - sm_heff(td / b) * c1;
595905bd4932b5b6ff1c6c76f98d8a55|file:///Users/loganmorrison/Documents/coding/numerical_recipies/code/roots.h|164|1|V|cpp
		const Int ITMAX=100;
		const Doub EPS=numeric_limits<Doub>::epsilon();
		Doub a=x1,b=x2,c=x2,d,e,fa=func(a),fb=func(b),fc,p,q,r,s,tol1,xm;
		if ((fa > 0.0 && fb > 0.0) || (fa < 0.0 && fb < 0.0))
			throw("Root must be bracketed in zbrent");
		fc=fb;
		for (Int iter=0;iter<ITMAX;iter++) {
			if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) {
				c=a;
				fc=fa;
				e=d=b-a;
			}
			if (abs(fc) < abs(fb)) {
				a=b;
				b=c;
				c=a;
				fa=fb;
				fb=fc;
				fc=fa;
			}
			tol1=2.0*EPS*abs(b)+0.5*tol;
			xm=0.5*(c-b);
			if (abs(xm) <= tol1 || fb == 0.0) return b;
			if (abs(e) >= tol1 && abs(fa) > abs(fb)) {
				s=fb/fa;
				if (a == c) {
					p=2.0*xm*s;
					q=1.0-s;
				} else {
					q=fa/fc;
					r=fb/fc;
					p=s*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));
					q=(q-1.0)*(r-1.0)*(s-1.0);
				}
				if (p > 0.0) q = -q;
				p=abs(p);
				Doub min1=3.0*xm*q-abs(tol1*q);
				Doub min2=abs(e*q);
				if (2.0*p < (min1 < min2 ? min1 : min2)) {
					e=d;
					d=p/q;
				} else {
					d=xm;
					e=d;
				}
			} else {
				d=xm;
				e=d;
			}
			a=b;
			fa=fb;
			if (abs(d) > tol1)
				b += d;
			else
				b += SIGN(tol1,xm);
				fb=func(b);
		}
		throw("Maximum number of iterations exceeded in zbrent");
e273a71b99ffd373dca6dc588f82c608|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|29|1|V|rust
	        let mut fa = f(a);
	        let mut fb = f(b);
	
	        if fa * fb >= 0.0 {
	            Err("compute_xi_const_td: Interval is not bounding".to_owned())
	        } else {
	            loop{
	                let c = a;
	                if fa.abs() < fb.abs() {
	                    let (mut a, mut b) = (b, a);
	                }
	                if fa  
	            }
	
	            Ok(xi)
	        }
e0a2dc2a9d074e9bb499682fe0b795f0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|32|6|v|rust
	fa > 0.0 && fb > 0.0
959b7175f88493905e3c324c2bf6f97d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|33|3|v|rust
	throw
e36846eea419917967b873228184a8a4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|31|2|v|rust
	Doub a=x1,b=x2,
d5363e9bffc50d9a60907d54f95d0b5a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|32|9|v|rust
	let de,
753dfd66799f23039834b9064ab6f64d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|34|8|V|rust
	        fc,p,q,r,s,tol1,xm;
49e61b56093e19fff4be011c75e82850|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|30|2|V|rust
		const Doub EPS=numeric_limits<Doub>::epsilon();
5850c248a2adbc05a9c3b42f0d536d25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|7|v|rust
	Int 
15f5d5a838efc7a7d91aac244244a9d7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|6|v|rust
	iter=0;iter<ITMAX;iter++
2da535db39cbe15a5a950da9a73591fa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|15|v|rust
	;iter<
303da8d6be75e06ff31fa4cfacfd490c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|22|v|rust
	;iter++
b22ddd5bc0bf5177f391c8976a71979a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|29|2|v|rust
	const Int ITMAX
30a9c705aefcaad14cc4fc0854681721|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|37|17|v|rust
	ITMAX
c23f7b43017821217187edbac2eadb56|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|38|7|v|rust
	fb > 0.0 && fc > 0.0
269a9ccbf851c27fd2505d75d87bf243|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|41|5|v|rust
	fa > 0.0 && fb > 0.0 || (fa < 0.0 && fb < 0.0)
143252d6da92eea925bef82d0427cb9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|46|6|v|rust
	fb > 0.0 && fc > 0.0 || (fb < 0.0 && fc < 0.0)
6ad2b0d1e954e1c11ebcad41b995c587|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|51|6|v|rust
	abs(fc) < abs(fb)
51ea12f258033d2b0d0ccc2df7ec3250|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|51|6|v|rust
	abs(
f769e195d12f39855cad97afbbeacedf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|62|6|v|rust
	abs(xm) <= tol1 || fb == 0.0
9586625af1e03c0828228f493275f5f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|63|6|v|rust
	abs(e) >= tol1 && abs(fa) > abs(fb)
b64849fe8e977d141a7771dc5f8b7752|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|65|7|v|rust
	a == c
22c2d8d992c806ecf54b941bcb031d8d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|76|4|v|rust
	Doub 
bd005e94e53952f29dadd636ca32fde3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|91|6|v|rust
	abs(d) > tol1
64d201220f17108c4ca2351ba172233d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|78|7|v|rust
	2.0*p < (min1 < min2 ? min1 : min2)
8c298232add7b438a3860c6b0425be07|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|74|7|v|rust
	p > 0.0
d5bc4d9a960c76609af1b88997c7a075|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|29|1|V|rust
		let itmax=100;
	        let tol = 1e-7;
		let mut c=b;
	        let mut d;
	        let mut e;
	        let mut o;
	        let mut q;
	        let mut r;
	        let mut s;
	        let mut tol1;
	        let mut xm;
	        let fa=f(a);
	        let fb=f(b);
		if fa > 0.0 && fb > 0.0 || (fa < 0.0 && fb < 0.0){
		    Err("Root must be bracketed in zbrent".to_owned());
	        }
		let fc=fb;
		for iter in 0..itmax {
			if fb > 0.0 && fc > 0.0 || (fb < 0.0 && fc < 0.0) {
				c=a;
				fc=fa;
				e=d=b-a;
			}
			if fc.abs() < fb.abs() {
				a=b;
				b=c;
				c=a;
				fa=fb;
				fb=fc;
				fc=fa;
			}
			tol1=2.0*std::f64::EPSILON*b.abs()+0.5*tol;
			xm=0.5*(c-b);
			if xm.abs() <= tol1 || fb == 0.0 {return Ok(b);}
			if e.abs() >= tol1 && fa.abs() > fb.abs() {
				s=fb/fa;
				if a == c {
					p=2.0*xm*s;
					q=1.0-s;
				} else {
					q=fa/fc;
					r=fb/fc;
					p=s*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));
					q=(q-1.0)*(r-1.0)*(s-1.0);
				}
				if p > 0.0 {q = -q;}
				p=p.abs();
				let min1=3.0*xm*q-abs(tol1*q);
				let min2=abs(e*q);
				if 2.0*p < (min1 < min2 ? min1 : min2) {
					e=d;
					d=p/q;
				} else {
					d=xm;
					e=d;
				}
			} else {
				d=xm;
				e=d;
			}
			a=b;
			fa=fb;
			if d.abs() > tol1{
				b += d;
	                }
			else{
				b += SIGN(tol1,xm);
				fb=f(b);
	                }
		}
2126ac44c297941e42379878ed3e414f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|4|2|v|rust
	const Doub EPS=numeric_limits<Doub>::epsilon();
122ed6f6ebadf7c93f2b5c7c2c6b300d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|12|1|V|rust
	        let mut fa = f(a);
f78492017c41f5afc23125a47a738a00|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|22|2|V|rust
		Doub a=x1,b=x2,c=x2,d,e,fa=func(a),fb=func(b),fc,p,q,r,s,tol1,xm;
6e587e45b65f87d0f8d6e8b3200e50cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|22|29|v|rust
	fa < 0.0 && fb < 0.0
33619cf88e4fdeac4edff4dd1c39a5bd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|26|6|v|rust
	Int iter=0;iter<ITMAX;iter++
e259f64724a6882d4a28af8361d438c2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|27|30|v|rust
	fb < 0.0 && fc < 0.0
65b164db371ec78984e24bc8f858c0d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|77|18|v|rust
	SIGN
4c1f2f8c01b8abf918504fa37c0465e0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|1|1|V|rust
	use crate::model::DarkSun;
7b775dfbf334929d5b99a2a14ba0d38c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|27|9|V|rust
	        Ok(xi)
9fdd4dac04c2be489cb65204c79ccd98|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|27|9|V|rust
	        //throw("Maximum number of iterations exceeded in zbrent");
c6caebcf3b5d6cf7a62db1d47cf3fb7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|23|9|V|rust
	        let mut xi = (a + b) / 2.0;
ebf577a1bb79481d6da60a858190ec20|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|24|1|V|rust
	        let f = |xi: f64| hd * xi.powi(3) - sm_heff(td / xi) * c1;
	
	        brent(f, lb, ub, 1e-5)
0ef51ee65ddc4b783b86033b924e14af|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|35|27|v|rust
	hd * xi.powi(3) - sm_heff(td / xi) * c1;
0d47cbb382fb4868f53c2a8a88e10071|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|9|1|V|rust
	    const XI_INF: f64;
	    const HD_INF: f64;
	    const SUM_G: f64;
	    const GL: f64;
	    const ML: f64;
4bc7dc02900d006e833e5b3a66f34e67|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|17|5|V|rust
	    pub xi_inf: f64
4023631942a283b20b95f3bd4c8c8286|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|39|9|V|rust
	        xi_inf: f64,
b30305a28c632686beddf6584803a25a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|15|1|V|rust
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
018b814a54448942a8430fe1e8f187c5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|206|1|V|rust
	        assert_eq!(model.params.lamc, lamc);
2e848d653cedbd57c62415129cdefc15|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|207|41|v|rust
	xi_inf
d1ec89e3a13bc6de673209b13db1fbb6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|207|1|V|rust
	        assert_eq!(model.params.xi_inf, 1e-2);
cee1b30f0c2bcf29d5c80c83ea665f15|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|5|V|rust
	    const XI_INF: f64 = self.xi_inf;
a65fdcf145b871570b814dd22648f49b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|5|V|rust
	    const HD_INF: f64;
172baded1a1b2336d20b3c24c24fc822|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|5|V|rust
	    const SUM_G: f64;
845088d988f11a87d118e814d3e2e62e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|5|V|rust
	    const GL: f64;
9d908b18c8cc702d78c87c949dd91ad3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|5|V|rust
	    const ML: f64;
e845bc717e8f46f781837ee1343a19f2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|33|40|v|rust
	XI_INF
3b7af7fbe3ec98abf20cc30029c57ef2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|20|18|v|rust
	Self::HD_INF
30ea46b4775fb0c97f4be8a415831385|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|42|65|v|rust
	Self::XI_INF
67a6b8a1494c9312eedd825c13ad6ea6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|52|41|v|rust
	Self::SUM_G
0ee21e772e2293134f1fd81d7c2a2bfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|57|12|v|rust
	Self::ML
0a3b4a49be5aae69e7889fcda6a791a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|58|45|v|rust
	Self::GL
3dd8fedd265ad6a7f25dff1e23b17f5b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|11|1|V|rust
	    fn xi_inf(&self) -> f64;
	    fn hd_inf(&self) -> f64;
	    fn sum_g(&self) -> f64;
	    fn gl(&self) -> f64;
	    fn ml(&self) -> f64;
c5c885627ae815918e2d3dcc10ed4a6b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|41|v|rust
	{
	        unimplemented!()
	    }
0cc3736b41ca66b5082908c341d8dee4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|8|28|v|rust
	{
	    }
	
d68b4fcfbf8783aedb243f3f81483b5e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|365|1|V|cpp
	        return m_eta.heff(Td) + m_delta.heff(Td) + m_dark_photon.heff(Td);
370c682c35c61670576d04eaa8d201dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|1|V|rust
	        unimplemented!()https://github.com/LoganAMorrison/darksun.git
b7327aca2e2e2a7c330011bd7e624e97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|43|v|rust
	+ m_dark_photon.heff(Td)
3401c33a77ef6f0dc22ffca03ec03199|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|9|v|rust
	m_eta
7c5261d3b545fa23bf13b78d4b5d39ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|20|v|rust
	m_delta
b0e7f7855369d77c76b58b547c5e037c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|129|1|V|rust
	            meta: params.mu_eta * params.lamc / (params.n as f64).sqrt(),
e9a23cbc455158951716b440c3d165e0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|130|13|v|rust
	meta
c533cc02b882f2ca3af84df935f546fb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|130|47|v|rust
	/ (params.n as f64).sqrt(),
3a8f336d4f226f7293aaf339377b87c8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|129|1|V|rust
	            meta: params.mu_eta * params.lamc / (params.n as f64).sqrt(),
	            mdel: params.mu_eta * params.lamc * (params.n as f64),
ce6130660b634cc7d5610ee0eef6c5ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|59|13|V|rust
	            meta: mu_eta * lamc / (n as f64).sqrt(),
fc927cf3aa8a5ed039a3ae668dcc3cc9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|59|13|V|rust
	            mdel: mu_eta * lamc * (n as f64),
8e1e8a5b6f234e5ee1863d9f2f99957b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|176|9|v|rust
	Mass of the eta.
bad7c190f183187dbf3f4f2ea50fdcc6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|178|9|v|rust
	Mass of the delta.
0918fdcf8ca3496956f72f5c2905d9d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|130|19|v|rust
	params.mu_eta * params.lamc / (params.n as f64).sqrt()
f275ee5c51b4e2a8148ecaf661d3ff1a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|132|13|v|rust
	mdel: params.mu_eta * params.lamc * (params.n as f64),
5292c365032f8dd290861735ae25046a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|133|19|v|rust
	params.mu_eta * params.lamc / (params.n as f64).sqrt(),
5ffcae92046757d3b3110900ce7052fc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|133|40|v|rust
	::new(),
b0a1814bbd7ceb06028903dde3a78eda|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|133|18|v|rust
	ThermodynamicParticle {
	                m: meta,
	                g: 1.0,
	                spin2: 0,
	            },
	
35af440344ff64063b8553054492eaf6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|138|19|v|rust
	params.mu_eta * params.lamc * (params.n as f64),
af10474e3ed18f3237a71b2e788206ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|138|13|v|rust
	mdel
6acade6d531182f148c0893c3f3fef8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|140|20|v|rust
	1.0,
122a73f01c1c625ddb921da0e8db8213|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|129|1|V|rust
	        let meta = params.mu_eta * params.lamc / (params.n as f64).sqrt();
	        let mdel = params.mu_eta * params.lamc * (params.n as f64);
	
	        let output = DarkSunOutput {
	            eta: ThermodynamicParticle {
	                m: meta,
	                g: 1.0,
	                spin2: 0,
	            },
	            delta: ThermodynamicParticle {
	                m: mdel,
	                g: (self.n + 1) as f64,
	                spin2: self.n,
	            },
91cbf8d7d78f5584977be80ac1f4848d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|58|1|V|rust
	        let output = DarkSunOutput {
14dd1c5013c23e761e32b23335c9986d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|69|17|V|rust
	                g: (self.n + 1) as f64,
0ec1e8189d08442197cfd488ddf170eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|9|v|rust
	heff(td,self.output.meta,1.0) + heff(Td)
0aed93d84fb148e74977785156059bc8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|1|V|rust
	        self.output.eta.h_eff(td)
5768574aba8268b380ebb8242fa59388|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|252|1|V|cpp
	        m_hd_inf = 7.0 / 2.0 * m_N + 2 * m_N * m_N - 2.0 + m_dark_photon.get_g();
8921b2bdc6c80d76f0c94d7acf8a98f2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|13|9|v|rust
	m_hd_inf 
496b2ea723cf90042cbf01af2f2b2c55|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|13|21|v|rust
	m_N 
df7e20bcb622376ea10b091aefef8350|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|14|36|v|rust
	 * m_N
fe21303491248f9099a10cdfdca0d4e4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|14|36|v|rust
	 - 2.0 + m_dark_photon.get_g();
36b8aaae647981109cea6825730c2820|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|20|1|V|rust
	        self.output.eta.g 
d980d85e679657effe7e6319b78079ff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|3|1|V|rust
	use haliax_thermal_functions::prelude::*;
4ca94de3b62e6deb4aff9e6795aa6667|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|16|1|V|rust
	        self.output.eta.g
c56f6bdcc7d6aef04da3a628b8bc4715|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|6|1|V|rust
	use compute_xi::*;
ca50108eec5d002f5566043ea90f6d00|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|237|1|V|rust
	        let model = DarkSun::default(10, 1e-3).build();
c88b4b43571320a5380cc061e41a5677|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|237|38|v|rust
	10, 1e-3
be49dc345963f1dbc853731f1ad7267a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|234|1|V|rust
	        let n = 10;
	        let lamc = 1e-3;
	        let model = DarkSun::default(n, lamc).build();
f76bc652c047ff6de5a7021e11fc3c44|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|268|9|V|rust
	        use crate::model::compute_xi::*
be2c4f774764d6083b7c73562af27377|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|1|1|V|rust
	pub mod compute_xi;
064c170cc5405e9d6d1ae8a5f078936c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|28|1|V|cpp
	static constexpr double _log_xmin = 0.602059991327962; // log10(4)
	static constexpr double _log_xmax = 2.69897000433602; // log10(500)
	static constexpr double _log_xstep = 0.006989700043360188;
	static constexpr double _eta_cs_slope = 14.02653358183077;
	static constexpr double _eta_cs_intercept = -6.1933023533564535;
7688210b8545d9f28694e326597792ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|5|12|v|rust
	log_xmin
5e0b502b2303954e9fa76521dbfe51e0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|v|rust
	static constexpr double
998c1a6393668de437ab5cc0914000bd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|12|v|rust
	_log_xmax
cab3d108368193885653ae48c9b6e017|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|8|16|v|rust
	eta_cs_slope
61e860ce5ce8f3b7b046dc97ddc3762e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|9|16|v|rust
	_eta_cs_intercept
a04319ee2a191fd54b5cfe65ab0b2b27|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|35|1|V|cpp
	        -16.637655236501224, -3.2073778028451474, -2.064304369976662, -1.3546809466722889, -0.8281658359797516,
	        -0.40253938967491654, -0.039502564053162006, 0.28364160682026235,
	        0.5772239884528931, 0.838111266851666, 1.0868009202155158, 1.3165324941873415, 1.5326218146462145,
	        1.7425200505064233, 1.9370828345768174, 2.125085632208347, 2.3069051266553204,
	        2.478546038197779, 2.65639789484337, 2.8203069536323957, 2.978730419114667, 3.1338320589598774,
	        3.288998184793619, 3.4376303031062525, 3.58417626478382, 3.734959349971237,
	        3.8721140443084954, 4.009342444091389, 4.144021960780492, 4.282415582197282, 4.417730984233178,
	        4.54843204980097, 4.679145110145505, 4.8046999385083815, 4.929874072565337,
	        5.0572858193187376, 5.183856715323707, 5.302187479857232, 5.425233252841499, 5.545537924432401,
	        5.665829743176893, 5.786232172779206, 5.905022225954679, 6.0258369227675415,
	        6.138636508498319, 6.255698645622665, 6.368823971955043, 6.483252788007763, 6.59763016077933, 6.712631284288037,
	        6.821808987572604, 6.930747854698604, 7.042786867284195,
	        7.1569283794315215, 7.262409238073819, 7.373585907964206, 7.482135041196106, 7.59007128705397,
	        7.7007077186924295, 7.809759218549317, 7.9138204216959975, 8.023202918358328,
	        8.127074833291443, 8.233259515944884, 8.342830412649826, 8.450962847401101, 8.552629916299894,
	        8.656124052323225, 8.763687606605245, 8.866273209021838, 8.967552235363398,
	        9.075691478656855, 9.183898759360103, 9.286054607208035, 9.386649353128306, 9.493095959513699, 9.59256817840535,
	        9.695189855326634, 9.798081193077408, 9.904232549402886,
	        10.00775435077294, 10.104328978940778, 10.209250799915372, 10.309536048894504, 10.415619200278199,
	        10.512914630611792, 10.616925067998318, 10.719545840790364, 10.82569052636717,
	        10.920026204996434, 11.019123642207628, 11.123726243878718, 11.223396862538673, 11.322457925709962,
	        11.423608717091355, 11.52137264956311, 11.626939696768193, 11.724363636568516,
	        11.829078290281942, 11.926756834670329, 12.023866977410192, 12.128754637861284, 12.229005579173206,
	        12.327150549599835, 12.42320073379204, 12.527505575937475, 12.624263995550486,
	        12.728288529421276, 12.831179430890277, 12.929373577091864, 13.019296117317667, 13.12576615740427,
	        13.228316221379316, 13.326752271746773, 13.421767475692928, 13.528376240165276,
	        13.621213484612975, 13.720237321024324, 13.820223741511278, 13.916508156762665, 14.014710829324216,
	        14.114795925887437, 14.214748909756986, 14.317607141627759, 14.411039427599727,
	        14.512167399083273, 14.610786681259539, 14.703982090462606, 14.805431627124811, 14.908040642743243,
	        15.002575847531137, 15.101189984138106, 15.198367008875683, 15.29764620343702,
	        15.396719987595997, 15.496524643113691, 15.596348694738474, 15.695865032147397, 15.798223622015554,
	        15.896844304936113, 15.994636909250309, 16.089005357220906, 16.187523173262452,
	        16.286877065339063, 16.38136510301903, 16.48611312927631, 16.580694250205873, 16.676140007828867,
	        16.777566155452426, 16.86851472623604, 16.972276170062106, 17.07236604676929,
	        17.17002998393461, 17.263518742143038, 17.371960381122054, 17.46679324741868, 17.566527606164218,
	        17.657190108223872, 17.76294506487139, 17.85800143424382, 17.95533926398797,
	        18.054084208438717, 18.152947633230575, 18.24784882593423, 18.348745139145336, 18.447309008046254,
	        18.544926914067986, 18.646181353693144, 18.74249797154525, 18.838536968682273,
	        18.938410159329106, 19.039708295100098, 19.12963606837031, 19.23961832162645, 19.328789120506478,
	        19.428831868588325, 19.524135208177725, 19.623132432405413, 19.725036388007293,
	        19.822908851049924, 19.916681049410915, 20.017173948675897, 20.117788115518543, 20.212385261481966,
	        20.309657314200834, 20.410678718805556, 20.50591946714346, 20.6039071615597,
	        20.710023214016594, 20.795935078224993, 20.892445919823906, 20.997837703659616, 21.091883072100714,
	        21.189986857759582, 21.28474246979953, 21.383595675156343, 21.489635305247493,
	        21.58658072126945, 21.67923306964906, 21.777151543542594, 21.877503807332698, 21.9777124345802,
	        22.074420570417356, 22.171924206337504, 22.26412444140273, 22.370400437296468,
	        22.46440200316392, 22.564445638277135, 22.661225884857526, 22.759392829896036, 22.855759327870224,
	        22.961025126269117, 23.04967330445861, 23.15086367387428, 23.24693124118719,
	        23.342482534019904, 23.440903850791386, 23.54353641327109, 23.639265951519356, 23.735095878576605,
	        23.83628836843447, 23.937952900572512, 24.029500321184912, 24.135181019639223,
	        24.232097520335735, 24.326548923665776, 24.420821030333116, 24.524166950199877, 24.62264131885209,
	        24.720467087699234, 24.8079699036987, 24.915334091759682, 25.006039372376208,
	        25.11092926075667, 25.206329650925014, 25.303373364546196, 25.40449321448272, 25.498342521804513,
	        25.59578509653883, 25.691699415485985, 25.792891227265198, 25.889764286973644,
	        25.989357277209372, 26.09162357758695, 26.18373528480038, 26.281826407237375, 26.37521869912794,
	        26.47482057242853, 26.580942063470875, 26.678337201255403, 26.776286672356854,
	        26.864896626788482, 26.965377322197643, 27.069142380346584, 27.163463331840834, 27.257275123072255,
	        27.35603533182855, 27.454050023145445, 27.55381560630426, 27.652028171736465,
	        27.753068180356422, 27.851517014690277, 27.941954988568334, 28.04625825672801, 28.143590313973302,
	        28.239825994178066, 28.33633209342876, 28.431863693763457, 28.53321745058022,
	        28.63225613663344, 28.724961183491533, 28.828884530768693, 28.924708511933343, 29.025410664836738,
	        29.121282759809816, 29.220270025971008, 29.310135957157353, 29.413877402170062,
	        29.510914274473848, 29.616368558872022, 29.706650112894227, 29.80755514838043, 29.90229574136799,
	        30.00459742503278, 30.098843898329033, 30.194621572805133, 30.296481970402994,
	        30.393556467012353, 30.49110980213624, 30.586373509120993, 30.685775036441395, 30.78946619562423,
	        30.883725941744665, 30.97720911177579, 31.07983605573461, 31.176156653596653,
	        31.27896288818872, 31.368149662172968, 31.469379909589453, 31.568463567862715, 31.665013490312656
e3fcbfa35f47185ce894ef3f008b1020|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|314|1|V|rust
	    static ref ETA_CS_INTERP: UnivariateSpline = {
	        let ys = Array1::<f64>::new((*LOG_ETA_CS));
	        UnivariateSplineBuilder::defualt().build().unwrap()
	    };
45ebad6b43d34f13ff82b7a723284374|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|317|1|V|rust
	    let ys = Array1::<f64>::new((*LOG_ETA_CS));
e6ca3e13a6e099d21dee3c8a7847c5a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|319|30|v|rust
	defualt
418823388c1d431f6f2bc6812880662b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|11|28|v|rust
	[f64; 301]
ccb4724ecead6e41b40fc92478ffa179|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|318|35|v|rust
	LOG_ETA_CS
0631f269bf4b4dc95331cbebb8a83e5a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|318|5|V|rust
	    let ys = Array1::<f64>::new((*));
c1514db37e0f6293710c8abb84876135|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|317|14|v|rust
	Array1::<f64>::new((*LOG_ETA_CS));
839a9103dc0799aed2774990cacc1e88|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	    static ref LOG_XMIN: f64 = 0.602059991327962;
	    static ref LOG_XMAX: f64 = 2.69897000433602;
	    static ref LOG_XSTEP: f64 = 0.006989700043360188;
6fae888b373dcb9c26b009ad7097eb62|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|317|21|v|rust
	0.602059991327962
ab0617cb3c086c2e719222b47b5e2a94|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|318|21|v|rust
	2.69897000433602
61cbe7d4d74cce3526b3e1a6aeead86e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|317|1|V|rust
	    LOG_XMIN: f64 = 0.602059991327962;
	    LOG_XMAX: f64 = 2.69897000433602;
	    LOG_XSTEP: f64 = 0.006989700043360188;
0a89b8d96084c9d886e4919ff3bfd6c4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|316|1|V|rust
	const ETA_CS_INTERP: UnivariateSpline = {
	    let xs = Array1::<f64>::linspace(0.602059991327962, 2.69897000433602, 301);
	    UnivariateSplineBuilder::default(&xs, &(*LOG_ETA_CS))
	        .extrapolation(3)
	        .degree(1)
	        .smoothing_factor(0.0)
	        .build()
	        .unwrap()
	};
f7390f5ee01c5d3ee43ede2747215415|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|498|1|V|cpp
	double DarkSUN::scaled_cross_section_2eta_4eta(double z) {
e6665e58e2de7c9c628bfe21f3250c0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|4|1|V|rust
	    fn sca
d18771f34d567ba9e55a6ce650133705|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|4|1|v|rust
	DarkSUN::
ac7bf4b0ab7c08afad91b9f96ddf9c9f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	    static ref LOG_XMIN: f64 = 0.602059991327962;
	    static ref LOG_XMAX: f64 = 2.69897000433602;
064fcf5306decc0a8c925f9c109ed4db|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	    static ref LOG_XMIN: f64 = 0.602059991327962;
	    static ref LOG_XMAX: f64 = 2.69897000433602;
	    static ref LOG_XSTEP: f64 = 0.006989700043360188;
	    static ref ETA_CS_SLOPE: f64 = 14.02653358183077;
	    static ref ETA_CS_INTERCEPT: f64 = -6.1933023533564535;
d052357f0984a7e8d3fc8e09b605a558|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|13|40|v|rust
	.powi(10)
7f6c75a4c8882782f1378f4cd6454a24|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|15|5|V|rust
	    pub fn 
e4757703c7ed226e2c3a7f1ec8c9d08f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|514|1|V|cpp
	double DarkSUN::scaled_thermal_cross_section_2eta_4eta(double x) {
2d0736e1ae873eb3c5632a8ac73c20c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|16|1|v|rust
	DarkSUN
e5ea568aeeb3d78f3af9093e35e6482b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|538|1|V|cpp
	double DarkSUN::thermal_cross_section_2eta_4eta(double x) const {
e1475b469b10e384cfb69469baf4612f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|314|1|V|rust
	    pub static ref ETA_CS_INTERP: UnivariateSpline = {
	        let xs = Array1::<f64>::linspace(0.602059991327962, 2.69897000433602, 301);
	        UnivariateSplineBuilder::default(&xs, &(*LOG_ETA_CS))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
	    };
1f9b4ae1aedc303dcaca61b8efb5249c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|323|20|v|rust
	ETA_CS_INTERP
05c7038f86dc6090e2ecfda088b53b7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|324|36|v|rust
	UnivariateSpline
412a6b289e5fa50bda7eef9a5ee72e9e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|325|1|V|rust
	        let xs = Array1::<f64>::linspace(0.602059991327962, 2.69897000433602, 301);
	        UnivariateSplineBuilder::default(&xs, &(*LOG_ETA_CS))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
247aae8d412d40274ae76eb76373d5ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|326|14|v|rust
	epto
688ef937e3576db3355f00b8365096b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|18|9|V|rust
	        let zmin = 4.0;
fc6c2a5d504e970af39f22b8258301c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|17|8|v|rust
	scaled_
534cf632e51595a076df540e761cd82a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|30|5|V|rust
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
9ce4f22e8b6c538b79fd323bfbe2be93|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|268|1|V|rust
	    #[test]
	    fn test_compute_xi() {
	        use crate::thermally_decoup::*;
	        let n = 10;
	        let lamc = 1e-3;
	        let model = DarkSun::default(n, lamc).build();
	        println!("{:?}", model.compute_xi_const_td(lamc / 2.0));
	    }
47b926eeba99c0e75a3837d8cbf84d9f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|277|8|v|rust
	test_compute_xi
ab1e6959556cde71fc703fa619511789|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|278|9|V|rust
	        use crate::thermally_decoup::*;
9dbc991c4239b2ab99b0cd56bfb1ee23|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|282|32|v|rust
	compute_xi_const_td(lamc / 2.0));
dc9a2564799447a4d93d463697b6273f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|6|12|v|rust
	scaled_cross_section_2eta_4eta
c9b4ac16c4699bc4336325ea23dca13c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|278|13|v|rust
	crate::model
c288c2dd611aa70b3fa5baa324be1da6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|276|1|V|rust
	    #[test]
	    fn test_scaled_cs() {
	        use super::cross_sections::*;
	        let n = 10;
	        let lamc = 1e-3;
	        let model = DarkSun::default(n, lamc).build();
	        let xs = [4.1, 4.5, 5.0, 10.0, 20.0, 50.0, 100.0];
	        for x in xs.iter() {
	            println!("{:e}", model.scaled_cross_section_2eta_4eta(*x));
	        }
	    }
d911a99b29da8f775787b05c41a9e3ab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|288|13|v|rust
	scaled
b09ca3d2e3a8eb5d8abfef200c618556|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|293|19|v|rust
	4.1, 4.5, 5.0, 10.0, 20.0, 50.0, 100.0
1f1aa6340575b86f3bbf16257adb125f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|278|9|V|rust
	        use super::cross_sections::*;
a9666f4bea3e5a6b2adf2f709aa98e86|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|13|20|v|rust
	*ETA_CS_SLOPE
73060f379ebc2e3c90568a7239b6ee9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|13|48|v|rust
	*ETA_CS_INTERCEPT
eedd3b7b92a4bdab7c8fbebe5826d22d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|3|1|V|rust
	pub mod data;
cd41bdf12fd26accc64dcd42feb27dff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|4|1|V|rust
	pub fn dudt(mut dw: ArrayViewMut1<f64>, w:ArrayView1<f64>, logx:f64) {
	}
1da68d6c626dc99f20ddfde5b8ce8bb2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|420|1|V|cpp
	        double x = exp(logx);
	        double meta = model->m_eta.get_mass();
	        double Tsm = meta / x;
	        double xi = model->compute_xi(Tsm);
	        double Td = xi * Tsm;
	        double s = sm_entropy_density(Tsm);
	
	        double neq = model->m_eta.neq(Td);
	        double weq = log(neq / s);
215fc09d4980daf579abe95388b3eea5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|7|9|V|rust
	        double x = exp(logx);
ff23f5eaf14dd7a18d22da04f39a3fab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|7|35|v|rust
	.get_mass();
9cd2819a8594bbdf65453cf465935979|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|178|1|V|rust
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    /// Confinement scale.
	    pub lamc: f64,
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    pub c: f64,
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
b02b79881c22f4bd7ff21d7ce9db62e7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|1|V|rust
	    pub params: DarkSunParameters,
83b5ff188d1996eff6859c05c8e6ffcb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|195|1|V|rust
	/// Parameters of the dark SU(N) sector.
	#[derive(Debug, Clone, Copy)]
	pub struct DarkSunParameters {
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    /// Confinement scale.
	    pub lamc: f64,
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    pub c: f64,
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	}
e201eeb0dbb7fcd02bd373b58e0fe700|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|198|1|V|rust
	    /// Eta struct
	    pub eta: ThermodynamicParticle,
	    /// Delta struct
	    pub delta: ThermodynamicParticle,
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	    /// Solution to the Boltzmann equation.
	    pub sol: Option<OdeSolution>,
f572fc23a8ebfec783769a960d3f3ad4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|31|1|V|rust
	    pub output: DarkSunOutput,
d11fd339b1009fd7a86f8a376c796ff2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|221|1|V|rust
	/// Output parameters from solving the Boltzmann equation.
	pub struct DarkSunOutput {
	    /// Eta struct
	    pub eta: ThermodynamicParticle,
	    /// Delta struct
	    pub delta: ThermodynamicParticle,
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	    /// Solution to the Boltzmann equation.
	    pub sol: Option<OdeSolution>,
	}
255138df06ded957eb7461bc9b500a94|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|96|1|V|rust
	            n,
	            lamc,
	            xi_inf,
	            c,
	            lec1,
	            lec2,
	            adel,
	            mu_eta,
	            mu_del,
d5c0b2a1ad8a21e24ee7ae7a324c2e54|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|100|9|v|rust
	let output = 
29c2c02a361c9d7028472e5d92cd4a54|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|100|16|v|rust
	Output
ea0206e88a2dd596ef2d3e9a3a75fb6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|95|9|V|rust
	        let params = DarkSunParameters {
9c876a2fd96ae0e0042fa294b3d2b867|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|130|9|V|rust
	        DarkSun { params, output }
ee9fa0df8dfb80e2ee6820cffbf38333|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|177|1|V|rust
	            n: self.n,
	            lamc: self.lamc,
	            xi_inf: self.xi_inf.unwrap_or(1e-2),
	            c: self.c.unwrap_or(1.0),
	            lec1: self.lec1.unwrap_or(1.0),
	            lec2: self.lec2.unwrap_or(1.0),
	            adel: self.adel.unwrap_or(1.0),
	            mu_eta: self.mu_eta.unwrap_or(1.0),
	            mu_del: self.mu_del.unwrap_or(1.0),
65c76914889f4a61e5625c6542af5d64|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|214|1|v|rust
	params, output
0610df6ceafd2d2c1fc2472fcdad3e6a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|191|1|V|rust
	            eta: ThermodynamicParticle {
	                m: meta,
	                g: 1.0,
	                spin2: 0,
	            },
	            delta: ThermodynamicParticle {
	                m: mdel,
	                g: (self.n + 1) as f64,
	                spin2: self.n,
	            },
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	            sol: None,
8afffc613f59cd24914806738f39e6d9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|190|13|V|rust
	        let output = DarkSunOutput {
	            eta: ThermodynamicParticle {
	                m: meta,
	                g: 1.0,
	                spin2: 0,
	            },
	            delta: ThermodynamicParticle {
	                m: mdel,
	                g: (self.n + 1) as f64,
	                spin2: self.n,
	            },
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	            sol: None,
	        };
dc5c9212098dc9427c24cb34f0c250d3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|176|9|V|rust
	        let params = DarkSunParameters {
	            n: self.n,
	            lamc: self.lamc,
	            xi_inf: self.xi_inf.unwrap_or(1e-2),
	            c: self.c.unwrap_or(1.0),
	            lec1: self.lec1.unwrap_or(1.0),
	            lec2: self.lec2.unwrap_or(1.0),
	            adel: self.adel.unwrap_or(1.0),
	            mu_eta: self.mu_eta.unwrap_or(1.0),
	            mu_del: self.mu_del.unwrap_or(1.0),
	        };
fbe3d3d094b477f1ae930b6ab25499e3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|176|1|V|rust
	        let mue = self.mu_eta.unwrap_or(1.0);
78e6221f6393d1356681db398f14ce6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|6|14|v|rust
	output
dd4f9ac8c4b8800253d359c08004356f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|33|1|V|rust
	            self.compute_xi_const_tsm(tsm)
7e64c2f67bab1366ea58c64ea3f5ccc6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|39|1|V|rust
	        if self.tsm_fo.is_none(){
	        }else{
	            if self.tsm
	        }
dd57ebd2b15cc6f907d9ca342a5a5bfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|31|17|V|rust
	                if tfo * self.xi_fo.unwrap() > self.eta.m{
07832a95e3952abb8ce9044042475f22|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|442|1|V|cpp
	        double sig_ee_eeee = model->thermal_cross_section_2eta_4eta(meta / Td);
	        double sig_eeee_ee = sig_ee_eeee / neq / neq;
	        sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	        double sig_ee_dd = model->thermal_cross_section_2eta_2delta(meta / Td);
	
	        double pf_e = -sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) * Tsm * s * s;
	        double pf_d = sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) * meta / (x * x);
	
	        // dW_e / dlogx
	        dw(0) = pf_e * sig_eeee_ee * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
	
	        // dY_d / dlogx
	        dw(1) = pf_d * sig_ee_dd * exp(2.0 * w(0));
e9b57f14a39d377541cfd6f6b2508da9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|36|34|v|rust
	w[0].exp()
2213bbf9d6ab23712c4dcb84acf2e0a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|8|1|V|rust
	    let x = logx.exp();
	
	    let meta = model.eta.m;
	    let tsm = meta / x;
	    let xi = model.compute_xi(tsm).unwrap();
	    let td = xi * tsm;
	    let s = sm_entropy_density(tsm);
	    let neq = model.eta.neq(td);
	    let weq = (neq / s).ln();
	
	    if w[0] - weq > 0.1 && model.xi_fo.is_none() {
	        model.xi_fo = Some(xi);
	        model.tsm_fo = Some(tsm);
	    }
	    if tsm < T_BBN && model.xi_bbn.is_none() {
	        model.xi_bbn = Some(xi);
	    }
	
	    let sig_ee_eeee = model.thermal_cross_section_2eta_4eta(meta / td);
	    let sig_eeee_ee = sig_ee_eeee / neq / neq;
	    // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	    let sig_ee_dd = model.thermal_cross_section_2eta_2delta(meta / td);
	
	    let pf_e = -(PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * tsm * s * s;
	    let pf_d = (PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * meta / (x * x);
	
	    // dW_e / dlogx
	    dw[0] = pf_e * sig_eeee_ee * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
	
	    // dY_d / dlogx
	    dw[1] = pf_d * sig_ee_dd * (2.0 * w[0]).exp();
bae33898bb27b11eeec42ed1dab5d741|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|53|1|V|rust
	    if w[0] - weq > 0.1 && model.xi_fo.is_none() {
	        model.xi_fo = Some(xi);
	        model.tsm_fo = Some(tsm);
	    }
	    if tsm < T_BBN && model.xi_bbn.is_none() {
	        model.xi_bbn = Some(xi);
	    }
b2461fbb182314e12d85d69383a9a349|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|478|1|V|cpp
	        // df_d / dW_e
	        J(0, 0) = pf_e * sig_eeee_ee * exp(w(0)) * (3.0 * exp(2.0 * w(0)) - exp(2.0 * weq));
	
	        // df_e / dY_d
	        J(0, 1) = 0.0;
	
	        // df_d / dW_e
	        J(1, 0) = 2.0 * pf_d * sig_ee_dd * exp(2.0 * w(0));
	
	        // df_d / dY_d
	        J(1, 1) = 0.0;
2456a85a56b1537d5aae9a4e32b314e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|63|1|V|rust
	    // dW_e / dlogx
	    dw[0] = pf_e * sig_eeee_ee * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
	
	    // dY_d / dlogx
	    dw[1] = pf_d * sig_ee_dd * (2.0 * w[0]).exp();
171fabf405dcad1d20a5efc9deea2005|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|63|38|v|rust
	exp(w(0))
32cc605bf7b9a483eb585e1cecbd083b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|578|1|V|cpp
	    double me = m_eta.get_mass();
	    double md = m_delta.get_mass();
	    double feta = (std::sqrt(m_N) * m_lam / (4.0 * M_PI));
	    double pf_num = std::exp(-2.0 * m_c * m_N) * pow<4>(me) * x;
	    double pf_den = 2.0 * M_PI * pow<2>(4.0 * feta * feta * m_lam * besselk2e(x));
	    double pf = pf_num / pf_den;
	    double r = md / me;
8041b0d6ed8709e64d5af469e8caae48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|41|25|v|rust
	get_mass();
b6005afdf49ac7a7c3de3e79425b7c5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|43|47|v|rust
	pow<4>(
e2159df0db83509bc05008f91436f6ff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|43|18|v|rust
	std::exp
e097be326fbd0aa4812f81b00b105111|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|44|31|v|rust
	pow<2>
f0aa6c186ae0493e8c294702e91b7230|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|19|1|V|rust
	        use std::f64::consts::PI;
2eafa660cbf35185b612fbef79e85121|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|4|1|V|rust
	use str
78ac7a8e81ea7502712989f3b3a17817|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|17|v|rust
	std::sqrt
ac4c4c85b25cf3b82b947d2cd62145b4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|49|v|rust
	4.0 * PI
c590c62f6d76dde631267f8ddebe7944|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|16|v|rust
	(n as f64).sqrt() * self.lamc / (4.0 * PI)
b82dfef35494bf848a1696e81e0a3887|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|41|1|V|rust
	        let feta = (self.n as f64).sqrt() * self.lamc / (4.0 * PI);
	        let pf_num = (-2.0 * self.c * self.n as f64).exp() * me.powi(4) * x;
	        let pf_den = 2.0 * PI * (4.0 * feta * feta * self.lamc * x.cyl_bessel_kn_scaled(2)).powi(2);
	        let pf = pf_num / pf_den;
	        let r = md / me;
779a9da9d7dc77f33413f2081f857fbf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|39|9|V|rust
	        let me = self.eta.m;
257c14f89bc2dda06ebe4824e44433b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|39|9|V|rust
	        let md = self.delta.m;
b602c99c805c3109a35bbcabe65fd1c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|45|44|v|rust
	bessel
c9e0b92798b7d2f0771e4d1f42cfd334|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|45|9|V|rust
	        smin = 4mdel^2
d96768420047f36b7a7df24f4e0a9311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|44|9|V|rust
	        z = sqrt(s) / meta
189c6c15191f92d815d07eb9f5798cd2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|373|1|V|cpp
	        double gd = dark_geff(Tsm * xi);
	        double gsm = sm_geff(Tsm);
	        return sm_sqrt_gstar(Tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
91c52d52878440862637987e42812caa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|9|39|v|rust
	Tsm * xi
4835878fd905312519bb5a4969fcb658|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|9|18|v|rust
	(xi * tsm)
698bf4d26de9276c43e2e690448c569f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|369|1|V|cpp
	        return m_eta.geff(Td) + m_delta.geff(Td) + m_dark_photon.geff(Td);
eeffd97201fc55c324c4ad452b90c6b3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|11|1|v|rust
	self.dark_geff(xi * tsm);
320bcebcae8ba09347c2d546f816400c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|2|1|V|rust
	use crate::thermally_decoup::ThermallyDecoupledModel;
7bd6057814cdbefabe7a519ae1278624|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|11|48|v|rust
	 + m_dark_photon.geff(Td);
0235da9fd6b59359a5929382a37b006c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|274|1|V|rust
	    #[test]
	    fn test_tcs_eta() {
	        let n = 10;
	        let lamc = 1e-3;
	        let model = DarkSun::default(n, lamc).build();
	        let xs = [1.0, 2.0, 5.0];
	        for x in xs.iter() {
	            println!("{:e}", model.thermal_cross_section_2eta_4eta(*x));
	        }
	    }
421599b984b17604b065b90f8b4417e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|285|13|v|rust
	tcs_eta
a821ca3cee52dd37fcbc4e8686400133|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|21|5|V|rust
	        self.
fb02889819f182d492a16aaf5c3dce74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|10|15|v|rust
	: Option<f64>,
1237d0b47f2971c9874473fcd3a5b883|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|20|13|v|rust
	: Option<OdeSolution>,
be513b273f0a91394c7335bd44ece945|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|695|1|V|cpp
	    double Td_init = m_lam / 2.0;
	    double xi_init = compute_xi_const_td(Td_init);
	    double Tsm_init = Td_init / xi_init;
	
	    double xstart = m_eta.get_mass() / Tsm_init;
	    double xfinal = m_eta.get_mass() / kT_CMB;
	    double w_eta_init = log(m_eta.neq(Td_init) / sm_entropy_density(Tsm_init));
	    double y_delta_init = exp(-m_a * m_N) * m_delta.neq(Td_init) / sm_entropy_density(Tsm_init);
	
	    auto logx_span = std::make_pair(std::log(xstart), std::log(xfinal));
	
	    Vector<double> winit{2};
	    winit(0) = w_eta_init;
	    winit(1) = y_delta_init;
9fdac04d5f3d1bea31e7882b6113c1ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|29|31|v|rust
	get_mass()
13f9d86492d170fc50f0848d3c66aece|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|30|30|v|rust
	.get_mass()
4aefa78ae264003ac4d5215d6113398c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|34|9|v|rust
	auto 
fde994b876c45c763f7100242de5df37|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|34|24|v|rust
	std::make_pair
43e37bd3580858eaac1c6c625a1a4753|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|40|9|V|rust
	        let logxspan = ();
551a7c186230e3970b37594ddeac2b3e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|37|16|v|rust
	w_eta_init
504544f0352895dbf29b5cef9c1617d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|41|1|V|rust
	        winit[0] = w_eta_init;
e7cc983fcc95e543ddc227e86f67a494|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|38|16|v|rust
	y_delta_init
feeacbf4bfa18126ff220763663e6799|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|36|1|V|rust
	    Vector<double> winit{2};
	    winit(0) = w_eta_init;
	    winit(1) = y_delta_init;
53f7d7cc70e8fa93b5b40d904d418b20|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|46|36|v|rust
	integrator.params
b26b9a81ed95a0f7fe4b3cdb8ecaa1eb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|65|1|V|rust
	    /// Callback function to mutate state of integrator after each step.
	    pub callback: Option<&'a dyn Fn(&mut Self)>,
cca0e401894ce8662a7ba23a669bd5da|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|201|1|V|rust
	    pub fn hess(mut self, val: bool) -> Self {
	        self.opts.hess = val;
	        self
	    }
90c62f60544de31ba2e69d2f2a51314f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|205|12|v|rust
	hess
326d56af80f8c60fe117ba2db99eb6cd|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|205|31|v|rust
	val: bool
1bd9ec692e6f9339746c5d60fd7fa935|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|128|1|V|rust
	        jac: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
7723e65d3c5f50e5cc4283a0601b6808|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|206|24|v|rust
	ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params
19a73e202797728a1554c79568157d2d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|94|37|v|rust
	&mut OdeIntegrator<'a, Params, Alg>
e94b1731e6e5ed240190907b52e4d9cb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|205|46|v|rust
	&mut Self
57a51c77a5cb0dc5bcfe22e86c4a873a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|17|1|V|rust
	    #[test]
	    fn test_ho() {
	        struct HO {
	            w: f64,
	        };
	        let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t: f64, p: &HO| {
	            du[0] = u[1];
	            du[1] = -p.w * u[0];
	        };
	        let uinit = array![0.0, 1.0];
	        let tspan = (0.0, 2.0);
	        let mut integrator = OdeIntegratorBuilder::default(
	            &dudt,
	            uinit.clone(),
	            tspan,
	            DormandPrince5,
	            HO { w: 1.0 },
	        )
	        .build();
	        let reltol = integrator.opts.reltol;
	
	        for (t, u) in (&mut integrator).into_iter() {
	            println!("{}, {}", t, u);
	            let dx = u[0] - t.sin();
	            let dy = u[1] - t.cos();
	            assert!(dx.abs() <= reltol * t.sin().abs() * 10.0);
	            assert!(dy.abs() <= reltol * t.cos().abs() * 10.0);
	        }
	    }
883c5f884c4cff226a7aecc147dfcf30|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|49|13|V|rust
	            w: f64
2904c7f6dbdca1ace6f0e3e604ad9a2c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|54|21|v|rust
	-p.w * u[0];
2d76241d116cb8fd285ff7617458e315|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|53|1|V|rust
	        let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t: f64, p: &BallDrop| {
	            du[0] = u[1];
	            du[1] = -p.g -p.b/p.m * u[1];
	        };
5e214152ec58bf8e1c65d71d5d9fcaac|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|57|25|v|rust
	mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t: f64, p: &BallDrop
515c9f722422bef0ae9b333ffd925e0f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|58|13|V|rust
	            du[0] = u[1];
7405c9d5ad6a3dba1ad1f38bec084fde|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|58|13|V|rust
	            du[1] = -p.g -p.b/p.m * u[1];
7c5508e58eacd21c38dc3f3c45884b57|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|69|24|v|rust
	w: 1.0 },
f06e022fc51c72a1f297512c84b0d671|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2134|1|V|c
	  fprintf("mass is = %e", M);
31b94167285dd1490b1e3508644d5164|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2070|13|v|c
	factor2;
b523fea6d3ec4deffe5016547591922c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2072|1|V|c
	    *rho *= 
db02434cc5461ce431383ebaa4e213e9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2045|1|V|c
	    // Function struct needed by GSL to integrate a function. We will use
	    // this for all functions and just set the `function` parameter
	    // appropriately (see below)
	    gsl_function F;
	    // Parameters of the PS distribution needed to evaluate integrands.
	    F.params = &params;
	    // Set function to integrate:
	    F.function = &ncdm_number_density_integrand;
	    double error;    // We will store the estimate integration errors here
	    double lb = 0.0; // Lower bound of integration.
	                     // Perform integration:
	    gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, n, &error);
	    // Set the result and rescale. Need extra factor of 1/rescale since
	    // n ~ T^3 and factor2 is for something that goes like T^4
	    *n *= factor2; /// rescale;
046c8fe1439d8bfc48146d16273b5359|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|2|V|c
	      // Function struct needed by GSL to integrate a function. We will use
f89b12961469a868d7e3e8adcc85a0fd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|7|V|c
	      // this for all functions and just set the `function` parameter
ff021130f0c6fd93032094257b3316f3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|7|V|c
	      // appropriately (see below)
41ae5abebb9a8c6ae592a532bd93c9cc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2074|7|V|c
	      // Parameters of the PS distribution needed to evaluate integrands.
8474db98a9934286a1761e6e6780f476|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2076|24|v|c
	// We will store the estimate integration errors here
5e8bcd52d31389eee350addeece75d72|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|23|V|c
	                       // Perform integration:
d257d1049a91d1d880cb31286a962fa2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2079|7|V|c
	      // Set the result and rescale. Need extra factor of 1/rescale since
a3a3d8633766774bae1b1081e869ccfc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2079|7|V|c
	      // n ~ T^3 and factor2 is for something that goes like T^4
b8429e8290213a050287c2ee2d658512|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2079|22|v|c
	/// rescale;
edf6f2652acd68ff8a942e7e25876be5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2071|7|V|c
	      *rho = *n * M / rescale;
4e6b837b4541705c04dedc0981bc037f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2071|6|v|c
	else{
e77ceb53a70662088364921998181cda|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2059|20|v|c
	/// 
0b7f8fbae4b3c7b92d9f04fb1128d994|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2079|1|V|c
	    *rho *= *n * M / rescale;
b27750a7d69891ff71f13a6b1bcb4bc6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|7|v|c
	*rho
8ee61557cfd58ccc02678a1a2eb1134e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2077|31|v|c
	M / 
92abe858b1c2461bfce47e9d449c1cfd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2070|7|V|c
	      gsl_function F;
3a36d6e923a14e3b02610de6ee719973|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|7|V|c
	      double lb = 0.0;
9e5aadf0ed21cdd1c4bd0969e0526965|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2072|7|V|c
	      double error;
8dc9327d49ff256e686d819595774225|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2073|7|V|c
	      try
2e52f0d5d4dd73a4482e4832a633972f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|5|v|c
	M == mreal / t0 
e3a6ce0739a8765fce89bc6805d7d40f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|1|V|c
	    throw(,,
082cbba20d8b678e5e61f02116c72e9d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|83|1|V|rust
	            assert!(dx.abs() <= reltol * t.sin().abs() * 10.0);
832fda059cf24a6877a974d3c9336ec1|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|83|13|V|rust
	            assert!(dy.abs() <= reltol * t.cos().abs() * 10.0);
9e61945de6e1d1429e216d1795a8f676|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|81|9|V|rust
	            let dx = u[0] - t.sin();
933e79b5ea4d6ebd06fbc6b84402b64c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|81|13|V|rust
	            let dy = u[1] - t.cos();
557c1f58d0dbcef320eb7a5f89757e39|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|59|1|V|rust
	                integrator.u[1] *= -1.0;
0fc80272a7907b88c009791167477aa9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/dorm_prince/dp5.rs|59|17|V|rust
	                integrator.u[0] *= -1.0;
054ee5a7d490e6540710eb6a2d83da04|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode.rs|7|1|V|rust
	pub mod statistics;
75ecde7cb63c1cafc7ec71efd4bea8d6|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/callback.rs|1|1|V|rust
	pub struct OdeCallBack{
534f4ae8dc5aa3f8726628339ee867d8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/callback.rs|4|13|v|rust
	_', 
43aab34e6a79513eddcf5a0df2229f24|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/callback.rs|4|45|v|rust
	&_', 
a1158ce94501b6abcfe43f8aeb26ec19|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/callback.rs|1|1|V|rust
	use super::integrator::OdeIntegrator;
69ebfe93c031bbcbc6e0e90f4da4be60|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/callback.rs|5|71|v|rust
	'_, 
b78a3223503896721cca1303f776159b|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|15|8|v|tex
	Title
ea65094239d1df0deeccc6928c30efb1|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|38|1|V|tex
	\begin{align}
bb2183e09af5e6020e365b4064b00eb5|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|38|1|V|tex
	\end{align}
c2d2ca6863ab0852018350dea1ac4fb4|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|33|1|V|tex
	Given the Boltzmann equation
	\begin{align}
		E\qty(\pd{t}-H\vb{p}\cdot\grad{\vb{p}})f = C_{\mathrm{ann}}[f] + C_{\mathrm{el}}[f]
	\end{align}
	we would like to investigate the elastic term. The elastic term is given by:
	\begin{align}
		C_{\mathrm{el}}[f] = \int
	\end{align}
3ffbce4da1156f03308c5938b281ad50|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|38|1|V|tex
		\dfrac{\dd{\tilde{\vb{p}}}}{(2\pi)^22\tilde{E}}
b4606e0d95329646c9812158f5f83d78|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|39|16|v|tex
	\tilde{
261beaae3b9043cf72318ee0aa079cd4|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|39|34|v|tex
	\{E}
e662f69223d7f3c085658712e60b5bae|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|45|1|V|tex
		J = \qty[\qty(1\mp g^{\pm}(\omega))g(\tilde{\omega})f(\tilde{p})
91588191240367b05bb03d398b1b3f28|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|45|11|v|tex
	\qty(1\mp g^{\pm}(\omega))g(\tilde{\omega})f(\tilde{p})
9a9cda0923076851501b891a91c97463|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|51|14|v|tex
	\label{eq:}
90574d53407bf526693803899039f667|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|52|11|v|tex
	\tilde{\vb{p}}+\tilde{\vb{k}} - \vb{p}-\vb{k}
55451adb3e8e80136c682d2a7c3b9deb|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|53|26|v|tex
	\tilde{\vb{k}}
fcc28714ec79a629b9b2d0f2c88514de|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|53|2|v|tex
	\delta^3(\tilde{\vb{p}} - \vb{p}+\vb{q})
6206d5bcf69df94288b18a308a1ee949|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|54|11|v|tex
	\tilde{\vb{p}} - \vb{p}
71a24733cc2d6f12caa2713f2cfeeeb3|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|59|2|V|tex
		\label{eq:}
997eedec4985bdbbcb7ac4aadd97fe8d|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|59|2|v|tex
	C_{\mathrm{el}}
747103d715eeea0974d721739a3b0c52|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|37|1|V|tex
		C_{\mathrm{el}} = \int
		\dfrac{\dd[3]{\tilde{\vb{p}}}}{(2\pi)^22\tilde{E}}
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		(2\pi)^4\delta^4(\tilde{p}+\tilde{k}-p-k)\qty|\mathcal{M}|^2J
ca827ee501e58b998913542a57d923b8|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|64|1|V|tex
		C^0 = 	
e7988cafcc6f43a068881720315e9d77|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|64|1|V|tex
		C^0_{\mathrm{el}} &= \int
		\dfrac{\dd[3]{\tilde{\vb{p}}}}{(2\pi)^22\tilde{E}}
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		(2\pi)^4\delta(\tilde{E}+\tilde{\omega}-E-\omega)
		\delta^3(\tilde{\vb{p}}-\vb{p})\qty|\mathcal{M}|^2J\\
d22451ba8ca9e13afbcc6c40b7fda4b2|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|65|2|V|tex
		\dfrac{\dd[3]{\tilde{\vb{p}}}}{(2\pi)^22\tilde{E}}
73a2a05cd47305f63b4c11d8df138ac2|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|68|33|v|tex
	\qty|\mathcal{M}|^2J
7a77ad03a69b6b1e4f2d440e19cf313d|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|68|2|v|tex
	\delta^3(\tilde{\vb{p}}-\vb{p})
9179259486cc9b3d5e464d5705f82618|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|64|1|V|tex
		C^0_{\mathrm{el}} &= 2\pi\int
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		(2\pi)^4\delta(\tilde{E}+\tilde{\omega}-E-\omega)
		\qty[\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]\bigg{|}_{\tilde{\vb{p}}=\vb{p}}\\
c496dae5c54e7a100e468c256e30638c|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|68|1|V|tex
		\qty[\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]\bigg{|}_{\tilde{\vb{p}}=\vb{p}}\\
484d7fab2cbb5d57aef941c1cea4b7c0|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|73|10|v|tex
	\delta(\tilde{E}+\tilde{\omega}-E-\omega)
c736a0a0ed8dbac2305cb72c465cbf84|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|74|2|V|tex
		\qty|\mathcal{M}|^2J
cc887b646ce5faf9cbbe0797309f5bb6|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|73|2|V|tex
		(2\pi)^4\delta(\tilde{E}+\tilde{\omega}-E-\omega)
f276fe28fa0f49559a717517a8aaa102|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|67|2|v|tex
	(2\pi)^4
93ef823bc64529e05e34e182cf76287c|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|67|9|v|tex
	\tilde{E}+
4d924b4dba1d387813aa5ce9fd122367|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|64|2|v|tex
	C^0_{\mathrm{el}}
ad6b8c4abc26e56132236ab03903f4a6|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|69|1|V|tex
		C^n_{\mathrm{el}} &= \dfrac{2\pi(-1)^n}{n!}\int
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		\qty{\qty(\vb{q}\cdot\nabla_{\tilde{\vb{p}}})^n
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]}\bigg{|}_{\tilde{\vb{p}}=\vb{p}}
1690df58ba1b9704a58512bf04dd6522|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|63|8|v|tex
	align}\label{eq:}
		C^0_{\mathrm{el}} &= 2\pi\int
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		\delta(\tilde{\omega}-\omega)
		\qty[\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]\bigg{|}_{\tilde{\vb{p}}=\vb{p}}\\
		C^n_{\mathrm{el}} &= \dfrac{2\pi(-1)^n}{n!}\int
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		\qty{\qty(\vb{q}\cdot\nabla_{\tilde{\vb{p}}})^n
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]}\bigg{|}_{\tilde{\vb{p}}=\vb{p}}
	\end{ali
cbb03c2727a9b8065b1d3cac77592583|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|83|1|V|tex
		C^0_{\mathrm{el}} &= 2\pi\int
		\dfrac{\dd[3]{\vb{k}}}{(2\pi)^22\omega}
		\dfrac{\dd[3]{\tilde{\vb{k}}}}{(2\pi)^22\tilde{\omega}}
		\delta(\tilde{\omega}-\omega)
		\qty[\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]\bigg{|}_{\tilde{\vb{p}}=\vb{p}}\\
c3198a6dbef629ca31403b4ccdff3fc7|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|83|31|v|tex
	2\pi
94d7aa9cc3d27174cf260876f7fd3c41|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|83|24|v|tex
	\dfrac{(-1)^n}{n!}
6f5422c3a136245678b78d4ab139259e|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|91|4|v|tex
	abel{eq:}
7254d298e7599f6201babafcf9a654a7|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|86|1|V|tex
		\qty{\qty(\vb{q}\cdot\nabla_{\tilde{\vb{p}}})
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]}\bigg{|}_{\tilde{\vb{p}}=\vb{p}}
ebf73ce18b48d7e9536c5be4762c01a6|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|91|2|v|tex
	\qty{
90415d73a31c6e7b4aa179717c69f8bb|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|91|2|v|tex
	\qty(
7679976b38cdf925ae54ff0ae864283b|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|91|1|V|tex
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}
0212d665e4dac4394b698c958d53151f|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|92|48|v|tex
	\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
9286ecb5837fb6e01044c885f009c268|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|93|4|v|tex
	\dfrac{
6206c7e85455bdb4f61ada73ac55e67d|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|93|1|V|tex
		&=\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)
bef6898194ac6e9e2316d6b2c8ed7fae|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|93|16|v|tex
	\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)
977081e0e6bd7422d1e48e1a7a6fbbd3|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|96|2|v|tex
	\vb{q}\cdot\nabla_{\tilde{\vb{p}}}
be6c36da517f067449ee3d1d1524868b|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|95|3|v|tex
	\qquad
9e9c5e5df52521c52d35714a5eff8ff8|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|95|4|v|tex
	\delta(\tilde{E}+\tilde{\omega}-E-\omega)
		\qty[J\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}}
6ff433367938d71ac8802ac522624831|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|90|1|V|tex
	\begin{align}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]
		&=\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)\\
		&+\delta(\tilde{E}+\tilde{\omega}-E-\omega)
		\qty[J\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}} 
		+ \dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}}\vb{q}\cdot\nabla_{\tilde{\vb{p}}}J]\notag
	\end{align}
68a366b2e39b2a7f4435cc58d101ea54|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|101|2|V|tex
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]
488e97bc823878a2fd45665fa67e3d9a|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|101|2|V|tex
		&=\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
b4af05ebe4da44d6349c50e44d526d9c|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|101|2|V|tex
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)\\
31cee55bde09138484b33054dec1b1ce|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|103|2|V|tex
		+ \dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}}\vb{q}\cdot\nabla_{\tilde{\vb{p}}}J]\notag
928e5a4317f5d2fb84c1da98fc519a39|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|102|1|v|tex
		\qty[
0625593fbb2c728c26a78ddd06904ce5|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|90|1|V|tex
	\begin{align}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}
		\qty[\delta(\tilde{E}+\tilde{\omega}-E-\omega)\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}]
		&=\dfrac{\qty|\mathcal{M}|^2J}{2\tilde{E}}
		\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)\\
		&+\delta(\tilde{\omega}-\omega)
		\qty[J\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}} 
		+ \dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}}\vb{q}\cdot\nabla_{\tilde{\vb{p}}}J]\notag
	\end{align}
538b50d65d2cc84f52a821114febd994|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|111|7|v|tex
	J\vb{q}\cdot\nabla_{\tilde{\vb{p}}}\dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}} 
00452678e1308ec47682250146aad3f6|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|94|13|v|tex
	\nabla_{\tilde{\vb{p}}}\delta(\tilde{E}+\tilde{\omega}-E-\omega)
82ea8ce80d81b95292c934c83693b529|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|107|1|V|tex
		\dfrac{\vb{q}\cdot\tilde{\vb{p}}}{\tilde{E}}\pd{\tilde{\omega}}\delta(\tilde{\omega}-\omega)
cb853b7b2bda927261f7d681a2869b33|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|116|9|v|tex
	\qty|\mathcal{M}|^2}{2\tilde{E}}
c487abc4069ada372566e0edcf9a4198|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|116|2|v|tex
	\dfrac{\qty|\mathcal{M}|^2}{2\tilde{E}}
0cf11142ffae38bfc69d767df5be85f7|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|113|33|v|tex
	\tilde{E}
3d729ee71669a6d00dcc87ef1e9aac89|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|113|16|v|tex
	\qty|\mathcal{M}|^2
92e4da341fe8f4cd46192f21b6ff3aa7|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|127|22|v|tex
	\epsilon
c66a0601fbde0f871cf5541f8f13e2e5|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|127|11|v|tex
	\mu(s_0) -2 E k z \dv{\mu}{s}(s_0)\dfrac{|\vb{p}|}{E} +
		\order{\dfrac{|\vb{p}|}{E}}^2
c5a50aeea3c3fc1424743dba240bb9be|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|128|32|v|tex
	=
		\mu(s_0) -k z \dv{\mu}{\omega}(s_0)\dfrac{|\vb{p}|}{E} +
		\order{\dfrac{|\vb{p}|}{E}}^2
	
a22b84695f3afacc19ed8d20b2813da4|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|127|45|v|tex
	\dfrac{|\vb{p}|}{E}
f5255176e8e39a5549dc79e793c72586|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|127|9|v|tex
	= \mu(s_0) -2 E k z \dv{\mu}{s}(s_0)\dfrac{|\vb{p}|}{E}
		+ 2 E^2 k^2 z^2 \dv[2]{\mu}{s}\dfrac{|\vb{p}|^2}{E^2}+
		\order{\dfrac{|\vb{p}|}{E}}^3 
71cdd0217cc056ed90cffc81c770250a|file:///Users/loganmorrison/Documents/research/BoltzmanEquation/notes/BoltzNotes.tex|126|36|v|tex
	|\vb{p}|
bedc87bfd4ed458691a69a5dbdf6bbc0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|2|1|V|rust
	    /// Compute the thermal average of the cross section times the Moler
	    /// velocity.
	    fn thermal_cross_section(&self, x:f64) -> f64;
	    /// Compute the 'out-of-equillibrum' average of the cross section times the
	    /// Moler velocity.
	    fn thermal_cross_section_neq(&self, x:f64) -> f64;
9e684cc80a19ebf27542be124e4765d9|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|11|5|V|rust
	    /// Compute the 'out-of-equillibrum' average of the cross section times the
2953529f36b4bc9e9f89dff44836e5ff|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|11|5|V|rust
	    /// Moler velocity.
d1bdce2e24b1ae487dc506a6f00fee33|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|11|5|V|rust
	    fn thermal_cross_section2_neq(&self, x: f64) -> f64;
18dee53cc3c32932051a154db6642af0|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|5|5|V|rust
	    /// Moler velocity. The anzsatz 
3773fbe59ec1d57cb2507b72ab190e37|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|5|5|V|rust
	    fn thermal_cross_section_neq(&self, x: f64) -> f64;
93f8bff790d5786414ff83355b679580|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|2|21|v|rust
	thermal average of the cross section times the Moler
	    /// velocity.
	
e309031b8741344607b611dde1fe57bf|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/coupled.rs|4|1|V|rust
	    /// Compute the thermal average of the cross section times the Moler
	    /// velocity times p^2/E
	    fn thermal_cross_section2(&self, x: f64) -> f64;
14d444d031e2511f9d7078e1ec99fb33|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|40|1|V|c
	  char precision_file[_ARGUMENT_LENGTH_MAX_];
17d06a0cb090001a34b89cd5874ad758|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|41|8|v|c
	precision_file
11fe0fd64229689eeaf6ba19027a70a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|63|1|V|c
	  precision_file[0] = '\0';
4084108edd6819ec5381791cfc20bfe4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|61|1|V|c
	  fc_precision.size = 0;
77b1fe17d1ed626ec7d52599281eb49c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|29|1|V|c
	  struct file_content
	      fc_input; /** - --> a temporary structure with all input parameters */
62b9ef1acfe14be602f957ffbb2bc451|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|36|16|v|c
	/** - --> a temporary structure with only the root name */
3a6d55401bd540f987ba86ca90523845|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|35|3|V|c
	  struct file_content fc_root; // LM: For
e2794d8f12719281eff5601251c8a680|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|64|6|v|c
	precision
ca12ed6de944bc7c92f85bbd0542ffda|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|81|17|v|c
	(strcmp(extension, ".pre") == 0)
eaa20751fbc2b53b3b573bc3e3fcf93c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|82|1|V|c
	        class_test(precision_file[0] != '\0', errmsg,
	                   "You have passed more than one precision with extension "
	                   "'.pre', choose one.");
	        strcpy(precision_file, argv[i]);
04c5009b9abd43499743e5013818db32|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|43|3|V|c
	  char data_file[_ARGUMENT_LENGTH_MAX_];
f0ee646675aa9f1aa910611aee75affa|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|39|31|v|c
	 // LM: For data input
2e7432271c6f8125fd47e723c8718571|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|33|1|V|c
	  struct file_content
	      fc_data; /** - --> a temporary structure with all input parameters */
126bf4f00c79ab2e3486fbb13910aff0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|68|16|v|c
	/** - --> a temporary structure with all input parameters */
9426ceea6d4aa7a6fc1dadda0a54b1a7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|61|3|V|c
	  fc_data.size = 0;
7d4f197428b4ac28d82e016cf957c8a6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|63|3|V|c
	  data_file[0] = '\0';
874b3fd3559420065f156978bc596121|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|64|25|v|c
	data.
3f45ebfdfc884e8b2ad3f8446e0427ac|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|154|3|V|c
	  // LM: Parse the .dat file for dark matter temperatures.
5a77505493ca88262d9e3a405c3ef19f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|87|9|v|c
	else if (strcmp(extension, ".dat") == 0) {
	        class_test(data_file[0] != '\0', errmsg,
	                   "You have passed more than one data with extension "
	                   "'.dat', choose one.");
	        strcpy(data_file, argv[i]);
	
61b9b3fc672baaf06ecb41df35e32ec1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/parse_dark_temp.h|1|15|v|cpp
	DARK 
cf6dba712e9bd55cee19ddce38bc680d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/parse_dark_temp.h|1|9|v|cpp
	CLASS_PARSE_DARK_TEMP_H
26f859b5771406468afc72c0a3b88667|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|149|1|V|c
	  if (precision_file[0] != '\0') {
	    class_call(parser_read_file(precision_file, &fc_precision, errmsg), errmsg,
	               errmsg);
	  }
f5644c854c6f9c27ad5e7605ed6c6a8e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|156|44|v|c
	fc_precision
a57f26bee85f959f890596bd91d7a0b2|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|164|1|V|c
	    class_call(parser_cat(pfc_input, &fc_precision, &fc, errmsg), errmsg,
	               errmsg);
ea8ff530a969a2753d1fbbb22f73915c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|166|5|V|c
	    class_call(parser_cat(pfc_input, &fc_precision, &fc, errmsg), errmsg,
68c8833fd06cda993dba5941a7a21f40|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|166|16|V|c
	               errmsg);
7f99ccef80018c282ec99c57c75a44f1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|163|3|V|c
	      (dtd_file[0] != '\0')) {
f4a6f46e3fe81718cc5a647d4c4e729d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/parse_dark_temp.h|4|1|V|cpp
	/**
	 * Structure to hold the dark temperature data
	 */
	struct dark_temp_data {
	  double *sm_temp;
	  double *dark_temp;
	};
72875910d395df5ea42e18539c8d8800|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/parse_dark_temp.h|6|6|v|cpp
	parse_dark_temp_data
ffb70196f435b5671ddbc34e08a73f9e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/include/parse_dark_temp.h|10|58|v|cpp
	, gsl_interp_acc *acc
b888e1ae088024b7c6efef95f657f583|term://.//44853%3A/bin/zsh|43|1|V|floaterm
	Default GSL error handler invoked.
9391ae2529c12df65baf513605014c25|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|87|9|v|c
	else if (strcmp(extension, ".dtd") == 0) {
4d91e9cb466304bcd46e766f00d56686|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|88|8|V|c
	        class_test(data_file[0] != '\0', errmsg,
9da91e0bcd9feb41aafab0e478a00525|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|88|20|V|c
	                   "You have passed more than one data with extension "
635439abe24b4accfa62cc7397c90d1c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|88|20|V|c
	                   "'.dtd', choose one.");
e4ba08a7aed823d536a21993601f8771|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|88|9|V|c
	        strcpy(data_file, argv[i]);
2af5cfdbf8b8b772723ac9cbe6c32895|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/input.c|149|1|V|c
	  // LM: Parse the .dat file for dark matter temperatures.
	  if (dtd_file[0] != '\0') {
	    class_call(parser_read_file(dtd_file, &fc_dtd, errmsg), errmsg, errmsg);
	  }
c8dea1f881f767032b156c2506676457|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2061|13|v|c
	factor2 
e8b7c7cc4e61328f12e1ce1983877a1f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2061|28|v|c
	factor2
c5bc48d7f20369df416ab54cf15a58a5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2061|1|V|c
	    printf("n = %e\n", *n);
ed1fac2c84271fc8b91f83ed01cfaefe|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2076|1|V|c
	      printf("n = %e\n", nn);
07a0cedd9642a7f197f16de28cc2300f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|16|v|c
	nn * factor2 / rescale
78c74579d2b47712529825b3c258381e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2078|18|v|c
	* factor2 / rescale
ce3bf2362242288c159c1fb09e018c21|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1876|3|V|c
	  q * q / x = (k/T)^2 / (m / T) / T
39cdc0bdc27437db82b09752f33f13de|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2080|3|V|c
	      printf("n = %e\n", *n);
532e0bcbf15adeff779faf9f7357e5a8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2077|7|V|c
	      printf("nn, M, rescale = %e,%e,%e\n", nn, M, rescale);
eb3072c8e91fb103a050d49a9a83f2a7|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2069|5|V|c
	    printf("HERE $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
89d0a7b59987b054dfd7680e67158159|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|1875|14|v|c
	-q * q / (2.0 * M / rescale)
e843ad2e1797fed5b6aaa5ff9c5b8238|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|109|1|v|c
	dark_temps = {....}
df9951e3d0e8012659c3c8120c62e7f5|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|254|16|v|c
	_TCMB_SMALL_
ef539fe034afa8e74890e955a9565647|file:///Users/loganmorrison/Documents/coding/rust/cyphus-interpolation/src/interp1d/util.rs|5|1|V|rust
	    let mut ilow = idx_low;
	    let mut ihigh = idx_high;
	
	    while ihigh > ilow + 1 {
	        let i = (ihigh + ilow) / 2;
	        if xarr[i] > x {
	            ihigh = i;
	        } else {
	            ilow = i;
	        }
	    }
	    ilow
9f238cbd677a7340a7263f5035019750|file:///Users/loganmorrison/Documents/coding/gsl/interpolation/linear.c|59|1|V|c
	  x_lo = x_array[index];
	  x_hi = x_array[index + 1];
	  y_lo = y_array[index];
	  y_hi = y_array[index + 1];
	  dx = x_hi - x_lo;
3f10cd3941ab178b27e2fa062eaff9de|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|274|17|v|c
	x_array
bd7385759441bb3066e4e794ed8836cc|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|276|17|v|c
	y_array
39e68d766d86544308d13f668f0b6e58|file:///Users/loganmorrison/Documents/coding/gsl/interpolation/linear.c|64|1|V|c
	  if (dx > 0.0)
	    {
	      *y = y_lo + (x - x_lo) / dx * (y_hi - y_lo);
	      return GSL_SUCCESS;
	    }
	  else
	    {
	      *y = 0.0;
	      return GSL_EINVAL;
	    }
91c12a0aaa67f387e990c3b23d04451c|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|282|4|V|c
	      return GSL_SUCCESS;
c4d7f2f3af107e7607c07b97caa04b70|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|281|7|v|c
	*y = 
71e1593d83472d6d804f7b4b0718c2f8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|286|7|V|c
	      return GSL_EINVAL;
617bff8915a602707e380ae622c677a0|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|288|3|V|c
	  double TD = f(T0);
55889c5700bcee8fcfab7c40d15ee78e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|152|1|V|c
	    2.3812206332141045e-7,   2.7359082495507367e-7,
	    3.1434320996982905e-7,   3.6116625067856847e-7,
	    4.1496420956263097e-7,   4.7677604057982173e-7,
	    5.477954512627536e-7,    6.293939529748887e-7,
	    7.231473443849042e-7,    8.308661395054754e-7,
	    9.546305277997766e-7,    1.0968305413578146e-6,
	    1.2602122046743848e-6,   1.447930558060902e-6,
	    1.6636105784243284e-6,   1.9114171736086656e-6,
	    2.1961356016606958e-6,   2.523263867632242e-6,
	    2.899118881749898e-6,    3.330958428431743e-6,
	    3.8271213008350965e-6,   4.397188306268721e-6,
	    5.05216725066252e-6,     5.804705473130042e-6,
	    6.669334033412828e-6,    7.662748265918711e-6,
	    8.804130115942352e-6,    0.000010115518480022935,
	    0.000011622232198526852, 0.000013353361213617486,
	    0.00001534233390562064,  0.00001762755855645606,
	    0.00002025316523198345,  0.000023269858263125077,
	    0.00002673589567759375,  0.0000307182112503198,
	    0.00003529370588585597,  0.00004055073511766159,
	    0.000046590815250333685, 0.000053530586768939356,
	    0.00006150405985822267,  0.0000706651859175594,
	    0.00008119084009236885,  0.00009328424503752827,
	    0.00010717893788075366,  0.0001231432573222868,
	    0.00014148549876016436,  0.00016255985402957267,
	    0.00018677326942503208,  0.00021459330453414384,
	    0.0002465571601925845,   0.0002832820510531407,
	    0.0003254771296222369,   0.0003739571777572471,
	    0.0004296583271112636,   0.0004936561411869511,
	    0.0005671863865568499,   0.0006516689360135496,
	    0.0007487351415789817,   0.0008602593369455034,
	    0.0009883952619852933,   0.0011356173087914538,
	    0.0013047680371583604,   0.001499114642635861,
	    0.001722409345136211,    0.0019789637257217915,
	    0.002273731327561681,    0.0026124002554711173,
	    0.003001496929882671,    0.0034484975561789193,
	    0.003961935177956545,    0.004551486453358407,
	    0.005228021350146372,    0.00600350009803531,
	    0.006890772118020549,    0.007903224168312496,
	    0.009054050817770522,    0.010355471804683896,
	    0.011817826678526284,    0.013448747708115445,
	    0.015252579859038261,    0.017230370040505514,
	    0.019380083793200397,    0.02169764368503727,
	    0.024178006200929497,    0.026816330605037506,
	    0.02960900679251214,     0.03255436006371291,
	    0.0356529440453311,      0.03890751070703115,
	    0.04232266649213464,     0.04590434515916059,
	    0.049659195035447905,    0.05359380907637371,
	    0.057713952728075626,    0.062023697502238975,
	    0.066524437332867,       0.07121376994676613,
	    0.0760842647546087,      0.08112203291710132,
	    0.08630525381665272,     0.09160274091781531,
	    0.09697282767400073,     0.10236269081518035,
	    0.1077086846696239,      0.11293762646098703,
	    0.11796947426474688,     0.12272123684912713,
	    0.12711194642643103,     0.13106810737996843,
	    0.13452930660243037,     0.13745316722359838,
	    0.1398193030682171,      0.1416317643783132,
	    0.1429201566793599,      0.14373901416796087,
	    0.14416651466651306,     0.144301834340776,
	    0.14426231031559208,     0.14418090932880187,
	    0.1442035061970041,      0.14448700183963556,
	    0.1451982580287294,      0.1465134010226897,
	    0.1486184732836017,      0.15171041226161378,
	    0.15599918981544225,     0.16171032604323105,
	    0.16908827361823628,     0.1784003031379798,
	    0.1899410539017364,      0.20403742969314448,
	    0.2210543193802807,      0.24140042077422624,
	    0.2655348970516622,      0.29397417228168277,
	    0.32729915271139604,     0.3661626328559249,
	    0.41129673971414854,     0.4635201466334644,
	    0.5237447288571622,      0.5929812135455987,
	    0.6723432205438463,      0.7630491186726254,
	    0.8664206439175793,      0.986198082428514,
	    1.1236162821952178,      1.2784810161727505,
	    1.4525164177478076,      1.647488563622209,
	    1.8651746480501157,      2.1073269791126332,
	    2.375633405895521,       2.671678242761375,
	    2.9969050702115996,      3.3525874474576987,
	    3.739813718615318,       4.1594876480942276,
	    4.612350392954017,       5.099023617061466,
	    5.620078190532724,       6.176115569916408,
	    6.767863381461989,       7.396271702240781,
	    8.062603798341733,       8.768511040019668,
	    9.516088976190378,       10.307909947459914,
	    11.147035285036793,      12.037010255282002,
	    12.981847910033014,      13.986007823403906,
	    15.05437504540875,       16.1922438229948,
	    17.405308114579928,      18.699661367794743,
	    20.081804408605638,      21.558659599729904,
	    23.137597251857677,      24.82646126939363,
	    26.63360581042556,       28.56793346906002,
	    30.638939154871075,      32.85675567972894,
	    35.23220558242063,       37.776854304706816,
	    40.503066772892474,      43.424072015460574,
	    46.55402637075819,       49.90808064743277,
	    53.50246040058027,       57.35454301388734,
	    61.482940036459475,      65.90758962721762,
	    70.64985501861226,       75.73262636857905,
	    81.18043197117875,       87.01955727493576,
	    93.2781723273649,        100.};
6beff15584b0fa2c93cd72d60529f583|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|110|33|V|c
	    0.0001,      0.000107189, 0.000114895, 0.000123155, 0.000132009,
	    0.000141499, 0.000151672, 0.000162576, 0.000174263, 0.000186791,
	    0.00020022,  0.000214614, 0.000230043, 0.000246581, 0.000264308,
	    0.00028331,  0.000303677, 0.000325509, 0.00034891,  0.000373994,
	    0.000400881, 0.0004297,   0.000460592, 0.000493705, 0.000529198,
	    0.000567243, 0.000608022, 0.000651734, 0.000698588, 0.00074881,
	    0.000802643, 0.000860346, 0.000922198, 0.000988496, 0.00105956,
	    0.00113573,  0.00121738,  0.0013049,   0.00139871,  0.00149927,
	    0.00160705,  0.00172259,  0.00184642,  0.00197917,  0.00212145,
	    0.00227397,  0.00243744,  0.00261268,  0.0028005,   0.00300184,
	    0.00321764,  0.00344896,  0.00369691,  0.00396269,  0.00424757,
	    0.00455294,  0.00488025,  0.0052311,   0.00560717,  0.00601028,
	    0.00644236,  0.00690551,  0.00740196,  0.0079341,   0.00850449,
	    0.00911589,  0.00977124,  0.0104737,   0.0112267,   0.0120338,
	    0.0128989,   0.0138262,   0.0148202,   0.0158857,   0.0170277,
	    0.0182518,   0.019564,    0.0209705,   0.0224781,   0.024094,
	    0.0258262,   0.0276829,   0.029673,    0.0318063,   0.0340929,
	    0.0365438,   0.039171,    0.0419871,   0.0450056,   0.0482411,
	    0.0517092,   0.0554266,   0.0594113,   0.0636825,   0.0682607,
	    0.0731681,   0.0784282,   0.0840665,   0.0901102,   0.0965883,
	    0.103532,    0.110975,    0.118953,    0.127505,    0.136672,
	    0.146497,    0.157029,    0.168318,    0.180419,    0.193389,
	    0.207292,    0.222195,    0.238169,    0.255291,    0.273644,
	    0.293317,    0.314404,    0.337006,    0.361234,    0.387204,
	    0.41504,     0.444878,    0.476861,    0.511143,    0.54789,
	    0.587279,    0.629499,    0.674754,    0.723263,    0.77526,
	    0.830994,    0.890735,    0.954772,    1.02341,     1.09699,
	    1.17585,     1.26038,     1.35099,     1.44812,     1.55223,
	    1.66382,     1.78343,     1.91164,     2.04907,     2.19639,
	    2.35429,     2.52354,     2.70496,     2.89942,     3.10787,
	    3.33129,     3.57079,     3.82749,     4.10266,     4.3976,
	    4.71375,     5.05263,     5.41587,     5.80523,     6.22257,
	    6.66992,     7.14943,     7.66341,     8.21434,     8.80488,
	    9.43788,     10.1164,     10.8437,     11.6232,     12.4588,
	    13.3545,     14.3146,     15.3437,     16.4468,     17.6291,
	    18.8965,     20.255,      21.7112,     23.272,      24.9451,
	    26.7384,     28.6607,     30.7211,     32.9297,     35.2971,
	    37.8346,     40.5546,     43.4701,     46.5953,     49.9451,
	    53.5357,     57.3844,     61.5099,     65.9319,     70.6718,
	    75.7525,     81.1984,     87.0359,     93.293,      100.};
9130134ee49a9bfe097bfd5ac7ae82b9|file:///Users/loganmorrison/Documents/coding/rust/haliax-constants/src/cosmology.rs|8|24|v|rust
	2.56215e-10
f71fbd033bcdc502ebc8d7e85fd2276e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|280|5|v|c
	Td = 0.0;
183b4d43329983dbefabdca947621676|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|283|3|V|c
	  return Tncmd0 / Td;
632d695ed7cd71e7aaab14a8555a47af|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|269|18|v|c
	TCMB * (1.0 + z)
392711887becabfd799273ef54cfe7dd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|272|3|V|c
	  if 
c62ed19d7f5c181d57aa9fe85848e7f6|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|282|3|V|c
	  double Td;
4efc8b467fb29d3fb362baf1fd3f54c9|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|272|3|V|c
	  // SM temperature at redshift z
9417166a3a6e24abb6522f98d5071251|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|270|3|V|c
	  // CMB temperature in GeV
e9489b9dc03882e1782b8b81d6f5d43d|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|279|5|V|c
	    return Tncmd0 / Td;
733a514c6d8c2abc2f7c49249c301394|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|113|1|V|c
	const double DARK_TEMP_DATA_SMALL_TSM_FIT_POW = 2.00008;
fbb35196f1ed0e8093a2fb2ebbbc6ddf|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|114|49|v|c
	2.00008
3cff449e630c27fb0ae02337b84fbecd|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|281|10|v|c
	DARK_TEMP_DATA_SMALL_TSM_FIT_COF 
c6459d97e85763d47c71e0229a4fd0a4|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|281|54|v|c
	DARK_TEMP_DATA_SMALL_TSM_FIT_POW
3fcaaf422cea0c81cf0d86fde3c4e0c1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|282|10|v|c
	DARK_TEMP_DATA_SMALL_TSM_FIT_COF
7ccfaf8a332ba13d241592b2efed3e3b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2233|3|V|c
	  // printf("recale, factor = %e, %e\n", rescale, factor);
a51cd1dc2e0f03d11e07c091e52c8871|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2233|3|V|c
	  // printf("mass is = %e\n", M);
4fb60d84d2cc9c99010c499bbccdb84b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2233|3|V|c
	  // printf("\n");
2f62789dcdc8b2674e6747a9c3fabb5b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2228|19|v|c
	6.08972e-9;
8d007ed109d7824a15e7b9870920a590|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2275|1|V|c
	      gsl_integration_qagiu(&F, lb, epsabs, epsrel, limit, w, &nn, &error);
a7f51543e5cfa4e209b782b705cdc741|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2107|1|V|c
	  double fq = ncdm_ps_dist(q, fp->mass, fp->rescale);
7ea452363e47918f69dcda4e16e5c3f3|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2126|1|V|c
	  double fq = ncdm_ps_dist(q, eng, fp->chemical_potential);
7b1c22c853b89ed59d6f1b3768b31850|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2107|31|v|c
	fp->mass
8c84f1fd93718cb794a7f75f79fbbec1|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2107|41|v|c
	escale
d6fd3ad3895ca592fa4c0f91bf781868|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|305|16|v|c
	 / Td
42b1d7ff6da6494886f4a6bd0bca11d8|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|259|1|V|c
	  int ilow = idx_low;
	  int ihigh = idx_high;
	
	  while (ihigh > ilow + 1) {
	    int i = (ihigh + ilow) / 2;
	    if (xarr[i] > x) {
	      ihigh = i;
	    } else {
	      ilow = i;
	    }
	  }
78549eb6f82ba0f30c652968168d873a|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|293|14|v|c
	idx_low
cdd12384e47a77bdb103e0da3325981e|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|294|15|v|c
	idx_high
06373326f39e8ab8e8be095a2ebb122b|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|299|11|v|c
	xarr
4a715d6d0e1516c6616608b7ea582aeb|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|305|5|V|c
	    int idx =
6ad13a3fbad5402167dff1fdbd8dc26f|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|305|9|V|c
	        interp_search(&DARK_TEMP_DATA_TSM[0], x, 0, DARK_TEMP_DATA_SIZE - 1);
69e29397f6a34eed700bc6c435419385|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|312|12|v|c
	Tncmd0 
5000f72a326ec2151c0c6582a2e3cb99|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|256|9|V|c
	int interp_search(const double *xarr, const double x, const int idx_low,
	                  const int idx_high) {
	
	  int ilow = idx_low;
	  int ihigh = idx_high;
	
	  while (ihigh > ilow + 1) {
	    int i = (ihigh + ilow) / 2;
	    if (xarr[i] > x) {
	      ihigh = i;
	    } else {
	      ilow = i;
	    }
	  }
	  return ilow;
	}
f2ac5105ca2fa021e7970dbb5fbfe542|file:///Users/loganmorrison/Documents/git_hub/class_public_evolve_psd/source/background.c|2270|5|V|c
	    if (0) {
f029ea881a532ed50cd57ed1ca09d885|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|1|25|v|rust
	prelude::*;
a1985b3c1891071608db1b9dcc3424a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|6|21|v|rust
	((Dot(p1, p3) * (1 - 2 * Dot(p2, p3))
	            + Dot(p2, p3)
	            + Dot(p1, p2) * (-1 + 2 * Dot(p1, p3) + 2 * Dot(p2, p3)))
	            * (-Dot(p2, p4) - Dot(p2, p5) + 2 * Dot(p2, p4) * Dot(p2, p5) + Dot(p3, p4)
	                - 2 * Dot(p2, p5) * Dot(p3, p4)
	                + Dot(p3, p5)
	                - 2 * Dot(p2, p4) * Dot(p3, p5)
	                + 2 * Dot(p3, p4) * Dot(p3, p5)
	                + Dot(p1, p5) * (-1 + 2 * Dot(p2, p4) - 2 * Dot(p3, p4) - 2 * Dot(p4, p5))
	                + Dot(p1, p4)
	                    * (-1 + 2 * Dot(p1, p5) + 2 * Dot(p2, p5)
	                        - 2 * Dot(p3, p5)
	                        - 2 * Dot(p4, p5))
	                + 3 * Dot(p4, p5)
	                + 2 * Dot(p1, p2) * Dot(p4, p5)
	                - 2 * Dot(p1, p3) * Dot(p4, p5)
	                - 2 * Dot(p2, p3) * Dot(p4, p5)
	                - 2 * Dot(p2, p4) * Dot(p4, p5)
	                - 2 * Dot(p2, p5) * Dot(p4, p5)
	                + 2 * Dot(p3, p4) * Dot(p4, p5)
	                + 2 * Dot(p3, p5) * Dot(p4, p5)))
	            / (1 + Dot(p1, p2) - Dot(p1, p3) - Dot(p2, p3));
fdae5bee976bf5f75b1b8b6a1fb72229|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|6|1|V|rust
	        let p1 = fm[0];
ca5d052cfff6c7662fe3dc3afec3f57a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|13|21|v|rust
	((p1.dot(p3) * (1 - 2 * p2.dot(p3))
	            + p2.dot(p3)
	            + p1.dot(p2) * (-1 + 2 * p1.dot(p3) + 2 * p2.dot(p3)))
	            * (-p2.dot(p4) - p2.dot(p5) + 2 * p2.dot(p4) * p2.dot(p5) + p3.dot(p4)
	                - 2 * p2.dot(p5) * p3.dot(p4)
	                + p3.dot(p5)
	                - 2 * p2.dot(p4) * p3.dot(p5)
	                + 2 * p3.dot(p4) * p3.dot(p5)
	                + p1.dot(p5) * (-1 + 2 * p2.dot(p4) - 2 * p3.dot(p4) - 2 * p4.dot(p5))
	                + p1.dot(p4)
	                    * (-1 + 2 * p1.dot(p5) + 2 * p2.dot(p5) - 2 * p3.dot(p5) - 2 * p4.dot(p5))
	                + 3 * p4.dot(p5)
	                + 2 * p1.dot(p2) * p4.dot(p5)
	                - 2 * p1.dot(p3) * p4.dot(p5)
	                - 2 * p2.dot(p3) * p4.dot(p5)
	                - 2 * p2.dot(p4) * p4.dot(p5)
	                - 2 * p2.dot(p5) * p4.dot(p5)
	                + 2 * p3.dot(p4) * p4.dot(p5)
	                + 2 * p3.dot(p5) * p4.dot(p5)))
	            / (1 + p1.dot(p2) - p1.dot(p3) - p2.dot(p3));
3bbd24837edc8ba5d489b9f345255906|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|13|21|v|rust
	((p1.dot(&p3) * (1.0 - 2.0 * p2.dot(&p3))
	            + p2.dot(&p3)
	            + p1.dot(&p2) * (-1 + 2 * p1.dot(&p3) + 2 * p2.dot(&p3)))
	            * (-p2.dot(&p4) - p2.dot(&p5) + 2 * p2.dot(&p4) * p2.dot(&p5) + p3.dot(&p4)
	                - 2 * p2.dot(&p5) * p3.dot(&p4)
	                + p3.dot(&p5)
	                - 2 * p2.dot(&p4) * p3.dot(&p5)
	                + 2 * p3.dot(&p4) * p3.dot(&p5)
	                + p1.dot(&p5) * (-1 + 2 * p2.dot(&p4) - 2 * p3.dot(&p4) - 2 * p4.dot(&p5))
	                + p1.dot(&p4)
	                    * (-1 + 2 * p1.dot(&p5) + 2 * p2.dot(&p5)
	                        - 2 * p3.dot(&p5)
	                        - 2 * p4.dot(&p5))
	                + 3 * p4.dot(&p5)
	                + 2 * p1.dot(&p2) * p4.dot(&p5)
	                - 2 * p1.dot(&p3) * p4.dot(&p5)
	                - 2 * p2.dot(&p3) * p4.dot(&p5)
	                - 2 * p2.dot(&p4) * p4.dot(&p5)
	                - 2 * p2.dot(&p5) * p4.dot(&p5)
	                + 2 * p3.dot(&p4) * p4.dot(&p5)
	                + 2 * p3.dot(&p5) * p4.dot(&p5)))
	            / (1 + p1.dot(&p2) - p1.dot(&p3) - p2.dot(&p3));
d8053106e2cde0345cc4877e80326092|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|12|1|v|rust
	
	        let diag1 = ((p1.dot(&p3) * (1.0 - 2.0 * p2.dot(&p3))
	            + p2.dot(&p3)
	            + p1.dot(&p2) * (-1.0 + 2.0 * p1.dot(&p3) + 2.0 * p2.dot(&p3)))
	            * (-1.0 * p2.dot(&p4) - 1.0 * p2.dot(&p5)
	                + 2.0 * p2.dot(&p4) * p2.dot(&p5)
	                + p3.dot(&p4)
	                - 2.0 * p2.dot(&p5) * p3.dot(&p4)
	                + p3.dot(&p5)
	                - 2.0 * p2.dot(&p4) * p3.dot(&p5)
	                + 2.0 * p3.dot(&p4) * p3.dot(&p5)
	                + p1.dot(&p5)
	                    * (-1.0 + 2.0 * p2.dot(&p4) - 2.0 * p3.dot(&p4) - 2.0 * p4.dot(&p5))
	                + p1.dot(&p4)
	                    * (-1.0 + 2.0 * p1.dot(&p5) + 2.0 * p2.dot(&p5)
	                        - 2.0 * p3.dot(&p5)
	                        - 2.0 * p4.dot(&p5))
	                + 3.0 * p4.dot(&p5)
	                + 2.0 * p1.dot(&p2) * p4.dot(&p5)
	                - 2.0 * p1.dot(&p3) * p4.dot(&p5)
	                - 2.0 * p2.dot(&p3) * p4.dot(&p5)
	                - 2.0 * p2.dot(&p4) * p4.dot(&p5)
	                - 2.0 * p2.dot(&p5) * p4.dot(&p5)
	                + 2.0 * p3.dot(&p4) * p4.dot(&p5)
	                + 2.0 * p3.dot(&p5) * p4.dot(&p5)))
	            / (1.0 + p1.dot(&p2) - 1.0 * p1.dot(&p3) - 1.0 * p2.dot(&p3));
	
	        let diag2 = ((p1.dot(&p4) * (1.0 - 2.0 * p2.dot(&p4))
	            + p2.dot(&p4)
	            + p1.dot(&p2) * (-1.0 + 2.0 * p1.dot(&p4) + 2.0 * p2.dot(&p4)))
	            * (-1.0 * p2.dot(&p3) - 1.0 * p2.dot(&p5)
	                + 2.0 * p2.dot(&p3) * p2.dot(&p5)
	                + p3.dot(&p4)
	                - 2.0 * p2.dot(&p5) * p3.dot(&p4)
	                + p1.dot(&p5)
	                    * (-1.0 + 2.0 * p2.dot(&p3) - 2.0 * p3.dot(&p4) - 2.0 * p3.dot(&p5))
	                + 3.0 * p3.dot(&p5)
	                + 2.0 * p1.dot(&p2) * p3.dot(&p5)
	                - 2.0 * p1.dot(&p4) * p3.dot(&p5)
	                - 2.0 * p2.dot(&p3) * p3.dot(&p5)
	                - 2.0 * p2.dot(&p4) * p3.dot(&p5)
	                - 2.0 * p2.dot(&p5) * p3.dot(&p5)
	                + 2.0 * p3.dot(&p4) * p3.dot(&p5)
	                + p1.dot(&p3)
	                    * (-1.0 + 2.0 * p1.dot(&p5) + 2.0 * p2.dot(&p5)
	                        - 2.0 * p3.dot(&p5)
	                        - 2.0 * p4.dot(&p5))
	                + p4.dot(&p5)
	                - 2.0 * p2.dot(&p3) * p4.dot(&p5)
	                + 2.0 * p3.dot(&p4) * p4.dot(&p5)
	                + 2.0 * p3.dot(&p5) * p4.dot(&p5)))
	            / (1.0 + p1.dot(&p2) - 1.0 * p1.dot(&p4) - 1.0 * p2.dot(&p4));
	        let diag3 = 
28765a0bef5705a19c8e2192f5639424|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|6|1|V|rust
	        let p1 = fm[0];
	        let p2 = fm[1];
	        let p3 = fm[2];
	        let p4 = fm[3];
	        let p5 = fm[4];
	        let p6 = fm[5];
1aac09142819e1a96fc8999bd79852a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|5|35|v|rust
	p1: FourMomentum
4bf09516b0b6baf9593ef7b656a944ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|7|1|V|rust
	        p1: FourMomentum,
6b32c5cabe72782a320497b5ef08996a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|11|1|V|rust
	        p6: FourMomentum,
8744c344fe186645361842c19c16d155|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|15|13|v|rust
	p1.dot(&q) * p2.dot(&p3)
5200cf7b741752aa76adc0f5a00cf13e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|15|1|V|rust
	            p1.dot(&q) * p2.dot(&p3)+
	            p2.dot(&q) * p3.dot(&p1)+
	            p3.dot(&q) * p1.dot(&p2)
8553ffafbcf56cb4aac9aebb2540a818|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|7|1|V|rust
	        p1: FourMomentum,
	        p2: FourMomentum,
	        p3: FourMomentum,
	        p4: FourMomentum,
	        p5: FourMomentum,
	        p6: FourMomentum,
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
fecba496f08559888e95aff5d9b8116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|15|v|rust
	FourMomentum
c10a1e30b6e6f7360e783c3d769e8137|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|5|8|v|rust
	mat_elem_2_to_4_diag
abb6a80de15840d354e4d0f9df902ff0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|26|1|V|rust
	        let diag1 = self.mat_elem_2_to_4_diag(&p1, &p2, &p3, &p4, &p5, &p6, &(p1 + p2 + p3));
7f57c56f5fb71ab1cae75ca04ff8e44e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|20|19|v|rust
	16.0 * PI * PI * self.lec1 / (3.0 * self.n * self.lamc.powi(4))
1e1bf00f539ac485ca66976db280ba66|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|17|15|v|rust
	*1.0
8e056b97ba31f2d36a3ec80c7f3472bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|19|18|v|rust
	squared_mass()
ebdbf38bf07f39d8d8f31fba88a079cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|86|1|V|rust
	        println!("p1.p1={}", p1.dot(&p1));
ae14bb8d2deeed204e12696a0608cf6f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|135|1|V|rust
	        println!("diag1 = {}", diag1);
7e76e4c571611f5e279e9fde7c66bcd1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|115|31|v|rust
	{
	            e: 1.35498,
	            px: 0.767926,
	            py: 0.35156,
	            pz: 0.350228,
	        };
b0adbc13e2705150b45fa420ed472a39|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|108|31|v|rust
	{
	            e: 1.3799,
	            px: 0.718476,
	            py: 0.550803,
	            pz: 0.290751,
	        };
a327e4b444cb27c7a78a5ffa68cbd3ba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|101|31|v|rust
	{
	            e: 1.34837,
	            px: 0.199804,
	            py: 0.8529,
	            pz: 0.225276,
	        };
c7782b4c9e65347ebde45d56b932c4f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|94|31|v|rust
	{
	            e: 1.43296,
	            px: 0.468067,
	            py: 0.0112993,
	            pz: 0.913331,
	        };
efa6d18ce1a3c84625bb4cf6a50a2573|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|87|31|v|rust
	{
	            e: 1.44641,
	            px: 0.393914,
	            py: 0.539447,
	            pz: 0.803693,
	        };
ed2d1c56fdf05a22b1d29178a6ec5369|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|80|31|v|rust
	{
	            e: 1.36348,
	            px: 0.486544,
	            py: 0.743913,
	            pz: 0.262553,
	        };
8a625dd8ecd2d226786d5773a17f78c2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|82|31|v|rust
	{1.44641,0.393914,0.539447,0.803693}
bac15678299a35fe62253f401ac806a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|144|1|V|rust
	        println!("diag1 = {}", diag1);
	        println!("diag2 = {}", diag2);
	        println!("diag3 = {}", diag3);
	        println!("diag4 = {}", diag4);
	        println!("diag5 = {}", diag5);
	        println!("diag6 = {}", diag6);
	        println!("diag7 = {}", diag7);
	        println!("diag8 = {}", diag8);
	        println!("diag9 = {}", diag9);
	        println!("diag10 = {}", diag10);
e4d27276a25c960512120f642f88ffde|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|143|1|V|rust
	        let mat = diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10;
90f9b941f297103ac0cf1bf9353fcefc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|143|26|v|rust
	18.05247982398534,17.372884288286393,18.54833413427864,18.80756268121668,-24.52857518513328,-85.91138791140078,-42.74839960071725,-131.28985303066247,276.4142767501613,50.25650487269819
92820712445911e3601608c052d712fe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|156|9|V|rust
	        println!("{:?}", (mat * mat).abs());
384d30f51facff7e142f3cfb4de2f663|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag2 
96f030649687bbcb2f9328b41abbe5d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag3 
d1b6b2cbfc307a2316e12114b0a9f43e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag5 
22f8ce903af5d4010dbc16f6f4539d0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag7 
b5fded9f1266b3fa247ee466741a3f89|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag8 
4036d7f1f11b85ac84671dc924323fa7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag6 
b2219d0596fcf65989607b092d5317ba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag10 
4e561b1242f5bbe01c9f311f6e928e2e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag4 
65744b93c0d6e014e07b5ed4f89e7445|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	diag9 
e66676f5673acd79e46535e534de821e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|159|1|V|rust
	            assert!((x - y).abs() < 1e-5);
e44e4612f62d2fb8f8738bab118a9850|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|159|13|v|rust
	assert
0fb3af853917204f6a9ff8d2c22ffe1f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|159|41|v|rust
	 < 1e-5
6f4feb5863a37fac962417dd1f4aef47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|159|13|V|rust
	            println!("{}", (x - y).abs());
f1e7cf9d65bc4fa4cd23d159afc5f1f1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|130|9|V|rust
	        println!("p6.p6={}", p6.dot(&p6));
6149bb72e9d2534df088261a6896bab3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|123|1|V|rust
	        println!("p5.p5={}", p5.dot(&p5));
3b95186bfa88a391e59b721f013c3616|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|116|9|V|rust
	        println!("p4.p4={}", p4.dot(&p4));
a3c3829c3db07a0f573c5560bf5bd1b4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|109|9|V|rust
	        println!("p3.p3={}", p3.dot(&p3));
f2f5fe4b8fecefd1084ea8418384e888|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|100|9|V|rust
	        println!("p2.p2={}", p2.dot(&p2));
5b9cf8d52a3e30d3a2c822d7cd950c1a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|119|1|V|rust
	        let mut pre = 16.0 * PI * PI * self.lec1 / (3.0 * self.n as f64 * self.lamc.powi(4));
	        pre *= pre * self.eta.m * self.eta.m;
6d140f0acffd6a1cb55f66e6b0cb777f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|118|1|V|rust
	        use std::f64::consts::PI;
	        let mut pre = 16.0 * PI * PI * self.lec1 / (3.0 * self.n as f64 * self.lamc.powi(4));
	        pre *= pre * self.eta.m * self.eta.m;
c50ceb22dda973c7b42a31da48fc856c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|126|9|v|rust
	pre 
c8b7851088cd1c03fddbb71127404712|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|63|35|v|rust
	).powi(2) 
a8850bb16dbbab28f6fe2a861e6b5275|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|64|9|V|rust
	        pre2 *= pre2 * self.eta.m * self.eta.m;
d66c4d557ac6587c0ada3b96c22559fe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|63|38|v|rust
	self.lec2 * 
e73aebd24d6f0f4ba5d4e29611723a99|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|66|12|v|rust
	Incoming four-momenta. Assume incoming particles are aligned along
	        // the z-direction.
bb85d5d1ace4fb3160e5d5a6a58ac711|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|62|37|v|rust
	self.eta.m
090171cec2ea1456727b7c553835b63d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|62|9|V|rust
	        pre1 *= pre1 * self.eta.m * ;
917ff9ad405068ec13dc6e020debac36|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|62|20|v|rust
	(16.0 * PI * PI * self.lec1 * self.eta.m.powi(3)
	            / (3.0 * self.n as f64 * self.lamc.powi(4)))
	        .powi(2);
ff043c727ac16d9979003255d5033dc7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|61|37|v|rust
	self.lec1 * 
76887d184484790ec66d7ee502bf0d63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|64|20|v|rust
	(16.0 * PI * PI * self.lec1 * self.eta.m.powi(3)
	            / (3.0 * self.n as f64 * self.lamc.powi(4)))
	        .powi(2);
	
8907bc504e138b22f35db674f92a8dfc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|66|13|V|rust
	            * (16.0 * PI * PI * self.eta.m.powi(3) / (self.n as f64 * self.lamc.powi(4))).powi(2);
c7163212c003055bae76d4fbb52a5130|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|64|36|v|rust
	 * pre
4df4c5aa771f8161667c6e3f255aeaa4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|180|1|V|rust
	            DarkSun::mat_elem_2_to_4_diag_4pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4)),
cceb27517d8de2a7b5797b95d43185e3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|171|1|V|rust
	            DarkSun::mat_elem_2_to_4_diag_4pt(&p1, &p2, &p3, &p4, &p5, &p6, &(p4 + p5 + p6)),
be8b98e985dab9d3b641a5e1d1679fd8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|181|13|V|rust
	            DarkSun::mat_elem_2_to_4_diag_6pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4)),
74efb3bd111bb84181ff87f9256abdfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|181|75|v|rust
	, &(p4 + p5 + p6)),
be4c02f886b962acf7ad63f8a95902f3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|200|22|v|rust
	x - y
d94a68b539f43758d86f785877fc921b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|200|21|v|rust
	().abs() < 1e-5
eb4763a6e4d99d5c31447fdd436e1b3e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|200|13|V|rust
	            println!("x, y = {}, {}", x, y);
5511f77fd7a7e0d85c1610a88a340128|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|206|18|v|rust
	vec![5.0, 10.0, 100.0];
30b7f1c0410bf4d91cfc8436a68487b4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|206|9|V|rust
	        let m = model.eta.m;
4162347f562b33106e09b843b239b0ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|208|70|v|rust
	).powi(2)
f123120173c3079bc920e942a1aa9cc5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|209|59|v|rust
	model.eta.m
0847caee4e98d7c5d7af14c618791db5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|122|13|V|rust
	            let m = self.eta.m;
1b9714b607083f5a1f47c14c21f516ba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|123|13|V|rust
	            let bf = (1.0 - 4.0 * m * m / s).sqrt();
23af122ceab742d7f3afdc45997dabfd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|124|13|v|rust
	bf *
42ffa75e7aa88f22f1c86dbc1384f598|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|212|55|v|rust
	z * m * m
d314b81be563c378b59f1fc0b275f809|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|116|47|v|rust
	s.sqrt() / self.eta.m
9fa493981add743db0a85201b1fb254a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|87|13|V|rust
	            let diag1 =
e99a38ced8b6358227bc6617d39b7b97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|88|13|V|rust
	            let diag2 =
66f2d0ca09f8df374cc8ca2b72edec11|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|89|13|V|rust
	            let diag3 =
2c66c85811cfb37bb8d3143265566fc2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|90|13|V|rust
	            let diag4 =
63170b68afa690fbffe6804e41f54da3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|91|13|V|rust
	            let diag5 =
d74497cd78c9dff9dcdb241873d8c568|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|92|13|V|rust
	            let diag6 =
1f8067654b816f05fea61f5151e71a19|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|93|13|V|rust
	            let diag7 =
acd388803cd579e91bc158b1b36650e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|94|13|V|rust
	            let diag8 =
4525044106608cdbb99b12593631bf3d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|95|13|V|rust
	            let diag9 =
e5f223fb3b6a1d9582313a717272b947|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|96|13|V|rust
	            let diag10 =
1466cd8ee35fa713042abc40b32d3204|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|98|13|v|rust
	let diag11 = 
491798765e7b73793b84baf33f3821cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|99|1|V|rust
	            let mat = pre1
	                * (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
	                + pre2 * diag11;
4e15a9f623560efe3a4eed5371a47ee3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|87|13|v|rust
	let mat = 
792cd5bfda34986ad65e0b7d9f40b92c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|99|13|V|rust
	            (mat * mat).abs()
3a15da0bbeb8d1ec2db6a660713150fe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|115|1|V|rust
	        let e1 = self.eta.m;
	        let e2 = p2.e * self.eta.m;
	        let vrel = p2.pz / p2.e;
cdda72bce66670104b149280d8b77b3d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|78|17|v|rust
	z * (z * z / 4.0 - 1.0).sqrt(),
69257ec398972fd78fd610787e59ad44|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|75|16|v|rust
	(z * z / 2.0 - 1.0),
8a204bf8aee668256dc89129607ffa91|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|123|21|v|rust
	z * z / 2.0 - 1.0
df927f995b49cbc3a4d6e406dee8cb26|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|128|13|V|rust
	            let den = 64.0 * PI * PI * (s - 2.0 * m * m);
fdb402faa2487094b793bf70a4b31b92|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|124|13|V|rust
	            let e1 = self.eta.m;
56e733430762f3681d94be076dd49b50|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|124|13|V|rust
	            let e2 = e * self.eta.m;
c5fd8bf95e25e5e247f69b6560256505|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|66|40|v|rust
	p1 is at rest and p2 moves along the
bbf632af9f69da87932ed76f7c278e22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|67|9|V|rust
	        // z direction.
c1f29fe10d3a8c7859187749fecbd60a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|74|24|v|rust
	 - 1.0,
bd080a3b04c8766f5b2a01d65b202899|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|77|1|V|rust
	            pz: (z * z / 4.0 - 1.0).sqrt(),
92a69a728c8823f7b9fbf450cae8da22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|71|1|V|rust
	            pz: 0.0,
e4fa0d9494295ddd2764c37915c42b0e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|120|1|V|rust
	            // 2E1 * 2E2 * (p1/E1 + p2/E1) = 4 E1 E2 p * (E1 + E2) / (E1 * E2)
314016340a99464debb139729e258022|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|121|16|v|rust
	2E1 * 2E2 * (p1/E1 + p2/E1) = 
7d1b916c819d6a14e42cb1b6702b5514|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|121|18|v|rust
	E1 E2 
c05df807adcf14e2753be546dc0cc481|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|121|22|v|rust
	(E1 + E2)
897fd5f63d20515fa8658aab5d1f6a3d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|121|1|V|rust
	            // 4 p * Ecm = 4 * (s/4-m^2) * sqrt(s)/2
b0c4feceb8b63e5539ea3927fc10fa7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|122|16|v|rust
	4 p * Ecm = 
78623165a45157f1b981f1baaf46a4de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|127|49|v|rust
	(4.0 * m * m * e * vrel)
1c8dc8646584b7bae26ac687c97a7a3f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|126|13|V|rust
	            let vrel = pz / e;
08aeb1a126163d626eec493c47546e89|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|125|13|V|rust
	            let pz = z * (z * z / 4.0 - 1.0).sqrt();
71baf1307bc8c42d4219f6a83b83a044|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|124|13|V|rust
	            let e = z * z / 2.0 - 1.0;
4bcfb4a2951840acbba565cfb84452ff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|123|13|V|rust
	            let z = s.sqrt() / m;
a6da7e5bff13d7640e847bc9ca57253a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|120|1|V|rust
	            // 2E1 * 2E2 * (p1/E1 + p2/E1) = 4 E1 E2 p * (E1 + E2) / (E1 * E2)
	            // 4 p * Ecm = 4 * sqrt(s/4-m^2) * sqrt(s)/2
	            // sqrt(s) * sqrt(s-4m^2)
ca49a67a112920c8f980fc5c5ffac5e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|121|49|v|rust
	(2.0 * s * (1.0 - 4.0 * m * m / s).sqrt()) / 24.0
e10beb502e44b9dc55d75346ab7b5038|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|210|29|v|rust
	integrated_matrix_element
b5408d61571c509d53a1edfbf88b4fb1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|207|9|V|rust
	        model.lec2 = 0.0;
c25af61add086c15e32270e3b0cbc522|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|110|19|v|rust
	pre2 * diag11)
c1850646a4905439a98ccfdbadc8340f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|110|13|V|rust
	                + 
8b359325571c94c7ead4edff31d5044c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|108|13|v|rust
	pre1 
d17f8722bf8cb372d85db4274409e48a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|120|29|v|rust
	s.sqrt()
2975ae0d482195a4da9913c3a2f3677d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|58|9|V|rust
	        let z = s.sqrt() / self.eta.m;
eb7a5539b1eca400ec736c3e0b18d9b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|57|9|V|rust
	        // Scaled center-of-mass energy.
5c74c07974fdb0da557bad839f7787e5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|116|9|V|rust
	        let m = self.eta.m;
e72bbe091da08fc412893cf77534b5f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|207|29|v|rust
	cross_section_2_4
09bd290933752196f35208f510ae53a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|205|42|v|rust
	(4.0 * m).powi(2), (100.0 * m).powi(2)
ea48f631a706a588867c613d03f530c2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|58|1|V|rust
	        // Prefactor use std::f64::consts::PI;
	        //        let pre =
	        //            (16.0 * PI * PI * self.eta.m.powi(3) / (self.n as f64 * self.lamc.powi(4))).powi(2);
	        //        let pre1 = pre * self.lec1 * self.lec1 / 9.0;
	        //        let pre2 = pre * self.lec2 / 15.0;
58390a26c60fbe88e230132119e738bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|196|1|V|rust
	        //let model = DarkSun::default(10, 1e-3).build();
07950e2c8c20cb6149f2974b600dccad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|196|9|V|rust
	        //let m = model.eta.m;
2ea899838aca383b937d8ccfa95fe2a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|194|8|v|rust
	test_int_msqrd
6373df0dc00ddf77c176a3de353507cc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|118|5|V|rust
	    pub fn generate_scaled_cross_section
79bbcf72ffe68d2f625ee2257ff50fda|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|6|1|V|rust
	use model::*;
7d0e7a0456779dd22b3c876fc1401c8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|195|1|V|rust
	        use ndarray::prelude::*;
	        let zs = Array1::<f64>::linspace(4.0, 100.0, 500);
	        for z in zs.iter() {
	            let int = DarkSun::scaled_integrated_matrix_element(*z);
	            println!("s, int = {:e}, {:e}", *z, int);
	        }
df257f46588871743158eeabb6fc4993|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|6|1|V|rust
	use generate_cs_data::*;
adb3868784587c806791bc755654f065|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|11|5|V|rust
	    use ndarray::prelude::*;
6a32278bc13151275d589507eeeed543|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|29|1|V|rust
	        let mut string = format!("{} {}\n", t, u).to_string();
	        string.retain(|c| !r#"(),"[]"#.contains(c));
	        file.write(string.as_bytes())?;
d6e88882bc478dc64f7117241f7a6112|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|18|1|V|rust
	        println!("s, int = {:e}, {:e}", *z, int);
675acd30e44427dd587d4d23d1863311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|19|9|V|rust
	        string.retain(|c| !r#"(),"[]"#.contains(c));
0f53e8dacedd20d9d6b944192b9c71c8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|17|22|v|rust
	format!("{} {}\n", z, int).to_string()
b45cffe084dd3d20d928bee85e7b0f21|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|18|20|v|rust
	string
9716d8a2012486a4f129f5b60a5f34ba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|17|9|V|rust
	        let string = format!("{} {}\n", z, int).to_string();
fb5fba274c8fbab1fdc31ecb65aab0f1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|8|1|V|rust
	use std::fs::File;
cafd1c54fea5069d360645111e47bc46|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|8|1|V|rust
	use std::io::prelude::*;
7e249602b93833dac8db53c106cce18e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|16|1|V|rust
	        file.write(format!("{} {}\n", z, int).to_string().as_bytes())?;
7958495f426a4ad9bc4cb6b48dff07eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|14|5|v|rust
	E1 -> Sqrt[s]/2uv
eaaff1a982a292d2dbdbed79414d4487|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|6|5|V|python
	    print(data)
8ed05df2bd1be0cbf793b99cd30cfb12|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|7|5|V|python
	    print(last_100)
79fc86a02e88a3e44b1fd7839c6245dd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|3|1|V|python
	from scipy
6dda34b6dcf28cdf5ac6ac78bf519001|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|7|14|v|python
	last_100_zs
00e9811ac168459ac25aa98d5ca2e64b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|7|25|v|python
	last_100_cs
09f8fd1d78f6fb87f6c5d82f48d4c006|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|111|59|V|rust
	            // 24 for 4! since 4 identical particles in final state
9b4d365eba7833f022ba1804df91054d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|113|26|v|rust
	/ 24.0
5fa485762d73111d253a3a040a690bf6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|18|28|v|rust
	scaled_integrated_matrix_element
7ed9a9ac05eb02856b993cba92fe7d8c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|108|12|v|rust
	scaled_cross_section_2_4
13dbf0ff472f87a09b7a1e2aa93987b0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|113|25|v|rust
	, res.1 / den)
e6d4e78850c7abe956081fe8730a833c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|115|13|v|rust
	(0.0, 0.0)
dfced54797f8d3f2241beb7ea8e465b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|20|38|v|rust
	int.0, int.1)
911359e3ab6981e1e28f89d6896b25a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|15|11|v|python
	pcov
6f7514b675c26510337dba0bde220c7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|12|1|V|python
	    def model(x, m, b):
	        return m * x + b
	
	    popt, _ = curve_fit(model, last_100_zs, last_100_cs)
	    print(popt)
c132b78385e866d78d9378da17b1e2f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|15|14|v|python
	data.T[0]
d55637e3ec5e461267bd047f2b8a61e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|24|7|V|toml
	[[bin]]
1e505da503f6cee53f422b442945df93|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|10|1|V|rust
	fn main() -> std::io::Result<()> {
	    let mut file = std::fs::File::create("data/scaled_cs_data.dat")?;
	
	    // Header
	    file.write("# cme/meta cross-section error\n".as_bytes())?;
	
	    let zs = Array1::<f64>::linspace(4.0 + 1e-5, 100.0, 500);
	    for z in zs.iter() {
	        let cs = DarkSun::scaled_cross_section_2_4(*z);
	        file.write(format!("{} {}\n", z, cs).to_string().as_bytes())?;
	    }
	    Ok(())
	}
a0421b35c248f2126ced135c9d688b53|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|6|1|V|rust
	use model::DarkSun;
	use ndarray::prelude::*;
	use std::io::prelude::*;
	
	fn main() -> std::io::Result<()> {
	    let mut file = std::fs::File::create("data/scaled_cs_data.dat")?;
	
	    // Header
	    file.write("# cme/meta cross-section error\n".as_bytes())?;
	
	    let zs = Array1::<f64>::linspace(4.0 + 1e-5, 100.0, 500);
	    for z in zs.iter() {
	        let cs = DarkSun::scaled_cross_section_2_4(*z);
	        file.write(format!("{} {}\n", z, cs).to_string().as_bytes())?;
	    }
	    Ok(())
	}
f99734e21fda67cb846177d43c0da57b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|9|1|V|rust
	use model::DarkSun;
93900408c7fb93652afc5d0ed8c87438|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|23|1|V|rust
	impl DarkSun {
e21eef0a76a8dede06b91399ad4d5783|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|123|19|v|rust
	DarkSun
cdc56e28fcd0f368d8fb3f06bc16bf60|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|11|1|V|rust
	    let mut file = std::fs::File::create("data/scaled_cs_data.dat")?;
	
	    // Header
	    file.write("# cme/meta cross-section error\n".as_bytes())?;
	
	    let zs = Array1::<f64>::linspace(4.0 + 1e-5, 100.0, 500);
	    for z in zs.iter() {
	        let cs = DarkSun::scaled_cross_section_2_4(*z);
	        file.write(format!("{} {}\n", z, cs).to_string().as_bytes())?;
	    }
	    Ok(())
97ea48651cd505c893c95f1cf7b21072|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|10|11|v|rust
	-> std::io::Result<()> {
1058af35f4ea0802637e7746969ec84c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/main.rs|6|1|V|rust
	use model::DarkSun;
	use ndarray::prelude::*;
	use std::io::prelude::*;
260eb2fa75b7e5799306c8968e720876|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|19|9|V|rust
	        let cs = scaled_cross_section_2_4(*z);
10ea590d34cd351cff2ce4d34f754a02|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|13|9|v|rust
	scipy
ac90f8c8f1a0554ed762a9555a26ec5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|11|1|V|rust
	    let gil = Python::acquire_gil();
	    let py = gil.python();
	    let curvefit = PyModule::import(py, "scipy.optimize.curve_fit")?;
34e82b79af8f43b5e304fca301bc67cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|28|9|v|rust
	curvefit
bcec1e74179b56f7429e8fccdaf4fab7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|28|56|v|rust
	.curve_fit
c2d2b3e6f4b1cca26cbf0a247d8c4b40|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|28|1|V|rust
	    let optimize = PyModule::import(py, "scipy.optimize")?;
	    let res = optimize.call1("curve_fit", 
a96090e6c04d488c49069ace344bf6e4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|6|1|V|python
	    data = np.genfromtxt("scaled_cs_data.dat")
	    last_100_zs, last_100_cs = np.log10(data[-100:]).T
	
	    def model(x, m, b):
	        return m * x + b
	
	    popt, _ = curve_fit(model, last_100_zs, last_100_cs)
	    print(popt)
afaa068b6f43965a2c4b09a9d4b986d9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|32|1|V|rust
	    def fit_mod(x, m, b):
	        return m * x + b
	
	    data = np.genfromtxt("
6dd77cb3da5964c7d430b5715ffb6392|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|41|1|V|rust
	    popt, _ = curve_fit(model, last_100_zs, last_100_cs)
1aadf1dce5c5e361b48bed6db0447268|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|42|5|V|rust
	    print(popt)
b662047a0c094838e88e72b0f724544d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|46|v|rust
	-100:
c13367945d5d4c91047b3b50234aa7ab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|9|v|rust
	code
afecfc0fb835ee1157a0607887b2035b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|1|1|V|python
	import numpy as np
	import matplotlib.pyplot as plt
	from scipy.optimize import curve_fit
ba1008cdaefd1f7ad9e26c6634927548|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|1|1|V|python
	import numpy as np
	import matplotlib.pyplot as plt
	from scipy.optimize import curve_fit
	
	if __name__ == "__main__":
	    data = np.genfromtxt("scaled_cs_data.dat")
	    last_100_zs, last_100_cs = np.log10(data[-100:]).T
b681eb72e321e22dab9dbda0208af0d5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|1|V|rust
	    import numpy as np
16e6bd058930398f3b2b4301b9fe33cc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|5|V|rust
	    from scipy.optimize import curve_fit
1fa221de58554dea642ffbb34c792e6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|1|V|rust
	import matplotlib.pyplot as plt
c5054d771009c6e1b0d73f5171998343|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|1|V|rust
	if __name__ == "__main__":
cb0556d8964aaf5abfd2fc8b5b13a2b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|5|V|rust
	    data = np.genfromtxt("scaled_cs_data.dat")
8dc87ecd6104d68d19bdd6f76a2bb0ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|5|V|rust
	    last_100_zs, last_100_cs = np.log10(data[-100:]).T
894891bea462c0d3080e88d2521da6b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|1|V|rust
	data = np.genfromtxt("data/scaled_cs_data.dat")
	last_100_zs, last_100_cs = np.log10(data).T
de5554ca7683e3101b29810544421bca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|1|V|rust
	def model(x, m, b):
	    return m * x + b
caf0814df4d3e90210a70644da85ec8b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|1|V|rust
	    print("hello!")
e4a2159c2da546015f52833f3ff10191|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|34|1|V|rust
	print("hello!")
9940ec9d6462a96f51f674c82c628866|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|1|V|rust
	import sys
af5822f2e06085a766119e7a11040792|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|1|V|rust
	print(sys.version)
87f80c4b37e1a2ec4ab54e716dae70d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|1|V|rust
	print("Loading numpy...")
2ea9510c37f7f89e4941ff75f62f21cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|16|v|rust
	numpy
4716631633020943cf245f60da856113|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|1|V|rust
	print("Loading numpy...")
	import numpy as np
	print("Loading scipy...")
	from scipy.optimize import curve_fit
a6a589332050973a9f916c37394059d4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|17|v|rust
	 as np
03f7f8625276a5dbe4b21da7ce2365d8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|34|v|rust
	 import curve_fit
76844d2789100bc9deeecc6ca93b77a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|16|v|rust
	(1.0, 2.0)
8388a5bed4c9438f09e4bd66e7b05ece|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|49|1|V|rust
	    let fitter = PyModule::from_code(
	        py,
	        r#"
	def get_opt():
	    return 1.0
	    "#,
	        "fitter.py",
	        "fitter",
	    )?;
1774957cc64762ea7bf764d63fc14256|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|44|19|v|rust
	, popt[1]
6a54237bbcb318f2392c3d5ed4cba440|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|34|1|V|rust
	    print("Loading numpy...")
	    import numpy as np
	    print("Loading scipy...")
	    from scipy.optimize import curve_fit
4c6b4fe892b4a0ecec1040fbf3be53d4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|18|v|rust
	PyModule
7236959dc6242c014e7e02711d0c221b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|26|v|rust
	from_code(
3e8315db486b591ab526e2be976f3383|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|9|v|rust
	fitter
75698f5a74eaf14e65b264a43bdb9ceb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|48|9|V|rust
	        "fitter.py",
1a85090f95901f6a546d12a8e448490f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|48|9|V|rust
	        "fitter",
e5a9991119f3229b2d380300a3d29d51|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|49|5|V|rust
	    let popt: f64 = dbg!(fitter.call1("get_opt", ()))?.extract()?;
690f7b9bba921d05f372df9f667e34ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|39|1|V|rust
	def get_spt():
ec1446b042109940aa00ed363a537eab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|45|1|V|rust
	popt[0]
caee6b114b299b31569862021316af61|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|50|8|v|rust
	popt
3af02ad80b4374c37bb686c634f8db15|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|31|5|v|rust
	let popt = 
c93bdefe5ad58e28db0f78815bf10cb1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|50|50|v|rust
	::<f64>()
1d1f6f6053c84c9af38196fc5978faed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|8|v|rust
	*locals.get_item("popt").unwrap().downcast.unwrap()
75fe4e859b2da8bfeb3286b1b52e64f3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|1|V|rust
	    let res: &PyFloat = *locals.get_item("popt").unwrap().downcast().unwrap();
6ba180904954241cccdc755ea94fd95c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|54|9|v|rust
	locals.get_item("popt").unwrap().downcast.unwrap() as f64)
745a1dae861dddf1d429ff6b5b8a7fb5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|54|12|v|rust
	 as f64
237abd81fa875598cc16fe6ff1ec0ea3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|58|v|rust
	downcast().unwrap().extract()?;
aa75d98f34d2c57b345d3c03fb5d6a13|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|12|v|rust
	: &PyFloat
c0047ebb049e619af51f61716fb3f3e1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|53|55|v|rust
	::<f64>::
46e67929c9dc0a845851bd1110c5d922|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|1|V|rust
	try:
7821fe4ca68d9f8dba0ebe0c6896ba07|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|1|V|rust
	except ImportError:
99cfea0b5cec1a127ed7a002ce4bc327|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|5|V|rust
	    print("cannot load numpy")
2165a3ac278eb64f0d36dac4f79fbeda|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|38|1|V|rust
	import numpy as np
f8f2a52674e0b2fc7e5545cfabdb10d2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|38|1|V|rust
	print("Loading scipy...")
5b40e94886efcedfe189f7e51e136ffa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|38|1|V|rust
	from scipy.optimize import curve_fit
9784109f308fdb289dd23005a663c202|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|9|v|rust
	locals 
7397f6b27b4084a973ece69230eeb4d9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|36|1|V|rust
	    dict.set_item("np", np);
fe929fbdcd603ca3c936a1da89cc54c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|49|9|v|rust
	Some(locals),
65004f81079422462f2162dcf38954f3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|51|20|v|rust
	locals
a9eae567fe92a914f02a6a757b0f9253|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|9|21|v|rust
	PyFloat
149837f71b3e4705b1da25f1bb21160c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|34|5|V|rust
	    let dict = PyDict::new(py);
876d7bc5093a8529282595c79a78f55f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|32|5|v|rust
	dict.set_item("sys", 
78f929ae3f5d3f5e010342dd1ef8b91b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|31|26|v|rust
	py.import("sys")?
969841487327ba023743c3e8234f89b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|1|V|rust
	    let sp = py.import("scipy")?;
ae3ea16756789738012f96ca19c6e21d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|38|17|v|rust
	PyErr::new()
ec635d392b85e635299adf65571ad372|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|38|6|V|rust
	            Err(err)
5a6395690346cafb3de5053cfb1f4c98|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|23|v|rust
	Ok(module),
0a6040e373994d01eaae7ba0b4078410|term://.//55513%3A/bin/zsh|10016|1|V|floaterm
	Importing the numpy C-extensions failed. This error can happen for
96a9135576cd702828f5d024a9981974|term://.//55513%3A/bin/zsh|10022|1|V|floaterm
	    https://numpy.org/devdocs/user/troubleshooting-importerror.html
81eafe5afea9506ea32b515083a44d9a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|40|1|V|rust
	    let np = dbg!(py.import("numpy"))?;
0314413b47a4456019ee3631c5ca3835|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|35|5|v|rust
	let np = 
c169536135643453e1c55efc6ff17197|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|31|1|V|rust
	    let sys = py.import("../data/fit_cs_data")?;
	    dict.set_item("sys", sys)?;
	    py.run("print(sys.version)", Some(&dict), None)?;
	    match py.import("numpy") {
	        Ok(module) => (println!("ok")),
	        Err(err) => {
	            &err.print_and_set_sys_last_vars(py);
	        }
	    }
	    let np = dbg!(py.import("numpy"))?;
	    let sp = py.import("scipy")?;
	    dict.set_item("np", np)?;
	    //dict.set_item("sp", sp)?;
3e572ea8ea11a99aa2e3c6251b3279da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|33|5|v|rust
	t("here")
f23526cdb6e7fe90ee0b256f50a394fd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|27|1|V|rust
	fn fit() -> PyResult<(f64)> {
	    let gil = Python::acquire_gil();
	    let py = gil.python();
	    let dict = PyDict::new(py);
	    py.run(
	        r#"
	prin
	data = np.genfromtxt("data/scaled_cs_data.dat")
	last_100_zs, last_100_cs = np.log10(data).T
	def model(x, m, b):
	    return m * x + b
	popt, _ = sp.optimize.curve_fit(model, last_100_zs, last_100_cs)
	popt = popt[0]
	    "#,
	        Some(&dict),
	        None,
	    )?;
	    let res: f64 = dict.get_item("popt").unwrap().extract().unwrap();
	    Ok(res)
	}
3395405fe278a051f2a3574437c7dee7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|21|1|V|rust
	    let res = fit();
ffc911117a35c63b46fb31d1638a8cd9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|21|5|V|rust
	    println!("{:?}", res);
fbd8f6cb2803f7934f68f60129a9d905|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|6|1|V|rust
	use pyo3::{prelude::*, types::PyDict, Python};
23eeeb4347bdd26bfc6b7ee9a3b755dd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|21|19|v|rust
	python
78c39a56857a91e34789ad76a091f8ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|14|1|V|python
	
	    plt.plot(data.T[0], data.T[1])
	    plt.plot(data.T[0], data.T[0] ** popt[0] * 10.0 ** popt[1])
	    plt.yscale("log")
	    plt.xscale("log")
	    plt.show()
d6ff965a1aec068c7fba354fc2113f24|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|21|19|v|rust
	cd data
eb30371ae01abad345977cef488c8758|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|13|1|V|python
	    print(popt[0])
4642a558e195e67fcb492cd3dd2c9dab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|14|5|V|python
	    print(popt[1])
e8f88bd975d02a0986c1ff6af1a3dc23|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|13|11|v|python
	f"{popt[0]}, {popt[1]}")
875c875b39586039a487db75296e1443|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|27|19|V|rust
	            .stdout
28fc9970eeed242fc97661fddfb006d0|term://.//55513%3A/bin/zsh|10043|1|V|floaterm
	Output { status: ExitStatus(ExitStatus(0)), stdout: "[ 14.00405715 -11.12287941]\n", stderr: "" }
4111f7ded968d5940a6a24322ba233a8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|10|40|v|rust
	14.02653358183077;
d9c34706ca3f034537d4ab1d9c2005ee|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|5|56|v|rust
	14.00405715
e6584f16311c85ee8cdfa646da1edf1c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|12|40|v|rust
	14.02653358183077
ed7e185521482a0f1a3c54db96a1e962|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|5|68|v|rust
	-11.12287941
f581c77070d9c03c5e08f8b72aaf1f55|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|13|44|v|rust
	-6.1933023533564535
7c1f50425e54cf11af9f1cc3f0f37513|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|v|csv
	150 
edc84274dca409a9bafc79ff5ff35bef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	4.00001 0.0000000000000000000002396547102004539
	4.292595150300601 0.000002254109326507421
5ce3bb3b1c9f91b5c06984a0ee7d8ef3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	4.585180300601202 0.00005158432803021939
	4.877765450901803 0.00040690513366936106
7e7f988e6550860c1e0cf8568dca5c85|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	4.292595150300601 0.000002254109326507421
	4.585180300601202 0.00005158432803021939
e7d21c7006398aba674bbe330951666d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	7.2184466533066125 1.8725152772694804
	7.511031803607214 3.7259602161491414
	7.803616953907815 7.156555379647312
	8.096202104208416 13.255593205613904
	8.388787254509017 23.854999574542315
	8.681372404809618 41.476463161707485
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
	13.362734809619237 31001.216530642112
	13.655319959919838 42758.30157189097
	13.94790511022044 58657.832669400916
	14.24049026052104 79322.40297311536
	14.533075410821642 107507.72421270079
	14.825660561122243 142764.4785004246
	15.118245711422844 189675.26425012155
	15.410830861723445 250976.29691099474
	15.703416012024046 332963.73368335527
	15.996001162324648 432148.7858211549
	16.28858631262525 561791.2842904389
	16.58117146292585 727472.3068205083
	16.87375661322645 932887.084296244
	17.16634176352705 1200052.1985521114
	17.458926913827653 1529988.3585294404
	17.751512064128256 1939874.722140508
	18.044097214428856 2459553.0015858514
	18.336682364729455 3096854.6440261337
	18.629267515030058 3920271.344645362
	18.92185266533066 4898038.401186031
	19.21443781563126 6095838.413819074
	19.50702296593186 7542024.579922753
	19.799608116232463 9320733.755917693
	20.092193266533062 11618809.917279037
	20.384778416833665 14214455.845413743
	20.677363567134268 17459695.13382207
	20.969948717434868 21296251.525331497
	21.262533867735467 25958659.12816804
	21.55511901803607 31567651.490300097
	21.847704168336673 38331745.608158566
	22.140289318637272 46089136.30887561
	22.43287446893787 55792691.50218214
	22.725459619238475 67277142.40166242
	23.018044769539078 80391133.70328811
	23.310629919839677 96857846.96827392
	23.603215070140276 115275265.12565802
	23.89580022044088 137415642.8752822
	24.188385370741482 163601055.8284144
	24.48097052104208 193589322.25602663
	24.77355567134268 229180176.515862
	25.066140821643284 269316676.6132674
	25.358725971943887 321722690.1009861
	25.651311122244486 374256514.1765469
	25.943896272545086 441628912.8101232
	26.23648142284569 515423143.1517963
	26.52906657314629 606130598.7617505
	26.82165172344689 707103232.9054028
	27.11423687374749 825163877.0588665
	27.406822024048093 963324681.6324245
	27.699407174348696 1116103944.3489358
	27.991992324649296 1289666282.429506
	28.284577474949895 1499254887.1717534
	28.577162625250498 1736684838.8237638
	28.8697477755511 2005853444.241309
	29.1623329258517 2316417891.314886
	29.4549180761523 2665037688.532878
	29.747503226452903 3062495041.844568
	30.040088376753506 3521235684.7910686
	30.332673527054105 4034253912.3434134
	30.625258677354704 4633961490.270888
	30.917843827655307 5280008059.017388
	31.21042897795591 6057890044.197345
	31.50301412825651 6927008194.28226
	31.79559927855711 7851835827.07828
	32.088184428857716 8893932944.0087
	32.38076957915831 10181677790.43591
	32.673354729458914 11617984120.2019
	32.96593987975952 13011450684.124943
	33.25852503006011 14803741254.697422
	33.55111018036072 16803343525.778408
	33.84369533066132 18993450115.729565
	34.136280480961915 21227958313.13276
	34.428865631262525 23995649111.549904
	34.72145078156312 27187866240.87863
	35.014035931863724 30632815259.65747
	35.30662108216433 34178668541.596375
	35.59920623246492 38600147852.21627
	35.89179138276553 43249531946.00447
	36.18437653306613 48377783030.81447
	36.476961683366724 54342035239.98881
	36.769546833667334 61192419291.04402
	37.06213198396793 68064863213.27338
	37.35471713426854 76251299387.21269
	37.647302284569136 85361796965.44157
	37.93988743486973 95304097313.46213
	38.23247258517034 104899591541.7904
	38.52505773547094 116966656548.7205
	38.817642885771534 129820634789.15015
	39.110228036072144 145138584500.84055
	39.40281318637274 161659220099.29736
	39.69539833667335 179933099136.93573
	39.987983486973945 198513362037.07016
	40.28056863727454 220376192997.53708
	40.57315378757515 244166576786.6219
	40.86573893787575 270744640595.71667
	41.15832408817634 298632806729.2585
	41.45090923847695 329776652103.4757
	41.74349438877755 363505599784.2937
	42.03607953907816 401145759642.7613
	42.328664689378755 441884804941.3015
	42.62124983967935 487570965247.9849
	42.91383498997996 537857037047.4693
	43.20642014028056 590676466730.4182
	43.49900529058115 647416461778.813
	43.79159044088176 713480608507.6669
	44.08417559118236 781260769422.7588
	44.37676074148297 860175909621.7167
	44.669345891783564 936785371264.0197
	44.96193104208416 1033561492671.5624
	45.25451619238477 1134460701497.4773
	45.547101342685366 1240304748991.1157
	45.83968649298596 1357719367908.5452
	46.13227164328657 1496939550874.28
	46.42485679358717 1612938188937.753
	46.71744194388778 1767954347409.3174
	47.010027094188374 1950990061637.2146
	47.30261224448897 2107417314858.9512
	47.59519739478958 2307604091708.449
	47.887782545090175 2513046343958.7354
	48.18036769539077 2747571115646.6157
	48.47295284569138 2958056786119.3086
	48.76553799599198 3228970313006.721
	49.05812314629259 3508133829193.113
	49.35070829659318 3830394704305.0283
	49.64329344689378 4162211105235.5874
	49.93587859719439 4501554155511.975
	50.228463747494985 4903427362393.34
	50.52104889779558 5357568022001.224
	50.81363404809619 5737517221839.398
	51.106219198396786 6254248659299.638
	51.3988043486974 6724235410825.345
	51.69138949899799 7275588121371.863
	51.98397464929859 7984350928347.944
	52.2765597995992 8541606745263.253
	52.569144949899794 9320083083053.787
	52.86173010020039 10020133099852.656
	53.154315250501 10824974432454.44
	53.446900400801596 11694006345717.074
	53.739485551102206 12683020816900.563
	54.0320707014028 13665262027193.594
	54.3246558517034 14796699225326.254
	54.61724100200401 15847817210696.285
	54.9098261523046 17079828207290.342
	55.2024113026052 18381349583412.613
	55.49499645290581 19839244837007.527
	55.787581603206405 21426837557175.496
	56.080166753507015 22995031200387.746
	56.37275190380761 24848174155392.11
	56.66533705410821 26754050277333.953
	56.95792220440882 28633087512958.547
	57.25050735470941 30801042922270.42
	57.54309250501001 33121783611865.47
	57.83567765531062 35605076178511.67
	58.128262805611215 38043872037012.84
	58.420847955911825 40869169501318.78
	58.71343310621242 43893672639228.69
	59.006018256513016 47473556719081.89
	59.298603406813626 50640985027902.19
	59.59118855711422 53932761987708.46
	59.88377370741482 57848621567170.945
	60.17635885771543 61776838021543.19
	60.468944008016024 66280713975223.63
	60.761529158316634 71301950497898.81
	61.05411430861723 75742731843271.84
	61.346699458917826 80714923041610.52
	61.639284609218436 86376561469728.72
	61.93186975951903 93150168636340.9
	62.22445490981963 99180718072093.72
	62.51704006012024 105529827228657.27
	62.80962521042083 113033923738113.4
	63.10221036072144 120808588546208.72
	63.39479551102204 128106374373635.48
	63.687380661322635 137278649475195.56
	63.979965811623245 146958379003574.84
	64.27255096192384 155618222926709.9
	64.56513611222444 167261284082016.66
	64.85772126252505 176585775576524.8
	65.15030641282564 187576251091700.84
	65.44289156312625 201684188107843.6
	65.73547671342685 213640024853675.56
	66.02806186372744 227402749994340.34
	66.32064701402805 242353144516931.1
40a23c6b0ecb16b2c08ed636c87047f5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	5.4629357515030055 0.007642495637043617
	5.755520901803607 0.02443070933200414
51ee9b3d35c815b250289023052e2c1d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	5.755520901803607 0.02443070933200414
	6.048106052104208 0.06844264193920464
a0f30972eabf5b98a041e177acfda8dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	6.340691202404809 0.17378527581888614
	6.63327635270541 0.4065235099765696
0fb708cf61a8d9703117fae7a88e4685|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	6.63327635270541 0.4065235099765696
	6.925861503006011 0.9007336942240574
2d641ff006d37ec834253bc7a07e23b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	6.048106052104208 0.06844264193920464
	6.340691202404809 0.17378527581888614
47a33d43e015305aea4063e8f6760be4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	4.877765450901803 0.00040690513366936106
	5.170350601202404 0.0020125277449759248
3e4ab71307480aebc95a021943abba0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	9.559127855711422 192.75494818919174
81a1d5cb2f0aceaafeacf9c320c852f3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	10.729468456913827 1147.2965039914598
4d1bcd0483d46000f1536b1b580e1735|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
	13.362734809619237 31001.216530642112
	13.655319959919838 42758.30157189097
	13.94790511022044 58657.832669400916
	14.24049026052104 79322.40297311536
	14.533075410821642 107507.72421270079
	14.825660561122243 142764.4785004246
	15.118245711422844 189675.26425012155
	15.410830861723445 250976.29691099474
	15.703416012024046 332963.73368335527
	15.996001162324648 432148.7858211549
	16.28858631262525 561791.2842904389
	16.58117146292585 727472.3068205083
	16.87375661322645 932887.084296244
	17.16634176352705 1200052.1985521114
	17.458926913827653 1529988.3585294404
	17.751512064128256 1939874.722140508
	18.044097214428856 2459553.0015858514
	18.336682364729455 3096854.6440261337
	18.629267515030058 3920271.344645362
	18.92185266533066 4898038.401186031
	19.21443781563126 6095838.413819074
	19.50702296593186 7542024.579922753
	19.799608116232463 9320733.755917693
	20.092193266533062 11618809.917279037
	20.384778416833665 14214455.845413743
	20.677363567134268 17459695.13382207
	20.969948717434868 21296251.525331497
	21.262533867735467 25958659.12816804
	21.55511901803607 31567651.490300097
	21.847704168336673 38331745.608158566
	22.140289318637272 46089136.30887561
	22.43287446893787 55792691.50218214
	22.725459619238475 67277142.40166242
	23.018044769539078 80391133.70328811
	23.310629919839677 96857846.96827392
	23.603215070140276 115275265.12565802
	23.89580022044088 137415642.8752822
	24.188385370741482 163601055.8284144
	24.48097052104208 193589322.25602663
	24.77355567134268 229180176.515862
	25.066140821643284 269316676.6132674
	25.358725971943887 321722690.1009861
	25.651311122244486 374256514.1765469
	25.943896272545086 441628912.8101232
	26.23648142284569 515423143.1517963
	26.52906657314629 606130598.7617505
	26.82165172344689 707103232.9054028
	27.11423687374749 825163877.0588665
	27.406822024048093 963324681.6324245
	27.699407174348696 1116103944.3489358
	27.991992324649296 1289666282.429506
	28.284577474949895 1499254887.1717534
	28.577162625250498 1736684838.8237638
	28.8697477755511 2005853444.241309
	29.1623329258517 2316417891.314886
	29.4549180761523 2665037688.532878
	29.747503226452903 3062495041.844568
	30.040088376753506 3521235684.7910686
	30.332673527054105 4034253912.3434134
	30.625258677354704 4633961490.270888
	30.917843827655307 5280008059.017388
	31.21042897795591 6057890044.197345
	31.50301412825651 6927008194.28226
	31.79559927855711 7851835827.07828
	32.088184428857716 8893932944.0087
	32.38076957915831 10181677790.43591
	32.673354729458914 11617984120.2019
	32.96593987975952 13011450684.124943
	33.25852503006011 14803741254.697422
	33.55111018036072 16803343525.778408
	33.84369533066132 18993450115.729565
	34.136280480961915 21227958313.13276
	34.428865631262525 23995649111.549904
	34.72145078156312 27187866240.87863
	35.014035931863724 30632815259.65747
	35.30662108216433 34178668541.596375
	35.59920623246492 38600147852.21627
	35.89179138276553 43249531946.00447
	36.18437653306613 48377783030.81447
	36.476961683366724 54342035239.98881
	36.769546833667334 61192419291.04402
	37.06213198396793 68064863213.27338
	37.35471713426854 76251299387.21269
	37.647302284569136 85361796965.44157
	37.93988743486973 95304097313.46213
	38.23247258517034 104899591541.7904
	38.52505773547094 116966656548.7205
	38.817642885771534 129820634789.15015
	39.110228036072144 145138584500.84055
	39.40281318637274 161659220099.29736
	39.69539833667335 179933099136.93573
	39.987983486973945 198513362037.07016
	40.28056863727454 220376192997.53708
	40.57315378757515 244166576786.6219
	40.86573893787575 270744640595.71667
	41.15832408817634 298632806729.2585
	41.45090923847695 329776652103.4757
	41.74349438877755 363505599784.2937
	42.03607953907816 401145759642.7613
	42.328664689378755 441884804941.3015
	42.62124983967935 487570965247.9849
	42.91383498997996 537857037047.4693
	43.20642014028056 590676466730.4182
	43.49900529058115 647416461778.813
	43.79159044088176 713480608507.6669
	44.08417559118236 781260769422.7588
	44.37676074148297 860175909621.7167
	44.669345891783564 936785371264.0197
	44.96193104208416 1033561492671.5624
	45.25451619238477 1134460701497.4773
	45.547101342685366 1240304748991.1157
	45.83968649298596 1357719367908.5452
	46.13227164328657 1496939550874.28
	46.42485679358717 1612938188937.753
	46.71744194388778 1767954347409.3174
	47.010027094188374 1950990061637.2146
	47.30261224448897 2107417314858.9512
	47.59519739478958 2307604091708.449
	47.887782545090175 2513046343958.7354
	48.18036769539077 2747571115646.6157
	48.47295284569138 2958056786119.3086
	48.76553799599198 3228970313006.721
	49.05812314629259 3508133829193.113
	49.35070829659318 3830394704305.0283
	49.64329344689378 4162211105235.5874
	49.93587859719439 4501554155511.975
	50.228463747494985 4903427362393.34
	50.52104889779558 5357568022001.224
	50.81363404809619 5737517221839.398
	51.106219198396786 6254248659299.638
	51.3988043486974 6724235410825.345
	51.69138949899799 7275588121371.863
	51.98397464929859 7984350928347.944
	52.2765597995992 8541606745263.253
	52.569144949899794 9320083083053.787
	52.86173010020039 10020133099852.656
	53.154315250501 10824974432454.44
	53.446900400801596 11694006345717.074
	53.739485551102206 12683020816900.563
	54.0320707014028 13665262027193.594
	54.3246558517034 14796699225326.254
	54.61724100200401 15847817210696.285
	54.9098261523046 17079828207290.342
	55.2024113026052 18381349583412.613
	55.49499645290581 19839244837007.527
	55.787581603206405 21426837557175.496
	56.080166753507015 22995031200387.746
	56.37275190380761 24848174155392.11
	56.66533705410821 26754050277333.953
	56.95792220440882 28633087512958.547
	57.25050735470941 30801042922270.42
	57.54309250501001 33121783611865.47
	57.83567765531062 35605076178511.67
	58.128262805611215 38043872037012.84
	58.420847955911825 40869169501318.78
	58.71343310621242 43893672639228.69
	59.006018256513016 47473556719081.89
	59.298603406813626 50640985027902.19
	59.59118855711422 53932761987708.46
	59.88377370741482 57848621567170.945
	60.17635885771543 61776838021543.19
	60.468944008016024 66280713975223.63
	60.761529158316634 71301950497898.81
	61.05411430861723 75742731843271.84
	61.346699458917826 80714923041610.52
	61.639284609218436 86376561469728.72
	61.93186975951903 93150168636340.9
	62.22445490981963 99180718072093.72
	62.51704006012024 105529827228657.27
	62.80962521042083 113033923738113.4
	63.10221036072144 120808588546208.72
	63.39479551102204 128106374373635.48
	63.687380661322635 137278649475195.56
	63.979965811623245 146958379003574.84
	64.27255096192384 155618222926709.9
	64.56513611222444 167261284082016.66
	64.85772126252505 176585775576524.8
	65.15030641282564 187576251091700.84
	65.44289156312625 201684188107843.6
	65.73547671342685 213640024853675.56
	66.02806186372744 227402749994340.34
	66.32064701402805 242353144516931.1
	66.61323216432865 257079066466441.9
	66.90581731462925 273692881011006.03
	67.19840246492986 292545307182859.8
	67.49098761523045 310693781920364.75
	67.78357276553106 329005776419829.06
	68.07615791583166 349881964716955.94
	68.36874306613225 372329890683435.6
	68.66132821643286 394225153464652.75
	68.95391336673346 419244611476995.56
	69.24649851703407 442292971450304.4
	69.53908366733467 472937155502056.94
	69.83166881763526 500484939979368
	70.12425396793587 528495378798551
df03e67f808b0e3feec7716ad88944c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	14.825660561122243 142764.4785004246
8b0ac61d8ac8dc27982984dffba40ea6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	13.655319959919838 42758.30157189097
9d8035c148c5854665b2f4250ca8c5be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	7.2184466533066125 1.8725152772694804
	7.511031803607214 3.7259602161491414
	7.803616953907815 7.156555379647312
5dc751c194a1575a59c1e8b541134cf6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	12.192394208416832 7956.8246153316695
93d66aaa0480ec3f2aef71aa8ed3c435|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	9.851713006012023 307.9398579488625
38f1af1243a39e84794fa1dcec2c526a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	14.533075410821642 107507.72421270079
4dd4bd0d3dad747b8996174d4f1df22c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	12.484979358717434 11373.615876565915
68b03647878f266dff230a180cdad82a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	11.022053607214428 1744.510968369484
7d154449f3f76bec7c090651f5270c74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	11.60722390781563 3813.673886137112
f98ac951a4d88ca6034486b9fa597ff9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	13.362734809619237 31001.216530642112
ce45b13388291d5cd1141a2fc4027156|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	7.511031803607214 3.7259602161491414
	7.803616953907815 7.156555379647312
	8.096202104208416 13.255593205613904
	8.388787254509017 23.854999574542315
	8.681372404809618 41.476463161707485
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
	13.362734809619237 31001.216530642112
	13.655319959919838 42758.30157189097
	13.94790511022044 58657.832669400916
	14.24049026052104 79322.40297311536
	14.533075410821642 107507.72421270079
	14.825660561122243 142764.4785004246
	15.118245711422844 189675.26425012155
	15.410830861723445 250976.29691099474
	15.703416012024046 332963.73368335527
	15.996001162324648 432148.7858211549
	16.28858631262525 561791.2842904389
	16.58117146292585 727472.3068205083
	16.87375661322645 932887.084296244
	17.16634176352705 1200052.1985521114
	17.458926913827653 1529988.3585294404
	17.751512064128256 1939874.722140508
	18.044097214428856 2459553.0015858514
	18.336682364729455 3096854.6440261337
	18.629267515030058 3920271.344645362
	18.92185266533066 4898038.401186031
	19.21443781563126 6095838.413819074
	19.50702296593186 7542024.579922753
	19.799608116232463 9320733.755917693
	20.092193266533062 11618809.917279037
	20.384778416833665 14214455.845413743
	20.677363567134268 17459695.13382207
	20.969948717434868 21296251.525331497
	21.262533867735467 25958659.12816804
	21.55511901803607 31567651.490300097
	21.847704168336673 38331745.608158566
	22.140289318637272 46089136.30887561
	22.43287446893787 55792691.50218214
	22.725459619238475 67277142.40166242
	23.018044769539078 80391133.70328811
	23.310629919839677 96857846.96827392
	23.603215070140276 115275265.12565802
	23.89580022044088 137415642.8752822
	24.188385370741482 163601055.8284144
	24.48097052104208 193589322.25602663
	24.77355567134268 229180176.515862
	25.066140821643284 269316676.6132674
	25.358725971943887 321722690.1009861
	25.651311122244486 374256514.1765469
	25.943896272545086 441628912.8101232
	26.23648142284569 515423143.1517963
	26.52906657314629 606130598.7617505
	26.82165172344689 707103232.9054028
	27.11423687374749 825163877.0588665
	27.406822024048093 963324681.6324245
	27.699407174348696 1116103944.3489358
	27.991992324649296 1289666282.429506
	28.284577474949895 1499254887.1717534
	28.577162625250498 1736684838.8237638
	28.8697477755511 2005853444.241309
	29.1623329258517 2316417891.314886
	29.4549180761523 2665037688.532878
	29.747503226452903 3062495041.844568
	30.040088376753506 3521235684.7910686
	30.332673527054105 4034253912.3434134
	30.625258677354704 4633961490.270888
	30.917843827655307 5280008059.017388
	31.21042897795591 6057890044.197345
	31.50301412825651 6927008194.28226
	31.79559927855711 7851835827.07828
	32.088184428857716 8893932944.0087
	32.38076957915831 10181677790.43591
	32.673354729458914 11617984120.2019
	32.96593987975952 13011450684.124943
	33.25852503006011 14803741254.697422
	33.55111018036072 16803343525.778408
	33.84369533066132 18993450115.729565
	34.136280480961915 21227958313.13276
	34.428865631262525 23995649111.549904
	34.72145078156312 27187866240.87863
	35.014035931863724 30632815259.65747
	35.30662108216433 34178668541.596375
	35.59920623246492 38600147852.21627
	35.89179138276553 43249531946.00447
	36.18437653306613 48377783030.81447
	36.476961683366724 54342035239.98881
	36.769546833667334 61192419291.04402
	37.06213198396793 68064863213.27338
	37.35471713426854 76251299387.21269
	37.647302284569136 85361796965.44157
	37.93988743486973 95304097313.46213
	38.23247258517034 104899591541.7904
	38.52505773547094 116966656548.7205
	38.817642885771534 129820634789.15015
	39.110228036072144 145138584500.84055
	39.40281318637274 161659220099.29736
	39.69539833667335 179933099136.93573
	39.987983486973945 198513362037.07016
	40.28056863727454 220376192997.53708
	40.57315378757515 244166576786.6219
	40.86573893787575 270744640595.71667
	41.15832408817634 298632806729.2585
	41.45090923847695 329776652103.4757
	41.74349438877755 363505599784.2937
	42.03607953907816 401145759642.7613
	42.328664689378755 441884804941.3015
	42.62124983967935 487570965247.9849
	42.91383498997996 537857037047.4693
	43.20642014028056 590676466730.4182
	43.49900529058115 647416461778.813
	43.79159044088176 713480608507.6669
	44.08417559118236 781260769422.7588
	44.37676074148297 860175909621.7167
	44.669345891783564 936785371264.0197
	44.96193104208416 1033561492671.5624
	45.25451619238477 1134460701497.4773
	45.547101342685366 1240304748991.1157
	45.83968649298596 1357719367908.5452
	46.13227164328657 1496939550874.28
	46.42485679358717 1612938188937.753
	46.71744194388778 1767954347409.3174
	47.010027094188374 1950990061637.2146
	47.30261224448897 2107417314858.9512
	47.59519739478958 2307604091708.449
	47.887782545090175 2513046343958.7354
	48.18036769539077 2747571115646.6157
	48.47295284569138 2958056786119.3086
	48.76553799599198 3228970313006.721
	49.05812314629259 3508133829193.113
	49.35070829659318 3830394704305.0283
	49.64329344689378 4162211105235.5874
	49.93587859719439 4501554155511.975
	50.228463747494985 4903427362393.34
	50.52104889779558 5357568022001.224
	50.81363404809619 5737517221839.398
	51.106219198396786 6254248659299.638
	51.3988043486974 6724235410825.345
	51.69138949899799 7275588121371.863
	51.98397464929859 7984350928347.944
	52.2765597995992 8541606745263.253
	52.569144949899794 9320083083053.787
	52.86173010020039 10020133099852.656
	53.154315250501 10824974432454.44
	53.446900400801596 11694006345717.074
	53.739485551102206 12683020816900.563
	54.0320707014028 13665262027193.594
	54.3246558517034 14796699225326.254
	54.61724100200401 15847817210696.285
	54.9098261523046 17079828207290.342
	55.2024113026052 18381349583412.613
	55.49499645290581 19839244837007.527
	55.787581603206405 21426837557175.496
	56.080166753507015 22995031200387.746
	56.37275190380761 24848174155392.11
	56.66533705410821 26754050277333.953
	56.95792220440882 28633087512958.547
	57.25050735470941 30801042922270.42
	57.54309250501001 33121783611865.47
	57.83567765531062 35605076178511.67
	58.128262805611215 38043872037012.84
	58.420847955911825 40869169501318.78
	58.71343310621242 43893672639228.69
	59.006018256513016 47473556719081.89
	59.298603406813626 50640985027902.19
	59.59118855711422 53932761987708.46
	59.88377370741482 57848621567170.945
	60.17635885771543 61776838021543.19
	60.468944008016024 66280713975223.63
	60.761529158316634 71301950497898.81
	61.05411430861723 75742731843271.84
	61.346699458917826 80714923041610.52
	61.639284609218436 86376561469728.72
	61.93186975951903 93150168636340.9
	62.22445490981963 99180718072093.72
	62.51704006012024 105529827228657.27
	62.80962521042083 113033923738113.4
	63.10221036072144 120808588546208.72
	63.39479551102204 128106374373635.48
	63.687380661322635 137278649475195.56
	63.979965811623245 146958379003574.84
	64.27255096192384 155618222926709.9
	64.56513611222444 167261284082016.66
	64.85772126252505 176585775576524.8
	65.15030641282564 187576251091700.84
	65.44289156312625 201684188107843.6
	65.73547671342685 213640024853675.56
	66.02806186372744 227402749994340.34
	66.32064701402805 242353144516931.1
	66.61323216432865 257079066466441.9
	66.90581731462925 273692881011006.03
	67.19840246492986 292545307182859.8
	67.49098761523045 310693781920364.75
	67.78357276553106 329005776419829.06
	68.07615791583166 349881964716955.94
	68.36874306613225 372329890683435.6
	68.66132821643286 394225153464652.75
	68.95391336673346 419244611476995.56
	69.24649851703407 442292971450304.4
	69.53908366733467 472937155502056.94
	69.83166881763526 500484939979368
	70.12425396793587 528495378798551
	70.41683911823647 562183227598147.1
	70.70942426853708 594934567031578.9
	71.00200941883767 632698027355021.4
	71.29459456913827 669739550934823.5
	71.58717971943888 711297501336792.8
	71.87976486973947 748551960455426.1
	72.17235002004007 791040879920129
	72.46493517034068 832658486450441.5
	72.75752032064128 893133929088445.4
	73.05010547094187 946860924085411.8
	73.34269062124248 992388954716701.8
	73.63527577154308 1051671331499023.4
	73.92786092184369 1106251526369075.3
c62c0b5d34be0dda1153f325f171e341|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	15.410830861723445 250976.29691099474
82bb171a834359a9553dd86ebb658f74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	15.703416012024046 332963.73368335527
599358861dfbf52b3864b78fe5f4f8aa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	8.096202104208416 13.255593205613904
	8.388787254509017 23.854999574542315
	8.681372404809618 41.476463161707485
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
f54d1d98190f43fc7d49692ac96ae0bd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	8.681372404809618 41.476463161707485
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
	13.362734809619237 31001.216530642112
	13.655319959919838 42758.30157189097
	13.94790511022044 58657.832669400916
	14.24049026052104 79322.40297311536
	14.533075410821642 107507.72421270079
	14.825660561122243 142764.4785004246
	15.118245711422844 189675.26425012155
	15.410830861723445 250976.29691099474
	15.703416012024046 332963.73368335527
	15.996001162324648 432148.7858211549
	16.28858631262525 561791.2842904389
	16.58117146292585 727472.3068205083
	16.87375661322645 932887.084296244
	17.16634176352705 1200052.1985521114
	17.458926913827653 1529988.3585294404
	17.751512064128256 1939874.722140508
	18.044097214428856 2459553.0015858514
	18.336682364729455 3096854.6440261337
	18.629267515030058 3920271.344645362
	18.92185266533066 4898038.401186031
	19.21443781563126 6095838.413819074
	19.50702296593186 7542024.579922753
	19.799608116232463 9320733.755917693
	20.092193266533062 11618809.917279037
	20.384778416833665 14214455.845413743
	20.677363567134268 17459695.13382207
	20.969948717434868 21296251.525331497
	21.262533867735467 25958659.12816804
	21.55511901803607 31567651.490300097
	21.847704168336673 38331745.608158566
	22.140289318637272 46089136.30887561
	22.43287446893787 55792691.50218214
	22.725459619238475 67277142.40166242
	23.018044769539078 80391133.70328811
	23.310629919839677 96857846.96827392
	23.603215070140276 115275265.12565802
	23.89580022044088 137415642.8752822
	24.188385370741482 163601055.8284144
	24.48097052104208 193589322.25602663
	24.77355567134268 229180176.515862
	25.066140821643284 269316676.6132674
	25.358725971943887 321722690.1009861
	25.651311122244486 374256514.1765469
	25.943896272545086 441628912.8101232
	26.23648142284569 515423143.1517963
	26.52906657314629 606130598.7617505
	26.82165172344689 707103232.9054028
	27.11423687374749 825163877.0588665
	27.406822024048093 963324681.6324245
	27.699407174348696 1116103944.3489358
	27.991992324649296 1289666282.429506
	28.284577474949895 1499254887.1717534
	28.577162625250498 1736684838.8237638
	28.8697477755511 2005853444.241309
	29.1623329258517 2316417891.314886
	29.4549180761523 2665037688.532878
	29.747503226452903 3062495041.844568
	30.040088376753506 3521235684.7910686
	30.332673527054105 4034253912.3434134
	30.625258677354704 4633961490.270888
	30.917843827655307 5280008059.017388
	31.21042897795591 6057890044.197345
	31.50301412825651 6927008194.28226
	31.79559927855711 7851835827.07828
	32.088184428857716 8893932944.0087
	32.38076957915831 10181677790.43591
	32.673354729458914 11617984120.2019
	32.96593987975952 13011450684.124943
	33.25852503006011 14803741254.697422
	33.55111018036072 16803343525.778408
	33.84369533066132 18993450115.729565
	34.136280480961915 21227958313.13276
	34.428865631262525 23995649111.549904
	34.72145078156312 27187866240.87863
	35.014035931863724 30632815259.65747
	35.30662108216433 34178668541.596375
	35.59920623246492 38600147852.21627
	35.89179138276553 43249531946.00447
	36.18437653306613 48377783030.81447
	36.476961683366724 54342035239.98881
	36.769546833667334 61192419291.04402
	37.06213198396793 68064863213.27338
	37.35471713426854 76251299387.21269
	37.647302284569136 85361796965.44157
	37.93988743486973 95304097313.46213
	38.23247258517034 104899591541.7904
	38.52505773547094 116966656548.7205
	38.817642885771534 129820634789.15015
	39.110228036072144 145138584500.84055
	39.40281318637274 161659220099.29736
	39.69539833667335 179933099136.93573
	39.987983486973945 198513362037.07016
	40.28056863727454 220376192997.53708
	40.57315378757515 244166576786.6219
	40.86573893787575 270744640595.71667
	41.15832408817634 298632806729.2585
b88735a38f131d0e8c75b417baed79cd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	14.24049026052104 79322.40297311536
b955a988eaad59ca1cc08ffc48bc4a26|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	15.118245711422844 189675.26425012155
8e3451ead04f177e1ac25271903b23e3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	22.140289318637272 46089136.30887561
bb62b30b90055b820498de0996184d23|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	21.262533867735467 25958659.12816804
b94d04450258ad15f75d26b365cb70a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	8.388787254509017 23.854999574542315
	8.681372404809618 41.476463161707485
	8.97395755511022 70.67875769604352
	9.26654270541082 118.42520896674478
	9.559127855711422 192.75494818919174
	9.851713006012023 307.9398579488625
	10.144298156312624 486.45252978813943
	10.436883306613225 752.7685959993374
	10.729468456913827 1147.2965039914598
	11.022053607214428 1744.510968369484
	11.314638757515029 2590.326457771899
	11.60722390781563 3813.673886137112
	11.899809058116231 5546.454195642855
	12.192394208416832 7956.8246153316695
	12.484979358717434 11373.615876565915
	12.777564509018035 16001.42928196151
	13.070149659318636 22581.99040155635
	13.362734809619237 31001.216530642112
	13.655319959919838 42758.30157189097
	13.94790511022044 58657.832669400916
	14.24049026052104 79322.40297311536
	14.533075410821642 107507.72421270079
	14.825660561122243 142764.4785004246
	15.118245711422844 189675.26425012155
	15.410830861723445 250976.29691099474
	15.703416012024046 332963.73368335527
	15.996001162324648 432148.7858211549
	16.28858631262525 561791.2842904389
	16.58117146292585 727472.3068205083
	16.87375661322645 932887.084296244
	17.16634176352705 1200052.1985521114
	17.458926913827653 1529988.3585294404
	17.751512064128256 1939874.722140508
	18.044097214428856 2459553.0015858514
	18.336682364729455 3096854.6440261337
	18.629267515030058 3920271.344645362
	18.92185266533066 4898038.401186031
	19.21443781563126 6095838.413819074
	19.50702296593186 7542024.579922753
	19.799608116232463 9320733.755917693
	20.092193266533062 11618809.917279037
	20.384778416833665 14214455.845413743
	20.677363567134268 17459695.13382207
	20.969948717434868 21296251.525331497
	21.262533867735467 25958659.12816804
	21.55511901803607 31567651.490300097
	21.847704168336673 38331745.608158566
	22.140289318637272 46089136.30887561
	22.43287446893787 55792691.50218214
	22.725459619238475 67277142.40166242
	23.018044769539078 80391133.70328811
72cf2211615bbb802450096f0f90b09c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	12.777564509018035 16001.42928196151
363eb834a8f6b98730aa3aa338334ab6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	11.899809058116231 5546.454195642855
6c45cf5cc87acc6bf291d54b154b1687|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	24.188385370741482 163601055.8284144
6504980949027d0a83e95331715891b9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	20.969948717434868 21296251.525331497
7604d199140af39eb95a6a8101fe42b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	10.144298156312624 486.45252978813943
0906cdb753fd57db859cd45a8163c619|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	10.436883306613225 752.7685959993374
37734f1883dbc4967c8e4740ad3cf2e5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	18.629267515030058 3920271.344645362
dc24d79d650451368ffe2fdb21b6b009|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	20.092193266533062 11618809.917279037
13c7b2b9c9fe1ca9c6e8192b4f2d41a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	11.314638757515029 2590.326457771899
5471d36eb270a7b4cbdf6b00a03231bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	18.336682364729455 3096854.6440261337
23032ace165e2dcc2b447e56adf71884|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	19.21443781563126 6095838.413819074
9d579ca44c45b54e60b4396a2ce4b947|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	24.48097052104208 193589322.25602663
9c960967d7f88497940ff46c6f149750|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	20.677363567134268 17459695.13382207
5899a994332f00ba2ea5f2448bfca8c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	5.170350601202404 0.0020125277449759248
	5.4629357515030055 0.007642495637043617
3d7c3e67ba9d793f479ff2d1a2c83bcb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	22.725459619238475 67277142.40166242
be838c5ab690a609e0a79b5ec72497d3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	13.070149659318636 22581.99040155635
cf7582780da70ec0500178ad53cdbb9f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	19.799608116232463 9320733.755917693
0d6ef9fe17d3818a4263017ecfc84e18|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	13.94790511022044 58657.832669400916
9e18836adc7e92b3d1e8afcd0594b380|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	23.018044769539078 80391133.70328811
2add476adf94e0abb46f6770c28773e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	23.310629919839677 96857846.96827392
1b3a6600ff9a7cd82ae2f9fbc8427eb5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	22.43287446893787 55792691.50218214
d604b44160d06c1c4538f033ce1dd43e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	17.751512064128256 1939874.722140508
610d7b07f6f601ef142cb6b95cc79113|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	18.92185266533066 4898038.401186031
e31854e6237a39a186781319407b3b11|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	20.384778416833665 14214455.845413743
ccd9dcdefa6eb48a368ae992dcd080e7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	18.044097214428856 2459553.0015858514
89cbc7aefa7ae7d11aef0ef334128993|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	26.52906657314629 606130598.7617505
90a6d42b918f479bfdc387521d50e301|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	15.996001162324648 432148.7858211549
fb45bbc4460864c2b97f2a6944a5a427|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	16.58117146292585 727472.3068205083
e184ac4460f1a8a2552f75048d2ee4eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	17.16634176352705 1200052.1985521114
6217c5a1daec98e7a5a56997ab85cf9b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	27.991992324649296 1289666282.429506
066a0afbc723a168be16d32141f2db48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	21.847704168336673 38331745.608158566
b4f8d32dd07d862bdb0b3318fd345ac1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	28.577162625250498 1736684838.8237638
bbf3668ed4348941872da0efa18e3465|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	25.651311122244486 374256514.1765469
ab60d4bed36dbc5028f27370f5571407|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	24.77355567134268 229180176.515862
c8ee5e5b66cf0b136e6240242ae80311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	30.040088376753506 3521235684.7910686
6085bd779b84c5a33e587f1df39d6356|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	26.23648142284569 515423143.1517963
69dc8c11c38f50ce2c54506efccaf677|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	19.50702296593186 7542024.579922753
7b63c38c8933b7669abebb1e92d3e693|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	28.8697477755511 2005853444.241309
7cc5c1a9ba1b2a562cfcf3311d2be1c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	16.28858631262525 561791.2842904389
cba4585be8c237bd93a7f1bb9fecb299|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	25.358725971943887 321722690.1009861
34397a1acc2505cb95898180a34a70ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	25.066140821643284 269316676.6132674
5362639851549d5575bfadb8d19c7f21|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	16.87375661322645 932887.084296244
d7811c2a6ab58fb1ab7d71dc15713095|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	25.943896272545086 441628912.8101232
bc4b363c1bcebab4a94027a7fd05a7d8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	17.458926913827653 1529988.3585294404
b0f99c1afb919b0f394e42f8def50c31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	32.96593987975952 13011450684.124943
ef28e21a40cff6cca77da27964a22cbc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	29.747503226452903 3062495041.844568
ebd6b29bc58260be65d9ee8cff87fb69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	23.89580022044088 137415642.8752822
4bbbd2ac4d6539e976d1f9083ec2ef94|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	35.014035931863724 30632815259.65747
5a9deddec78032d33d7ef6082d946a2e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	27.406822024048093 963324681.6324245
66d17c5ce64bb8419cb2e9ace5ad9992|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	34.136280480961915 21227958313.13276
1e9388f980cc4c98be6dfb159d6e6cbf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	34.428865631262525 23995649111.549904
bd0eb9c863c747ef456d70f95abe66ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	23.603215070140276 115275265.12565802
a61bcac6098a4c5110b21b7eb039fa59|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	28.284577474949895 1499254887.1717534
6f2e1c098c829f4cad5aecc4789dfb5d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	21.55511901803607 31567651.490300097
fcfc6e9154ef2400fe83b4bdc54519d6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	31.79559927855711 7851835827.07828
bf6b7dfdc25d813ba115ee906c9714ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	29.1623329258517 2316417891.314886
62198dc89b44196127272efc54a4116d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	33.84369533066132 18993450115.729565
f445ea77bcebcd6aec74fc86e33e19f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	36.18437653306613 48377783030.81447
78515fc7b8b018604a77794ddac7c610|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	35.59920623246492 38600147852.21627
509a76d2aa8808ee7d30a807b205b576|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	31.21042897795591 6057890044.197345
4f9ff081b947e73a8dd0f7cfaaebe8cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	32.38076957915831 10181677790.43591
c02a965621fcfc12d242d88b8e7eb448|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	31.50301412825651 6927008194.28226
033d54c472c6af97f746d67960a1f908|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	32.088184428857716 8893932944.0087
b01bba2d79c62a28d3b1cfa63de8b6d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	30.625258677354704 4633961490.270888
98ba300cf812278069693b521281efb0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	40.86573893787575 270744640595.71667
9b4aebe0b79b6b34cccf438e2def8c31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	36.769546833667334 61192419291.04402
ac30b6cea634c6da5305af0c848a9421|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	27.11423687374749 825163877.0588665
e48522c0a60f3dd6b1f703d2a0e1834b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	30.332673527054105 4034253912.3434134
8fe690aa046b2110cf323cb9f9f75ac3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	35.30662108216433 34178668541.596375
1cc88509605d10528d0360879e975b08|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	39.69539833667335 179933099136.93573
48a4e4df365983be6ceb05b8a6bbe220|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	38.52505773547094 116966656548.7205
ccd192f4b4bda985717c49ec9cac596b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	30.917843827655307 5280008059.017388
adbffa909e38b77c525f5abde8407e7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	29.4549180761523 2665037688.532878
91ce93a24c0d05e56cad29c273f93fdd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	32.673354729458914 11617984120.2019
d793c8bd1cad74d128b1eae25ef6a3d4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	37.06213198396793 68064863213.27338
526e7b2caf45d9b470c4db8c725fc66a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	38.23247258517034 104899591541.7904
3187d16bacbe9e395c6550e551ba698d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	26.82165172344689 707103232.9054028
82a68c74c3a45422aabc596e83f92f94|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	39.110228036072144 145138584500.84055
bdf562484e3ffc5a9d2778fa942ce6bb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	43.79159044088176 713480608507.6669
149ee73679159eb7a5dcad40d689ca42|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	33.55111018036072 16803343525.778408
00aff3fb301d3bec78f76d4c45f8d110|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	35.89179138276553 43249531946.00447
8fbf71745f13cae70fc14b897a21d45c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	39.40281318637274 161659220099.29736
e8bcdafe97f92f3597ce44b72dec9521|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	38.817642885771534 129820634789.15015
9497ebdcdcc88f76522d817edf96fd7e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	27.699407174348696 1116103944.3489358
b38cba791629c9b8fe14f3ad992bc874|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	39.987983486973945 198513362037.07016
ca3c60db4571ebd625441ee9085c7ecf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	36.476961683366724 54342035239.98881
309674a4f9aa7940dc493ae3e8cde6d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	41.45090923847695 329776652103.4757
39df0bc347ca8ba370e346441adabed2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	40.28056863727454 220376192997.53708
d0173304fda26e38469a36082d0464ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	48.76553799599198 3228970313006.721
1c5afd8cccb6ed5945b9b46a94d09896|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	44.96193104208416 1033561492671.5624
347eaad3a2fc721f6fdbdb41872bb503|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	37.93988743486973 95304097313.46213
54cac69f77c1068d0e37892270595bd1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	37.647302284569136 85361796965.44157
d88921a304ce36a8119f83f9a9ef0924|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	52.569144949899794 9320083083053.787
3bbbfc2bc62622682917bf831086455a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	40.57315378757515 244166576786.6219
1b9fb2ac945bec1c3f0debf32d32ff16|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	42.62124983967935 487570965247.9849
f1d8ae684930f426e285565dbebebbb0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	44.08417559118236 781260769422.7588
9ad5624e1b91b37a2671e31c40daf140|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	37.35471713426854 76251299387.21269
9f4e1540c9da44cfa929f46079e03e06|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	34.72145078156312 27187866240.87863
c2df93a16b27449bf3818c50aa7de88d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	41.15832408817634 298632806729.2585
94f7e853a0f9eae0ac62e8105d6b4e9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	41.74349438877755 363505599784.2937
89da8e9ba77d890ca95f7a0c3609b658|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	33.25852503006011 14803741254.697422
f4cc07b0b50fdc388bfcb92128ff59eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	44.669345891783564 936785371264.0197
cde041934e76a5533ef78549a3e8b648|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	44.37676074148297 860175909621.7167
e5c52fc206843e1f8ad6863e15e46354|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	46.13227164328657 1496939550874.28
f55a9603ffe7b22b7f746f2adbc20980|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	54.61724100200401 15847817210696.285
de93000ce7e0dcaf6bc4ac1ab4c6665e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	50.52104889779558 5357568022001.224
7760de056d608d5f56c2399d0ee40536|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	58.128262805611215 38043872037012.84
118c15af588a089f50d6bb7671e0bc4a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	42.03607953907816 401145759642.7613
b432a86356000728268df60061596cc8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	56.95792220440882 28633087512958.547
188891a4f99f1fc2918105cc51a4e917|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	49.05812314629259 3508133829193.113
b20be4e76d6644f0ca946ca47acacdf3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	51.3988043486974 6724235410825.345
4385528e9d622eb4e128e24421b19521|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	48.47295284569138 2958056786119.3086
43d671a234a4837118bbb18f5a6dabe0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	45.547101342685366 1240304748991.1157
c1d1d115aa6d85c5a169174e05ae3dfd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	46.71744194388778 1767954347409.3174
1b62671772f2c2fa71011310780fcb2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	51.69138949899799 7275588121371.863
0489bcee33d41ebfec83f697d9b319c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	52.2765597995992 8541606745263.253
ee1f035910530a82630c8ce0b1a724b9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	48.18036769539077 2747571115646.6157
18d60973bd3d59be896009d69bde116b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	53.154315250501 10824974432454.44
852c82df3e30ac1604e24e074d4e7206|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	42.91383498997996 537857037047.4693
89613216ebf8135a6274c48b19a34b16|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	51.98397464929859 7984350928347.944
21f1cf02df036d8cab2da4bf1277be97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	47.010027094188374 1950990061637.2146
4dce9c0a67c4c7ca202492bd699500d4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	55.787581603206405 21426837557175.496
53bd1f7e533dbf578c5139afda168ef4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	46.42485679358717 1612938188937.753
f6a66bb55ec1ae08950ea9a2f33fa8ca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	53.446900400801596 11694006345717.074
894b375b64232d9ad46e9081b57d70fc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	55.49499645290581 19839244837007.527
26a294d88295ee80884e97fbff14b2dd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	50.228463747494985 4903427362393.34
8f82bfc5e4ddd93e4008d875663531e4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	51.106219198396786 6254248659299.638
4464d859007f0e1cdc4feaf3849f93ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	62.22445490981963 99180718072093.72
b9fd4a3d2dfae0eb627ff2c82a41b033|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	43.49900529058115 647416461778.813
ce99b143fc587687b177e4abfd666258|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	63.687380661322635 137278649475195.56
ccd36b18acaf4030bc06f5f1c985ac6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	47.887782545090175 2513046343958.7354
9f148ffa6fcd05cc7f59ea8a86c2f531|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	54.0320707014028 13665262027193.594
d4ae01925260590c56b6820114b8598a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	54.9098261523046 17079828207290.342
11481ff0f7a8d89abfd1fc989c6589db|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	66.32064701402805 242353144516931.1
3a467630a6acfadc187293f46ef7f160|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	53.739485551102206 12683020816900.563
6e556908162b40c7528953d4ee86910d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	47.59519739478958 2307604091708.449
9a4ed12f7f407ffeb5f95aabbb5d14cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	47.30261224448897 2107417314858.9512
77efb16675352537d3aa371aa7432598|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	56.66533705410821 26754050277333.953
cea8f77d5f02d5a8d708bd64929fcc5d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	62.51704006012024 105529827228657.27
98072788dea04c84c9adf6bbe09f47c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	64.27255096192384 155618222926709.9
8cb3035c365ac9e3769678e9030d11c4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	61.639284609218436 86376561469728.72
6b682ecbce31d628ee8941c95effe02e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	55.2024113026052 18381349583412.613
ac16f6c0f484ab200d0a5af8c93c9b47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	49.64329344689378 4162211105235.5874
7e2eb35924632c593b5de0f29d5818d7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	50.81363404809619 5737517221839.398
4d420c861615ff88c836ac74b4628ec0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	58.420847955911825 40869169501318.78
6e06367707ed915aec35da33763f7017|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	49.35070829659318 3830394704305.0283
66d3592872c00bd8f57c886c21098536|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	42.328664689378755 441884804941.3015
200bcd1869956237fdf827cee1ac3de1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	43.20642014028056 590676466730.4182
782fad53f19cfdede8fd760211287d8e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	56.080166753507015 22995031200387.746
f4ee82c408895a36da73a288105718e9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	45.25451619238477 1134460701497.4773
f03b8151256b946faba5d34ce6f7e3ca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	61.93186975951903 93150168636340.9
e18cdcc1aef243e32ab662cc945d9028|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	49.93587859719439 4501554155511.975
4ba99c118230e2620597fd68c9f948e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	58.71343310621242 43893672639228.69
15ed0b4cf1d7a212c9124a936b922b9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	63.979965811623245 146958379003574.84
a2aa27c578fadef47c6568f92077ceba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	60.17635885771543 61776838021543.19
4f6d4849bbbfdaafe917adc7fbe8492f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	61.05411430861723 75742731843271.84
98b4d09ec8e77dfae2452b345db62e25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	66.61323216432865 257079066466441.9
b6e2cf1e55c25041e62404f706707b34|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	63.39479551102204 128106374373635.48
8655b13cb32d7d4fc22f1e4e7b402110|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	65.44289156312625 201684188107843.6
6694a30b874046614c5d01279ec19dad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	57.25050735470941 30801042922270.42
682021ec2132ce7da1429903df7091a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	71.00200941883767 632698027355021.4
62f9adf45b40f7c5931f608d400f7e24|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	63.10221036072144 120808588546208.72
f76b70277dad63b6402b970a1892af8b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	56.37275190380761 24848174155392.11
c29354ba6ef6fd07c4a7dad05b937c68|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	57.83567765531062 35605076178511.67
e3b0bee3cd066eda34cd29eb1e8b36b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	67.78357276553106 329005776419829.06
df6c8035d6e7192cf6c719a99b4d6097|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	45.83968649298596 1357719367908.5452
ba1f299b8f344e32eecc127030e93edf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	73.63527577154308 1051671331499023.4
dcd8292e6d518dc8e6cb0b4d22755311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	61.346699458917826 80714923041610.52
b655b292628668960dc37f9dcab39bd1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	69.24649851703407 442292971450304.4
3b0a043f6a1e94a40a8ed7425290819e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	59.298603406813626 50640985027902.19
1723def24db2aa3d1cb9af8f5147ee61|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	54.3246558517034 14796699225326.254
03e0d68d8bc280732ae111b9737bc055|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	59.88377370741482 57848621567170.945
f93a110f929b7e86027a1be32b7c026c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	52.86173010020039 10020133099852.656
9df601a34a7080de34dfae955c2d0775|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	62.80962521042083 113033923738113.4
21cffcb4b4f971fff613751a57da803d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	68.66132821643286 394225153464652.75
9d342baf1b57b5abbf695ce917fc9ce4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	66.02806186372744 227402749994340.34
e38db4d9498e3bba6ee1d49e97ed3eb7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	65.73547671342685 213640024853675.56
308dd37382b7372efd45a787f51f5c84|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	64.56513611222444 167261284082016.66
b8d55f898fef0420c7fa444d332f5c2c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	59.59118855711422 53932761987708.46
25ba91e14e954d3f080fedacad97d0ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	73.05010547094187 946860924085411.8
7b440c3fc5581fde4fe6841c69602d7c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	68.07615791583166 349881964716955.94
dd5df82b19acd80100be572430805eaa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	68.36874306613225 372329890683435.6
6a609261b4148fbf390bb73d59611311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	64.85772126252505 176585775576524.8
184bc85e0edf33984f075d529a8ad30a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	74.22044607214428 1171228613012291.5
ca725fb7d13dc2589ab6e00f42fb198e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	82.99800058116232 5631289093806335
e32ff4047dbc86de187d60518d7ec9de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	68.95391336673346 419244611476995.56
62bce70527af99edce0e40507bdd5ebd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	70.41683911823647 562183227598147.1
ac0756a2ee8229de987b079f5ecf6c43|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	72.46493517034068 832658486450441.5
9ba1525f48c8f26a9f786883c8af461c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	59.006018256513016 47473556719081.89
42a1314aafdfd82b9879c0477d3706ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	71.58717971943888 711297501336792.8
6a2110891c6d89477d047a942158e55a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	82.12024513026051 4844382045717717
d3e3ced5bd4a6aaef1d6aaa43ae43df3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	71.29459456913827 669739550934823.5
2931c9491c9d0ad841b10a22529ad403|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	66.90581731462925 273692881011006.03
0051ea89d160a008dd57ae4bc537e4f9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	70.12425396793587 528495378798551
5c463c2367c7ef17cfef9ac02bda4652|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	72.17235002004007 791040879920129
e834592473b8eb8448b941345812b169|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	83.58317088176352 6236856693828976
e186db3570ddaf1510446acf07b7732d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	70.70942426853708 594934567031578.9
c051bf3950b3a6115f4cd26c01f5ac14|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	65.15030641282564 187576251091700.84
df5af35fb01f0523285a199209838abf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	74.80561637274549 1313361374467700.8
ad5138bcd1d25519e1522897f76c3dd5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	67.19840246492986 292545307182859.8
7d6cd631b3dfb9111860d062c0936311|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	76.85371242484969 1916029739140473.3
7ada0dacd23f886c714baeebf55ec22b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	72.75752032064128 893133929088445.4
4f113c4ffd9f2af6def20ba9db22d53d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	73.92786092184369 1106251526369075.3
819a85a78d43d9d820e138e4ad970d46|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	69.83166881763526 500484939979368
e78bd666e16f3142a887565c5c20adcd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	82.70541543086172 5330372636856199
6b48837f247da5150e7ca35e4aef0fbf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	73.34269062124248 992388954716701.8
8f7cebaf45769d329ed87cc1783de3a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	60.761529158316634 71301950497898.81
113013629b860e1dc6813d575736539f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	75.3907866733467 1462257518144462.8
13450d2bae68821a62c2dabdac0a8b09|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	69.53908366733467 472937155502056.94
32031755d6734d67b257e0e10e1865cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	87.67936298597193 12161180807570274
2c20e184630e5e1f26711b5d39179ac0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	79.7795639278557 3239966823363707.5
715a33a5e1ae8c280fc2ff034f8d4010|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	87.97194813627254 12763841324526236
b3a664a10ac5373613cd4a13a3aadacf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	85.04609663326653 7966655075969272
4d0ba1df4ed6aafaafe4b91a18ec6045|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	77.73146787575149 2262045779170034.5
fdf166b89287273bbdadc713258da7b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	78.0240530260521 2373872223966514.5
9d7655dead4ab69fb6bb97e9072699f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	84.46092633266532 7193072010010735
c7d94531c242e7d1ee61ad7d859504b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	80.07214907815631 3394532940039977
58675a7bb91053501183cc084d646b71|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	77.1462975751503 2017289460488448.8
4f355c0315d916229e0470461c8f7eba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	78.9018084769539 2768351208135395.5
3ed020b0aacee8b40aa51e435e35e512|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	81.53507482965931 4370811327791084
76a3d9f3cc3ea3e7392d153a54fc3cb0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	82.41283028056111 5091264330137185
933c821a4ca4c52fb7fed347d89dec0c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	83.87575603206412 6495808643202881
7c9a52077e56d6cc864d6e0d09a357a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	67.49098761523045 310693781920364.75
e3f84ce487a0a827872de0949fd55664|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	84.16834118236473 6873801284902010
503e02e9f26b2095a869fe2ecaa98d7c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	81.24248967935871 4188207504855594
6a856d58e3fd57e3d5b990fa4b135c91|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	71.87976486973947 748551960455426.1
57fcc720190b59a461139da8442c8e99|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	75.68337182364729 1542705969890733.3
fd84873d9166825eaf8209fe7aa06ad0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	76.2685421242485 1713628652422763
64aa06b26ff8bbe99da7c6df52e8586f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	78.3166381763527 2504284060413185.5
0bbe982394899d89312a3147d48c2fc4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	79.1943936272545 2913805332849708.5
4f15268ff602c6e564726d17e726c706|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	90.60521448897795 19121943262307470
eda8f4127e7fd64717b89a391932674b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	93.82365114228456 31438765078584350
fac48a96b15994e7ec98f29f47661144|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	86.80160753507013 10531664340658800
d945033c5f417bb4836ed7e18e49a26d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	88.55711843687374 13985744389247728
83ef08f069d0fd4d34c7fec2fb8e724c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	83.29058573146293 5918538334580787
db6c5d8a30dc24c2dfe23a698662be6e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	78.60922332665331 2630282173407508
40e3e2b851d2f242b41a3523dfe9b3bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	80.94990452905812 3943608778360628.5
44180084e2219741e7da4c7000754532|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	75.09820152304609 1386625957561791.8
e21ac87ef1a4af7d7a6a689bafe8eba9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	81.82765997995992 4628045126400370
f2009a1bd57a85b65f66cc1accf9e190|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	89.43487388777555 15955227039994638
0540f1b37934ba17d590e50a026d6ca5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	84.75351148296593 7509279637325186
e478bd852146ff265ce1396a1c8ab7d6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	85.92385208416833 9194501998637182
3bf103600ddb33e677aaac2460a9fc4c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	96.74950264529058 48457104393058930
02c4d5e08e372564371d667c9ee64729|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	85.33868178356713 8336804017143292
0d15a346ecc1befe901451d13998fb55|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	80.6573193787575 3768591214469139.5
d73b6d5412b8e6761b8afafceaea3435|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	87.38677783567134 11648975784944872
612fc5205def276b54facab0494bbe8b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	93.23848084168336 28713826506324520
e79dcf407b2f63868ca3d61de914a762|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	92.94589569138276 27619877670567460
3051386274e91fd1a09901825e7c295f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	87.09419268537073 10995759499724794
428b4bdafb263330440276dc8c5892a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	86.21643723446893 9587765907883986
b9d274505c4e37c44f77e8ca81366b48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	96.45691749498997 46074269456146840
758c3bdf98da95af81f9db0a9f32c768|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	86.50902238476954 10096717445021788
a805ac6e816e79c27881e3ab0cbdcfe0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	88.26453328657314 13335991504769858
8ee0b13500f8e2876a8a0bfacb6246a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	97.04208779559117 50360993156104010
5e7bd83c927df6ab966300f0a689d142|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	98.79759869739479 64609968189461230
39bc79dc3b89aa6ad5877c1502a25d9b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	94.99399174348697 37444264639469540
9768cb54c5c2a4955f26af7149aad59a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	100.26052444889778 79773237096864850
152997f4ed130361054d492bf0b702de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	90.89779963927855 20200596932414310
17916db5de9198cc40a773b1d004c7ab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	91.77555509018035 23055614308000268
1438f189d69153526268e518749793f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	85.63126693386774 8685387888133001
ede961a8137db088b474d937f03abed7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	79.48697877755511 3080883600657825
211e084272f41bad012241f9f08ec95d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	57.54309250501001 33121783611865.47
c7cb0806ebea02626c19d3d5cf328e7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	75.97595697394789 1631250939577403.5
b5acf5ff9211e7a4f9bdeac66dea0f92|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	95.28657689378757 38759592643478780
115fd58f23b2c84f4d2063550003daed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	91.48296993987975 22192794096004988
0b1fa0d19ba6017d0800a8fa5591db02|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	90.02004418837674 17604779683141198
b914f4c00404d1fb92e3e412750131f2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	94.11623629258517 32896214470781936
231dacfa5fe33a82cb804ae1ee6ed6e5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	99.67535414829659 73015873350690930
ba21c283272d1a036f6026fd83b553a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	91.19038478957916 20918185559550624
8c6ad4edb8836b675d829f99a10a7b91|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	90.31262933867735 18387127472894436
022f0fed6b1dbc701576c282a455ee32|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	92.36072539078155 25287579365473476
dbf2c51b23f9a406cf7e67c759edc5ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	74.51303122244488 1241453286097411.5
1360ea568681be9abb8544e5a8c7c695|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	93.53106599198397 29967181420049070
b700f626d6eb9a2e9cf0f6ab7b15239c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	98.21242839679358 59630871301958950
2d7679c6f45042d4964eacdd36a56465|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	94.70140659318636 35705453976729070
af573234368ce8f9705d5352bfffbd69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	60.468944008016024 66280713975223.63
8a2b286399f7abda3f66ce9bac5e06a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	99.09018384769539 67202336312922870
944cd808b40b3d8c0ebc8098b1690735|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	88.84970358717435 14560836559490078
9d71d04d5a04be7c6aea1d98ea38f6dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	89.72745903807615 16759169002207602
8c88831bc3b60292139fe8c7cd3a71f5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	92.06814024048096 23936741165654084
02e878d9ec5cacc7de31462278fb0912|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	106.98998290581162 198898717678915500
0592a725e305d797b71841fd4869ef3d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	76.5611272745491 1808913140555354
84c8cb35157ef0dd68eb889019e440bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	80.36473422845691 3571409269255345
90eb9484f93d92e3f595ce35b5ef5623|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	103.1863759519038 119059760148417600
37328d88b1edb930cd790f6f760dda4d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	89.14228873747494 15293140930179504
7e0bda49d7185bce128797e2a443fbb7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	77.4388827254509 2136323561314186.5
f952e0308f80d8a0745f5f0f9f30563d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	104.6493017034068 144423544338537700
396a9e30495afb4eca0bfaeb584ee760|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	95.87174719438877 42415438240500950
44096fa94e1faaff1e231f8d21d7579b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	99.96793929859719 76591835061183280
a8be43635598ee3aa7506b2f42112136|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	101.13827989979958 89428650594605970
9044664446ef00d212012610eac5d455|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	107.57515320641282 213346538130089000
71103e9d861169922a1c25d66f0c1120|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	110.79358985971943 322983082344390300
b55498e855bdd193af0ffc483f65d717|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	100.5531095991984 82764529980603980
3dfb2b34fe0a56f7060c03f5094a4928|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	101.4308650501002 93031999478604430
dd9ebf10074843b4b23d43a05f576323|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	96.16433234468937 44387273122944840
a3ccb0e2623db42327f5ee5214f95227|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	94.40882144288577 34352525788491590
72711d9db97b0f514182fbd5a7d1be3a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	116.35270771543085 642390052963289200
61be2cb00ddc4c47d514c4789b145c3a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	97.33467294589178 52416656823872210
983ab266e5aa991f727fdd15efca67ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	108.16032350701403 230272078313254270
1eb5904974c0dd37726867304d4e6802|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	116.06012256513026 616582763556738700
60d8af59650657c813402ab6cec33534|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	106.69739775551102 188984560884559940
bf6efdd95c5726e1d290ab5e0a580253|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	111.08617501002003 333053465645182000
81287e550a46781a7f1b86b7549d1a04|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	97.62725809619238 54987027285340280
89645fdcde7a297732175cf82a39755c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	111.67134531062123 361732137893482800
a9ed1a9ab3a46c13204bb87ce9e2d364|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	109.62324925851702 277129768604004500
c020ec836eb61b35d1f5a9e2fe5a89da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	108.45290865731462 239992589277163140
45784fb50715b3ed703056c3342bb4a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	109.33066410821642 268920901378570660
1aea044787447014869e59f141b07a73|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	99.38276899799598 70533540071726216
115ba6c5c9003b0d3c6ab0836ce4aa9a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	102.0160353507014 101471982639948600
2d7984f1ee875a8220bbc875dfd87308|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	102.60120565130259 109059928658382960
404225b7e4bb93e7dfc8d5175da13063|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	92.65331054108216 26320905016403028
3c372013706138a36728326ef3713331|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	109.91583440881763 288792100528111600
54110f1cee84b519271f2cadba6e217d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	103.47896110220441 123839721192116130
e076f3442e9bb441fbeb80f6dbb6bc4c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	105.52705715430861 163486934212282750
6e10de0df7df3803b0fd42c6b2e838dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	100.84569474949899 86667279874849040
53ed908639dbba6d9606fd2eff47dd2a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	106.40481260521041 183009918938185250
2641b88066bdbe0baa42ff7a15b3fafa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	103.771546252505 129087240749951100
bb92bb393cbd1d836dfb63d823c3b6bb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	105.8196423046092 168722024134839600
9d9491b1a87142b7a5a7813afc643fd3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	104.35671655310621 139001940049636700
f42e8e15138323784626facf9a0d2a69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	98.50501354709418 61680538257416620
2e8f483f1a72525ff95ba0b94c9fbb34|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	116.64529286573145 661652894569595500
6cf1c034f5f232fa1157bb898064bd29|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	102.308620501002 105503730335037490
f78846b856f5446418e19ef895839602|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	113.13427106212424 430652176292652900
6e71dad860844354fa568b539f486067|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	106.11222745490981 176407926244598660
9e6a87f6dd5127e81884f790f7b60f05|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	104.0641314028056 134373986066059820
67f52ee7071b658fc766258ab0a6af9c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	120.74148496993988 1074989756230449300
4195ccae3cf45e8acdce9ed15f879598|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	101.72345020040079 97536155253779090
8cb6062c4ddf624ada54064e083c7088|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	115.18236711422844 557717178452548350
b3165e42a14e31a390240d24cccd1752|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	118.69338891783566 845114019020201000
5e6d9c07d67d141773fe2051a8d28740|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	121.03407012024047 1112180723367799900
c19ef55f87ef5a7ad30d4b2c8719cc9c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	104.9418868537074 150150298026008060
016a5f53864c41bd6214eb7521a451c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	120.44889981963927 1035815517779659400
c67bbbb253970cb3296395d1843074de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	112.25651561122244 389911765382101600
66528766fc55f7009aa05f4149c5b5fa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	115.76753741482965 594281238338731900
5b0a7731499d1f808bfcf64c309104a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	114.01202651302604 480724787476482400
6b880527186cd9979b035d09405baa81|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	110.50100470941882 311210194199813760
00c546e72bd8131a618c991cfa3c4bbf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	105.23447200400801 157026300644059740
ffbb19b1c0ad5566c4dd23ed9d69dcd3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	95.57916204408816 40576273445698024
631b5706a6fb284c85991b7924b6cc36|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	117.52304831663326 735011542260105100
94f646dd761573cdf587557443f10541|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	111.37876016032064 348237754043487040
a615654879406ee891fabf5e4972a8b3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	108.74549380761522 248904170938002980
2d913f929c96774750e424b542b6fed5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	118.40080376753507 818060288824708600
d407878fdd3fa7f9d3f00889dae11fd8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	113.71944136272545 465743487090771100
90075e1b2fc2ac71b2ab4e3765dbffb6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	120.15631466933867 1004355299745682000
389922f5231c8ee8f0b921b93471a771|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	126.59318797595189 2081151788133769700
46225ffeb7798cf4b7c66ecd39f3c1a4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	112.84168591182365 415936523756749500
e7ab01a10022127fb57a3d95200f7909|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	107.28256805611221 205238801732676300
793aeede12ddce16403a453f65f0b9f6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	112.54910076152304 399869003194834940
4f6025b822520dfb620642dfd2952b1c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	114.88978196392785 536098548601787650
55fdc4c497f715cd6cb68bdcfe0b67d4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	117.23046316633265 711723286917650300
ef7c5a9c5bfd4147ee182a67b9246154|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	124.25250677354708 1605065130990305800
4e3038eca730958e541e168636792d4e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	111.96393046092183 371750518998068200
2639a6fc35306e456d34c28a2e8f3dc1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	119.27855921843687 909910219289823600
ff5fb9df89c6317ca9a059b44613e39d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	113.42685621242484 447045674624809540
737b1066233fbf6e75aec629d2f34644|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	127.1783582765531 2223414860583389400
99fa4e85bb15db32406aa18a7c25889d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	123.37475132264528 1453032844046822400
500492b138c76575708463afd36c7b0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	114.30461166332664 497221511862783940
b6f24b20697402cac732836918b5bfb3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	121.91182557114227 1229866280394003000
fe8a2bcebfe9221335c6811ed6dce840|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	131.2745503807615 3478904217767196700
2f1edd5321cdc8babe4bead95133278b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	119.86372951903806 962196641783746200
46b3e8bf036a12ca7ad2c6a5f5cf37f3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	130.6893800801603 3265650336569890000
2839718cbb7238207f6f62eb00b81b2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	128.05611372745489 2448281624626638000
0590c2b9d5599d2863dc5f6e19d40f39|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	118.98597406813626 872898443469376300
f7c15669d3742bab4e7bced81856d982|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	102.8937908016032 114610045838069170
ce3c1cb0cee9f7e0fa5b4031d8a39540|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	114.59719681362725 517080213205121800
23ebbf6295b83dd67c545f4f69e0fbbe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	117.81563346693386 763171746069841900
6b32212da3d9576278dc1b0e806cb5c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	119.57114436873746 937522200452542500
1ffe6084992407f2bcdbd5e5c70f8275|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	118.10821861723446 793429206160558300
a7779d73bbf9dc94cebadd3ec0b2f47c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	127.7635285771543 2368438621365338000
0f648eefc27646ea429939e3818666cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	130.9819652304609 3355678682422291500
f18159b5142ea6ae6a184b9324672832|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	122.78958102204408 1364355278304517600
87d724bbe2711aee5291a5cf37dc656f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	134.78557218436873 5031293302796975000
d9c1d987d1d15225f95b7e283f732a5d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	124.54509192384768 1657249285602888200
1e693cdae4fe0d781d47a31ef06be68a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	125.4228473747495 1830645966063493600
82d7996c2e14ae0635c66a745dfbe9d8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	115.47495226452905 578834466147311400
d6bd093e5ddf57347423a843e777e74c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	110.20841955911823 300449503284516740
1f7835a38f0bb4e7fc0e810902515b4a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	134.2004018837675 4705301922466898000
16a46df9868fd80ecc1be65775664cec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	126.3006028256513 2025473101726091500
78b2008119fb0c1e8d33d8e00be9f0e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	135.66332763527052 5490287420836621000
a328e355e2ec7112366435059008f8d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	130.3967949298597 3160988674828880000
759e8f8d674618046b77cce440b6d6c5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	128.9338691783567 2695630067233205000
4b7bddf8d78b4b1eaa3ac4f0edbe10e1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	121.32665527054107 1155087561734209800
586f017df240358972c07671e2b9b58d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	131.85972068136272 3713871021387341000
615937fc0feeb2699cf7a37e7d00265e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	125.71543252505009 1904351471321053700
48448890912131c769b9343e131d8a6a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	124.83767707414829 1715362860786588700
333b073ec852394a34b55a408972567f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	121.61924042084168 1187393473741392000
7aa740f7c24e5463d9bb9a654a32ecf6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	123.95992162324649 1553129569941729300
1b98c60dae86d1a2a3209faee647bedd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	129.8116246292585 2987469179843069000
dc9dd55ef9c3ded6faf469ff256e99d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	109.03807895791583 258091964648684740
d2f0f61856253daa31a4632251eb751c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	97.91984324649297 56760821122172650
760919d8195f35f47b1fa9d9d1b062ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	135.95591278557114 5696237656270722000
1b81e94824effee4da8846ab552208f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	123.66733647294588 1502744755827498000
c14ca960bf86406de848886ad51226ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	126.00801767535069 1946575395208818700
10913e5a9c7ac4f0905cee34bebae87e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	123.08216617234469 1408009063295999700
5407ba104d934c7ed4c9513bb982d536|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	126.8857731262525 2140357186418473200
19ea82117efd6c2069e5b1ecd508ff53|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	136.83366823647293 6203972123428648000
d3b566baf5b9f79934ea196bdad29feb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	122.20441072144288 1261293447752103400
a545d8cf066e57a555af847ece2c87f2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	125.13026222444888 1779605731690512100
e8b1b31c36a235db9b47a7b81e48af18|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	136.54108308617234 6032959344654762000
8b5a80b5777d40548392f1da21b70635|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	135.37074248496992 5380790450199709000
23f1603d9cba7ce1384dcb2e4c219b33|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	133.03006128256513 4182792534421582300
fb1914606c5ce11bcda8ac87742409c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	107.86773835671342 221501496062877060
12f9a1ef6f95a6c92385af9c27994861|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	128.6412840280561 2605834123157798400
3c3da693d158b24fc213fea4cbc6da7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	137.41883853707415 6580183264627627000
293953421481194a8e43457874d49d26|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	138.00400883767534 6956392439133681000
5a3fd74d535cd2016b5350162e47aede|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	128.34869887775548 2535861167255635500
209e67847921380c8f0807365d591a5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	122.49699587174348 1319879555514932200
04050331f966faf1c55306612d26fce6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	133.61523158316632 4416469642818395000
99417428122afef494d43254a2061943|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	140.34469004008014 8778981745176210000
d041aa667cb3e8b82177976c611b7f68|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	133.32264643286572 4317802992565478000
f63cee29181c78d52a73479c84ed02a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	131.56713553106212 3572505746669042000
318d45282660caf4c8767a85404769fb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	129.5190394789579 2875143719079283000
acc5f1b888954766de8a71d475fb0182|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	132.7374761322645 4054280989695411000
004d9b74eac03ecfb2646ee226164d97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	127.4709434268537 2295876905677931800
431559d7befd9ea7f47e60f1959871c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	138.29659398797594 7203445639535652000
faa244aa1088c74702e3a2c283837d96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	137.71142368737475 6731838752436094000
73d6a064bc1e9b574e344b924d893f8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	116.93787801603206 687189606598013700
7429c72762b1e06acf9aa26c8f8afab5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	132.1523058316633 3789887557038218000
540aa6b6722a80ed04733df9f4709d49|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	138.88176428857713 7601882364174112000
9c15c67f1590450ab69518a907c64626|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	140.05210488977954 8614501438678467000
206b81e2d616e391f2ae61ed3b462112|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	139.75951973947895 8332664991630578000
9e7ea30596b7a88b7116354cf0ff7e25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	139.46693458917835 8054003427128222000
b62c8fbb28352b75aefac1efc48d82e0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	140.63727519038076 9087534842509988000
bfce7a98e3265c10c435db3f6aca0ebc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	133.90781673346692 4592041532664397000
faccdb9d905f827fd183e793344cecf2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	138.58917913827653 7403540384735881000
f90dc559635d024c708d92685f71f72a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	139.17434943887775 7884359609753942000
a44c73693d4673bc6bc48758f40d2d62|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	136.24849793587174 5868158023127620000
ed94e2e3678a05f42d649fd7f72ca2ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	141.22244549098195 9628259817178495000
fcf8de8887f465808b7fd2d20f43a35e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	141.51503064128255 9984296972794458000
167ad6e4895ff625066e91ba5c6abba6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	140.92986034068136 9427499497064733000
04ed3eefaf8327956614376e1625439c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	137.12625338677353 6390682592808423000
accdc5b5cd086d0c979a504749791c69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	132.4448909819639 3939094448080248300
f5745dfdd193377805bb84ad8c656642|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	135.07815733466933 5190150459728158000
c6aed84812ee5ae9c0ba52a55ba066d7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	142.68537124248496 11137696852029571000
2a21224163c23fa4202de74c144e1dad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	134.49298703406814 4859074154745320000
485d20060838e72cd4e4723de38f758c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	144.14829699398797 12918013450331867000
01b908632300a86e8ce5fad4e3321747|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	142.10020094188374 10526889179202243000
fe06cb5f8fad8385af77f8865ea1dd79|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	142.39278609218437 10859418550785004000
106d945bf149ae275c754402eccd8b29|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	141.80761579158315 10258159957000055000
c5c3402498a04477494c0b9600fb51a7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	145.31863759519038 14391746395586950000
9b7cfe95deed5d26346d533139d58645|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	143.56312669338675 12049675198603348000
e2abaa54e4348db1a11df46214da42c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	130.1042097795591 3072607944152170000
82beb04fc93e47cd9aad48451c99f67a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	144.73346729458916 13576336666511020000
5452972379df41b5e84ff0237f1c9957|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	129.2264543286573 2784353673737427000
6e183f900e5549b67432747047104e63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	144.44088214428857 13127619102072721000
2bdb0e9ce8dffc39998f0fdc11753120|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	146.48897819639276 16140938072824082000
f56aa4a576c802f3ead73074da1b32bc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	148.537074248497 19573866490664014000
77ef836a24482b86adcf2275b6dc4dc5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	147.65931879759518 18070003476547504000
baddedd4d5a3cff3af3f8ab79689b705|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	142.97795639278556 11521370336740125000
e33858bb2dfdb9f25ab5f60c03b03adc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	145.02605244488976 14054615800274782000
fe3c04c4ff4cd792a03aa6f9a826ec62|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	145.90380789579157 15385929527470942000
a0737e7b34feba0cd4145e460b3c1df0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	143.85571184368737 12485278445898467000
a5e226c7992d2e10adb09349040448f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	146.7815633466934 16527594139229528000
339e0ab05eb2209bd9112649b897db64|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	145.61122274549098 14784873144374327000
d15ba541941146cf25a60876e699a8be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	147.95190394789577 18572206834027110000
9477e804e8f67f5f37450c1aae032e14|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	146.19639304609217 15613853537215805000
c397839ca8c47906a923e8da6873c52d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	149.12224454909818 20604886170935484000
5167b27ff8d00f5bbf9fb6dc8334860e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	149.70741484969938 21896387938238226000
c85cdbca9e4868a94de5d5bcbe237b9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	148.8296593987976 19969921943230820000
93e05de318e14aeaad13503606a6ee21|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	148.24448909819637 19001006041633920000
08f762686fe212afd2c7c15e32be1e46|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	147.07414849699398 17051673553086267000
079a81b845de15e2418c087fe469dbb2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	143.27054154308615 11790503524637850000
584da6648c168304a8873ec0cf2ceade|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	150.0 22447765817135854000
f2cd6012db28684cd8a21fe3c6b7ac47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	147.36673364729458 17528751389231540000
99be3be2eff716314bc134e459c9c5f8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data.dat|501|1|V|csv
	149.41482969939878 21271140879753396000
b5dde83b975e1eca9727ab0360eeda36|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|10|1|V|rust
	    let mut file_zs = std::fs::File::create("data/scaled_cs_data.dat")?;
3e01057a08bba2b738b6f1b07c7c423d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|14|5|V|rust
	    file.write("# cme/meta cross-section error\n".as_bytes())?;
7654cf157c49b5496882d83e04d6f3dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|13|1|V|rust
	    // Header
7cb02dbd950cf3a2b7366811b7ae097d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|17|1|V|rust
	        file.write(format!("{} {}\n", z, cs).to_string().as_bytes())?;
4d2ea4c2dbf9a28d51e0c2d156d95a1d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|17|40|v|rust
	, zs
d08aceea1395d0ccc0909a37129a2e0c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|6|1|V|python
	    data_zs = np.genfromtxt("data/scaled_cs_data.dat")
a514d910dec6462868f26ccaf1d2627a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|45|v|python
	[-100:]
b54e56f3b6c34dcccb5be58624324c24|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|1|V|python
	    last_100_zs, last_100_cs = np.log10(data_xs[-100:]).T
415b5c1d8694e653f1157f02ef5d0fe7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|32|v|python
	np.log10(data_xs[-100:]).T
758b4121ae46b538ebafd21e03b00027|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|18|v|python
	last_100_cs 
5c1c014f82daa7a4145ffe5f4f22efde|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|5|V|python
	    last_100_zs= np.log10(data_zs[-100:]).T, np.log10(data_cs[-100:]).T
bd0b56f4c1db7a1b4d51676fa95b4d6e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|8|44|v|python
	np.log10(data_cs[-100:]).T
63e68618c75f34374af2acec61be9403|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/scaled_cs_data_zs.dat|1|1|V|csv
	4.00001
	4.292595150300601
	4.585180300601202
	4.877765450901803
	5.170350601202404
	5.4629357515030055
	5.755520901803607
	6.048106052104208
	6.340691202404809
	6.63327635270541
	6.925861503006011
	7.2184466533066125
	7.511031803607214
	7.803616953907815
	8.096202104208416
	8.388787254509017
	8.681372404809618
	8.97395755511022
	9.26654270541082
	9.559127855711422
	9.851713006012023
	10.144298156312624
	10.436883306613225
	10.729468456913827
	11.022053607214428
	11.314638757515029
	11.60722390781563
	11.899809058116231
	12.192394208416832
	12.484979358717434
	12.777564509018035
	13.070149659318636
	13.362734809619237
	13.655319959919838
	13.94790511022044
	14.24049026052104
	14.533075410821642
	14.825660561122243
	15.118245711422844
	15.410830861723445
	15.703416012024046
	15.996001162324648
	16.28858631262525
	16.58117146292585
	16.87375661322645
	17.16634176352705
	17.458926913827653
	17.751512064128256
	18.044097214428856
	18.336682364729455
	18.629267515030058
	18.92185266533066
	19.21443781563126
	19.50702296593186
	19.799608116232463
	20.092193266533062
	20.384778416833665
	20.677363567134268
	20.969948717434868
	21.262533867735467
	21.55511901803607
	21.847704168336673
	22.140289318637272
	22.43287446893787
	22.725459619238475
	23.018044769539078
	23.310629919839677
	23.603215070140276
	23.89580022044088
	24.188385370741482
	24.48097052104208
	24.77355567134268
	25.066140821643284
	25.358725971943887
	25.651311122244486
	25.943896272545086
	26.23648142284569
	26.52906657314629
	26.82165172344689
	27.11423687374749
	27.406822024048093
	27.699407174348696
	27.991992324649296
	28.284577474949895
	28.577162625250498
	28.8697477755511
	29.1623329258517
	29.4549180761523
	29.747503226452903
	30.040088376753506
	30.332673527054105
	30.625258677354704
	30.917843827655307
	31.21042897795591
	31.50301412825651
	31.79559927855711
	32.088184428857716
	32.38076957915831
	32.673354729458914
	32.96593987975952
	33.25852503006011
	33.55111018036072
	33.84369533066132
	34.136280480961915
	34.428865631262525
	34.72145078156312
	35.014035931863724
	35.30662108216433
	35.59920623246492
	35.89179138276553
	36.18437653306613
	36.476961683366724
	36.769546833667334
	37.06213198396793
	37.35471713426854
	37.647302284569136
	37.93988743486973
	38.23247258517034
	38.52505773547094
	38.817642885771534
	39.110228036072144
	39.40281318637274
	39.69539833667335
	39.987983486973945
	40.28056863727454
	40.57315378757515
	40.86573893787575
	41.15832408817634
	41.45090923847695
	41.74349438877755
	42.03607953907816
	42.328664689378755
	42.62124983967935
	42.91383498997996
	43.20642014028056
	43.49900529058115
	43.79159044088176
	44.08417559118236
	44.37676074148297
	44.669345891783564
	44.96193104208416
	45.25451619238477
	45.547101342685366
	45.83968649298596
	46.13227164328657
	46.42485679358717
	46.71744194388778
	47.010027094188374
	47.30261224448897
	47.59519739478958
	47.887782545090175
	48.18036769539077
	48.47295284569138
	48.76553799599198
	49.05812314629259
	49.35070829659318
	49.64329344689378
	49.93587859719439
	50.228463747494985
	50.52104889779558
	50.81363404809619
	51.106219198396786
	51.3988043486974
	51.69138949899799
	51.98397464929859
	52.2765597995992
	52.569144949899794
	52.86173010020039
	53.154315250501
	53.446900400801596
	53.739485551102206
	54.0320707014028
	54.3246558517034
	54.61724100200401
	54.9098261523046
	55.2024113026052
	55.49499645290581
	55.787581603206405
	56.080166753507015
	56.37275190380761
	56.66533705410821
	56.95792220440882
	57.25050735470941
	57.54309250501001
	57.83567765531062
	58.128262805611215
	58.420847955911825
	58.71343310621242
	59.006018256513016
	59.298603406813626
	59.59118855711422
	59.88377370741482
	60.17635885771543
	60.468944008016024
	60.761529158316634
	61.05411430861723
	61.346699458917826
	61.639284609218436
	61.93186975951903
	62.22445490981963
	62.51704006012024
	62.80962521042083
	63.10221036072144
	63.39479551102204
	63.687380661322635
	63.979965811623245
	64.27255096192384
	64.56513611222444
	64.85772126252505
	65.15030641282564
	65.44289156312625
	65.73547671342685
	66.02806186372744
	66.32064701402805
	66.61323216432865
	66.90581731462925
	67.19840246492986
	67.49098761523045
	67.78357276553106
	68.07615791583166
	68.36874306613225
	68.66132821643286
	68.95391336673346
	69.24649851703407
	69.53908366733467
	69.83166881763526
	70.12425396793587
	70.41683911823647
	70.70942426853708
	71.00200941883767
	71.29459456913827
	71.58717971943888
	71.87976486973947
	72.17235002004007
	72.46493517034068
	72.75752032064128
	73.05010547094187
	73.34269062124248
	73.63527577154308
	73.92786092184369
	74.22044607214428
	74.51303122244488
	74.80561637274549
	75.09820152304609
	75.3907866733467
	75.68337182364729
	75.97595697394789
	76.2685421242485
	76.5611272745491
	76.85371242484969
	77.1462975751503
	77.4388827254509
	77.73146787575149
	78.0240530260521
	78.3166381763527
	78.60922332665331
	78.9018084769539
	79.1943936272545
	79.48697877755511
	79.7795639278557
	80.07214907815631
	80.36473422845691
	80.6573193787575
	80.94990452905812
	81.24248967935871
	81.53507482965931
	81.82765997995992
	82.12024513026051
	82.41283028056111
	82.70541543086172
	82.99800058116232
	83.29058573146293
	83.58317088176352
	83.87575603206412
	84.16834118236473
	84.46092633266532
	84.75351148296593
	85.04609663326653
	85.33868178356713
	85.63126693386774
	85.92385208416833
	86.21643723446893
	86.50902238476954
	86.80160753507013
	87.09419268537073
	87.38677783567134
	87.67936298597193
	87.97194813627254
	88.26453328657314
	88.55711843687374
	88.84970358717435
	89.14228873747494
	89.43487388777555
	89.72745903807615
	90.02004418837674
	90.31262933867735
	90.60521448897795
	90.89779963927855
	91.19038478957916
	91.48296993987975
	91.77555509018035
	92.06814024048096
	92.36072539078155
	92.65331054108216
	92.94589569138276
	93.23848084168336
	93.53106599198397
	93.82365114228456
	94.11623629258517
	94.40882144288577
	94.70140659318636
	94.99399174348697
	95.28657689378757
	95.57916204408816
	95.87174719438877
	96.16433234468937
	96.45691749498997
	96.74950264529058
	97.04208779559117
	97.33467294589178
	97.62725809619238
	97.91984324649297
	98.21242839679358
	98.50501354709418
	98.79759869739479
	99.09018384769539
	99.38276899799598
	99.67535414829659
	99.96793929859719
	100.26052444889778
	100.5531095991984
	100.84569474949899
	101.13827989979958
	101.4308650501002
	101.72345020040079
	102.0160353507014
	102.308620501002
	102.60120565130259
	102.8937908016032
	103.1863759519038
	103.47896110220441
	103.771546252505
	104.0641314028056
	104.35671655310621
	104.6493017034068
	104.9418868537074
	105.23447200400801
	105.52705715430861
	105.8196423046092
	106.11222745490981
	106.40481260521041
	106.69739775551102
	106.98998290581162
	107.28256805611221
	107.57515320641282
	107.86773835671342
	108.16032350701403
	108.45290865731462
	108.74549380761522
	109.03807895791583
	109.33066410821642
	109.62324925851702
	109.91583440881763
	110.20841955911823
	110.50100470941882
	110.79358985971943
	111.08617501002003
	111.37876016032064
	111.67134531062123
	111.96393046092183
	112.25651561122244
	112.54910076152304
	112.84168591182365
	113.13427106212424
	113.42685621242484
	113.71944136272545
	114.01202651302604
	114.30461166332664
	114.59719681362725
	114.88978196392785
	115.18236711422844
	115.47495226452905
	115.76753741482965
	116.06012256513026
	116.35270771543085
	116.64529286573145
	116.93787801603206
	117.23046316633265
	117.52304831663326
	117.81563346693386
	118.10821861723446
	118.40080376753507
	118.69338891783566
	118.98597406813626
	119.27855921843687
	119.57114436873746
	119.86372951903806
	120.15631466933867
	120.44889981963927
	120.74148496993988
	121.03407012024047
	121.32665527054107
	121.61924042084168
	121.91182557114227
	122.20441072144288
	122.49699587174348
	122.78958102204408
	123.08216617234469
	123.37475132264528
	123.66733647294588
	123.95992162324649
	124.25250677354708
	124.54509192384768
	124.83767707414829
	125.13026222444888
	125.4228473747495
	125.71543252505009
	126.00801767535069
	126.3006028256513
	126.59318797595189
	126.8857731262525
	127.1783582765531
	127.4709434268537
	127.7635285771543
	128.05611372745489
	128.34869887775548
	128.6412840280561
	128.9338691783567
	129.2264543286573
	129.5190394789579
	129.8116246292585
	130.1042097795591
	130.3967949298597
	130.6893800801603
	130.9819652304609
	131.2745503807615
	131.56713553106212
	131.85972068136272
	132.1523058316633
	132.4448909819639
	132.7374761322645
	133.03006128256513
	133.32264643286572
	133.61523158316632
	133.90781673346692
	134.2004018837675
	134.49298703406814
	134.78557218436873
	135.07815733466933
	135.37074248496992
	135.66332763527052
	135.95591278557114
	136.24849793587174
	136.54108308617234
	136.83366823647293
	137.12625338677353
	137.41883853707415
	137.71142368737475
	138.00400883767534
	138.29659398797594
	138.58917913827653
	138.88176428857713
	139.17434943887775
	139.46693458917835
	139.75951973947895
	140.05210488977954
	140.34469004008014
	140.63727519038076
	140.92986034068136
	141.22244549098195
	141.51503064128255
	141.80761579158315
	142.10020094188374
	142.39278609218437
	142.68537124248496
	142.97795639278556
	143.27054154308615
	143.56312669338675
	143.85571184368737
	144.14829699398797
	144.44088214428857
	144.73346729458916
	145.02605244488976
	145.31863759519038
	145.61122274549098
	145.90380789579157
	146.19639304609217
	146.48897819639276
	146.7815633466934
	147.07414849699398
	147.36673364729458
	147.65931879759518
	147.95190394789577
	148.24448909819637
	148.537074248497
	148.8296593987976
	149.12224454909818
	149.41482969939878
	149.70741484969938
	150
b41f061c23f57c46fe142d28c326e5b3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|9|19|v|python
	np.log10(
f93cc960340088e7977600af14847f7d|term://.//81590%3A/bin/zsh|1093|1|V|floaterm
	Output { status: ExitStatus(ExitStatus(0)), stdout: "[ 14.00554949 -11.12625161]\n", stderr: "" }
763df70d51e6ed32e24e1896c8f327bc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|5|56|v|rust
	14.00554949
b618aedf04ec4384609cc3528a92f4b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|5|68|v|rust
	-11.12625161
3d03ec2235a73738d807ed992b4bccec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_zs.dat|1|1|V|csv
	0.60206107706281
	0.6327199305755308
	0.6613564178722604
	0.6882209132741219
	0.7135199935784539
	0.7374260928938989
	0.760084635444769
	0.7816193978105844
	0.802136603154288
	0.8217280910651342
	0.8404738026795635
	0.858443751243144
	0.8756996008967137
	0.8922959435919184
	0.9082813408552776
	0.9236991805254978
	0.9385883865499247
	0.9529840110823897
	0.9669177315527876
	0.9804182704423978
	0.9935117517540767
	1.006222005298933
	1.018570827706279
	1.0305782073389946
	1.042262518943199
	1.0536406927916515
	1.064728362229385
	1.0755399928486837
	1.0860889959716107
	1.0963878286735478
	1.1064480822189273
	1.1162805604836912
	1.1258953496949233
	1.135301880616334
	1.1445089841407161
	1.1535249411108
	1.162357527072945
	1.1710140525698107
	1.1795013994951913
	1.1878260539639993
	1.1959941360907187
	1.204011427018821
	1.2118833935001676
	1.2196152102861508
	1.227211780560269
	1.234677754614189
	1.2420175469454364
	1.2492353519341282
	1.256335158238147
	1.2633207620304558
	1.2701957791885445
	1.276963656533996
	1.2836276822096364
	1.2901909952724833
	1.2966565945725388
	1.3030273469803029
	1.3093059950195003
	1.3154951639558843
	1.3215973683879816
	1.3276150183811857
	1.3335504251826515
	1.3394058065509011
	1.3451832917309023
	1.3508849261025446
	1.35651267552791
	1.3620684304204602
	1.3675540095572154
	1.3729711636531634
	1.3783215787154721
	1.3836068791935898
	1.3888286309399551
	1.3939883439948224
	1.3990874752075888
	1.4041274307060134
	1.4091095682237942
	1.4140351992961473
	1.4189055913322652
	1.4237219695728516
	1.4284855189402936
	1.4331973857884637
	1.4378586795586108
	1.4424704743473302
	1.447033810392151
	1.4515496954798817
	1.4560191062824874
	1.4604429896249234
	1.4648222636890436
	1.4691578191574146
	1.4734505203005983
	1.4777012060112227
	1.4819106907879342
	1.4860797656721247
	1.4902091991401183
	1.4942997379533418
	1.4983521079688302
	1.502367014912265
	1.506345145115607
	1.5102871662212505
	1.514193727854507
	1.5180654622661118
	1.5219029849463421
	1.5257068952122415
	1.5294777767693466
	1.5332161982492403
	1.5369227137241623
	1.5405978631998447
	1.5442421730876728
	1.5478561566571951
	1.551440314469964
	1.554995134795619
	1.5585210940110783
	1.562018656983657
	1.5654882774388805
	1.5689303983137208
	1.5723454520959452
	1.5757338611502254
	1.579096038031625
	1.5824323857870426
	1.5857432982451656
	1.5890291602954558
	1.5922903481566586
	1.595527229635305
	1.598740164374653
	1.6019295040944883
	1.6050955928221813
	1.6082387671153853
	1.6113593562767319
	1.6144576825608694
	1.617534061374166
	1.620588801467392
	1.6236222051216704
	1.6266345683279801
	1.6296261809604762
	1.6325973269438803
	1.6355482844151852
	1.638479325879902
	1.6413907183630703
	1.6442827235552397
	1.6471555979536239
	1.6500095929986158
	1.6528449552058464
	1.6556619262939611
	1.6584607433082783
	1.6612416387404891
	1.6640048406445487
	1.6667505727489038
	1.6694790545651967
	1.672190501493573
	1.6748851249247239
	1.6775631323387827
	1.68022472740119
	1.6828701100556391
	1.685499476614208
	1.6881130198447794
	1.6907109290558469
	1.6932933901787965
	1.6958605858477611
	1.698412695477124
	1.7009498953367606
	1.7034723586250964
	1.7059802555400518
	1.7084737533479537
	1.7109530164504783
	1.7134182064496946
	1.715869482211272
	1.7183069999259137
	1.7207309131690767
	1.723141372959034
	1.725538527813333
	1.727922523803708
	1.7302935046094878
	1.7326516115695605
	1.7349969837329287
	1.7373297579079108
	1.7396500687100265
	1.7419580486086108
	1.7442538279721944
	1.7465375351126922
	1.7488092963284358
	1.7510692359460862
	1.7533174763614618
	1.755554138079315
	1.7577793397520884
	1.7599931982176868
	1.7621958285362873
	1.7643873440262219
	1.766567856298962
	1.768737475293224
	1.7708963093082322
	1.7730444650361556
	1.775182047593748
	1.7773091605532132
	1.7794259059723165
	1.7815323844237687
	1.7836286950238986
	1.7857149354606372
	1.7877912020208344
	1.789857589616924
	1.7919141918129573
	1.7939611008500265
	1.7959984076710864
	1.7980262019452014
	1.8000445720912261
	1.80205360530094
	1.804053387561648
	1.8060440036782643
	1.8080255372948912
	1.8099980709159098
	1.811961685926591
	1.8139164626132456
	1.8158624801829206
	1.8177998167826581
	1.8197285495183253
	1.8216487544730287
	1.8235605067251222
	1.8254638803658219
	1.827358948516436
	1.8292457833452205
	1.831124456083869
	1.83299503704365
	1.8348575956311959
	1.8367122003639555
	1.8385589188853189
	1.840397817979421
	1.842228963585633
	1.8440524208127507
	1.8458682539528848
	1.8476765264950632
	1.8494773011385508
	1.8512706398058938
	1.853056603655697
	1.8548352530951377
	1.8566066477922272
	1.8583708466878188
	1.8601279080073787
	1.8618778892725139
	1.863620847312273
	1.8653568382742194
	1.8670859176352839
	1.8688081402124028
	1.8705235601729453
	1.8722322310449366
	1.87393420572708
	1.8756295364985827
	1.877318275028793
	1.8790004723866476
	1.8806761790499393
	1.8823454449144061
	1.884008319302644
	1.8856648509728529
	1.887315088127415
	1.8889590784213108
	1.8905968689703758
	1.892228506359404
	1.8938540366500969
	1.8954735053888678
	1.8970869576144977
	1.8986944378656516
	1.9002959901882563
	1.9018916581427407
	1.9034814848111463
	1.9050655128041052
	1.906643784267694
	1.9082163408901622
	1.9097832239085384
	1.9113444741151195
	1.912900131863843
	1.914450237076545
	1.9159948292491078
	1.9175339474574977
	1.9190676303636975
	1.920595916221533
	1.9221188428823976
	1.9236364478008792
	1.9251487680402857
	1.926655840278077
	1.9281577008112014
	1.9296543855613426
	1.9311459300800737
	1.9326323695539245
	1.9341137388093619
	1.9355900723176869
	1.9370614041998464
	1.938527768231166
	1.939989197846001
	1.9414457261423124
	1.9428973858861625
	1.944344209516139
	1.9457862291477046
	1.947223476577473
	1.9486559832874173
	1.950083780449007
	1.9515068989272775
	1.9529253692848345
	1.9543392217857913
	1.9557484863996442
	1.9571531928050834
	1.9585533703937432
	1.9599490482738933
	1.961340255274068
	1.9627270199466398
	1.9641093705713366
	1.9654873351587
	1.9668609414534928
	1.9682302169380486
	1.969595188835574
	1.9709558841133936
	1.9723123294861478
	1.9736645514189401
	1.975012576130435
	1.9763564295959075
	1.9776961375502484
	1.9790317254909187
	1.9803632186808637
	1.9816906421513787
	1.983014020704933
	1.9843333789179503
	1.9856487411435482
	1.9869601315142338
	1.9882675739445619
	1.9895710921337504
	1.9908707095682587
	1.9921664495243268
	1.9934583350704755
	1.9947463890699726
	1.996030634183259
	1.9973110928703417
	1.9985877873931504
	1.9998607398178594
	2.001129972017177
	2.0023955056725997
	2.003657362276634
	2.004915563134989
	2.006170129368731
	2.0074210819164144
	2.008668441536177
	2.0099122288078064
	2.0111524641347778
	2.0123891677462633
	2.013622359699109
	2.0148520598797903
	2.0160782880063324
	2.0173010636302107
	2.0185204061382187
	2.019736334754314
	2.020948868541436
	2.022158026403299
	2.023363827086161
	2.0245662891805685
	2.0257654311230735
	2.026961271197932
	2.0281538275387763
	2.0293431181302637
	2.0305291608097065
	2.0317119732686746
	2.032891573054579
	2.0340679775722363
	2.0352412040854073
	2.036411269718317
	2.0375781914571567
	2.0387419861515594
	2.039902670516065
	2.0410602611315554
	2.04221477444668
	2.0433662267792547
	2.0445146343176486
	2.0456600131221467
	2.0468023791263015
	2.0479417481382574
	2.0490781358420693
	2.0502115577989932
	2.0513420294487683
	2.0524695661108754
	2.0535941829857864
	2.054715895156191
	2.055834717588211
	2.0569506651325997
	2.0580637525259236
	2.0591739943917293
	2.0602814052416982
	2.061385999476783
	2.0624877913883317
	2.063586795159198
	2.0646830248648347
	2.0657764944743775
	2.066867217851712
	2.0679552087565294
	2.069040480845365
	2.0701230476726318
	2.07120292269163
	2.072280119255557
	2.073354650618492
	2.0744265299363778
	2.0754957702679877
	2.0765623845758774
	2.07762638572733
	2.078687786495288
	2.0797465995592708
	2.080802837506285
	2.081856512831723
	2.0829076379402487
	2.0839562251466734
	2.0850022866768234
	2.086045834668394
	2.0870868811717926
	2.088125438150979
	2.089161517484284
	2.0901951309652302
	2.0912262903033323
	2.0922550071248973
	2.0932812929738094
	2.0943051593123063
	2.0953266175217484
	2.0963456789033783
	2.0973623546790705
	2.098376655992072
	2.099388593907736
	2.1003981794142477
	2.1014054234233366
	2.1024103367709874
	2.103412930218138
	2.104413214451371
	2.105411200083598
	2.106406897654733
	2.1074003176323632
	2.108391470412408
	2.1093803663197703
	2.1103670156089844
	2.1113514284648525
	2.1123336150030756
	2.113313585270878
	2.114291349247623
	2.1152669168454223
	2.1162402979097417
	2.1172115022199933
	2.1181805394901274
	2.1191474193692166
	2.1201121514420285
	2.121074745229599
	2.1220352101897952
	2.122993555717873
	2.1239497911470284
	2.1249039257489426
	2.1258559687343217
	2.1268059292534303
	2.127753816396619
	2.128699639194847
	2.129643406620197
	2.1305851275863867
	2.1315248109492746
	2.132462465507358
	2.133398100002269
	2.1343317231192622
	2.1352633434876997
	2.136192969681528
	2.1371206102197533
	2.1380462735669092
	2.138969968133518
	2.1398917022765542
	2.140811484299893
	2.1417293224547618
	2.1426452249401837
	2.1435591999034176
	2.1444712554403917
	2.1453813995961357
	2.1462896403652048
	2.1471959856921017
	2.148100443471694
	2.1490030215496256
	2.1499037277227266
	2.150802569739417
	2.1516995553001057
	2.1525946920575865
	2.1534879876174315
	2.154379449538377
	2.1552690853327072
	2.1561569024666363
	2.157042908360682
	2.157927110390038
	2.158809515884944
	2.159690132131048
	2.16056896636977
	2.1614460257986567
	2.162321317571736
	2.1631948487998676
	2.16406662655109
	2.164936657850962
	2.165804949682905
	2.166671508988535
	2.167536342668001
	2.1683994575803114
	2.1692608605436594
	2.17012055833575
	2.1709785576941156
	2.171834865316437
	2.1726894878608536
	2.173542431946276
	2.174393704152693
	2.175243311021476
	2.1760912590556813
3b41229105b45c321c85fcf4f7708118|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs.dat|1|1|V|csv
	-21.619042133142987
	-5.647842152323036
	-4.287842799069538
	-3.389947015338773
	-2.6940656418363544
	-2.113926238326188
	-1.6101545595274425
	-1.163917017584774
	-0.7607455217535478
	-0.3901602529946759
	-0.04525977411384999
	0.2736594431293401
	0.5720970295883483
	0.8552815686796373
	1.1250641470307563
	1.3758170629580104
	1.6184877375562576
	1.8528319099852038
	2.0730880755568486
	2.28501733331067
	2.4892816939092515
	2.6882224675720967
	2.875551602562933
	3.063069038433103
	3.2378213123069868
	3.4117473253278905
	3.5806399441346337
	3.744056285480351
	3.899997590514754
	4.055731058649874
	4.205332527344611
	4.348421557560286
	4.490723123272289
	4.631088150011728
	4.765329291256688
	4.899534241029584
	5.028369935180692
	5.156302810036343
	5.276657202609002
	5.400529762888221
	5.519513165720456
	5.637365144746729
	5.751252196703181
	5.86178483006879
	5.971997370507331
	6.082371047633442
	6.184136720386346
	6.291601562311976
	6.392171915480385
	6.494077007707947
	6.590447397520335
	6.688879486235148
	6.783611807794806
	6.881219722742247
	6.970764024293478
	7.063109329375332
	7.151715575889736
	7.2423451223547195
	7.33294499660074
	7.41277625653122
	7.498731049511012
	7.58383530627784
	7.667123199329628
	7.745572088419421
	7.827213064064709
	7.908002017423055
	7.985007952385814
	8.062703385252624
	8.137053226101516
	8.21430278178605
	8.287956919401731
	8.362362099750557
	8.431196777772488
	8.50401177582172
	8.576039149575967
	8.64305990923378
	8.714408333168556
	8.779250070626961
	8.847046639906255
	8.91655739842653
	8.984006298497963
	9.046010291195905
	9.112323226268838
	9.176224697595938
	9.240393672653358
	9.303018105271411
	9.362186148107172
	9.423426837684561
	9.485054008845571
	9.545982089243582
	9.60561631695688
	9.662570323379407
	9.722658428989599
	9.780723593876953
	9.839194751353482
	9.895805867857874
	9.953157371920817
	10.00771583499176
	10.060672625894995
	10.11781919239762
	10.171286994675771
	10.223024687679448
	10.277783854739017
	10.331113557144151
	10.384490863173912
	10.43435837213512
	10.487783269918456
	10.535806649596239
	10.587057598739017
	10.633102969216393
	10.686176950610491
	10.734349513797127
	10.785652986571375
	10.833484357130027
	10.882142718546893
	10.928935005100344
	10.975047693104896
	11.022035811164875
	11.070096611279972
	11.117415335498007
	11.158695986190933
	11.209194333206828
	11.255161167371819
	11.298734563677908
	11.342613116263454
	11.385467621370198
	11.43002723969353
	11.474293349016442
	11.51508132752264
	11.559476147160112
	11.60352760673877
	11.644328679741951
	11.688572237963692
	11.728003096189877
	11.772202042064666
	11.812514232911303
	11.853239362234435
	11.89347637624845
	11.933924379726317
	11.974895974027417
	12.014987088609775
	12.056307077762826
	12.09012119367191
	12.130353403904188
	12.170942682617317
	12.20838709309809
	12.249093221812952
	12.284967484186481
	12.32138976907234
	12.361762392057365
	12.396019309468254
	12.434408012844273
	12.472159645540152
	12.51038702494909
	12.546951143595296
	12.5839169201078
	12.618424111361152
	12.65642608508181
	12.690770820239809
	12.722132955372196
	12.761758384468795
	12.795400267924878
	12.828524032350131
	12.866921000601991
	12.899620593213657
	12.933589904501869
	12.96820502603547
	13.00243337405693
	13.034152975893644
	13.069573039823933
	13.104608310996175
	13.135234607998399
	13.168205979332148
	13.199711984052108
	13.234134511076128
	13.26719751179659
	13.29936592094582
	13.331256112108578
	13.36083282985931
	13.39549046750228
	13.425791962229367
	13.460435961294737
	13.483828121410484
	13.516459636515426
	13.55212623782056
	13.581116501149875
	13.61109141257771
	13.641446093325358
	13.6739363445868
	13.704073446437677
	13.732665907059477
	13.76278864067166
	13.790584302600164
	13.820769448179789
	13.850746149373771
	13.881318106739716
	13.910499340213319
	13.939062678533501
	13.963355081746453
	13.996258836974514
	14.024108301775362
	14.052138280073512
	14.07920532503273
	14.111312677347648
	14.136408408832976
	14.166701765847762
	14.191878285716973
	14.219135947520234
	14.249645687956626
	14.276274158281847
	14.30241443371669
	14.329066964870899
	14.355657693943385
	14.386050116093795
	14.411512388033884
	14.44005809527722
	14.465558600028578
	14.492114766740245
	14.519468333902207
	14.545445380135584
	14.571452283026153
	14.597538500775656
	14.621200230369551
	14.647539011977516
	14.671044973465316
	14.697327710134841
	14.724092859381162
	14.747989113856026
	14.77531960757454
	14.800861820185935
	14.824493398214232
	14.850541047182018
	14.873441268279688
	14.898662317684401
	14.922568303280746
	14.950965358928798
	14.971670542621656
	14.997640820970473
	15.02162984249614
	15.043118648606452
	15.070178002705344
	15.091194456712968
	15.116680442054113
	15.141316016646511
	15.162333802883179
	15.187636015315467
	15.21225557738147
	15.237128963393147
	15.258074801763234
	15.283574807156505
	15.305580733784245
	15.32788114087351
	15.351506494637666
	15.376491050277549
	15.394787227083759
	15.418378247711548
	15.445526579177091
	15.464866976025862
	15.487915040605662
	15.507303102775865
	15.533273230982322
	15.557126829201293
	15.576479963430678
	15.59839471627368
	15.616306892048057
	15.64159756996258
	15.66612068948847
	15.685033023827897
	15.708842768041796
	15.729804191012802
	15.74947590562358
	15.771472635625337
	15.793119436157793
	15.816329342265105
	15.83559847477079
	15.860621970042136
	15.874241083785071
	15.900126072265838
	15.919890781169173
	15.940369325150936
	15.962654254861528
	15.981041435448978
	16.001507999939754
	16.02209024894804
	16.044153447832027
	16.063650923326758
	16.083523115482564
	16.10363279779258
	16.12279576477196
	16.14491767917679
	16.165671542331673
	16.18411306361684
	16.20285554839007
	16.2262442544683
	16.244678911099648
	16.264255337391038
	16.28481169144623
	16.30383437801561
	16.322135379909717
	16.343038218586752
	16.360819437570957
	16.37944720917037
	16.401800229182722
	16.419368417963007
	16.438324673165905
	16.460837693853186
	16.478355690791997
	16.497771810564927
	16.517398859072745
	16.53102566107786
	16.55217601396874
	16.57397562206745
	16.590963837363674
	16.608046297237237
	16.62993412915942
	16.648597806095403
	16.66450640846402
	16.683209702070723
	16.701241356172215
	16.71962069124148
	16.741030704760632
	16.758358503928417
	16.774721646983828
	16.793217464919774
	16.81039249331827
	16.82886122855273
	16.847514190819055
	16.866145203899563
	16.88345639508421
	16.900000799853
	16.91799869564099
	16.93471681797178
	16.954265982285175
	16.970156930788352
	16.99077056027272
	17.00960925298605
	17.02201853234475
	17.042219825439183
	17.05879422794408
	17.07524682792861
	17.091701909226742
	17.109302371312566
	17.130229246228954
	17.143192387477576
	17.162159004591548
	17.176891201305203
	17.19189259174011
	17.21131606249252
	17.23057708301444
	17.2449272702833
	17.26136143055546
	17.28030910732524
	17.297530069426635
	17.310618324966473
	17.329166932302133
	17.345009166181477
	17.36044050081977
	17.376806318705455
	17.396280066747114
	17.409667580289334
	17.42827494470861
	17.444199927416484
	17.461513165566167
	17.476062462697495
	17.492071086161772
	17.508188632030805
	17.525606543390573
	17.540797761833634
	17.55634420988244
	17.572977792603332
	17.589813180404683
	17.60620851058162
	17.619688845501276
	17.636210418672178
	17.653271504108424
	17.66594108061729
	17.68336008673236
	17.69543719486139
	17.712986178922016
	17.730376078343703
	17.74495799122021
	17.75899841000372
	17.774229352212874
	17.790129225874495
	17.807060726800234
	17.820680173120955
	17.837874314434288
	17.852499123616937
	17.86780328993399
	17.882677467422937
	17.895564134387588
	17.912445041179378
	17.925799352836062
	17.940354183225953
	17.959751679232177
	17.970620795301617
	17.986227045303632
	18.001560957357
	18.014960320735714
	18.029247409503277
	18.04640723987356
	18.060894959982118
	18.074957338307314
	18.090363809641
	18.104998089016348
	18.11882594524412
	18.134340391846262
	18.150161565480577
	18.16114370193087
	18.17616441485552
	18.189983340036235
	18.204387815776975
	18.221411467259998
	18.233670450851335
	18.249148841460432
	18.264189820814245
	18.276864371607626
	18.289261030384978
	18.303534663572098
	18.31891368562692
	18.335011881068514
	18.348835656583464
	18.361985560788177
	18.37634731758239
	18.390507303610015
	18.402014490584705
	18.418665079442217
	18.429247395453128
	18.442552291079107
	18.45885816356422
	18.469552944682928
	18.486524846560783
	18.49754058080148
	18.51690540362506
	18.526378711987117
	18.537826012593033
	18.552330379398693
	18.563864761804904
	18.57981595483251
	18.595320173660458
	18.611160847434004
	18.619161734737396
	18.63473223143547
	18.649132411572236
	18.659725014084287
	18.673346791309683
	18.68612076121479
	18.696748955456282
	18.71237852810283
	18.72786793400049
	18.740981057952407
	18.753113995568306
	18.766198599775382
	18.77803250089043
	18.793960989580697
	18.803253898625968
	18.81637423247016
	18.83297431081651
	18.84496074970731
	18.856713360620038
	18.869803490037448
	18.881788983776516
	18.896965385724258
	18.90721561751546
	18.92226810164353
	18.934195100664564
	18.94686255643491
	18.960524943756027
	18.970421605043633
	18.98423683310367
	18.997010567530317
	19.008507132148246
	19.021029425147514
	19.03677305511276
	19.0474918966563
	19.059665148365156
	19.073928083145745
	19.084563440354394
	19.097320468794308
	19.110012496604895
	19.121080636864257
	19.13390762831336
	19.14280225348292
	19.158206856292512
	19.17378752580034
	19.18248460636618
	19.19272964363466
	19.20793443673657
	19.21901264048976
	19.230853415471568
	19.24489278387208
	19.255652043863325
	19.269527966535776
	19.280986575787335
	19.29148759932258
	19.304133393955407
	19.31295894005656
	19.327950352828644
	19.336575661462362
	19.349822720964863
c14436e5f46499ea8ec8010da88ce8dd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|13|1|V|rust
	        -16.637655236501224,
	        -3.2073778028451474,
	        -2.064304369976662,
	        -1.3546809466722889,
	        -0.8281658359797516,
	        -0.40253938967491654,
	        -0.039502564053162006,
	        0.28364160682026235,
	        0.5772239884528931,
	        0.838111266851666,
	        1.0868009202155158,
	        1.3165324941873415,
	        1.5326218146462145,
	        1.7425200505064233,
	        1.9370828345768174,
	        2.125085632208347,
	        2.3069051266553204,
	        2.478546038197779,
	        2.65639789484337,
	        2.8203069536323957,
	        2.978730419114667,
	        3.1338320589598774,
	        3.288998184793619,
	        3.4376303031062525,
	        3.58417626478382,
	        3.734959349971237,
	        3.8721140443084954,
	        4.009342444091389,
	        4.144021960780492,
	        4.282415582197282,
	        4.417730984233178,
	        4.54843204980097,
	        4.679145110145505,
	        4.8046999385083815,
	        4.929874072565337,
	        5.0572858193187376,
	        5.183856715323707,
	        5.302187479857232,
	        5.425233252841499,
	        5.545537924432401,
	        5.665829743176893,
	        5.786232172779206,
	        5.905022225954679,
	        6.0258369227675415,
	        6.138636508498319,
	        6.255698645622665,
	        6.368823971955043,
	        6.483252788007763,
	        6.59763016077933,
	        6.712631284288037,
	        6.821808987572604,
	        6.930747854698604,
	        7.042786867284195,
	        7.1569283794315215,
	        7.262409238073819,
	        7.373585907964206,
	        7.482135041196106,
	        7.59007128705397,
	        7.7007077186924295,
	        7.809759218549317,
	        7.9138204216959975,
	        8.023202918358328,
	        8.127074833291443,
	        8.233259515944884,
	        8.342830412649826,
	        8.450962847401101,
	        8.552629916299894,
	        8.656124052323225,
	        8.763687606605245,
	        8.866273209021838,
	        8.967552235363398,
	        9.075691478656855,
	        9.183898759360103,
	        9.286054607208035,
	        9.386649353128306,
	        9.493095959513699,
	        9.59256817840535,
	        9.695189855326634,
	        9.798081193077408,
	        9.904232549402886,
	        10.00775435077294,
	        10.104328978940778,
	        10.209250799915372,
	        10.309536048894504,
	        10.415619200278199,
	        10.512914630611792,
	        10.616925067998318,
	        10.719545840790364,
	        10.82569052636717,
	        10.920026204996434,
	        11.019123642207628,
	        11.123726243878718,
	        11.223396862538673,
	        11.322457925709962,
	        11.423608717091355,
	        11.52137264956311,
	        11.626939696768193,
	        11.724363636568516,
	        11.829078290281942,
	        11.926756834670329,
	        12.023866977410192,
	        12.128754637861284,
	        12.229005579173206,
	        12.327150549599835,
	        12.42320073379204,
	        12.527505575937475,
	        12.624263995550486,
	        12.728288529421276,
	        12.831179430890277,
	        12.929373577091864,
	        13.019296117317667,
	        13.12576615740427,
	        13.228316221379316,
	        13.326752271746773,
	        13.421767475692928,
	        13.528376240165276,
	        13.621213484612975,
	        13.720237321024324,
	        13.820223741511278,
	        13.916508156762665,
	        14.014710829324216,
	        14.114795925887437,
	        14.214748909756986,
	        14.317607141627759,
	        14.411039427599727,
	        14.512167399083273,
	        14.610786681259539,
	        14.703982090462606,
	        14.805431627124811,
	        14.908040642743243,
	        15.002575847531137,
	        15.101189984138106,
	        15.198367008875683,
	        15.29764620343702,
	        15.396719987595997,
	        15.496524643113691,
	        15.596348694738474,
	        15.695865032147397,
	        15.798223622015554,
	        15.896844304936113,
	        15.994636909250309,
	        16.089005357220906,
	        16.187523173262452,
	        16.286877065339063,
	        16.38136510301903,
	        16.48611312927631,
	        16.580694250205873,
	        16.676140007828867,
	        16.777566155452426,
	        16.86851472623604,
	        16.972276170062106,
	        17.07236604676929,
	        17.17002998393461,
	        17.263518742143038,
	        17.371960381122054,
	        17.46679324741868,
	        17.566527606164218,
	        17.657190108223872,
	        17.76294506487139,
	        17.85800143424382,
	        17.95533926398797,
	        18.054084208438717,
	        18.152947633230575,
	        18.24784882593423,
	        18.348745139145336,
	        18.447309008046254,
	        18.544926914067986,
	        18.646181353693144,
	        18.74249797154525,
	        18.838536968682273,
	        18.938410159329106,
	        19.039708295100098,
	        19.12963606837031,
	        19.23961832162645,
	        19.328789120506478,
	        19.428831868588325,
	        19.524135208177725,
	        19.623132432405413,
	        19.725036388007293,
	        19.822908851049924,
	        19.916681049410915,
	        20.017173948675897,
	        20.117788115518543,
	        20.212385261481966,
	        20.309657314200834,
	        20.410678718805556,
	        20.50591946714346,
	        20.6039071615597,
	        20.710023214016594,
	        20.795935078224993,
	        20.892445919823906,
	        20.997837703659616,
	        21.091883072100714,
	        21.189986857759582,
	        21.28474246979953,
	        21.383595675156343,
	        21.489635305247493,
	        21.58658072126945,
	        21.67923306964906,
	        21.777151543542594,
	        21.877503807332698,
	        21.9777124345802,
	        22.074420570417356,
	        22.171924206337504,
	        22.26412444140273,
	        22.370400437296468,
	        22.46440200316392,
	        22.564445638277135,
	        22.661225884857526,
	        22.759392829896036,
	        22.855759327870224,
	        22.961025126269117,
	        23.04967330445861,
	        23.15086367387428,
	        23.24693124118719,
	        23.342482534019904,
	        23.440903850791386,
	        23.54353641327109,
	        23.639265951519356,
	        23.735095878576605,
	        23.83628836843447,
	        23.937952900572512,
	        24.029500321184912,
	        24.135181019639223,
	        24.232097520335735,
	        24.326548923665776,
	        24.420821030333116,
	        24.524166950199877,
	        24.62264131885209,
	        24.720467087699234,
	        24.8079699036987,
	        24.915334091759682,
	        25.006039372376208,
	        25.11092926075667,
	        25.206329650925014,
	        25.303373364546196,
	        25.40449321448272,
	        25.498342521804513,
	        25.59578509653883,
	        25.691699415485985,
	        25.792891227265198,
	        25.889764286973644,
	        25.989357277209372,
	        26.09162357758695,
	        26.18373528480038,
	        26.281826407237375,
	        26.37521869912794,
	        26.47482057242853,
	        26.580942063470875,
	        26.678337201255403,
	        26.776286672356854,
	        26.864896626788482,
	        26.965377322197643,
	        27.069142380346584,
	        27.163463331840834,
	        27.257275123072255,
	        27.35603533182855,
	        27.454050023145445,
	        27.55381560630426,
	        27.652028171736465,
	        27.753068180356422,
	        27.851517014690277,
	        27.941954988568334,
	        28.04625825672801,
	        28.143590313973302,
	        28.239825994178066,
	        28.33633209342876,
	        28.431863693763457,
	        28.53321745058022,
	        28.63225613663344,
	        28.724961183491533,
	        28.828884530768693,
	        28.924708511933343,
	        29.025410664836738,
	        29.121282759809816,
	        29.220270025971008,
	        29.310135957157353,
	        29.413877402170062,
	        29.510914274473848,
	        29.616368558872022,
	        29.706650112894227,
	        29.80755514838043,
	        29.90229574136799,
	        30.00459742503278,
	        30.098843898329033,
	        30.194621572805133,
	        30.296481970402994,
	        30.393556467012353,
	        30.49110980213624,
	        30.586373509120993,
	        30.685775036441395,
	        30.78946619562423,
	        30.883725941744665,
	        30.97720911177579,
	        31.07983605573461,
	        31.176156653596653,
	        31.27896288818872,
	        31.368149662172968,
	        31.469379909589453,
	        31.568463567862715,
	        31.665013490312656
c9aaa451f6000cae36dae8a3b61f55a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|12|1|V|rust
	    pub static ref LOG_ETA_CS: Array1<f64> = arr1(&[
8514241e20b12cfb85e84e0bc937890b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|7|4|v|rust
	 pub static ref LOG_XMIN: f64 = 0.602059991327962;
	    pub static ref LOG_XMAX: f64 = 2.69897000433602;
	    pub static ref LOG_XSTEP: f64 = 0.006989700043360188;
	
327155291f72700a6788b0bd851b8974|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1014|6|V|rust
	        let xs = Array1::<f64>::linspace(0.602059991327962, 2.69897000433602, 301);
6cafd0366f9dc0fb69609eaf2e267de8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|10|1|V|rust
	        0.60206107706281,
79dd642ee2bccc9df6665b415aeb1371|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|510|1|V|rust
	        2.1760912590556813,
55fb680158bcf9c923957372d2852e8b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|9|1|V|rust
	    pub static ref LOG_ETA_ZS_MIN: f64 = 0.60206107706281;
f1c3633266932ffb7da5d162b56b96e5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|11|1|v|rust
	0.60206107706281
46c68d3e7e75b646e0e21582d5e71fe4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|9|21|v|rust
	LOG_XMIN
6f0e7382fe18be38b128d3b1155fb5ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|9|49|v|rust
	LOG_XMAX
8a7ad1d6a6e1b99c6629e83b5dbaf5d3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|19|14|v|rust
	e = self.eta.m;
d6379cfb8a639210a8933a0e21c88c0c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|22|1|V|rust
	        let fe = n.sqrt() * lam / (4.0 * PI);
	        let l1 = self.lec1;
858b0cf8f554177c0b9dc1030754e1cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|23|24|v|rust
	self.lec1
853aac0d399ffb93724e34da6fa0743c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|26|35|v|rust
	* (l1 * l1 * me.powi(7) / (fe * lam).powi(4)).powi(2);
ec2f8cf78748babace214587403985bb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|20|23|v|rust
	eta.m;
3f5cb10ba7364d2f5073ff503674fb5f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|24|75|v|rust
	* n * n
4471e38f0349aefc53c1818d5da734da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|24|23|v|rust
	(16.0 * PI * PI * l1 * l1 * mu.powi(7) / (3.0 * lam)).powi(2) / n.powi(11);
f2cfb97ad9866d9d26276da46ba597ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|35|1|V|rust
	    /// Current value of xi
	    pub xi: f64,
0c7379659c49654c38efed76cdf43e0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|49|48|v|rust
	integrator.params.xi
06135778c14f1bf57dfd0457c84ddde8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|47|1|V|rust
	                let x = logx.exp();
	                let tsm = integrator.params.eta.m / x;
95c47db3b09ed18f3535f17cef07cba1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|80|1|V|rust
	    let td = xi * tsm;
	    let s = sm_entropy_density(tsm);
	    let neq = model.eta.neq(td);
	    let weq = (neq / s).ln();
a4dfefc4bdf9213f5fd069237989b3cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|51|1|V|rust
	            let tsm = integrator.params.eta.m / x;
6050b9a1730144e0a918d5d6980ddb6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|51|13|V|rust
	            let x = logx.exp();
08f75b5fdbce83f6014d0d46070adb68|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|46|1|V|rust
	            let x = logx.exp();
	            let tsm = integrator.params.eta.m / x;
	            let xi = integrator.params.xi;
	            let td = xi * tsm;
	            let s = sm_entropy_density(tsm);
	            let neq = integrator.params.eta.neq(td);
	            let weq = (neq / s).ln();
	            if w[0] - weq > 0.1 && integrator.params.xi_fo.is_none() {
	                integrator.params.xi_fo = Some(xi);
	                integrator.params.tsm_fo = Some(tsm);
	            }
	            if tsm < T_BBN && integrator.params.xi_bbn.is_none() {
	                integrator.params.xi_bbn = Some(xi);
	            }
c1efb6783b323def8effebcb29e5a20d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|63|1|V|rust
	        for (logx, w) in (&mut integrator).into_iter() {
	        }
812aa8ef88451bac321fda1743a9cfb7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|293|1|V|rust
	        let xs = [1.0, 2.0, 5.0];
	        for x in xs.iter() {
	            println!("{:e}", model.thermal_cross_section_2eta_4eta(*x));
	        }
593acf54fe2005c60a6aabca7d9a0c99|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|296|35|v|rust
	unwrap
40bce7727e2c3aaadb5b5be4caae3942|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|296|39|v|rust
	model.
2e256d8a0e4896aa759d4199cd91d9cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|299|9|V|rust
	        println!("{:?}, {:?}", sol.ts, sol.us);
775010fe49e01c0af45b2df3dfb5f53b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|297|1|V|rust
	            println!("{:?}, {:?}", t, u[0]);
97538bf9fa8bb66a68673031fc948bb6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|299|23|v|rust
	, {:?}
4745b06701d42160b6993c6bf53ffe97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|299|26|v|rust
	t, u[0]
eaad88e6855d452bfa21cac456f993a2|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|2|9|v|toml
	py_cpp_demangle
14e9f3e3106bb22a59b2e88080ffc9dc|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|4|13|v|toml
	 Frederickson
a90a6389a705ef1669a6e4320aadaced|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|7|9|v|toml
	mymod
3ae8936d4f8254eb85529f5e12d1e148|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|7|14|v|toml
	my_mod
532e4ec5b21ea9f2b11e04515519b8d2|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|2|9|v|toml
	PyMyMod
b5d6ae277530a79b73280758e0dfc473|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|11|1|v|toml
	cpp_demangle
0e591676949d1032471f2681537da651|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|10|2|v|toml
	dependencies
90b3728c29634bc559cf686b97505548|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|11|1|V|toml
	test_mod = "0.1.0"
138a6ed631be4acae9114154b1e0951b|file:///Users/loganmorrison/Documents/coding/rust/projects/pyo3_test/Cargo.toml|12|1|V|toml
	[dependencies.pyo3]
	version = "0.11.1"
	features = ["extension-module"]
80154347a090f8803a39aec750654379|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/setup.py|5|11|v|python
	hello-rust",
e31541e3bec882a5033a8f07c2c48049|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/lanre/__init__.py|1|7|v|python
	html_py_ever
f82b42831a407d60ca6c09d598274985|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/setup.py|1|1|V|python
	from setuptools import setup
	from setuptools_rust import Binding, RustExtension
	
	setup(
	    name="lanre"
	    version="1.0",
	    rust_extensions=[RustExtension("hello_rust.hello_rust", binding=Binding.PyO3)],
	    packages=["hello_rust"],
	    # rust extensions are not zip safe, just like C-extensions.
	    zip_safe=False,
	)
fbe515b05019b45a68e226523962bf75|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/setup.py|22|11|v|python
	html-py-ever",
6863fa555d18d285c50491c43cf2bfbc|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/setup.py|34|37|v|python
	html_py_ever.html_py_ever
c515b759fad5e65cf01f434cabf0d016|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|1|V|rust
	#[pyclass]
	pub struct DarkSun {
	    #[pyo3(get, set)]
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    #[pyo3(get, set)]
	    /// Confinement scale.
	    pub lamc: f64,
	    #[pyo3(get, set)]
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    #[pyo3(get, set)]
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    #[pyo3(get, set)]
	    pub c: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    #[pyo3(get, set)]
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	    // Solution to the Boltzmann equation.
	    //pub sol: Option<OdeSolution>,
	}
	
	#[pymethods]
	impl DarkSun {
	    #[new]
	    pub fn new(n: usize, lamc: f64) -> Self {
	        DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-3,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	    }
	}
eeebebd7e3d7222bed0123ea7ecae8d6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|72|5|V|rust
	    // Solution to the Boltzmann equation.
c042896f89f95bc38a67b151b8bd98ab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|72|5|V|rust
	    //pub sol: Option<OdeSolution>,
93473a7344419b15c4219cc2b6c64c6f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/darksun/__init__.py|1|1|v|python
	import
ce1cbe623e85d6aacf6b6313f966141a|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/Cargo.toml|12|1|V|toml
	pyo3 = {version = "0.11.1", features = ['extension-module']}
9f44c6a52140742159532958407cc91b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|19|1|V|toml
	pyo3 = {version="0.11.1", 
724a0a530642f41842429c0871dd7fd7|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/Cargo.toml|14|1|V|toml
	[lib]
	name = "lanre"
	crate-type = ["cdylib"]
8b31726394342001607c2ea27923fae8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|22|1|V|toml
	[[bin]]
	name = "main"
	path = "src/main.rs"
	
	[[bin]]
	name = "generate_cs_data"
	path = "src/generate_cs_data.rs"
08b3b44868f9783dfe9ca6d0141c79ca|file:///Users/loganmorrison/Documents/coding/rust/projects/lanre/setup.py|1|1|V|python
	#!/usr/bin/env python
	import sys
	
	from setuptools import setup
	
	try:
	    from setuptools_rust import RustExtension
	except ImportError:
	    import subprocess
	
	    errno = subprocess.call(
	        [sys.executable, "-m", "pip", "install", "setuptools-rust"]
	    )
	    if errno:
	        print("Please install setuptools-rust package")
	        raise SystemExit(errno)
	    else:
	        from setuptools_rust import RustExtension
	
	setup_requires = ["setuptools-rust>=0.10.1", "wheel"]
	install_requires = []
	
	setup(
	    name="lanre",
	    version="0.1.0",
	    classifiers=[
	        "License :: OSI Approved :: MIT License",
	        "Development Status :: 3 - Alpha",
	        "Intended Audience :: Developers",
	        "Programming Language :: Python",
	        "Programming Language :: Rust",
	        "Operating System :: POSIX",
	        "Operating System :: MacOS :: MacOS X",
	    ],
	    packages=["lanre"],
	    rust_extensions=[RustExtension("lanre.lanre")],
	    install_requires=install_requires,
	    setup_requires=setup_requires,
	    include_package_data=True,
	    zip_safe=False,
	)
ff711bf2e7eead942cfc434bbc7752dd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/setup.py|1|1|V|python
	from setuptools import setup
	from setuptools_rust import Binding, RustExtension
	
	setup(
	    name="darksun",
	    version="0.1.0",
	    rust_extensions=[RustExtension("darksun", "Cargo.toml", binding=Binding.PyO3)],
	    zip_safe=False,
	)
fa7e97ad1ffed729b53fc08a791fb708|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|92|1|V|rust
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
90bdf107e111fb0e00bdeddfe4415c2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|79|1|V|rust
	    #[new]
	    #[args(
	        xi_inf = "1e-2",
	        c = "1.0",
	        lec1 = "1.0",
	        lec2 = "1.0",
	        adel = "1.0",
	        mu_eta = "1.0",
	        mu_del = "1.0",
	        xi_fo = "None",
	        tsm_fo = "None",
	        xi_bbn = "None",
	        xi_cmb = "None",
	        rd_eta = "None",
	        rd_del = "None",
	        dneff_cmb = "None",
	        dneff_bbn = "None",
	        eta_si_per_mass = "None",
	        del_si_per_mass = "None"
	    )]
22461e4e87466f300e3c76df76ac6520|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|77|5|V|rust
	    #[new]
a956af09162870af6ce4ebe0f12ccaf8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|77|7|v|rust
	args
da011456dee421dd32063a5a9d735e82|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|99|9|V|rust
	        kwargs.
3329bc5ba2a4c2f73b03f703c6fcc8b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|102|21|v|rust
	1e-3
d191c817cea24df48cbdfbfd0b2960d2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|102|21|v|rust
	kwargs.
0a3c749fe30358dd09860bbdb6a71f63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|79|1|V|rust
	        xi_inf = "1e-2",
	        c = "1.0",
	        lec1 = "1.0",
	        lec2 = "1.0",
	        adel = "1.0",
	        mu_eta = "1.0",
	        mu_del = "1.0",
	        xi_fo = "None",
	        tsm_fo = "None",
	        xi_bbn = "None",
	        xi_cmb = "None",
	        rd_eta = "None",
	        rd_del = "None",
	        dneff_cmb = "None",
	        dneff_bbn = "None",
	        eta_si_per_mass = "None",
	        del_si_per_mass = "None"
8fdbf5773a665265104d20457a7c3f4f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|83|9|V|rust
	        let kwargs: &PyDict = py_kwargs.unwrap_or();
4a60505063612b101955fdb0bd2a8b49|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|87|21|v|rust
	kwargs.get_item("xi_inf"),
6c38cf380c76f4786ab1e6691b9362c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|84|17|v|rust
	DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-2,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	
03a32723cd0e2002b06e32a0f4d77ffa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|108|21|v|rust
	1e-2,
d804ae343cb4dbb5db73f1ea8015545d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|115|25|v|rust
	kwargs.get_item("xi_inf")
d2849f9e22ad1306d3ac21aba23c9e90|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|106|50|v|rust
	.unwrap_or(1e-2),
35e33d82ed8a49a339820dd2c079905e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|78|5|V|rust
	    #[args(py_kwargs = "**")]
1da8abb85e3ccc75a7cab2517120a113|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|102|1|V|rust
	            Some(kwargs) => DarkSun {
	                n: n,
	                lamc: lamc,
	                xi_inf: kwargs.get_item("xi_inf").unwrap().extract()
	                c: kwargs.get_item("c").unwrap_or(1.0),
	                lec1: kwargs.get_item("lec1").unwrap_or(1.0),
	                lec2: kwargs.get_item("lec2").unwrap_or(1.0),
	                adel: kwargs.get_item("adel").unwrap_or(1.0),
	                mu_eta: kwargs.get_item("mu_eta").unwrap_or(1.0),
	                mu_del: kwargs.get_item("mu_del").unwrap_or(1.0),
	                xi_fo: None,
	                tsm_fo: None,
	                xi_bbn: None,
	                xi_cmb: None,
	                rd_eta: None,
	                rd_del: None,
	                dneff_cmb: None,
	                dneff_bbn: None,
	                eta_si_per_mass: None,
	                del_si_per_mass: None,
	            },
eb1dbd6ad87238137853f46ffb7660ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|101|9|V|rust
	            },
	        }
0acbc5306010c634322325988e0528e1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|80|5|V|rust
	        match py_kwargs {
8103e9d134faaa37f1e2f04284643817|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|79|35|v|rust
	, py_kwargs: Option<&PyDict>
6422e93fe606bb4ce75a7359f302cfb4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|80|13|V|rust
	            None => DarkSun {
2ac03164e3900a9855bc04ff3219f4e9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|80|13|v|rust
	None => 
dcd6e10aa97f603cb2f41651cd9f1f1f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|7|1|V|rust
	use pyo3::prelude::*;
	use pyo3::types::PyDict;
	
	#[pyclass]
	pub struct DarkSun {
	    #[pyo3(get, set)]
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    #[pyo3(get, set)]
	    /// Confinement scale.
	    pub lamc: f64,
	    #[pyo3(get, set)]
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    #[pyo3(get, set)]
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    #[pyo3(get, set)]
	    pub c: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    #[pyo3(get, set)]
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	}
	
	#[pymethods]
	impl DarkSun {
	    #[new]
	    /// Create a new DarkSun object
	    pub fn new(n: usize, lamc: f64) -> Self {
	        DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-2,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	    }
	}
983ced502483cab0c2aefb5f2365f1e9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|1|V|rust
	#[pyclass]
	pub struct DarkSun {
	    #[pyo3(get, set)]
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    #[pyo3(get, set)]
	    /// Confinement scale.
	    pub lamc: f64,
	    #[pyo3(get, set)]
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    #[pyo3(get, set)]
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    #[pyo3(get, set)]
	    pub c: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    #[pyo3(get, set)]
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	    // Solution to the Boltzmann equation.
	    //pub sol: Option<OdeSolution>,
	}
	
	#[pymethods]
	impl DarkSun {
	    #[new]
	    #[args(
	        xi_inf = "1e-2",
	        c = "1.0",
	        lec1 = "1.0",
	        lec2 = "1.0",
	        adel = "1.0",
	        mu_eta = "1.0",
	        mu_del = "1.0",
	        xi_fo = "None",
	        tsm_fo = "None",
	        xi_bbn = "None",
	        xi_cmb = "None",
	        rd_eta = "None",
	        rd_del = "None",
	        dneff_cmb = "None",
	        dneff_bbn = "None",
	        eta_si_per_mass = "None",
	        del_si_per_mass = "None"
	    )]
	    /// Create a
	    pub fn new(n: usize, lamc: f64) -> Self {
	        DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-3,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	    }
	}
8f725a48c9121a3a728e4fce7fbcda5e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|11|1|V|rust
	use pyo3::types::PyDict;
f438b3344949b52b098ca39041db85c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|125|1|V|rust
	    // #[test]
	    // fn test_compute_xi() {
	    //     use crate::thermally_decoup::*;
	    //     let n = 10;
	    //     let lamc = 1e-3;
	    //     let model = DarkSun::default(n, lamc).build();
	    //     println!("{:?}", model.compute_xi_const_td(lamc / 2.0));
	    // }
	    // #[test]
	    // fn test_scaled_cs() {
	    //     let n = 10;
	    //     let lamc = 1e-3;
	    //     let model = DarkSun::default(n, lamc).build();
	    //     let xs = [4.1, 4.5, 5.0, 10.0, 20.0, 50.0, 100.0];
	    //     for x in xs.iter() {
	    //         println!("{:e}", model.scaled_cross_section_2eta_4eta(*x));
	    //     }
	    // }
	    // #[test]
	    // fn test_tcs_eta() {
	    //     let n = 10;
	    //     let lamc = 1e-3;
	    //     let model = DarkSun::default(n, lamc).build();
	    //     let xs = [1.0, 2.0, 5.0];
	    //     for x in xs.iter() {
	    //         println!("{:e}", model.thermal_cross_section_2eta_4eta(*x));
	    //     }
	    // }
	    // #[test]
	    // fn test_boltz() {
	    //     let n = 10;
	    //     let lamc = 1e-3;
	    //     let mut model = DarkSun::default(n, lamc).build();
	    //     model = model.solve_boltzmann(1e-6, 1e-6);
	    //     let sol = model.sol.unwrap();
	
	    //     for (t, u) in sol.ts.iter().zip(sol.us.iter()) {
	    //         println!("{:?}, {:?}", t, u[0]);
	    //     }
	    //     println!("{:?}", sol.retcode);
	    // }
c8e998c6ad47511eef57b1eca34abf0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|105|1|V|rust
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_darksun_build() {
	        let n = 10;
	        let lamc = 1e-3;
	        let model = DarkSun::new(n, lamc);
	        assert_eq!(model.n, n);
	        assert_eq!(model.lamc, lamc);
	        assert_eq!(model.xi_inf, 1e-2);
	        assert_eq!(model.c, 1.0);
	        assert_eq!(model.lec1, 1.0);
	        assert_eq!(model.lec2, 1.0);
	        assert_eq!(model.adel, 1.0);
	        assert_eq!(model.mu_eta, 1.0);
	        assert_eq!(model.mu_del, 1.0);
	    }
	}
aae233f7588559055a0f0cc9ac9070fc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|1|V|rust
	use pyo3::prelude::*;
3fccaa1d4e921d1d675e3076fcea2a2b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|10|1|V|rust
	#[pyclass]
	pub struct DarkSun {
	    #[pyo3(get, set)]
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    #[pyo3(get, set)]
	    /// Confinement scale.
	    pub lamc: f64,
	    #[pyo3(get, set)]
	    /// Temperature ration td/tsm above confinement scale.
	    pub xi_inf: f64,
	    #[pyo3(get, set)]
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    #[pyo3(get, set)]
	    pub c: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constants in 4-pt eta interaction
	    pub lec1: f64,
	    #[pyo3(get, set)]
	    /// Low-energy constant in the 6-pt eta interaction
	    pub lec2: f64,
	    #[pyo3(get, set)]
	    /// Exponential supression factor for initial delta density
	    pub adel: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    #[pyo3(get, set)]
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    #[pyo3(get, set)]
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    #[pyo3(get, set)]
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    #[pyo3(get, set)]
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	}
	
	#[pymethods]
	impl DarkSun {
	    #[new]
	    /// Create a new DarkSun object
	    pub fn new(n: usize, lamc: f64) -> Self {
	        DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-2,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	    }
	}
7f3ad7260873da9bcfebd77ce4a8c504|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|16|1|V|rust
	fn main() {}
23331801ddd32595c819ec2d438e7283|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|4|1|V|rust
	impl ThermallyDecoupledModel for DarkSun {
	    fn dark_heff(&self, td: f64) -> f64 {
	        self.eta.heff(td) + self.delta.heff(td)
	    }
	    fn xi_inf(&self) -> f64 {
	        self.xi_inf
	    }
	    fn hd_inf(&self) -> f64 {
	        let n = self.n as f64;
	        7.0 / 2.0 * n + 2.0 * n * n
	    }
	    fn sum_g(&self) -> f64 {
	        self.eta.g + self.delta.g
	    }
	    fn gl(&self) -> f64 {
	        self.eta.g
	    }
	    fn ml(&self) -> f64 {
	        self.eta.m
	    }
	}
	
	impl DarkSun {
	    pub fn compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.eta.m {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
	}
e55fa666f73f70b582ad7241b24dd4c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|1|V|rust
	#[pymethods]
e38f8993b9d4f0188e71aecfe854aebd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|6|37|v|rust
	PyResult
b1e065da036ddb4125c43199fb972b96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|20|9|V|rust
	        self.eta.
21c936b08c4f50e3fc22857fc8ef7841|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|25|1|V|rust
	        self.mu_eta * self.lamc / (self.n as f64).sqrt()
f25930ce52c85e6fc1c69b7c63c29aa8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|9|1|V|rust
	        let me = self.mu_eta * self.lamc / (self.n as f64).sqrt();
9b0b10c6d79995d6431864aa479a068e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|11|1|V|rust
	       heff(td, me, 1.0, 0)
2856bd0705fead4171c925c1d957da75|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|13|9|V|rust
	        self.eta.heff(td) + self.delta.heff(td)
b6176a8f80fbad2d87f0c9fbe9c0d420|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|2|12|v|rust
	thermally_decoup::ThermallyDecoupledModel;
8c97693f5029e1424cf48aea5c6451b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|32|43|v|rust
	Result<f64, String>
65542e1f3efe79c0f3fc36ee30710299|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|48|9|v|rust
	PyErr::new::<exceptions::TypeError, _>("Error").restore(py)
695c6ae413c00446733d926ccadefd8b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|48|13|v|rust
	Some
4190d3501798c4bade4190eddbea7b2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|51|9|V|rust
	        Err(PyErr)
8e55425cded265a201d93b17bb039848|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|51|29|v|rust
	PyErr
137bf8cff2d59f0883c600f9524b3eed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|51|54|v|rust
	TypeError
3bd3a8aa5a65d790af4d6e73b2a0ba3e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|51|29|v|rust
	PyErr::new::<exceptions::ValueError, _>("Error").restore(py)),
0450e6458325d670939e0b893e45a31a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|22|9|v|rust
	self.eta.g + self.delta.g
f0e7516cb2e2673024d6ba0a4ebc2fd3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|35|9|V|rust
	        let gil = Python::acquire_gil();
ddf82c179861d037d4290dbc0bbd6ff3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|35|9|V|rust
	        let py = gil.python();
fffabd000b89fba035bbe6c35b972cc6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|6|1|V|rust
	use pyo3::Python;
0c1d2657dfa1051e9cb81a62fb3b388d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|70|15|v|rust
	, set
4d4969a5abbfb114474ba780efc183b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|39|5|V|rust
	    #[pyo3(get, set)]
b31c39f23a2087cc2391fa29f98a9c59|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|95|5|V|rust
	    /// Temperature ration td/tsm above confinement scale.
66b1cdee315d935e3b6f6be97f59e10f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|97|5|V|rust
	    pub n: usize,
6d958b49d2cfc6c55e1d88ecd5392a49|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|92|1|V|rust
	    #[getter]
	    pub fn get_n(&self) -> PyResult<usize>{
	        Ok(self.n)
	    }
6b31257f93ea4c8911ad032f01201b82|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|101|5|V|rust
	    #[getter]
c0ebda7cbc8a606e8b07399c0497aae5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|112|1|V|rust
	    #[getter]
	    pub fn get_mu_eta(&self) -> PyResult<usize>{
	        Ok(self.n)
	    }
02469f354d7b4f15a1721182294d038a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|121|19|V|rust
	    pub lamc: f64,
	    pub xi_inf: f64,
	    pub c: f64,
	    pub lec1: f64,
	    pub lec2: f64,
	    pub adel: f64,
	    pub mu_eta: f64,
	    pub mu_del: f64,
1748a4b7ffce01e7d7c8ea172fb3e74f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|112|1|V|rust
	    #[getter]
	    pub fn get_mu_eta(&self) -> PyResult<usize>{
	        Ok(self.n)
	    }
	    #[getter]
	    pub fn get_mu_del(&self) -> PyResult<usize>{
	        Ok(self.n)
	    }
746074466d6ef5a39a4e0737ff0a76de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|125|16|v|rust
	mu_del
3f258666d2a57099a7cc7f0769d62aef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|92|1|V|rust
	    #[getter]
	    pub fn get_n(&self) -> PyResult<usize> {
	        Ok(self.n)
	    }
	    #[getter]
	    pub fn get_lamc(&self) -> PyResult<f64> {
	        Ok(self.lamc)
	    }
	    #[getter]
	    pub fn get_xi_inf(&self) -> PyResult<f64> {
	        Ok(self.xi_inf)
	    }
	    #[getter]
	    pub fn get_c(&self) -> PyResult<f64> {
	        Ok(self.c)
	    }
	    #[getter]
	    pub fn get_adel(&self) -> PyResult<f64> {
	        Ok(self.adel)
	    }
	    #[getter]
	    pub fn get_mu_eta(&self) -> PyResult<f64> {
	        Ok(self.mu_eta)
	    }
	    #[getter]
	    pub fn get_mu_del(&self) -> PyResult<f64> {
	        Ok(self.mu_del)
	    }
	    #[getter]
	    pub fn get_lec1(&self) -> PyResult<f64> {
	        Ok(self.lec1)
	    }
	    #[getter]
	    pub fn get_lec2(&self) -> PyResult<f64> {
	        Ok(self.lec2)
	    }
6d1f3c79a6ed212f8a63161734c5743b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|128|7|v|rust
	getter
24ebf3cdf0a1bd858aec23e97f478fae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|128|1|V|rust
	    #[setter]
b29207e7528ed08f77fa186d2b8c4d9c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|131|9|V|rust
	        Ok(self.n)
a92ea65ec7fe66d239ea9b6023547eec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|132|1|V|rust
	        Ok(())
f3e2461423f7c77d06ef05eb0ad3f9f9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|136|9|v|rust
	Ok(self.lamc)
912915f5907abd89b46cfc70bd4d0e0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|34|1|V|rust
	    pub meta: f64,
2e2cb22d37f219071e52d85e1baa9385|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|38|1|V|rust
	    #[pyo3(get)]
168ca2e3793d91843b65ecab38a0f8ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|141|1|V|rust
	        self.m_eta = self.mu_eta * self.lamc / (n as f64).sqrt();
e1baf4eba53ffb430f184b127d94c004|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|142|58|v|rust
	.sqrt();
1c6f3c0f99a6a1232e57c13c46dcb723|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|141|1|V|rust
	        self.m_eta = self.mu_eta * self.lamc / (n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (n as f64);
9fc3049aad2b59a8c16242a175d6e985|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|141|1|V|rust
	        self.m_eta = self.mu_eta * self.lamc / (self.n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (self.n as f64);
02bb8e0594c96bbf10219deb7ef173a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|181|9|V|rust
	    #[setter]
	    pub fn set_lec1(&mut self, lec1: f64) -> PyResult<()> {
	        self.lec1 = lec1;
	        Ok(())
	    }
	    #[setter]
	    pub fn set_lec2(&mut self, lec2: f64) -> PyResult<()> {
	        self.lec2 = lec2;
	        Ok(())
	    }
c37c500a819b48473242f5946c3e7ac9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|152|1|V|rust
	    #[setter]
	    pub fn set_xi_inf(&mut self, xi_inf: f64) -> PyResult<()> {
	        self.xi_inf = xi_inf;
	        Ok(())
	    }
	    #[setter]
	    pub fn set_c(&mut self, c: f64) -> PyResult<()> {
	        self.c = c;
	        Ok(())
	    }
	    #[setter]
	    pub fn set_adel(&mut self, adel: f64) -> PyResult<()> {
	        self.adel = adel;
	        Ok(())
	    }
54f3fade001d0792b023e93f2a395d2b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|129|5|V|rust
	    #[getter]
	    pub fn get_lec1(&self) -> PyResult<f64> {
	        Ok(self.lec1)
	    }
	    #[getter]
	    pub fn get_lec2(&self) -> PyResult<f64> {
	        Ok(self.lec2)
	    }
35f05ac665cc79eea8d4abdcf365dc25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|109|1|V|rust
	    #[getter]
	    pub fn get_xi_inf(&self) -> PyResult<f64> {
	        Ok(self.xi_inf)
	    }
	    #[getter]
	    pub fn get_c(&self) -> PyResult<f64> {
	        Ok(self.c)
	    }
	    #[getter]
	    pub fn get_adel(&self) -> PyResult<f64> {
	        Ok(self.adel)
	    }
6ab4168b384329505f98ca6161a5d851|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|10|2|v|rust
	       let md = self.mu_del * self.lamc * (self.n as f64);
dad9b1e25d9494075f850a769a5b06dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|25|9|V|rust
	        self.mu_eta * self.lamc / (self.n as f64).sqrt(
8bd0e21956338073bbf25c5be5c4e99d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|35|17|V|rust
	                let me = self.mu_eta * self.lamc / (self.n as f64).sqrt();
63bcabf86a9a991864777c631c5b7617|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|45|31|v|rust
	delta
8b9eb7c8c71bce924b83c324aa72441f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|35|16|v|rust
	.extract()
c8ddecffbf736de8f2e4136c605938f9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|9|1|V|rust
	    pub fn scaled_cross_section_2eta_4eta(&self, z: f64) -> PyResult<f64> {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            Ok(10f64.powf((*ETA_CS_INTERP).eval(logz)))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            Ok(0.0)
	        } else {
	            Ok(z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT))
	        }
	    }
466653c72ad14ae3cee75f4ab5656b2e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|8|70|v|rust
	PyResult<f64>
fc1fc9e7274a9aa1bdb53502c43079e8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|23|1|V|rust
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            Ok(10f64.powf((*ETA_CS_INTERP).eval(logz)))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            Ok(0.0)
	        } else {
	            Ok(z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT))
	        }
0a7c6e5fb84e41378ea61eb0f4b12650|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|8|12|v|rust
	internal_scaled_cross_section_2eta_4eta
7e2f68b190404c47282b988eb855e391|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|32|13|v|rust
	256.0
7f16b5b2abfa8738b4dca6255c6c4ede|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|32|28|v|rust
	* PI.powi(4)
b39ea4c0b85a376b81f058c59d5d63cc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|32|58|v|rust
	9.0 * 
bb8b14620dfc82af3329961c6165d60c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|57|1|V|rust
	            let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
edb33edab75f167dbfde5a4a272900be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|59|13|v|rust
	sig 
a0646a6965244bed161c0afb2cc6dece|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|63|9|V|rust
	        Ok(0.0)
fec89c9c1e23e28ae996adaa20403c2d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|10|1|V|rust
	#[pyclass]
	pub struct DarkSun {
	    /// Order of the SU(N) gauge group.
	    pub n: usize,
	    /// Confinement scale.
	    pub lamc: f64,
	    /// Temperature ration td/tsm above confinement scale.
	    #[pyo3(get, set)]
	    pub xi_inf: f64,
	    /// Constant parameterizing delta+delta->eta+eta matrix element. It is
	    /// defined such that M ~ exp(-c*n)
	    #[pyo3(get, set)]
	    pub c: f64,
	    /// Low-energy constants in 4-pt eta interaction
	    #[pyo3(get, set)]
	    pub lec1: f64,
	    /// Low-energy constant in the 6-pt eta interaction
	    #[pyo3(get, set)]
	    pub lec2: f64,
	    /// Exponential supression factor for initial delta density
	    #[pyo3(get, set)]
	    pub adel: f64,
	    /// Prefactor of the eta mass defined such that
	    /// meta = mu_eta * lamc / sqrt(n).
	    pub mu_eta: f64,
	    /// Prefactor of the delta mass defined such that
	    /// mdel = mu_del * lamc * n.
	    pub mu_del: f64,
	
	    /// Mass of the eta.
	    #[pyo3(get)]
	    pub m_eta: f64,
	    /// Mass of the delta.
	    #[pyo3(get)]
	    pub m_del: f64,
	    #[pyo3(get)]
	    /// Value of xi = Td / Tsm when the eta freezes out.
	    pub xi_fo: Option<f64>,
	    #[pyo3(get)]
	    /// Value of Tsm when the eta freezes out.
	    pub tsm_fo: Option<f64>,
	    #[pyo3(get)]
	    /// Value of xi = Td / Tsm at BBN.
	    pub xi_bbn: Option<f64>,
	    #[pyo3(get)]
	    /// Value of xi = Td / Tsm at CMB.
	    pub xi_cmb: Option<f64>,
	    #[pyo3(get)]
	    /// Relic density of the eta.
	    pub rd_eta: Option<f64>,
	    #[pyo3(get)]
	    /// Relic density of the delta.
	    pub rd_del: Option<f64>,
	    #[pyo3(get)]
	    /// dNeff at CMB.
	    pub dneff_cmb: Option<f64>,
	    #[pyo3(get)]
	    /// dNeff at BBN.
	    pub dneff_bbn: Option<f64>,
	    #[pyo3(get)]
	    /// Value of sigma_eta / m_eta.
	    pub eta_si_per_mass: Option<f64>,
	    #[pyo3(get)]
	    /// Value of sigma_del / m_del.
	    pub del_si_per_mass: Option<f64>,
	}
	
	#[pymethods]
	impl DarkSun {
	    #[new]
	    /// Create a new DarkSun object
	    pub fn new(n: usize, lamc: f64) -> Self {
	        DarkSun {
	            n: n,
	            lamc: lamc,
	            xi_inf: 1e-2,
	            c: 1.0,
	            lec1: 1.0,
	            lec2: 1.0,
	            adel: 1.0,
	            mu_eta: 1.0,
	            mu_del: 1.0,
	            m_eta: lamc / (n as f64).sqrt(),
	            m_del: lamc * n as f64,
	            xi_fo: None,
	            tsm_fo: None,
	            xi_bbn: None,
	            xi_cmb: None,
	            rd_eta: None,
	            rd_del: None,
	            dneff_cmb: None,
	            dneff_bbn: None,
	            eta_si_per_mass: None,
	            del_si_per_mass: None,
	        }
	    }
	    #[getter]
	    pub fn get_n(&self) -> PyResult<usize> {
	        Ok(self.n)
	    }
	    #[getter]
	    pub fn get_lamc(&self) -> PyResult<f64> {
	        Ok(self.lamc)
	    }
	    #[getter]
	    pub fn get_mu_eta(&self) -> PyResult<f64> {
	        Ok(self.mu_eta)
	    }
	    #[getter]
	    pub fn get_mu_del(&self) -> PyResult<f64> {
	        Ok(self.mu_del)
	    }
	
	    #[setter]
	    pub fn set_n(&mut self, n: usize) -> PyResult<()> {
	        self.n = n;
	        self.m_eta = self.mu_eta * self.lamc / (self.n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (self.n as f64);
	        Ok(())
	    }
	    #[setter]
	    pub fn set_lamc(&mut self, lamc: f64) -> PyResult<()> {
	        self.lamc = lamc;
	        self.m_eta = self.mu_eta * self.lamc / (self.n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (self.n as f64);
	        Ok(())
	    }
	    #[setter]
	    pub fn set_mu_eta(&mut self, mu_eta: f64) -> PyResult<()> {
	        self.mu_eta = mu_eta;
	        self.m_eta = self.mu_eta * self.lamc / (self.n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (self.n as f64);
	        Ok(())
	    }
	    #[setter]
	    pub fn set_mu_del(&mut self, mu_del: f64) -> PyResult<()> {
	        self.mu_del = mu_del;
	        self.m_eta = self.mu_eta * self.lamc / (self.n as f64).sqrt();
	        self.m_del = self.mu_del * self.lamc * (self.n as f64);
	        Ok(())
	    }
	}
7cb32ded0c8ce2add52d5b422fece2a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|6|1|V|rust
	//use cyphus_diffeq::prelude::OdeSolution;
	//use haliax_thermal_functions::prelude::*;
	use pyo3::prelude::*;
8df56b287963182ca107270cdd353a0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|2|46|v|rust
	DarSun
10ff52382032032f1d221dab4d419989|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|29|1|V|rust
	#[pymethods]
	impl DarkSun {
	    pub fn compute_xi(&self, tsm: f64) -> PyResult<f64> {
	        let res = match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        };
	        match res {
	            Ok(val) => Ok(val),
	            Err(err) => Err(exceptions::ValueError::py_err(format!(
	                "Failed to compute xi: {:?}",
	                err
	            ))),
	        }
	    }
	}
945f062634ad9d4cd93665ff3066310d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|43|1|V|rust
	        match res {
	            Ok(val) => Ok(val),
	            Err(err) => Err(exceptions::ValueError::py_err(format!(
	                "Failed to compute xi: {:?}",
	                err
	            ))),
	        }
3115f1783392f23e28877fd5f356dc8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|32|9|v|rust
	let res =
fcc44543a7b46e66c55869477a3105cc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|24|8|v|rust
	rust_ml
8a5fdc7644fd9bbda089cb2e52e2d0c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|165|1|V|rust
	    pub fn compute_xi(&self, tsm: f64) -> PyResult<f64> {
	        let res = match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        };
	        match res {
	            Ok(val) => Ok(val),
	            Err(err) => Err(exceptions::ValueError::py_err(format!(
	                "Failed to compute xi: {:?}",
	                err
	            ))),
	        }
	    }
6b783e107fba64098a51ad3dc511dffc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|183|1|V|rust
	#[pymethods]
	impl DarkSun {}
3c3dd5304f487f785ab0c25b35ca776c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|4|1|V|rust
	use pyo3::exceptions;
8f2a12fb72227b5c0d5e413c9cded664|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|1|1|V|rust
	use super::DarkSun;
0f340ccdaf351ca40ea55fa2227007f8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|4|1|V|rust
	use pyo3::exceptions;
	use pyo3::prelude::*;
d1efad72dc5b17dc66a46767c32fff40|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|8|12|v|rust
	internal
6801c14f769b992312f00a5f742c840d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|26|1|V|rust
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.internal_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        Ok(int * pre)
	    }
	
	    pub fn thermal_cross_section_2eta_2delta(&self, x: f64) -> PyResult<f64> {
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, zmin, f64::EPSILON).val;
	    }
ac0b216cfb4b7a25d87ee0d5a2489d4e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|8|1|V|rust
	    pub fn rust_scaled_cross_section_2eta_4eta(&self, z: f64) -> f64 {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	    }
	    pub fn rust_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
	    }
	
	    pub fn rust_thermal_cross_section_2eta_2delta(&self, x: f64) -> f64 {
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, zmin, f64::EPSILON).val;
	
	        pf * sig * int
	    }
3e35ad40a1cf22e1eb589acff113b66b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|61|1|V|rust
	    pub fn scaled_cross_section_2eta_4eta(&self, z: f64) -> PyResult<f64> {
	        Ok(self.internal_scaled_cross_section_2eta_4eta(z))
	    }
	
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.internal_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        Ok(int * pre)
	    }
	
	    pub fn thermal_cross_section_2eta_2delta(&self, x: f64) -> PyResult<f64> {
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, zmin, f64::EPSILON).val;
	    }
96518077bb03270d86735495e20c2021|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|62|1|V|rust
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
6add63fd990604fe599e9c88c0850c17|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|64|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
a4fe0b737a72321fb930c6310146cf96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|67|1|V|rust
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, zmin, f64::EPSILON).val;
	
	        pf * sig * int
2f81aa57a5887c2f4f0702c84efb00c7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|59|1|V|rust
	#[pymethods]
	impl DarkSun {
	    pub fn scaled_cross_section_2eta_4eta(&self, z: f64) -> PyResult<f64> {
	        Ok(self.rust_scaled_cross_section_2eta_4eta(z))
	    }
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_thermal_cross_section_2eta_4eta(x))
	    }
	
	    pub fn thermal_cross_section_2eta_2delta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_thermal_cross_section_2eta_2delta(x))
	    }
	}
1c105428027a90c7d193d58765ac3d20|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|188|1|V|rust
	    /// Compute the scaled (all prefactors/ mass dimensions removes) cross
	    /// section for 2eta -> 4eta as a function of z = cme / meta.
eeb27b6117234d4e59e58fda568f196d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|193|5|V|rust
	    /// Compute the scaled (all prefactors/ mass dimensions removes) cross
e75e8595da4e39daf7848e5cb13c46b3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|193|5|V|rust
	    /// section for 2eta -> 4eta as a function of z = cme / meta.
a8faf99e6003ba23e65f3581545df45f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|193|1|V|rust
	    /// Compute the thermally average annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta / Teta.
73769b23f6a76f8d831a2e894159d22b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|7|1|V|rust
	    pub fn rust_scaled_cross_section_2eta_4eta(&self, z: f64) -> f64 {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	    }
d4e21b1f965bc468ba61c017bb8c54f2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|21|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
9450708182b826571451e5de0412e401|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|17|1|V|rust
	    /// Cross section for 2eta -> 4eta with all prefactors included as a
	    /// function of the center of mass energy.
99f78c54130e752954404fff0707dcbd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|7|60|v|rust
	included
8fba3f60c030114f6f1ba5e9e21e156b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|8|25|v|rust
	center of mass energy.
d704f93c7c1352d9bf0aec4a9037aca8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|30|1|V|rust
	    pub fn rust_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let mut pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
	    }
b29aa95b8b5b5d3d31dd4c548c0d178e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|51|1|V|rust
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        pre *= x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
a2d4f5a31ee548826750f643c79a2f2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|30|1|V|rust
	    pub fn rust_scaled_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pre = x / (den * den);
e6e8ecd157c070a6a2d9cdb69aada436|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|30|12|v|rust
	rust_scaled_thermal_cross_section_2eta_4eta
b07286ebbb5bc7aa91cc3eaa8bc19711|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|31|42|v|rust
	removed
e3ebef4bbf6bd4c7cb5048ee09074a7c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|30|1|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta with all prefactors REMOVED as a function of x = meta/Teta,
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
b3461745d64b12346503b2980e436db5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|48|42|v|rust
	REMOVED
83cd0a32d597f92a7837164b73689605|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|48|22|v|rust
	with all prefactors  
7d99a02973bb54b28cb1760db5ed9e63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|49|5|V|rust
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
9cbd949a56e8f0132819a2e7ee8fb94a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|49|5|V|rust
	    /// has been removed.
41c27868b3bd779d0ce55c1362e28e53|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|47|1|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta/Teta,
2adfeecaeff8f02b634b96f3b60c394f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|58|1|V|rust
	    /// Compute the
43e1c72b52419f89183db132af793e44|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|7|1|V|rust
	    /// Cross section for 2eta -> 4eta with all prefactors REMOVED as a
	    /// function of the scaled center-of-mass energy z = cme / meta.
	    pub fn rust_scaled_cross_section_2eta_4eta(&self, z: f64) -> f64 {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	    }
	    /// Cross section for 2eta -> 4eta with all prefactors included as a
	    /// function of the center-of-mass energy.
	    pub fn rust_cross_section_2eta_4eta(&self, cme: f64) -> f64 {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	        pre * self.rust_scaled_cross_section_2eta_4eta(cme / self.m_eta)
	    }
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta with all prefactors REMOVED as a function of x = meta/Teta,
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
	    pub fn rust_scaled_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pre = x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
	    }
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta/Teta,
	    pub fn rust_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	        pre * self.rust_scaled_thermal_cross_section_2eta_4eta(x)
	    }
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 2delta as a function of x = meta/Teta,
	    pub fn rust_thermal_cross_section_2eta_2delta(&self, x: f64) -> f64 {
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, zmin, f64::EPSILON).val;
	
	        pf * sig * int
	    }
3d9f979803a06bf230c9767bb7c0fdf5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|188|1|V|rust
	    /// Compute the scaled (all prefactors/ mass dimensions removes) cross
	    /// section for 2eta -> 4eta as a function of z = cme / meta.
	    pub fn scaled_cross_section_2eta_4eta(&self, z: f64) -> PyResult<f64> {
	        Ok(self.rust_scaled_cross_section_2eta_4eta(z))
	    }
	    /// Compute the thermally average annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta / Teta.
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_thermal_cross_section_2eta_4eta(x))
	    }
	    /// Compute the thermally average annihilation cross section for
	    /// 2eta -> 2delta as a function of x = meta / Teta.
	    pub fn thermal_cross_section_2eta_2delta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_thermal_cross_section_2eta_2delta(x))
	    }
6a09f4b229bc1fcc48f362c2efa25c48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|195|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	        pre * self.rust_scaled_cross_section_2eta_4eta(cme / self.m_eta)
7554b947ab085258d2e544e2ad50d029|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|201|1|V|rust
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pre = x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
9ae61c7a5fc2d44391548e88955ccd3b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|205|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let l1 = self.lec1;
	        let norm = 7.6770415885086560e6; // (256 pi^4/9)^2
	        let pre = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
	        pre * self.rust_scaled_thermal_cross_section_2eta_4eta(x)
18ddab0418287f40a99a519fb4d11811|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|191|1|V|rust
	        Ok(self.rust_scaled_cross_section_2eta_4eta(z))
15277dbb7fcb3586f21dd440e523cd2e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|191|1|V|rust
	        Ok(self.rust_scaled_cross_section_2eta_4eta(z))
	    }
48fa9adc006aa64967ccf18d5088c2db|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|203|28|v|rust
	_cross_section_2eta_4eta(z))
4ac0c98517b69a50578277e471fca42d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|203|1|V|rust
	        Ok(self.rust_scaled_thermal_cross_section_2eta_4eta(x))
3f4de798500d2c2eebff8f86e67a990a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|203|1|V|rust
	        Ok(self.rust_scaled_thermal_cross_section_2eta_4eta(x))
	    }
446901a0d17d286957436ba401858370|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|209|1|V|rust
	        Ok(self.rust_thermal_cross_section_2eta_4eta(x))
98c453d114f49877fbea9ef7577c0468|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|200|1|V|rust
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
400b95db598774dbdfbb14c5ec11ae12|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|8|1|V|rust
	use model::compute_xi::*;
702bb2bee50dcfa36ced958b47f2342b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|70|1|V|rust
	/// Compute the integrated squared matrix element for 2eta -> 4eta in the
	/// center of mass frame with scaled center-of-mass energy z = cme / meta.
	pub fn scaled_integrated_matrix_element(z: f64) -> (f64, f64) {
	    // Scaled masses.
	    let masses = vec![1.0, 1.0, 1.0, 1.0];
	    let nevents = 50000;
	    // Incomping particle momenta.
	    let p1 = FourMomentum {
	        e: z / 2.0,
	        px: 0.0,
	        py: 0.0,
	        pz: (z * z / 4.0 - 1.0).sqrt(),
	    };
	    let p2 = FourMomentum {
	        e: z / 2.0,
	        px: 0.0,
	        py: 0.0,
	        pz: -(z * z / 4.0 - 1.0).sqrt(),
	    };
	
	    let msqrd = |fm: &Vec<FourMomentum>| {
	        let p3 = fm[0];
	        let p4 = fm[1];
	        let p5 = fm[2];
	        let p6 = fm[3];
	
	        let diag1 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p3, &p4, &p5, &p6, &(p4 + p5 + p6));
	        let diag2 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p4, &p3, &p5, &p6, &(p3 + p5 + p6));
	        let diag3 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p5, &p4, &p3, &p6, &(p3 + p4 + p6));
	        let diag4 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p6, &p4, &p5, &p3, &(p3 + p4 + p5));
	        let diag5 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p4, &p2, &p5, &p6, &(-p2 + p5 + p6));
	        let diag6 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p5, &p4, &p2, &p6, &(-p2 + p4 + p6));
	        let diag7 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p6, &p4, &p5, &p2, &(-p2 + p4 + p5));
	        let diag8 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p5, &p2, &p3, &p6, &(-p2 + p3 + p6));
	        let diag9 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p6, &p2, &p5, &p3, &(-p2 + p3 + p5));
	        let diag10 = mat_elem_2_to_4_diag_4pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4));
	        //let diag11 = mat_elem_2_to_4_diag_6pt(&p1, &p2, &p3, &p4, &p5, &p6);
	
	        (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
	            .powi(2)
	            .abs()
	    };
	    Rambo::integrate_phase_space(&masses, z, &msqrd, nevents)
	}
c341d0be2deb0a842e3a3dd946618a47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|106|9|V|rust
	        //let diag11 = mat_elem_2_to_4_diag_6pt(&p1, &p2, &p3, &p4, &p5, &p6);
1f2cca84bad70b8ace5d57664eaf918a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|139|1|V|rust
	        let diag1 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p3, &p4, &p5, &p6, &(p4 + p5 + p6));
	        let diag2 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p4, &p3, &p5, &p6, &(p3 + p5 + p6));
	        let diag3 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p5, &p4, &p3, &p6, &(p3 + p4 + p6));
	        let diag4 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p6, &p4, &p5, &p3, &(p3 + p4 + p5));
	        let diag5 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p4, &p2, &p5, &p6, &(-p2 + p5 + p6));
	        let diag6 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p5, &p4, &p2, &p6, &(-p2 + p4 + p6));
	        let diag7 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p6, &p4, &p5, &p2, &(-p2 + p4 + p5));
	        let diag8 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p5, &p2, &p3, &p6, &(-p2 + p3 + p6));
	        let diag9 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p6, &p2, &p5, &p3, &(-p2 + p3 + p5));
	        let diag10 = mat_elem_2_to_4_diag_4pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4));
71c4e2b203ecbac2c03bb7689e9b55a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|141|9|v|rust
	(diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
e4a047aaa72951a50fb7f1f843fd9f66|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|184|13|V|rust
	            .powi(2)
4ed0016c35262ad204f80680f1ec821d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|90|1|V|rust
	    let msqrd = |fm: &Vec<FourMomentum>| {
	        let p3 = fm[0];
	        let p4 = fm[1];
	        let p5 = fm[2];
	        let p6 = fm[3];
	
	        let diag1 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p3, &p4, &p5, &p6, &(p4 + p5 + p6));
	        let diag2 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p4, &p3, &p5, &p6, &(p3 + p5 + p6));
	        let diag3 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p5, &p4, &p3, &p6, &(p3 + p4 + p6));
	        let diag4 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p6, &p4, &p5, &p3, &(p3 + p4 + p5));
	        let diag5 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p4, &p2, &p5, &p6, &(-p2 + p5 + p6));
	        let diag6 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p5, &p4, &p2, &p6, &(-p2 + p4 + p6));
	        let diag7 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p6, &p4, &p5, &p2, &(-p2 + p4 + p5));
	        let diag8 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p5, &p2, &p3, &p6, &(-p2 + p3 + p6));
	        let diag9 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p6, &p2, &p5, &p3, &(-p2 + p3 + p5));
	        let diag10 = mat_elem_2_to_4_diag_4pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4));
	        //let diag11 = mat_elem_2_to_4_diag_6pt(&p1, &p2, &p3, &p4, &p5, &p6);
	
	        (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
	            .powi(2)
	            .abs()
	    };
08e3178a4d6c8489de30fcc1f90737ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|90|1|V|rust
	    let msqrd44 = |fm: &Vec<FourMomentum>| {
	        let p3 = fm[0];
	        let p4 = fm[1];
	        let p5 = fm[2];
	        let p6 = fm[3];
	
	        let diag1 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p3, &p4, &p5, &p6, &(p4 + p5 + p6));
	        let diag2 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p4, &p3, &p5, &p6, &(p3 + p5 + p6));
	        let diag3 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p5, &p4, &p3, &p6, &(p3 + p4 + p6));
	        let diag4 = mat_elem_2_to_4_diag_4pt(&p1, &p2, &p6, &p4, &p5, &p3, &(p3 + p4 + p5));
	        let diag5 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p4, &p2, &p5, &p6, &(-p2 + p5 + p6));
	        let diag6 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p5, &p4, &p2, &p6, &(-p2 + p4 + p6));
	        let diag7 = mat_elem_2_to_4_diag_4pt(&p1, &p3, &p6, &p4, &p5, &p2, &(-p2 + p4 + p5));
	        let diag8 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p5, &p2, &p3, &p6, &(-p2 + p3 + p6));
	        let diag9 = mat_elem_2_to_4_diag_4pt(&p1, &p4, &p6, &p2, &p5, &p3, &(-p2 + p3 + p5));
	        let diag10 = mat_elem_2_to_4_diag_4pt(&p1, &p5, &p6, &p4, &p2, &p3, &(-p2 + p3 + p4));
	        //let diag11 = mat_elem_2_to_4_diag_6pt(&p1, &p2, &p3, &p4, &p5, &p6);
	
	        (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
	            .powi(2)
	            .abs()
	    };
a5773c8459ca056ebdc1a76b79df44e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|120|1|V|rust
	        (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10)
	            .powi(2)
	            .abs()
88b40cb0da81b2b53087f73f3a9c7436|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|118|9|v|rust
	diag11 
46fbe39cfdc8637bdbc7b3af2227490f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|119|9|V|rust
	        diag11 * diag11
f5c0e21e0b20f293258e40cae4244cac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|137|5|V|rust
	    let int1 Rambo::integrate_phase_space(&masses, z, &msqrd, nevents)
ae3b28cde02542f81acce8783245430d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|137|9|v|rust
	int1
136664775c010869fe9687b3d5640d41|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|137|1|V|rust
	    let res1 =  Rambo::integrate_phase_space(&masses, z, &msqrd, nevents);
0004ef8b23db21bf00c8d8a75c3767ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|147|1|V|rust
	        let den = 2.0 * z * (z * z - 4.0).sqrt() * 24.0;
	        let res = scaled_integrated_matrix_element(z);
c268f3debbd967aee5a0250a858eddf1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|75|4|V|rust
	    let res = scaled_integrated_matrix_element(z);
f0f7ce344969aadf220aea6556c5d8ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|74|5|V|rust
	    let den = 2.0 * z * (z * z - 4.0).sqrt() * 24.0;
21ca41e5d38ebf7596ba75ecfa335ecf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|72|56|v|rust
	, f64), (f64, 
583870773a28dcab1e959c37a4cc4ada|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|144|48|V|rust
	/// Compute the scaled cross-section for 2eta -> 4eta for a given scaled
	/// center-of-mass energy z = cme / meta.
	pub fn scaled_cross_section_2_4(z: f64) -> f64 {
	    if z > 4.0 {
	        // 24 for 4! since 4 identical particles in final state
	        let den = 2.0 * z * (z * z - 4.0).sqrt() * 24.0;
	        let res = scaled_integrated_matrix_element(z);
	        res.0 / den
	    } else {
	        0.0
	    }
	}
549fbf76057a1610472743aece007e0b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|11|1|V|rust
	    let mut file_cs44 = std::fs::File::create("data/log_scaled_cs_data_cs.dat")?;
c8b051d8679a7d0bc6a9524ec200aaea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|20|1|V|rust
	        file_cs.write(format!("{}\n", cs.log10()).to_string().as_bytes())?;
bc57a1a6edea5f796c9c9713269d2a0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|24|1|V|rust
	    println!(
	        "{:?}",
	        Command::new("python")
	            .arg("data/fit_cs_data.py")
	            .output()
	            .unwrap()
	    );
7991ec97e49a662fa31e8957d41b0427|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/fit_cs_data.py|1|1|V|python
	import numpy as np
	import matplotlib.pyplot as plt
	from scipy.optimize import curve_fit
	
	if __name__ == "__main__":
	    data_zs = np.genfromtxt("data/log_scaled_cs_data_zs.dat")
	    data_cs = np.genfromtxt("data/log_scaled_cs_data_cs.dat")
	    last_100_zs = data_zs[-100:]
	    last_100_cs = data_cs[-100:]
	
	    def model(x, m, b):
	        return m * x + b
	
	    popt, _ = curve_fit(model, last_100_zs, last_100_cs)
	    print(popt)
f7cb99973061fb024bfa3d1a27eeb180|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|45|v|rust
	.log10()
23bc0699aed6181cc240b526fe1e8204|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|25|1|V|rust
	            cs.0 + cs.1 + cs.2
3151895b1a8dedb3e83b54e203637683|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|20|60|v|rust
	, {:e}
e77f848ebbae19a99eee74e4d5246ce5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|15|50|v|rust
	150.0
841b89b283fbb3066b6c09566fd2c15c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|18|9|v|rust
	z, cs
a2751ef651c0aee56ed56ea65ad465eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|18|23|v|rust
	.zip(css.iter()) {
b777157e590c0f3618bc99f024ad9ebe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|16|5|V|rust
	    let css = zs.mapv(|z| scaled_cross_section_2_4(z));
2ba97ab212989423e2c282b36eb94fe8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|7|1|V|rust
	use std::process::Command;
591c1c7d5b3af7454e105077d128cfcd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|19|9|V|rust
	        println!("i = {}", i);
c492f1011dc1089272a2184b75acd352|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|18|23|v|rust
	.enumerate() {
a79a06c0a0ee0d16a811e8a6e684e7a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|15|29|v|rust
	linspace
cad8a362ef16fa7a0555433ebd607596|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|20|43|v|rust
	10f64.powf(*logz)
1fdda45804afb97f7922339cb410a121|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|19|32|V|rust
	        let z = 10f64.powf(*logz);
d32ce23e8eaeb9f7e6fe22444cf15d7f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|27|39|v|rust
	logz
c738bd8b9df7d32a9a73f0ea5cac3bd6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs44.dat|1|1|V|csv
	-21.619848012731406
	-9.641816061346494
	-8.551456781306602
	-7.900255586829307
	-7.425677799101529
	-7.05002163929024
	-6.73720526161475
	-6.4675925602925295
	-6.228054123262039
	-6.012862445042298
	-5.81827156940603
	-5.636978495249665
	-5.469588914975759
	-5.312316245091108
	-5.164814685567957
	-5.025015769422347
	-4.891915592385283
	-4.765110985229022
	-4.642952010537159
	-4.52587703104933
	-4.4131690471471
	-4.305343046448957
	-4.1993860427887535
	-4.09653896328271
	-3.99756100556169
	-3.9013498508083746
	-3.8079699234046234
	-3.715949010229925
	-3.6280704290319297
	-3.539366691596351
	-3.4544315628330664
	-3.3700286518979636
	-3.288506830855195
	-3.2080089416112454
	-3.1280634609430544
	-3.049949741099756
	-2.9745495432758147
	-2.898429279830391
	-2.824227352939147
	-2.7509504043110784
	-2.6796154200333238
	-2.608479880421362
	-2.538118151802318
	-2.468902369650168
	-2.40033471050014
	-2.3326817405187796
	-2.266680334916021
	-2.2002527949378172
	-2.135248126061985
	-2.0707818538450886
	-2.0067215400117417
	-1.9444186182618066
	-1.8810884668761405
	-1.8181877329447689
	-1.7572452819752509
	-1.6971996128401194
	-1.6365724521076888
	-1.575604541671091
	-1.5166521233070749
	-1.4578713205536
	-1.3994066647356829
	-1.3416446384272227
	-1.2841523934464916
	-1.2253981987155276
	-1.1704809759127777
	-1.113524195571263
	-1.0576875292968393
	-1.002042120720549
	-0.9461458495501945
	-0.891455263007457
	-0.8367657446282164
	-0.7820677921860941
	-0.7282455031258876
	-0.6742418772669205
	-0.6209674446220198
	-0.5685482133849051
	-0.5157464360060401
	-0.4628133752946946
	-0.4112980903508665
	-0.35915491320696585
	-0.3068316502567353
	-0.2552484023023076
	-0.20426939870897284
	-0.15331445148631553
	-0.10206752228532442
	-0.05195187757165768
	-0.0011121512357502078
	0.04958566785785851
	0.09922176103108317
	0.14766449344967286
	0.19864681364604114
	0.24718882112299417
	0.2973859124735321
	0.3460506609091458
	0.39436592683995714
	0.44347812433626793
	0.49178273430428354
	0.5399298521811168
	0.5884134705889434
	0.6361865334592718
	0.6847646735622219
	0.7314916012406864
	0.7790757654575852
	0.8273292437727047
	0.8746038950285405
	0.9211137250076935
	0.9679449637028912
	1.0153666609011103
	1.0616900231101303
	1.1087078723076673
	1.154686351957733
	1.2010913776372762
	1.2475095175207318
	1.293839576454572
	1.3400912149883673
	1.38561534614327
	1.4318259305906968
	1.477068321018353
	1.522864883863765
	1.567311597256967
	1.6134241167493149
	1.6587576432326339
	1.704861699941428
	1.7493198357139856
	1.7937577468695458
	1.8384381489014425
	1.882720245616654
	1.9281262952460787
	1.9727171660107592
	2.01666357319995
	2.0620543951246573
	2.105767062163921
	2.1510246776979938
	2.1937385650876298
	2.2386127524107877
	2.2824205980333847
	2.3267093171153683
	2.370561618325453
	2.4140174800875287
	2.4584258592605925
	2.502319559131667
	2.545210820260769
	2.589224857684307
	2.632728012406601
	2.67589580638328
	2.7192217432987467
	2.7621364374969115
	2.805356711045202
	2.8481984241120357
	2.8920969938212964
	2.934885774557642
	2.977889642899121
	3.0211653913307983
	3.0637158533037208
	3.106490258832232
	3.1496073463425254
	3.191751686087334
	3.2339241927878453
	3.2774174457708156
	3.3185434847212854
	3.362339131898067
	3.4045312897972546
	3.4464913296097817
	3.489052841823736
	3.5319192169181983
	3.5736746116248086
	3.6158349336961737
	3.6588073537155044
	3.6995262378837905
	3.7431864878996697
	3.7841524591067155
	3.826684356996295
	3.8689790289162054
	3.9102838710074947
	3.9521179139998774
	3.994324444886534
	4.0354998669827
	4.077342193349932
	4.118750290523519
	4.160933188389255
	4.202926139317832
	4.244340362072028
	4.286670424108496
	4.326807406438237
	4.369721200584185
	4.410650632613904
	4.4517126450705256
	4.492759375171014
	4.535045467297046
	4.57568262898968
	4.61654684907699
	4.658607508667615
	4.700147118864058
	4.741623515694294
	4.781658235063012
	4.823876682004514
	4.864721962919626
	4.9056956983287385
	4.946448022520808
	4.987628664348778
	5.029477587155127
	5.070348959370736
	5.111444978294471
	5.152256224770387
	5.19312780411119
	5.233739225454103
	5.273991497692523
	5.315874504374847
	5.356502810916267
	5.396722907715186
	5.438767745219172
	5.4790636145479406
	5.519140139561516
	5.560103707365316
	5.600728129615255
	5.641087358803533
	5.682733738949423
	5.723267876411713
	5.762536474009791
	5.8041100567830854
	5.844471517518016
	5.885506633249391
	5.926347505003673
	5.966700027475388
	6.007358470751043
	6.047147237113871
	6.087789019425609
	6.1282029041645165
	6.167843308981729
	6.209338165158138
	6.249780021997567
	6.2904015096065296
	6.329770356281181
	6.370047577061625
	6.410049129105573
	6.45129560282116
	6.492144813168217
	6.532652248175582
	6.5727150161961205
	6.61260183885047
	6.652754287647936
	6.6927474423314015
	6.733335938338978
	6.7741979098134
	6.8138149060405455
	6.853938962634256
	6.89488967954436
	6.934215162112538
	6.9746640590405855
	7.015823643889912
	7.054512130920071
	7.094931663112658
	7.135013597399961
	7.17510046087007
	7.215091662220033
	7.254774770595356
	7.294994360110425
	7.33520590590205
	7.375758187210575
	7.41520686649303
	7.454880568764483
	7.494940389377684
	7.534887524347708
	7.575043871910054
	7.615589588859924
	7.65502561291211
	7.6950796817919676
	7.735924143345745
	7.774630700098285
	7.8148442658493025
	7.854725374554685
	7.894386899881939
	7.9349842678351346
	7.974440628836767
	8.013718257612842
	8.054167259720824
	8.09374682221771
	8.133312691394028
	8.173985705276628
	8.213281449123677
	8.252899308969916
	8.292722126331531
	8.332107206768777
	8.37270845161477
	8.413124995613595
	8.452503582859324
	8.492917645042667
	8.531575701585192
	8.571629684058657
	8.611353830327676
	8.651587740505144
	8.691029791132742
	8.730195880654083
	8.770513677990103
	8.809763589460092
	8.849642685921289
	8.889926167639905
	8.929577713656485
	8.967973289902101
	9.008281470403796
	9.047053731923212
	9.088099779850559
	9.127833840236566
	9.167304077773649
	9.206808229346152
	9.24702970307382
	9.285944239413803
	9.325355686800826
	9.365985698518381
	9.404623658324825
	9.44388292541514
	9.484610560271724
	9.52373855885132
	9.563932779013749
	9.602525489505942
	9.642207204310791
	9.681164757860172
	9.72209147903615
	9.762012069817393
	9.800923096730745
	9.841114959883466
	9.879469979234221
	9.919052303019178
	9.959503366322252
	9.998320324867807
	10.038463208369004
	10.078419890018647
	10.117181953221555
	10.157278524260477
	10.196375522339038
	10.236255501636142
	10.274909008791184
	10.315396607435828
	10.354302226830509
	10.393284564249845
	10.432774538030452
	10.472946358516614
	10.511931098267747
	10.552427464995917
	10.59154633085244
	10.630858224655402
	10.669867806258644
	10.709134462128041
	10.749516990234868
	10.788003075385086
	10.828941590350935
	10.867951652235297
	10.90686983101088
	10.9468146196196
	10.986190161800845
	11.025152370350103
	11.064750932572602
	11.105292290262165
	11.14364950264913
	11.183803659597531
	11.222916554157877
	11.263123960004592
	11.3019173958011
	11.341350877655458
	11.380669442294
	11.419643063134897
	11.459701481403059
	11.498233309685993
	11.538643290766576
	11.577554945820696
	11.617334274651391
	11.656157157825671
	11.69556619781937
	11.734757936595813
	11.774415598229234
	11.814538408779988
	11.854177706493573
	11.892752597740602
	11.932349954837935
	11.970923393235891
	12.011186966505754
	12.050538473066442
	12.089612763092925
	12.129098154330519
	12.168593036973373
	12.207547773246638
	12.24678273110122
	12.286789715995448
	12.325651030131311
	12.364828931677833
	12.405385369124287
	12.444334445543223
	12.48339802839249
	12.522334544156283
	12.562672279235386
	12.601499543663998
	12.640633479660597
	12.680158718670347
	12.720356146030005
	12.759293589397517
	12.798773059237451
	12.838314275488468
	12.877279466873215
	12.916707826295536
	12.955696401447044
	12.995228463791843
	13.034218469474473
	13.074840714876515
	13.112843444638042
	13.152104453025185
	13.191399818363628
	13.230415977659886
	13.271333233654095
	13.309549527148878
	13.34839005013559
	13.38846086771669
	13.427450879194911
	13.466521079951347
	13.507208991969122
	13.54588250147923
	13.58417628681098
	13.623898479753539
	13.664022291682077
	13.703893167049195
	13.74260667435688
	13.78093902677215
	13.820939150044314
	13.859172127279233
	13.899118318503167
	13.939605156009527
	13.977938801866308
	14.017736874010126
	14.056269469315824
	14.095997612632786
	14.135851587310016
	14.174641725492853
	14.214819016911388
	14.253611940743397
	14.292618937304804
	14.33207465034109
	14.37154827367178
	14.410074198914588
	14.449703380693878
	14.489430566182794
	14.528244387604119
	14.567226310772405
	14.607053674766169
	14.647030933654868
	14.685785712605425
	14.724418691943626
	14.76442519189912
	14.803689546713795
	14.842535557719238
	14.882141053694985
	14.921530944582726
	14.960042782772769
	14.99992096051535
	15.038329369555269
	15.078649220051338
	15.118107560609978
	15.157386895158142
	15.196152839762837
	15.23541289642696
	15.27480348946093
	15.314392953537421
	15.353935809985495
	15.392056239274908
	15.43136782259067
	15.471661165637936
	15.510528894627718
	15.548854955498836
	15.588786895190285
	15.62732637518205
	15.667218542015426
	15.707596110546403
	15.746498247082334
	15.785704992644588
	15.825051691832126
	15.863571007384362
	15.902931091761076
	15.942378188427144
	15.982270793480417
	16.021079775029957
	16.06046235980317
	16.099051421355515
	16.138864667122306
	16.177738510201564
	16.217640802370553
	16.257497451744737
	16.295423095106443
	16.334824066247258
	16.374189841211756
	16.41314189402594
	16.453481414051666
	16.49208797111893
	16.531902657980062
	16.570464757066272
	16.609158113932512
	16.64902721389431
	16.68867211153959
	16.727444484674475
	16.765829524102287
	16.806159388752278
	16.845467104553826
	16.8849351660208
a9629e15c31f5c265d521152251ff1f9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|513|1|V|rust
	    pub static ref LOG_ETA_CS44: Array1<f64> = arr1(&[
1e0f0a1901083e2bc9122df7a88ffb5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1015|1|V|rust
	    pub static ref LOG_ETA_CS44: Array1<f64> = arr1(&[
	    ]);
f3c3a3afa5a20c3025577336261b2270|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs66.dat|1|1|V|csv
	-22.611516111524036
	-10.632992023170058
	-9.542017152700993
	-8.889792340576786
	-8.415688017556324
	-8.040031919094137
	-7.726126600503797
	-7.4553852684766
	-7.215939587749034
	-7.001353268111213
	-6.804762432834192
	-6.62347608084882
	-6.455745259637879
	-6.29835018139914
	-6.149865556843243
	-6.009285118765992
	-5.876265547436385
	-5.748785483820548
	-5.626530225731229
	-5.508836897045465
	-5.395385612266104
	-5.286553015825434
	-5.18067799177242
	-5.077715878526032
	-4.979730615549895
	-4.882103736897821
	-4.7878162288997155
	-4.695857796549309
	-4.6065118712436535
	-4.5192104731572105
	-4.432173077261211
	-4.348257535901129
	-4.265797348637414
	-4.184540254308319
	-4.105074029767912
	-4.026378256295249
	-3.9490578920867194
	-3.8743289937240597
	-3.7996948284078718
	-3.7264137357490754
	-3.653244635708397
	-3.5818686282314753
	-3.5115625075442254
	-3.44171195612264
	-3.3735397700928114
	-3.30535459292181
	-3.238533120034017
	-3.1722081245714784
	-3.1066830757015302
	-3.041372193317043
	-2.9771454808436375
	-2.9140178077283525
	-2.850962496769392
	-2.7883219868528015
	-2.726811517789525
	-2.665483512169479
	-2.6044547752376084
	-2.543609954203882
	-2.4841096200197343
	-2.4251806050031592
	-2.3662842558873933
	-2.307482429931646
	-2.2501407668923545
	-2.1918067657191265
	-2.134795881631077
	-2.0782080068496476
	-2.022682331610046
	-1.9652860602523856
	-1.91049982662136
	-1.8547228922050742
	-1.799784505338777
	-1.7448855344494782
	-1.6910749285275328
	-1.6369127482689239
	-1.5831243329544393
	-1.5293558884255627
	-1.4763631231213765
	-1.4234373707183856
	-1.3714637760842838
	-1.3190459766706732
	-1.2658556669522762
	-1.2148574606525049
	-1.1623779116229687
	-1.1115509641776231
	-1.0601206725065881
	-1.0095122207675482
	-0.9596680016391277
	-0.9080892606198578
	-0.8578719365014424
	-0.8075066185376473
	-0.7579326993707517
	-0.707981704915058
	-0.6586659461838819
	-0.6090585493823532
	-0.5603002780968049
	-0.5110875183966955
	-0.46259221890815516
	-0.4139813702889496
	-0.3648536188910725
	-0.31743735263427764
	-0.26874910325181084
	-0.22114878618844702
	-0.1731424334169522
	-0.12494828429021843
	-0.07858029521773112
	-0.030123472344080898
	0.01676574238082601
	0.06439434907254105
	0.11052398936868646
	0.15793133871340304
	0.20488889297954913
	0.2510566408532481
	0.2978399334952734
	0.34394349210255953
	0.3902545840314406
	0.43617595118787356
	0.48348240195140235
	0.5290494985690039
	0.573780674240253
	0.620083990850059
	0.6657568410048751
	0.7117207524102417
	0.7572436399630504
	0.8017930006832061
	0.8469393488812081
	0.8929727458684582
	0.9368822560119917
	0.9828132472931451
	1.0277754859864734
	1.071305030733247
	1.1157162031730685
	1.1605854291744777
	1.2054310410869475
	1.2505501860994737
	1.2938225443611124
	1.3393260691437576
	1.383185573301589
	1.4267035400937378
	1.4718171945498937
	1.5153613621356528
	1.5584934525840355
	1.6021763912869316
	1.646609969933948
	1.6902240464043647
	1.7339220561848674
	1.777034471169976
	1.8204055334780511
	1.8644440119694297
	1.9075706018673693
	1.9508822584596732
	1.99340090569433
	2.0372407718285572
	2.0801828823994786
	2.1228522390403546
	2.1661703926797626
	2.210033898072229
	2.2515848146211366
	2.294745123204864
	2.3375215003271057
	2.380216690269494
	2.422657564070804
	2.465002692327691
	2.5078924150852444
	2.55080692164275
	2.5937508632243214
	2.635489169265763
	2.6789578300129304
	2.720464547001851
	2.762892879427058
	2.8058957084859752
	2.8477705070387738
	2.889491904812506
	2.9320796627799752
	2.9740815303190886
	3.01560878427058
	3.0579500216900994
	3.0996449268317092
	3.1414860843877226
	3.1831349459989573
	3.2254595308290828
	3.2676498565762246
	3.308580402508282
	3.3505618696163406
	3.392906536998799
	3.4336855546051375
	3.4752479934098206
	3.517380349876575
	3.5587255306647796
	3.600195813524539
	3.642025535383814
	3.683343247365791
	3.7252368373509275
	3.7660385088677204
	3.807072498293808
	3.8483802378065533
	3.8902461709192866
	3.931556475373467
	3.973647304825333
	4.013517177394448
	4.055008474563573
	4.096462689935116
	4.138020261878739
	4.17838651002127
	4.219933393832434
	4.260925303052938
	4.301313759451742
	4.3431986525544835
	4.383776548152048
	4.424708538015275
	4.465895015312071
	4.5067183358805325
	4.547358917602971
	4.587871817376243
	4.629080872013805
	4.669542969935199
	4.710489347784034
	4.750422163205947
	4.792331786862219
	4.832435055804869
	4.873544476947836
	4.915177632717313
	4.955366900738315
	4.99556869172314
	5.036026005815261
	5.076350466166576
	5.1177293655041876
	5.158173835633094
	5.197991826290236
	5.239735109381815
	5.27982598105327
	5.320436157446755
	5.359514773431538
	5.400502231210395
	5.441579966744102
	5.481762215913735
	5.523100024595553
	5.5638629208259305
	5.603176043519362
	5.643628599794358
	5.683706131440063
	5.724606491586047
	5.764535087301105
	5.805154192410685
	5.845221766422853
	5.885641730765333
	5.925250285701137
	5.966029175742146
	6.006015076617536
	6.046697913601031
	6.086330605800286
	6.126937416622098
	6.167314283159634
	6.207222109629139
	6.246924100060061
	6.287138671061964
	6.327931793268276
	6.367255823390625
	6.408023478454109
	6.447541840457392
	6.489148235189086
	6.528017107915731
	6.569115125754748
	6.6088582102069315
	6.648765803865664
	6.688497060705304
	6.72823216532066
	6.768676427573359
	6.808152415324037
	6.848382394871664
	6.887374546385144
	6.927720036007096
	6.967926759879252
	7.008321115759833
	7.0483114747484334
	7.088321050057336
	7.128194289897136
	7.168666976297389
	7.207603383645611
	7.246882732387075
	7.287471998862112
	7.327410500007831
	7.367845640832448
	7.407123685365239
	7.446768026099291
	7.486688411815105
	7.526445339908116
	7.566170562407687
	7.605670363967726
	7.6474161815504464
	7.6857101190739465
	7.726245173223663
	7.765144468078946
	7.804440699345711
	7.845044517185898
	7.884826177517114
	7.924579798896648
	7.964982598050968
	8.00304934755741
	8.043630588690888
	8.083815347558804
	8.122860728888153
	8.163181215414543
	8.201727559755472
	8.243099272518277
	8.282190353574238
	8.321495254080153
	8.361341983783646
	8.401613755630255
	8.439951551025985
	8.480917524656741
	8.51986362659945
	8.559403845358744
	8.598477124005553
	8.638058797787764
	8.67924469764703
	8.719173907136662
	8.758223067796143
	8.797665103056538
	8.836452678221564
	8.876965698230602
	8.917173750973907
	8.95618956627081
	8.994751679803787
	9.034882807861205
	9.074778901040904
	9.113592321140112
	9.15456844998911
	9.193618194856265
	9.232329743852924
	9.272511310402448
	9.311602743299888
	9.35123536300333
	9.390115430276666
	9.429802328242733
	9.470221259302225
	9.509526505609823
	9.548871321397282
	9.589264976134503
	9.629135928322652
	9.668069649083593
	9.706757936827938
	9.746626010580487
	9.786713465521808
	9.825279483622916
	9.864967129970205
	9.904824820338515
	9.9439307106843
	9.9836742118414
	10.023311211435425
	10.061965077293882
	10.102150158241619
	10.142509765868052
	10.181140999657684
	10.220366679453912
	10.259631784492889
	10.299025810131697
	10.338736884777667
	10.37835268421337
	10.417611273216435
	10.456887472075199
	10.497048147320772
	10.535468699664403
	10.575982441815073
	10.615136350261709
	10.654517196532641
	10.693013591261625
	10.73356456938134
	10.772729494241865
	10.812281856333877
	10.851150811184684
	10.891665747043096
	10.93087524519868
	10.96965271585084
	11.008684177538765
	11.049243941194673
	11.089162632152682
	11.127345582225715
	11.166069462160811
	11.20627699550346
	11.245818391965031
	11.286062008374053
	11.324083447217225
	11.36365750149118
	11.403613156740942
	11.442964685729105
	11.482357213489987
	11.520947965243405
	11.561114319053093
	11.600130737461516
	11.639648594732522
	11.67903789777543
	11.718365064004844
	11.75723920050444
	11.796189397631267
	11.835982734229479
	11.875695436044571
	11.914890429264634
	11.955554374412175
	11.993386760847528
	12.033387759155818
	12.072051629099176
	12.112493273874197
	12.150753857202107
	12.190159838360884
	12.229824748292138
	12.26974742681362
	12.308736542250825
	12.348295095924334
	12.387674764951564
	12.426760316119832
	12.46561183675159
	12.506085925326785
	12.545256816104969
	12.584482148892496
	12.623962152576402
	12.663250058216894
	12.701805824799557
	12.741405598486105
	12.780872108242821
	12.819777667430605
	12.859055315542777
	12.898218481285424
	12.937537166937123
	12.97657375825411
	13.016482596026412
	13.057270615204462
	13.094789936308779
	13.13412186972364
	13.17302988864656
	13.21308286343717
	13.251940206058139
	13.291729903706171
	13.331323128824032
	13.370424425696749
	13.409545162526369
	13.449147366666867
	13.488140073324043
	13.527804651736806
	13.567400686065426
	13.606155961150442
	13.645521570142717
	13.684635666703167
	13.723833653864931
	13.763634493682352
	13.802914620318042
	13.842799479471465
	13.881397078009666
	13.9206483936022
	13.960020862192483
	13.999548114923268
	14.038235928164054
	14.077341561247207
	14.116920973458136
	14.156947479152178
	14.194954187625074
	14.234855013516453
	14.274251866679123
	14.312494648550766
	14.352868006117133
	14.392456756773674
	14.4310905127545
	14.47098074992516
	14.509933513389905
	14.54918399950655
	14.588508132691507
	14.627546664674128
	14.666861057070683
	14.70676175371115
	14.745379314609705
	14.785182807949088
	14.823730180453692
	14.863028935370503
	14.902876504922377
	14.942038768711633
	14.980633976119877
	15.02021603902256
	15.059933822562812
	15.099322467305992
	15.137247886792006
	15.178119133482484
	15.215935101549414
	15.255559398618729
	15.294673811717768
	15.33453139101627
	15.37401800315128
	15.412655341901033
	15.452394135641972
	15.491870270885913
	15.530776954155185
	15.569834983583142
	15.609400504044768
	15.649366033552704
	15.688002150858301
	15.726580928127945
	15.76674713098938
	15.805567724365602
	15.844440175457747
	15.883899038694118
	15.92335799707269
	15.962708324663367
dc4867a4bd80265a14a183a966335b10|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|513|20|v|rust
	LOG_ETA_CS44
54a9f986e16858217bea7db9cf94e3a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs46.dat|1|1|V|csv
	-22.115113502323208
	-10.137941858904236
	-9.048006743685391
	-8.394403943535742
	-7.919847296345437
	-7.545176324224815
	-7.231230010059101
	-6.96101438083237
	-6.722369731536322
	-6.507557125539073
	-6.310633930639443
	-6.131039739836928
	-5.96270453797542
	-5.8052800814814205
	-5.657059056824217
	-5.516899229543687
	-5.384436647749207
	-5.256868134006969
	-5.134617802202615
	-5.018330843123485
	-4.9046379036107455
	-4.795639749902748
	-4.69018876864411
	-4.5876925702874045
	-4.488960452378587
	-4.392184804781401
	-4.297195535246655
	-4.205896215653972
	-4.117057477813804
	-4.0292736892198775
	-3.9427224980781896
	-3.8590727473793285
	-3.7767294514744645
	-3.695706286462534
	-3.6169835073374537
	-3.5390461357671876
	-3.461473342573769
	-3.3856914609316306
	-3.3119123744102352
	-3.238928158068324
	-3.1668617041131166
	-3.094850723680608
	-3.025076655259788
	-2.9554981524271136
	-2.887739025066566
	-2.8195503766382832
	-2.7531571133533714
	-2.685588284818227
	-2.621321682021114
	-2.556126085017686
	-2.4924757961956954
	-2.42839254992488
	-2.3656881726468364
	-2.3037436759927536
	-2.2420089405465853
	-2.1808316881660503
	-2.120157056311918
	-2.0599208660650308
	-2.000471578034251
	-1.9410485540099003
	-1.8826436689781327
	-1.8236616723183154
	-1.7669230334478845
	-1.7098875618835776
	-1.6533234650782869
	-1.5960851758627588
	-1.539194458470061
	-1.4834878397673914
	-1.4289882369006308
	-1.373487208396718
	-1.3193322982438833
	-1.2639485937679937
	-1.2088087629702293
	-1.1556765254292831
	-1.1025952141189317
	-1.049231222629876
	-0.9960815564813826
	-0.9435845683022888
	-0.8907069316295102
	-0.8390126444878462
	-0.7873976186458809
	-0.7353665662897141
	-0.683807034887797
	-0.6325440510526581
	-0.5814679907745798
	-0.530373638027025
	-0.4799878461187316
	-0.4307616832504425
	-0.37992068833414244
	-0.3295666117169489
	-0.28034917956783406
	-0.23059075370153512
	-0.18060913222534922
	-0.13195301044288824
	-0.0831790218849953
	-0.03413814424760673
	0.01457282665591891
	0.06280915038155611
	0.11156212110557726
	0.15940885903133503
	0.20742984784746665
	0.25600461032823313
	0.3031860619895071
	0.3503956898099518
	0.39826486858646487
	0.4454064795067462
	0.4933579389519969
	0.53912149272081
	0.5860659497179407
	0.6328853090408739
	0.6806099534405778
	0.7258433215930198
	0.7732072270663886
	0.8184519036796178
	0.8652841176655142
	0.9112363453190545
	0.9567210124249053
	1.0021014090642555
	1.0483700683827248
	1.0939724270478355
	1.1397431780605312
	1.1843006331617727
	1.2307775300550166
	1.2747358551788215
	1.3197597733753796
	1.3650055410857598
	1.4099095477926928
	1.4545193040062718
	1.499804252382012
	1.5438024595555586
	1.589281975796949
	1.633178836221402
	1.6778335476325408
	1.722344423038942
	1.7668937659929407
	1.8106493424331631
	1.8544663861434725
	1.8983818804844703
	1.94250734578831
	1.9866036892721413
	2.0299395894750156
	2.073794721578951
	2.1170903398745393
	2.161120101243166
	2.2043306187751317
	2.2479229084598105
	2.2919258222959087
	2.3335397772091926
	2.3779176009838596
	2.4203906988830446
	2.4647488931139856
	2.507650474790287
	2.550171350252625
	2.5935656696198643
	2.6359597968891
	2.6792338360899284
	2.7223443096469975
	2.764079913774347
	2.806831181411865
	2.8499976876746174
	2.892374670590127
	2.9346170875710214
	2.977154873624247
	3.0198535814806333
	3.0626648973542254
	3.1046118104747054
	3.147134219919363
	3.1889835858709827
	3.231914034629668
	3.273889596934272
	3.315886729278747
	3.3568501761694503
	3.3991973320030824
	3.441781484683097
	3.4832169219898628
	3.5259308557257554
	3.567276680246116
	3.609546886197213
	3.651889500305528
	3.6928674941981403
	3.734821601531288
	3.775925269419995
	3.817623680335711
	3.859114924925349
	3.9007026498625654
	3.942725402100012
	3.9847521002134974
	4.026422401829424
	4.066602782273575
	4.108371192614671
	4.14958171484273
	4.191012428880699
	4.232833782378928
	4.273717493160613
	4.315013684737591
	4.356529246592934
	4.398265680367282
	4.438203510618307
	4.48002764996159
	4.520505853728773
	4.56162378310637
	4.6038030949933635
	4.644853502598223
	4.684772948045485
	4.726215931162057
	4.7669884180733115
	4.807316711601006
	4.849198650558109
	4.890043076160409
	4.93102532279884
	4.972297905076286
	5.0129467141391295
	5.053739014524186
	5.094220033851346
	5.134344979279539
	5.175000898903402
	5.2170653496348045
	5.257394758306326
	5.298407821825643
	5.338511739408584
	5.378716891389006
	5.420279550604222
	5.460642370159676
	5.500619144110211
	5.541677200112846
	5.582064006881813
	5.622042428095397
	5.663108974698889
	5.703425180878771
	5.744577038346672
	5.784143997964266
	5.824660221577721
	5.8653917007608385
	5.905951878842396
	5.946101039233048
	5.987293485988308
	6.027790152274389
	6.067304724527984
	6.107507034220363
	6.14797797024499
	6.1884165372867
	6.229541946611882
	6.268564243927271
	6.308969075286076
	6.348530130351557
	6.389677907354063
	6.429785297909832
	6.4704566155141405
	6.51039954784109
	6.550532100284011
	6.591083837488243
	6.630714718666928
	6.671007021362221
	6.710571358906028
	6.750707878393693
	6.791845879957809
	6.830394958569218
	6.871325467352239
	6.911048311156397
	6.951146829396727
	6.991054090777552
	7.03151840584423
	7.0717038552592975
	7.111100721290016
	7.151534621480813
	7.192119921243745
	7.230836134166222
	7.271017132388123
	7.311449379227487
	7.35073762821882
	7.390973394716511
	7.430547206538617
	7.470915382480991
	7.5102148195350695
	7.551137638330861
	7.590769276570093
	7.630646482028846
	7.6703823720134725
	7.70952188487925
	7.749645784376626
	7.790103716996095
	7.830239406771627
	7.869657414326647
	7.909343701625987
	7.9492818374751915
	7.988145780691143
	8.029836823241066
	8.067788625657467
	8.108606410848777
	8.147811919032932
	8.188761172692265
	8.227634467615685
	8.266652234768282
	8.308069730421423
	8.347247898993645
	8.385319445366791
	8.426677333796807
	8.46617015053137
	8.50541430134182
	8.545073372692016
	8.584380432200284
	8.624782478033303
	8.665094903461325
	8.704354988568152
	8.744491606775775
	8.783639299794196
	8.823268723960823
	8.862734249914249
	8.902373545747585
	8.942474623316109
	8.981988339040017
	9.020882947072078
	9.06047828739401
	9.100781659724312
	9.140494753847646
	9.180640558143807
	9.219743567306026
	9.259253374843489
	9.299020254976874
	9.337638353205266
	9.377593813734283
	9.41777579691654
	9.456823530014875
	9.49760001451645
	9.53634696659936
	9.575265883720252
	9.614452472944937
	9.6547371510436
	9.694007717761085
	9.73460133085925
	9.77375783653608
	9.813243979681749
	9.852518916934985
	9.89260136494742
	9.93165844403415
	9.971920767588243
	10.01080553123667
	10.049563311519103
	10.089493252238448
	10.12941115061394
	10.168544575101215
	10.208431572595902
	10.246841321246423
	10.28715463287138
	10.326714720583574
	10.365665205531178
	10.406495546860587
	10.445029062507919
	10.484501098505518
	10.524097691493422
	10.563531901762444
	10.60245590397736
	10.643081634317948
	10.68163282837479
	10.721742240130071
	10.760583475508966
	10.799768836387562
	10.839926255388866
	10.878566327189068
	10.918728062145815
	10.957753032311334
	10.997361927377753
	11.035583998421432
	11.075698027039932
	11.115801420913852
	11.154666313909647
	11.194880075784836
	11.234049176442761
	11.273159421275972
	11.31242255242964
	11.352142361916547
	11.39201745327834
	11.431272017935203
	11.470740141039556
	11.510054034913603
	11.54864804457774
	11.588895198153242
	11.6277429655059
	11.66737171334554
	11.706201381439769
	11.745968739835652
	11.784919255868902
	11.824706564920175
	11.864005511262476
	11.903398605849866
	11.942208699017424
	11.982991789973166
	12.021682313843446
	12.060793972777413
	12.100028789209468
	12.139685025588552
	12.179596623366699
	12.218940841168099
	12.25752968070982
	12.297047854120354
	12.336263427238338
	12.375410738593917
	12.41508235182272
	12.45464518525904
	12.49409288801656
	12.532707120967059
	12.572849631364058
	12.612269502657544
	12.65149235196949
	12.690411807239029
	12.730554651477355
	12.76964375815112
	12.808963213986344
	12.847195562143174
	12.886857771928163
	12.92720357001765
	12.96480029109769
	13.005701689764763
	13.045012552793567
	13.083507373834976
	13.12372479459882
	13.163186115674428
	13.201576193912192
	13.241198555189778
	13.280685833052486
	13.31996966886129
	13.358872001854737
	13.398206537311836
	13.437112316331467
	13.477232132583234
	13.516468989107736
	13.555555601430282
	13.594327293822106
	13.63505625586703
	13.67356700506597
	13.712128001980881
	13.752412562807848
	13.791059438945817
	13.830899998688896
	13.870352520942575
	13.909217086610395
	13.949157130697262
	13.988117816261445
	14.02788864331253
	14.065700632657537
	14.105990717150249
	14.145142506219472
	14.184556985881418
	14.22392848994336
	14.262840465026853
	14.302380853292494
	14.342206758017575
	14.381454492333031
	14.419758244724607
	14.459466288057003
	14.498912603670618
	14.538652469493787
	14.577163178492444
	14.616398511343869
	14.656260973579949
	14.695650280004264
	14.7343530750184
	14.773496063167606
	14.812810103208623
	14.852596592873931
	14.892096886082282
	14.93093618207087
	14.970453655771458
	15.009856132194084
	15.048575897027382
	15.088075375083507
	15.126649791517211
	15.16673855304546
	15.206192499326606
	15.244385829822395
	15.284566098923754
	15.323610837748767
	15.362785968744378
	15.4022284983468
	15.441614874171503
	15.48060712262723
	15.52055096833489
	15.559298937911848
	15.598570987135039
	15.63825356565277
	15.676681629752034
	15.71565245045416
	15.75537778702538
	15.794374620497925
	15.833871100629887
	15.872670949164203
	15.91270883066341
	15.952266794250926
	15.991508708065119
	16.029872802522444
	16.06979403233594
	16.108336154188716
	16.148400968978716
	16.186584473508663
	16.226294547682482
	16.265329142527506
	16.30606717148921
	16.344415860915877
	16.383987711330782
	16.423358835188903
3d6ee0ba1503eb63070b05e87b338932|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2019|1|V|rust
	    pub static ref ETA_CS44_INTERP: UnivariateSpline = {
	        UnivariateSplineBuilder::default(&(*LOG_ETA_ZS), &(*LOG_ETA_CS44))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
	    };
042c1156ec970ff5346654fd6571c3a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_zs.dat|1|1|V|csv
	0.60206107706281
	0.6048625578702993
	0.6076640386777887
	0.610465519485278
	0.6132670002927674
	0.6160684811002568
	0.6188699619077461
	0.6216714427152354
	0.6244729235227249
	0.6272744043302142
	0.6300758851377035
	0.632877365945193
	0.6356788467526823
	0.6384803275601716
	0.641281808367661
	0.6440832891751503
	0.6468847699826398
	0.6496862507901291
	0.6524877315976184
	0.6552892124051078
	0.6580906932125972
	0.6608921740200865
	0.6636936548275759
	0.6664951356350652
	0.6692966164425546
	0.672098097250044
	0.6748995780575333
	0.6777010588650226
	0.6805025396725121
	0.6833040204800014
	0.6861055012874907
	0.6889069820949801
	0.6917084629024695
	0.6945099437099589
	0.6973114245174482
	0.7001129053249375
	0.702914386132427
	0.7057158669399163
	0.7085173477474056
	0.711318828554895
	0.7141203093623844
	0.7169217901698737
	0.7197232709773631
	0.7225247517848524
	0.7253262325923417
	0.7281277133998312
	0.7309291942073205
	0.7337306750148098
	0.7365321558222993
	0.7393336366297886
	0.7421351174372779
	0.7449365982447673
	0.7477380790522566
	0.750539559859746
	0.7533410406672354
	0.7561425214747247
	0.758944002282214
	0.7617454830897035
	0.7645469638971928
	0.7673484447046821
	0.7701499255121715
	0.7729514063196609
	0.7757528871271502
	0.7785543679346396
	0.7813558487421289
	0.7841573295496183
	0.7869588103571077
	0.789760291164597
	0.7925617719720864
	0.7953632527795758
	0.7981647335870651
	0.8009662143945545
	0.8037676952020438
	0.8065691760095333
	0.8093706568170226
	0.8121721376245119
	0.8149736184320013
	0.8177750992394907
	0.82057658004698
	0.8233780608544694
	0.8261795416619587
	0.828981022469448
	0.8317825032769375
	0.8345839840844268
	0.8373854648919161
	0.8401869456994056
	0.8429884265068949
	0.8457899073143842
	0.8485913881218736
	0.851392868929363
	0.8541943497368523
	0.8569958305443417
	0.859797311351831
	0.8625987921593203
	0.8654002729668098
	0.8682017537742991
	0.8710032345817884
	0.8738047153892778
	0.8766061961967672
	0.8794076770042565
	0.8822091578117459
	0.8850106386192352
	0.8878121194267246
	0.890613600234214
	0.8934150810417033
	0.8962165618491926
	0.8990180426566821
	0.9018195234641714
	0.9046210042716607
	0.9074224850791501
	0.9102239658866395
	0.9130254466941288
	0.9158269275016182
	0.9186284083091076
	0.9214298891165968
	0.9242313699240863
	0.9270328507315757
	0.9298343315390649
	0.9326358123465543
	0.9354372931540438
	0.938238773961533
	0.9410402547690224
	0.9438417355765119
	0.9466432163840012
	0.9494446971914905
	0.9522461779989799
	0.9550476588064692
	0.9578491396139586
	0.960650620421448
	0.9634521012289373
	0.9662535820364266
	0.9690550628439161
	0.9718565436514054
	0.9746580244588947
	0.9774595052663841
	0.9802609860738735
	0.9830624668813628
	0.9858639476888522
	0.9886654284963415
	0.9914669093038309
	0.9942683901113203
	0.9970698709188096
	0.9998713517262989
	1.0026728325337884
	1.0054743133412778
	1.008275794148767
	1.0110772749562564
	1.0138787557637459
	1.016680236571235
	1.0194817173787245
	1.022283198186214
	1.0250846789937031
	1.0278861598011926
	1.030687640608682
	1.0334891214161712
	1.0362906022236607
	1.03909208303115
	1.0418935638386393
	1.0446950446461287
	1.0474965254536182
	1.0502980062611074
	1.0530994870685968
	1.0559009678760862
	1.0587024486835754
	1.0615039294910649
	1.0643054102985543
	1.0671068911060435
	1.069908371913533
	1.0727098527210224
	1.0755113335285116
	1.078312814336001
	1.0811142951434904
	1.0839157759509797
	1.086717256758469
	1.0895187375659585
	1.0923202183734477
	1.0951216991809372
	1.0979231799884266
	1.1007246607959158
	1.1035261416034052
	1.1063276224108947
	1.1091291032183839
	1.1119305840258733
	1.1147320648333627
	1.117533545640852
	1.1203350264483414
	1.1231365072558308
	1.12593798806332
	1.1287394688708094
	1.1315409496782989
	1.134342430485788
	1.1371439112932775
	1.139945392100767
	1.1427468729082562
	1.1455483537157456
	1.148349834523235
	1.1511513153307242
	1.1539527961382137
	1.156754276945703
	1.1595557577531923
	1.162357238560682
	1.1651587193681712
	1.1679602001756604
	1.17076168098315
	1.1735631617906392
	1.1763646425981285
	1.179166123405618
	1.1819676042131073
	1.1847690850205965
	1.1875705658280862
	1.1903720466355754
	1.1931735274430646
	1.1959750082505543
	1.1987764890580435
	1.2015779698655327
	1.2043794506730223
	1.2071809314805115
	1.2099824122880007
	1.2127838930954904
	1.2155853739029796
	1.2183868547104688
	1.2211883355179585
	1.2239898163254477
	1.226791297132937
	1.2295927779404265
	1.2323942587479157
	1.2351957395554052
	1.2379972203628946
	1.2407987011703838
	1.2436001819778733
	1.2464016627853627
	1.249203143592852
	1.2520046244003413
	1.2548061052078308
	1.25760758601532
	1.2604090668228094
	1.2632105476302988
	1.266012028437788
	1.2688135092452775
	1.271614990052767
	1.2744164708602561
	1.2772179516677455
	1.280019432475235
	1.2828209132827242
	1.2856223940902136
	1.288423874897703
	1.2912253557051923
	1.2940268365126817
	1.2968283173201711
	1.2996297981276603
	1.3024312789351498
	1.3052327597426392
	1.3080342405501284
	1.3108357213576178
	1.3136372021651073
	1.3164386829725965
	1.319240163780086
	1.3220416445875753
	1.3248431253950645
	1.327644606202554
	1.3304460870100434
	1.3332475678175326
	1.336049048625022
	1.3388505294325115
	1.3416520102400007
	1.3444534910474901
	1.3472549718549796
	1.3500564526624688
	1.3528579334699582
	1.3556594142774476
	1.3584608950849368
	1.3612623758924263
	1.3640638566999157
	1.366865337507405
	1.3696668183148943
	1.3724682991223838
	1.375269779929873
	1.3780712607373624
	1.3808727415448518
	1.383674222352341
	1.3864757031598305
	1.38927718396732
	1.3920786647748091
	1.3948801455822986
	1.397681626389788
	1.4004831071972772
	1.4032845880047666
	1.406086068812256
	1.4088875496197453
	1.4116890304272347
	1.4144905112347241
	1.4172919920422133
	1.420093472849703
	1.4228949536571922
	1.4256964344646814
	1.428497915272171
	1.4312993960796603
	1.4341008768871495
	1.4369023576946391
	1.4397038385021284
	1.4425053193096176
	1.4453068001171072
	1.4481082809245964
	1.4509097617320856
	1.4537112425395753
	1.4565127233470645
	1.4593142041545537
	1.4621156849620434
	1.4649171657695326
	1.4677186465770218
	1.4705201273845114
	1.4733216081920006
	1.4761230889994899
	1.4789245698069795
	1.4817260506144687
	1.4845275314219581
	1.4873290122294476
	1.4901304930369368
	1.4929319738444262
	1.4957334546519157
	1.4985349354594049
	1.5013364162668943
	1.5041378970743837
	1.506939377881873
	1.5097408586893624
	1.5125423394968518
	1.515343820304341
	1.5181453011118304
	1.5209467819193199
	1.523748262726809
	1.5265497435342985
	1.529351224341788
	1.5321527051492771
	1.5349541859567666
	1.537755666764256
	1.5405571475717452
	1.5433586283792347
	1.546160109186724
	1.5489615899942133
	1.5517630708017027
	1.5545645516091922
	1.5573660324166814
	1.5601675132241708
	1.5629689940316602
	1.5657704748391494
	1.5685719556466389
	1.5713734364541283
	1.5741749172616175
	1.576976398069107
	1.5797778788765964
	1.5825793596840856
	1.585380840491575
	1.5881823212990644
	1.5909838021065537
	1.593785282914043
	1.5965867637215325
	1.5993882445290217
	1.6021897253365114
	1.6049912061440006
	1.6077926869514898
	1.6105941677589795
	1.6133956485664687
	1.6161971293739579
	1.6189986101814475
	1.6218000909889367
	1.624601571796426
	1.6274030526039156
	1.6302045334114048
	1.633006014218894
	1.6358074950263837
	1.6386089758338729
	1.641410456641362
	1.6442119374488517
	1.647013418256341
	1.6498148990638302
	1.6526163798713198
	1.655417860678809
	1.6582193414862982
	1.661020822293788
	1.663822303101277
	1.6666237839087663
	1.669425264716256
	1.6722267455237452
	1.6750282263312344
	1.677829707138724
	1.6806311879462132
	1.6834326687537025
	1.686234149561192
	1.6890356303686813
	1.6918371111761705
	1.6946385919836602
	1.6974400727911494
	1.7002415535986386
	1.7030430344061283
	1.7058445152136175
	1.7086459960211067
	1.7114474768285963
	1.7142489576360855
	1.7170504384435747
	1.7198519192510644
	1.7226534000585536
	1.7254548808660428
	1.7282563616735325
	1.7310578424810217
	1.733859323288511
	1.7366608040960005
	1.7394622849034898
	1.742263765710979
	1.7450652465184686
	1.7478667273259578
	1.750668208133447
	1.7534696889409367
	1.756271169748426
	1.759072650555915
	1.7618741313634048
	1.764675612170894
	1.7674770929783832
	1.7702785737858728
	1.773080054593362
	1.7758815354008513
	1.778683016208341
	1.7814844970158301
	1.7842859778233193
	1.787087458630809
	1.7898889394382982
	1.7926904202457874
	1.795491901053277
	1.7982933818607663
	1.8010948626682555
	1.8038963434757451
	1.8066978242832343
	1.8094993050907235
	1.8123007858982132
	1.8151022667057024
	1.8179037475131916
	1.8207052283206813
	1.8235067091281705
	1.8263081899356597
	1.8291096707431493
	1.8319111515506386
	1.8347126323581278
	1.8375141131656174
	1.8403155939731066
	1.8431170747805963
	1.8459185555880855
	1.8487200363955747
	1.8515215172030643
	1.8543229980105536
	1.8571244788180428
	1.8599259596255324
	1.8627274404330216
	1.8655289212405108
	1.8683304020480005
	1.8711318828554897
	1.873933363662979
	1.8767348444704686
	1.8795363252779578
	1.882337806085447
	1.8851392868929366
	1.8879407677004258
	1.890742248507915
	1.8935437293154047
	1.896345210122894
	1.8991466909303831
	1.9019481717378728
	1.904749652545362
	1.9075511333528512
	1.9103526141603409
	1.91315409496783
	1.9159555757753193
	1.918757056582809
	1.9215585373902981
	1.9243600181977873
	1.927161499005277
	1.9299629798127662
	1.9327644606202554
	1.935565941427745
	1.9383674222352343
	1.9411689030427235
	1.9439703838502131
	1.9467718646577024
	1.9495733454651916
	1.9523748262726812
	1.9551763070801704
	1.9579777878876596
	1.9607792686951493
	1.9635807495026385
	1.9663822303101277
	1.9691837111176174
	1.9719851919251066
	1.9747866727325958
	1.9775881535400854
	1.9803896343475746
	1.9831911151550639
	1.9859925959625535
	1.9887940767700427
	1.991595557577532
	1.9943970383850216
	1.9971985191925108
	2
812a766da41f56018f7bcbac959eb779|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|30|41|V|rust
	        // value of cs.2 are all negative
5f9de05f5902357755ca313da1e54b7e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs46.dat|1|1|V|csv
	-22.11523191704046
d7e6f8d9415658e8bf46fc723b12e474|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1519|8|V|rust
	        -22.11523191704046
2eab38ce67df9685946c9a29469eb567|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/data/log_scaled_cs_data_cs46.dat|1|1|V|csv
	-22.11523191704046
	-10.137204360704613
	-9.047609584625242
	-8.394417929606275
	-7.920872329282688
	-7.544832230770647
	-7.231452605416672
	-6.961808437999855
	-6.722065369939154
	-6.507758252970375
	-6.311584014185266
	-6.130496463927229
	-5.962781588829567
	-5.805644349368073
	-5.65750541218734
	-5.517049942323164
	-5.383682944781375
	-5.256899865169347
	-5.134707563658331
	-5.018082176431628
	-4.904641092629691
	-4.795383322151187
	-4.689912916379204
	-4.588014932536261
	-4.489058522363544
	-4.391906951888231
	-4.29761088628192
	-4.206258670366968
	-4.116488993280968
	-4.028160899513216
	-3.9434604326595206
	-3.859162097086034
	-3.776920546803163
	-3.6958414941278503
	-3.6166645995033497
	-3.5387412555903124
	-3.462060476723484
	-3.3863855487366568
	-3.3117168820877656
	-3.238530564768624
	-3.1667483185293834
	-3.096275857678843
	-3.0245934175601152
	-2.9555374792567832
	-2.887419582864301
	-2.819733780644392
	-2.752597731441559
	-2.6865912489171553
	-2.6206742524504048
	-2.556505653903028
	-2.4921559102537976
	-2.428734370175336
	-2.365551783254935
	-2.3035876235596735
	-2.2417418399617195
	-2.181060239801085
	-2.120698275271693
	-2.0603801450756154
	-2.0009236381580324
	-1.9412000208476496
	-1.8828562140816882
	-1.824490567376435
	-1.767967031531039
	-1.7101117771771888
	-1.6521434229453718
	-1.5963822362060534
	-1.5398449836375825
	-1.4839024571343307
	-1.4280260962329467
	-1.3733723072745223
	-1.3181074581111272
	-1.2638431921399673
	-1.2099539649806867
	-1.1560327476889698
	-1.1017964210562863
	-1.0476524141759047
	-0.9967959671934913
	-0.9433956205650985
	-0.8907665615710059
	-0.8377170371208053
	-0.7862509030449751
	-0.73583128442985
	-0.6834173823006706
	-0.6321132775167941
	-0.5815626651393084
	-0.5300797929066131
	-0.48004230721188734
	-0.4300212739620149
	-0.37996021038426453
	-0.32957862757161177
	-0.27976297828564584
	-0.23049229337370258
	-0.18098869001939205
	-0.13146976393550353
	-0.08289032961688504
	-0.03394677637618454
	0.013744847443554696
	0.06287769402995524
	0.11130097867864398
	0.15976158140937358
	0.2071239276837501
	0.2545525430619502
	0.30251464450627863
	0.34992528557129643
	0.3979032229892193
	0.44554157387162957
	0.4923391807592985
	0.5393561501712478
	0.5869202196948701
	0.6332579220223086
	0.6797822636865577
	0.7259763173366737
	0.7724280438972921
	0.8186902778753632
	0.8652276090698852
	0.9114855149133643
	0.956688405537237
	1.002241624522372
	1.0480567379986476
	1.0939656568340528
	1.1390197786846026
	1.1852153873933864
	1.2304049528178385
	1.2761901692033255
	1.320267300636234
	1.3652845025557603
	1.4109301267825705
	1.4552784635303635
	1.4997077760445747
	1.5442748308084462
	1.5892075855604773
	1.633495929139291
	1.6776363531080005
	1.7221317838725752
	1.7662494114264455
	1.8097105902625452
	1.8546988946119114
	1.8989306588032515
	1.9425030680508433
	1.9866011510611195
	2.0299642292061075
	2.073603154888061
	2.1173357399660664
	2.1607005656420197
	2.2049776326345474
	2.2488350050495765
	2.2917390722088444
	2.334064135897967
	2.3782181571356302
	2.421404041982275
	2.4637891561358316
	2.507404303924951
	2.550580538525257
	2.5928145373307485
	2.636869328880741
	2.6789648673713584
	2.7220805553925396
	2.764304998658252
	2.807229869284346
	2.8497589031643913
	2.892422465410929
	2.9350734747524942
	2.9772615079915985
	3.0201204645152107
	3.062136828569425
	3.1053465121510144
	3.146685575343584
	3.189199212871677
	3.230717720709751
	3.2731494962879344
	3.31529749800614
	3.3579015210469283
	3.3991720504813077
	3.441893541768013
	3.484376560738122
	3.5262324982598274
	3.5671369347574973
	3.610348270362467
	3.6514399873913717
	3.6921417487662747
	3.7351393632543544
	3.7760989145636694
	3.8174072401406405
	3.8594080335601153
	3.901129078618721
	3.942990300611854
	3.9843604662316916
	4.025360329131765
	4.0663930404093005
	4.108635443118319
	4.149571555824421
	4.191617170729469
	4.233126898881052
	4.274406760594998
	4.3154443671588885
	4.356359048429764
	4.398057927615922
	4.4394210054240935
	4.479392424516695
	4.5219840886438405
	4.5623066173363265
	4.603359582564213
	4.643634105589995
	4.685840774912274
	4.7271505778645855
	4.767209629897444
	4.808192239994555
	4.849798734680868
	4.89066299256043
	4.9310227799452395
	4.971185214478447
	5.0119916959994715
	5.05355596510598
	5.095189192721223
	5.135100519454889
	5.1753318964383075
	5.216671476771304
	5.257461906494779
	5.297536248383119
	5.3386699588887865
	5.378203969280791
	5.419953807309153
	5.459694111635896
	5.500483828377084
	5.541375891098334
	5.582757334282457
	5.621761894276969
	5.662621190655252
	5.703304861947194
	5.7447619854779735
	5.784765773507368
	5.8249404014853505
	5.866031349534071
	5.905730342717683
	5.946272723598888
	5.985657510890678
	6.027031709906907
	6.067250539428664
	6.1075976213860725
	6.1476973391177365
	6.1884784070536245
	6.228490738196273
	6.268384749403203
	6.30891682566298
	6.348997736688499
	6.390060602040151
	6.429696175244947
	6.469719644852211
	6.5097389137613515
	6.5502756080523605
	6.5897603362400625
	6.630525389087199
	6.670302258283583
	6.710900167961492
	6.751520306648648
	6.790899246920402
	6.830468159639794
	6.870667417834209
	6.911609133347514
	6.9508687160727725
	6.991393150789675
	7.031589511430581
	7.071072607490472
	7.1115618212259815
	7.150872937233379
	7.191780186895996
	7.231354396830113
	7.271567787869081
	7.311487232445487
	7.351418028515449
	7.390684834926916
	7.430606524485574
	7.470023234430472
	7.510839317586457
	7.550783075694863
	7.590142987172604
	7.6305199501417365
	7.670415868533249
	7.710892652940343
	7.749434938835596
	7.790166382164142
	7.829702136513966
	7.869129081493775
	7.9099530731997785
	7.948757115215877
	7.988714545447845
	8.029368533184314
	8.06797237902245
	8.108369896435773
	8.148092982142094
	8.187924419177994
	8.228095666281025
	8.266889027917557
	8.307506067483923
	8.346590199692464
	8.386342384016833
	8.426881623643656
	8.465683944241134
	8.506657272356685
	8.546070770897503
	8.585766696631268
	8.624884838726004
	8.664351109634069
	8.704277612880336
	8.744259739816979
	8.783303461520992
	8.82387250575693
	8.86278187340083
	8.902865625497693
	8.942174638435024
	8.982059850296602
	9.02101342558067
	9.060989652478366
	9.101041183746608
	9.140328053590382
	9.179419126118793
	9.21908623317976
	9.258674597208019
	9.29939626293374
	9.338071101879729
	9.377662657489088
	9.417623776096134
	9.456049871100525
	9.496583758424766
	9.536428204993658
	9.575601720067423
	9.614989720129262
	9.654367307273933
	9.694033401553407
	9.734686452818492
	9.774126505654763
	9.812348316830118
	9.851986441362962
	9.892393416796775
	9.931936913350588
	9.971208012675184
	10.010233280114893
	10.050197790896688
	10.090042652798585
	10.129140718286884
	10.168389619222818
	10.207572528947363
	10.247667430483434
	10.28663338450035
	10.325795014764374
	10.366307702308855
	10.404946388786017
	10.44561330731499
	10.484492675704729
	10.52322750514998
	10.563955806278848
	10.60273134682149
	10.64121546068083
	10.681964962322922
	10.720729793974423
	10.760682879851254
	10.799714847791291
	10.839602929318456
	10.878660965242604
	10.918256260002229
	10.957641546044947
	10.996609493726291
	11.036073184257495
	11.076130977224713
	11.114997414223398
	11.154846455102957
	11.194700762429544
	11.233538934697178
	11.273311510891721
	11.311918163692532
	11.352763753988288
	11.391047077187896
	11.431651259119546
	11.470684629268668
	11.510398176141758
	11.548990145620873
	11.588332470597656
	11.627538140238393
	11.667123531625995
	11.70738389031332
	11.746418253213283
	11.784802767715753
	11.824666412668122
	11.864544900495213
	11.903828042079452
	11.942974464153659
	11.982005392410834
	12.021747571046026
	12.060530750686336
	12.100517768195907
	12.13950286500866
	12.179146622922703
	12.218112524142924
	12.257503862011358
	12.297990170672053
	12.33606366326211
	12.375878209337332
	12.415673432788278
	12.455014292760401
	12.49371114241786
	12.533380247842276
	12.572320687387213
	12.611708371164877
	12.65026063047214
	12.691332355274078
	12.730083709372945
	12.769288883213394
	12.80758413871383
	12.847708662243729
	12.88661246385226
	12.92627015664197
	12.965981992271304
	13.00587965351462
	13.04386079753698
	13.084427954296991
	13.123273884327274
	13.162681473196953
	13.20196460274867
	13.241007042878316
	13.28026996698678
	13.320049068763632
	13.358880310255516
	13.398747267672448
	13.439071178182859
	13.476820289008204
	13.517173571907081
	13.555518774010578
	13.594207203066896
	13.634761788914107
	13.673285839182975
	13.7127427067696
	13.75248615158504
	13.79198263091675
	13.83079367421475
	13.870350296415765
	13.90988328490229
	13.949197841767843
	13.988151512328185
	14.027437041952851
	14.066669232546436
	14.106403593943805
	14.145279898128633
	14.18386944876649
	14.223695709485117
	14.262688751762019
	14.302718634662408
	14.34155174186815
	14.381219088059296
	14.420278861643336
	14.459806584674038
	14.498563959147935
	14.539265413077457
	14.577538582260885
	14.616701880609071
	14.656090995763853
	14.695319712427592
	14.734691980867686
	14.773643794626011
	14.813571611104683
	14.85221840563396
	14.892932136505403
	14.930957310435288
	14.97032749739645
	15.008862678116554
	15.047931927158462
	15.088649993185825
	15.127090781413873
	15.166736930106447
	15.206144482962898
	15.244659607676283
	15.284434250816876
	15.323397051858452
	15.3618339351186
	15.40217337989497
	15.442006000173938
	15.481031914960989
	15.519264333748842
	15.559863661633331
	15.598972898116143
	15.637304427473351
	15.676489638708878
	15.716032679455155
	15.755926709354512
	15.794771530372103
	15.83401387766795
	15.872713157404919
	15.91304973419165
	15.95153729851192
	15.990728786826837
	16.030164549868214
	16.06976843220022
	16.109472060440552
	16.148978923458003
	16.187568012896026
	16.226479621062435
	16.26649543109911
	16.305441695756063
	16.34367984504559
	16.38385766063182
	16.422150871950638
697a43d0a82ddce3d19e9edf5cbdcde1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|10|1|V|rust
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS44_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
4a0088b8b99d155f5fafbf0014b1a585|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|37|1|V|rust
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
600bd80494189f6caafa9342068fcd99|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|36|11|v|rust
	else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	
adc9311f2251b8ec7f616ea7c601a2f1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|33|1|V|rust
	            cs += 10f64.powf((*ETA_CS44_INTERP).eval(logz));
19baa9aa5284b7ed29d08b1697a50b92|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|37|1|V|rust
	            cs += z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT);
dc776ed358be315fece0e6a179bb8b31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|37|27|v|rust
	ETA_CS_SLOPE
db34705182e621ee4d63d10cd92babb7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|38|32|V|rust
	            cs += z.powi(14) * 10f64.powf(*ETA_CS_INTERCEPT);
9559270bf584b8ee4813c19abffdee05|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|38|32|V|rust
	            cs += z.powi() * 10f64.powf(*ETA_CS_INTERCEPT);
17528690330723e9e5ca6d5d180268c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|7|1|V|rust
	    pub static ref ETA_CS_SLOPE: f64 = 14.00554949;
cebb5acc8c41b9504b022c6ed10ca8c2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|7|1|V|rust
	    pub static ref ETA_CS_INTERCEPT: f64 = -11.12625161;
5da4642dfd8a00859140aea750da5240|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|8|46|v|rust
	-11.12625161;
66ab24af0f62c18332dff7d333ff5059|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|37|33|v|rust
	10f64.powf(*ETA_CS_INTERCEPT44)
022fdb844724a79251783a32d742a589|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|27|1|v|rust
	7.6770415885086560
b3f2c32183c694931cd8ce6c4761c220|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|28|1|V|rust
	        let c44 = norm * l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
daaf2cc91564d6ea49a6ec28c0f29823|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|28|39|v|rust
	mu.powi(14) / (lam * lam * n.powi(11));
3459488c4db3c88aaa4f7e2228fb6370|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|27|41|v|rust
	* mu.powi(14)
7fd699dcc7c0e86accff5e341330c3e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|27|83|v|rust
	/ (lam * ;
85128c07b5dabccccdf4fa04303ca684|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|27|83|v|rust
	// (256 pi^4/9)^2
3727cee1fcd586dc801eaa18840bde03|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|28|24|v|rust
	* l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
d53ce13316443d2362e096066f60f81a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|25|25|V|rust
	        let l1 = self.lec1;
66ed72da2e3bb1c887e92df8557eea8d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|29|26|v|rust
	l1.powi(4) * mu.powi(14) / (lam * lam * n.powi(11));
6aa779d7ce7dba0690d6286bc15d00b4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|45|28|v|rust
	led_cross_section_2eta_4eta(cme / self.m_eta)
17ff9975180f86135ac0e494c1888065|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|45|27|V|rust
	        pre * self.rust_sca
b46424c265fa89f42551aa7a511d795f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|44|10|V|rust
	        cs
e3fa6961139d3045e12325a4a13ed8ca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|35|13|v|rust
	cs += 
3ab0557eefb34923b38ebd039f620e9b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|31|25|V|rust
	        let mut cs = 0.0;
bd51139b6233ccb92243e4f04176242f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|7|20|v|rust
	on for 2eta -> 4eta with all prefactors REMOVED as a
	    /// function of the scaled center-of-mass energy z = cme / meta.
	    pub fn rust_scaled_cross_section_2eta_4eta(&self, z: f64) -> f64 {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS44_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	    }
	
6c08a61cace7c2cd057d94e08e81887a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|7|1|V|rust
	    /// Cross section for 2eta -> 4eta with all prefactors REMOVED as a
	    /// function of the scaled center-of-mass energy z = cme / meta.
	    pub fn rust_scaled_cross_section_2eta_4eta(&self, z: f64) -> f64 {
	        let logz = z.log10();
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            10f64.powf((*ETA_CS44_INTERP).eval(logz))
	        } else if logz <= (*LOG_ETA_ZS_MIN) {
	            0.0
	        } else {
	            z.powf(*ETA_CS_SLOPE) * 10f64.powf(*ETA_CS_INTERCEPT)
	        }
	    }
c56bf9cfe1ca397776fcf23b899bcc60|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|34|9|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta with all prefactors REMOVED as a function of x = meta/Teta,
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
	    pub fn rust_scaled_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pre = x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_scaled_cross_section_2eta_4eta(z);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = (*TCS_INTEGRATOR).integrate(f, 4.0, f64::INFINITY).val;
	        int * pre
	    }
40050ced86bc1c8b60193a1bb472e851|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|187|1|V|rust
	    /// Cross section for 2eta -> 4eta with all prefactors REMOVED as a
	    /// function of the scaled center-of-mass energy z = cme / meta,
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
	    pub fn scaled_cross_section_2eta_4eta(&self, z: f64) -> PyResult<f64> {
	        Ok(self.rust_scaled_cross_section_2eta_4eta(z))
	    }
26ac102dbac0221a485124e4eef12a6f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|192|1|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta with all prefactors REMOVED as a function of x = meta/Teta,
	    /// i.e. a factor of (246 pi^2 / 9)^2 * (l1^4 * mu_eta^14 / (lam^2 n^11)
	    /// has been removed.
	    pub fn scaled_thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_scaled_thermal_cross_section_2eta_4eta(x))
	    }
48d3e3d06977ae5b32d170485108630a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|65|61|v|rust
	EPSILON
bb9a5932a1702308502709529ee891eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|4|1|V|rust
	//pub mod generate_cs_data;
e2a6428114aa7dad112437fea88aba67|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|10|1|V|toml
	#cyphus-diffeq = { path = "../../cyphus-diffeq"}
638d87b0945dea91932a0671a0a8ab4d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|31|1|V|rust
	/// Structure to hold all information needed to integrate an ODE.
	pub struct OdeIntegrator<'a, Params: 'a, Alg: OdeAlgorithm + 'a> {
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
	    /// Jacobian w.r.t. t of RHS of ODE
	    pub(crate) dfdt: Option<&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)>,
	    /// Jacobian w.r.t. u of RHS of ODE
	    pub(crate) dfdu: Option<&'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &Params)>,
	    /// Parameters of the ODE
	    pub params: Params,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// The algorithm being used to solve the ODE.
	    pub alg: Alg,
	    /// Callback function to mutate state of integrator after each step.
	    pub callback: Option<&'a dyn Fn(&mut Self)>,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
96c967829d353e6a981d5708e4429d0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|2|25|v|rust
	<'a, Params: 'a, Alg: OdeAlgorithm + 'a>
195391a9b928b07d0c1ec1347b81e55f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|25|V|rust
	    pub dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
9c3163c047364d56e81a9d08e82f6711|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|25|V|rust
	    /// Jacobian w.r.t. t of RHS of ODE
6ec6677d3d104dac3b338602d719e235|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|25|V|rust
	    pub(crate) dfdt: Option<&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)>,
b6e2a99a6b45773ad89a3bb51d6b11ba|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|25|V|rust
	    pub(crate) dfdu: Option<&'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &Params)>,
4ed4a970d4625ca706c742c54fa2cabc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|25|V|rust
	    /// Parameters of the ODE
1e709da3a4e522f64cda963a4adf1575|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|3|23|V|rust
	    pub params: Params,
81be77b885b1fe0d0a59e97f45e82f58|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|25|1|V|rust
	    /// The algorithm being used to solve the ODE.
	    pub alg: Alg,
3fc541324eeae05a8bd06356793876d8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/cache.rs|3|1|V|rust
	pub struct Radau5Cache {
	    pub(crate) caljac: bool,
	    pub(crate) first: bool,
	    pub(crate) last: bool,
	    pub(crate) reject: bool,
	    pub(crate) decompose: bool,
	    pub(crate) fac1: f64,
	    pub(crate) alphn: f64,
	    pub(crate) betan: f64,
	    pub(crate) dtopt: f64,
	    pub(crate) faccon: f64,
	    pub(crate) dtfac: f64,
	    pub(crate) dtacc: f64,
	    pub(crate) erracc: f64,
	    pub(crate) thqold: f64,
	    pub(crate) cfac: f64,
	    pub(crate) theta: f64,
	    pub(crate) nsing: usize,
	    pub(crate) newt: usize,
	    pub(crate) err: f64,
	    pub(crate) u0: Array1<f64>,
	    pub(crate) scal: Array1<f64>,
	    pub(crate) cont: Array1<f64>,
	    pub(crate) z1: Array1<f64>,
	    pub(crate) z2: Array1<f64>,
	    pub(crate) z3: Array1<f64>,
	    pub(crate) f1: Array1<f64>,
	    pub(crate) f2: Array1<f64>,
	    pub(crate) f3: Array1<f64>,
	    pub(crate) ip1: Array1<i32>,
	    pub(crate) ip2: Array1<i32>,
	    pub(crate) e1: Array2<f64>,
	    pub(crate) e2r: Array2<f64>,
	    pub(crate) e2i: Array2<f64>,
	    pub(crate) dfdu: Array2<f64>,
	}
ba97e63b49598dd0e05dea45b7098a48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|29|23|v|rust
	Alg::Cache,
1c6fcd4d51ebc1b00a4f347af06af5de|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/options.rs|1|1|V|rust
	/// Common options for differential equations
	#[derive(Clone)]
	pub struct OdeIntegratorOpts {
	    /// Relative tolerance
	    pub reltol: f64,
	    /// Absolute tolerance
	    pub abstol: f64,
	    /// Flag specifying if dense output is requested
	    pub dense: bool,
	    /// Initial step value
	    pub dtstart: f64,
	    /// Maximum allowed step size
	    pub dtmax: f64,
	    /// Maximum number of allowed steps
	    pub max_steps: usize,
	    /// Maximum number of allowed newton iterations.
	    pub max_newt_iter: usize,
	    /// Maximum number of stiff detections allowed
	    pub max_stiff: usize,
	    /// If true, use modern predictive controller (Gustafsson).
	    pub modern_pred: bool,
	    /// Safety factor used in adaptive step selection.
	    pub safe: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold <= 1/facr.
	    pub facr: f64,
	    /// Gustafsson step control factor. Restricts dtnew/dtold >= 1/facl.
	    pub facl: f64,
	    /// Minimum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot1: f64,
	    /// Maximum allowed ratio of dtnew/dtold such that dt will be held constant.
	    pub quot2: f64,
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
	    /// and Wanner's book.)
	    pub beta: f64,
	    /// The amount to decrease the timestep by if the Newton iterations of an
	    /// implicit method fail.
	    pub fnewt: f64,
	    /// If true, the extrapolated collocation solution is taken as the starting
	    /// value of the Newton iteration.
	    pub use_ext_col: bool,
	    /// If true, the Jacobian will be converted into Hessenberg form.
	    pub hess: bool,
	    /// Decides whether the Jacobian should be recomputed.
	    pub theta: f64,
	}
	
	impl OdeIntegratorOpts {
	    pub fn new() -> OdeIntegratorOpts {
	        OdeIntegratorOpts {
	            reltol: 1e-3,
	            abstol: 1e-7,
	            dense: false,
	            dtstart: 1e-6,
	            dtmax: f64::INFINITY,
	            max_steps: 100000,
	            max_newt_iter: 7,
	            max_stiff: 1000,
	            modern_pred: true,
	            safe: 0.9,
	            facr: 0.0,
	            facl: 0.0,
	            quot1: 0.0,
	            quot2: 0.0,
	            beta: 0.0,
	            fnewt: 0.0,
	            use_ext_col: true,
	            hess: false,
	            theta: 0.0,
	        }
	    }
	}
70c75869e3bfbe35f7a61ebf8805617b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|63|1|V|rust
	    /// The "beta" for stabilized step size control (see Sec.(IV.2) of Hairer
	    /// and Wanner's book.)
	    pub beta: f64,
068977d63342f347e15247c3e641aa31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|92|1|V|rust
	            beta: 0.0,
f898fb508ddd87501a02424cb72fadea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/constants.rs|1|1|V|rust
	use super::Radau5;
	
	// Declare all the constants needed for Radau5
	impl Radau5 {
	    pub(crate) const T11: f64 = 9.1232394870892942792e-02;
	    pub(crate) const T12: f64 = -0.14125529502095420843;
	    pub(crate) const T13: f64 = -3.0029194105147424492e-02;
	    pub(crate) const T21: f64 = 0.24171793270710701896;
	    pub(crate) const T22: f64 = 0.20412935229379993199;
	    pub(crate) const T23: f64 = 0.38294211275726193779;
	    pub(crate) const T31: f64 = 0.96604818261509293619;
	    pub(crate) const TI11: f64 = 4.3255798900631553510;
	    pub(crate) const TI12: f64 = 0.33919925181580986954;
	    pub(crate) const TI13: f64 = 0.54177053993587487119;
	    pub(crate) const TI21: f64 = -4.1787185915519047273;
	    pub(crate) const TI22: f64 = -0.32768282076106238708;
	    pub(crate) const TI23: f64 = 0.47662355450055045196;
	    pub(crate) const TI31: f64 = -0.50287263494578687595;
	    pub(crate) const TI32: f64 = 2.5719269498556054292;
	    pub(crate) const TI33: f64 = -0.59603920482822492497;
	    pub(crate) const C1: f64 = 0.1550510257216822;
	    pub(crate) const C2: f64 = 0.6449489742783178;
	    pub(crate) const C1M1: f64 = -0.8449489742783178;
	    pub(crate) const C2M1: f64 = -0.3550510257216822;
	    pub(crate) const C1MC2: f64 = -0.4898979485566356;
	    pub(crate) const ALPHA: f64 = 2.681082873627752;
	    pub(crate) const BETA: f64 = 3.050430199247411;
	    pub(crate) const U1: f64 = 3.637834252744496;
	}
5e4c67b0c9130b8463f28c56ac113ba5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/dec.rs|1|1|V|rust
	//! Module for performing decompositions of various matrices.
	
	use ndarray::prelude::*;
	
	/// Perform a triangular decomposition on a real dense matrix `a`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn dec(n: usize, mut a: ArrayViewMut2<f64>, mut ip: ArrayViewMut1<i32>) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            for i in kp1..n {
	                if a[[i, k]].abs() > a[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut t = a[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                a[[m, k]] = a[[k, k]];
	                a[[k, k]] = t;
	            }
	            if t == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            t = t.recip();
	            for i in kp1..n {
	                a[[i, k]] *= -t;
	            }
	            for j in kp1..n {
	                t = a[[m, j]];
	                a[[m, j]] = a[[k, j]];
	                a[[k, j]] = t;
	                if t != 0.0 {
	                    for i in kp1..n {
	                        a[[i, j]] += a[[i, k]] * t;
	                    }
	                }
	            }
	        }
	    }
	    if a[[n - 1, n - 1]] == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
	
	/// Perform a triangular decomposition on a real Hessenberg matrix `a` with
	/// lower-bandwidth of `lb`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn dech(
	    n: usize,
	    mut a: ArrayViewMut2<f64>,
	    lb: usize,
	    mut ip: ArrayViewMut1<i32>,
	) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            let na = n.min(lb + k + 1);
	            for i in kp1..na {
	                if a[[i, k]].abs() > a[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut t = a[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                a[[m, k]] = a[[k, k]];
	                a[[k, k]] = t;
	            }
	            if t == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            t = 1.0 / t;
	            for i in kp1..n {
	                a[[i, k]] *= -t;
	            }
	            for j in kp1..n {
	                t = a[[m, j]];
	                a[[m, j]] = a[[k, j]];
	                a[[k, j]] = t;
	                if t != 0.0 {
	                    for i in kp1..na {
	                        a[[i, j]] += a[[i, k]] * t;
	                    }
	                }
	            }
	        }
	    }
	    if a[[n - 1, n - 1]] == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
	
	/// Perform a triangular decomposition on a complex matrix with real and
	/// imaginary components `ar` and `ai`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn decc(
	    n: usize,
	    mut ar: ArrayViewMut2<f64>,
	    mut ai: ArrayViewMut2<f64>,
	    mut ip: ArrayViewMut1<i32>,
	) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            for i in kp1..n {
	                if ar[[i, k]].abs() + ai[[i, k]].abs() > ar[[m, k]].abs() + ai[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut tr = ar[[m, k]];
	            let mut ti = ai[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                ar[[m, k]] = ar[[k, k]];
	                ai[[m, k]] = ai[[k, k]];
	                ar[[k, k]] = tr;
	                ai[[k, k]] = ti;
	            }
	            if tr.abs() + ti.abs() == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            let den = tr * tr + ti * ti;
	            tr = tr / den;
	            ti = -ti / den;
	            for i in kp1..n {
	                let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                ar[[i, k]] = -prodr;
	                ai[[i, k]] = -prodi;
	            }
	            for j in kp1..n {
	                tr = ar[[m, j]];
	                ti = ai[[m, j]];
	                ar[[m, j]] = ar[[k, j]];
	                ai[[m, j]] = ai[[k, j]];
	                ar[[k, j]] = tr;
	                ai[[k, j]] = ti;
	                if tr.abs() + ti.abs() == 0.0 {
	                } else if ti == 0.0 {
	                    for i in kp1..n {
	                        let prodr = ar[[i, k]] * tr;
	                        let prodi = ai[[i, k]] * tr;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                } else if tr == 0.0 {
	                    for i in kp1..n {
	                        let prodr = -ai[[i, k]] * ti;
	                        let prodi = ar[[i, k]] * ti;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                } else {
	                    for i in kp1..n {
	                        let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                        let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                }
	            }
	        }
	    }
	    if ar[[n - 1, n - 1]].abs() + ai[[n - 1, n - 1]].abs() == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
e2ab17bbff8b4338b2c3fae79357da25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|59|1|V|rust
	/// Perform a triangular decomposition on a real Hessenberg matrix `a` with
	/// lower-bandwidth of `lb`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn dech(
	    n: usize,
	    mut a: ArrayViewMut2<f64>,
	    lb: usize,
	    mut ip: ArrayViewMut1<i32>,
	) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            let na = n.min(lb + k + 1);
	            for i in kp1..na {
	                if a[[i, k]].abs() > a[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut t = a[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                a[[m, k]] = a[[k, k]];
	                a[[k, k]] = t;
	            }
	            if t == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            t = 1.0 / t;
	            for i in kp1..n {
	                a[[i, k]] *= -t;
	            }
	            for j in kp1..n {
	                t = a[[m, j]];
	                a[[m, j]] = a[[k, j]];
	                a[[k, j]] = t;
	                if t != 0.0 {
	                    for i in kp1..na {
	                        a[[i, j]] += a[[i, k]] * t;
	                    }
	                }
	            }
	        }
	    }
	    if a[[n - 1, n - 1]] == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
8c0e111967290c27c8c94e7c87d054be|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/linalg/sol.rs|6|1|V|rust
	pub(crate) fn sol(n: usize, a: ArrayView2<f64>, mut b: ArrayViewMut1<f64>, ip: ArrayView1<i32>) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k];
	            let t = b[m as usize];
	            b[m as usize] = b[k];
	            b[k] = t;
	            for i in kp1..n {
	                b[i] += a[[i, k]] * t;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            b[kb] = b[kb] / a[[kb, kb]];
	            let t = -b[kb];
	            for i in 0..(km1 + 1) {
	                b[i] += a[[i, kb]] * t;
	            }
	        }
	    }
	    b[0] = b[0] / a[[0, 0]];
	}
	
	pub(crate) fn solh(
	    n: usize,
	    a: ArrayView2<f64>,
	    lb: usize,
	    mut b: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k] as usize;
	            let t = b[m];
	            b[m] = b[k];
	            b[k] = t;
	            let na = n.min(lb + k + 1);
	            for i in kp1..na {
	                b[i] += a[[i, k]] * t;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            b[kb] = b[kb] / a[[kb, kb]];
	            let t = -b[kb];
	            for i in 0..(km1 + 1) {
	                b[i] += a[[i, kb]] * t;
	            }
	        }
	    }
	    b[0] = b[0] / a[[0, 0]];
	}
	
	pub(crate) fn solc(
	    n: usize,
	    ar: ArrayView2<f64>,
	    ai: ArrayView2<f64>,
	    mut br: ArrayViewMut1<f64>,
	    mut bi: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k] as usize;
	            let tr = br[m];
	            let ti = bi[m];
	            br[m] = br[k];
	            bi[m] = bi[k];
	            br[k] = tr;
	            bi[k] = ti;
	            for i in kp1..n {
	                let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                br[i] += prodr;
	                bi[i] += prodi;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            let den = ar[[kb, kb]] * ar[[kb, kb]] + ai[[kb, kb]] * ai[[kb, kb]];
	            let mut prodr = br[kb] * ar[[kb, kb]] + bi[kb] * ai[[kb, kb]];
	            let mut prodi = bi[kb] * ar[[kb, kb]] - br[kb] * ai[[kb, kb]];
	            br[kb] = prodr / den;
	            bi[kb] = prodi / den;
	            let tr = -br[kb];
	            let ti = -bi[kb];
	            for i in 0..(km1 + 1) {
	                prodr = ar[[i, kb]] * tr - ai[[i, kb]] * ti;
	                prodi = ai[[i, kb]] * tr + ar[[i, kb]] * ti;
	                br[i] += prodr;
	                bi[i] += prodi;
	            }
	        }
	    }
	    let den = ar[[0, 0]] * ar[[0, 0]] + ai[[0, 0]] * ai[[0, 0]];
	    let prodr = br[0] * ar[[0, 0]] + bi[0] * ai[[0, 0]];
	    let prodi = bi[0] * ar[[0, 0]] - br[0] * ai[[0, 0]];
	    br[0] = prodr / den;
	    bi[0] = prodi / den;
	}
e740fc0144553ed857c8fbb8b5466999|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|175|1|V|rust
	pub(crate) fn solh(
	    n: usize,
	    a: ArrayView2<f64>,
	    lb: usize,
	    mut b: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k] as usize;
	            let t = b[m];
	            b[m] = b[k]
	            b[k] = t;
	            let na = n.min(lb + k + 1);
	            for i in kp1..na {
	                b[i] += a[[i, k]] * t;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            b[kb] = b[kb] / a[[kb, kb]];
	            let t = -b[kb];
	            for i in 0..(km1 + 1) {
	                b[i] += a[[i, kb]] * t;
	            }
	        }
	    }
	    b[0] = b[0] / a[[0, 0]];
	}
104dd3ffe990342b531a2210b13560e2|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/error_estimate.rs|6|1|V|rust
	impl Radau5 {
	    /// Compute the error estimate for the Radau5 algorithm.
	    pub(crate) fn error_estimate<Params>(integrator: &mut OdeIntegrator<Params, Radau5>) {
	        integrator.cache.err = 0.0;
	
	        let n = integrator.cache.e1.nrows();
	        let hee1 = -(13.0 + 7.0 * 6f64.sqrt()) / (3.0 * integrator.dt);
	        let hee2 = (-13.0 + 7.0 * 6f64.sqrt()) / (3.0 * integrator.dt);
	        let hee3 = -1.0 / (3.0 * integrator.dt);
	
	        for i in 0..n {
	            integrator.cache.f2[i] = hee1 * integrator.cache.z1[i]
	                + hee2 * integrator.cache.z2[i]
	                + hee3 * integrator.cache.z3[i];
	            integrator.cache.cont[i] = integrator.cache.f2[i] + integrator.cache.u0[i];
	        }
	        sol(
	            n,
	            integrator.cache.e1.view(),
	            integrator.cache.cont.view_mut(),
	            integrator.cache.ip1.view(),
	        );
	
	        integrator.cache.err = 0.0;
	        for i in 0..n {
	            integrator.cache.err += (integrator.cache.cont[i] / integrator.cache.scal[i]).powi(2);
	        }
	        integrator.cache.err = (integrator.cache.err / n as f64).sqrt().max(1.0e-10);
	
	        if integrator.cache.err < 1.0 {
	            return;
	        }
	
	        if integrator.cache.first || integrator.cache.reject {
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.cont[i];
	            }
	            (integrator.dudt)(
	                integrator.cache.f1.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t,
	                &integrator.params,
	            );
	            integrator.stats.function_evals += 1;
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.cache.f1[i] + integrator.cache.f2[i];
	            }
	            sol(
	                n,
	                integrator.cache.e1.view(),
	                integrator.cache.cont.view_mut(),
	                integrator.cache.ip1.view(),
	            );
	
	            integrator.cache.err = 0.0;
	            for i in 0..n {
	                integrator.cache.err +=
	                    (integrator.cache.cont[i] / integrator.cache.scal[i]).powi(2);
	            }
	            integrator.cache.err = (integrator.cache.err / n as f64).sqrt().max(1.0e-10);
	        }
	    }
	}
537c4e87bbabd76385dd57bc267db22d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|35|72|v|rust
	<Params, Radau5>
b1657f1d741b08d018720d17d0b67c7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|1|10|v|rust
	::ode
8e29a5517c456e7058a2d25d778a6487|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|73|13|v|rust
	(integrator.dudt)
74ff32ece3e976a82d297af4d7de93a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|77|17|V|rust
	                &integrator.params,
0a3128d08921fb765ff7a4352bc273bc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|80|1|V|rust
	pub fn dudt(mut dw: ArrayViewMut1<f64>, w: ArrayView1<f64>, logx: f64, model: &DarkSun) {
	    let x = logx.exp();
	
	    let meta = model.eta.m;
	    let tsm = meta / x;
	    let xi = model.compute_xi(tsm).unwrap();
	    let td = xi * tsm;
	    let s = sm_entropy_density(tsm);
	    let neq = model.eta.neq(td);
	    let weq = (neq / s).ln();
	
	    let sig_ee_eeee = model.thermal_cross_section_2eta_4eta(meta / td);
	    let sig_eeee_ee = sig_ee_eeee / neq / neq;
	    // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	    let sig_ee_dd = model.thermal_cross_section_2eta_2delta(meta / td);
	
	    let pf_e = -(PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * tsm * s * s;
	    let pf_d = (PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * meta / (x * x);
	
	    // dW_e / dlogx
	    dw[0] = pf_e * sig_eeee_ee * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
	
	    // dY_d / dlogx
	    dw[1] = pf_d * sig_ee_dd * (2.0 * w[0]).exp();
	}
	
	pub fn dfdu(mut j: ArrayViewMut2<f64>, w: ArrayView1<f64>, logx: f64, model: &DarkSun) {
	    let x = logx.exp();
	
	    let meta = model.eta.m;
	    let tsm = meta / x;
	    let xi = model.compute_xi(tsm).unwrap();
	    let td = xi * tsm;
	    let s = sm_entropy_density(tsm);
	    let neq = model.eta.neq(td);
	    let weq = (neq / s).ln();
	
	    let sig_ee_eeee = model.thermal_cross_section_2eta_4eta(meta / td);
	    let sig_eeee_ee = sig_ee_eeee / neq / neq;
	    // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	    let sig_ee_dd = model.thermal_cross_section_2eta_2delta(meta / td);
	
	    let pf_e = -(PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * tsm * s * s;
	    let pf_d = (PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * meta / (x * x);
	
	    // df_d / dW_e
	    j[[0, 0]] = pf_e * sig_eeee_ee * w[0].exp() * (3.0 * (2.0 * w[0]).exp() - (2.0 * weq).exp());
	
	    // df_e / dY_d
	    j[[0, 1]] = 0.0;
	
	    // df_d / dW_e
	    j[[1, 0]] = 2.0 * pf_d * sig_ee_dd * (2.0 * w[0]).exp();
	
	    // df_d / dY_d
	    j[[1, 1]] = 0.0;
	}
4da8302c0815d8e9b0ead5d38fcb9844|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|3|77|v|rust
	, model: &DarkSun
dc6547741ef199feba3b246d037b6cd7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|71|1|V|rust
	impl DarkSun {
	    fn sqrt_gstar(&self, tsm: f64, xi: f64) -> f64 {
	        let td = xi * tsm;
	        let gd = self.eta.geff(td) + self.delta.geff(td);
	        let gsm = sm_geff(tsm);
	        return sm_sqrt_gstar(tsm) * (gsm / (gsm + gd * xi * xi * xi * xi)).sqrt();
	    }
	}
8932f7737c36a1f2c8d5a7af6d25b901|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|72|1|V|rust
	    fn sqrt_gstar(&self, tsm: f64, xi: f64) -> f64 {
	        let td = xi * tsm;
	        let gd = self.eta.geff(td) + self.delta.geff(td);
	        let gsm = sm_geff(tsm);
	        return sm_sqrt_gstar(tsm) * (gsm / (gsm + gd * xi * xi * xi * xi)).sqrt();
	    }
e9655cfacf2a6dac960c7e7a25490f40|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|8|18|v|rust
	self.eta.
d52f1890a82f87e648779b8daa3445f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|55|1|V|rust
	    #[pyo3(get)]
	    pub m_del: f64,
a9bc8eb9ebaa93ccf89e224f4541cebd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|54|1|V|rust
	    /// Mass of the delta.
	    #[pyo3(get)]
	    pub m_del: f64,
593f2e3d0e22e3a9bcbecf7e9c0c4dc8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|57|5|V|rust
	    /// dof delta
5a5695533327f92fe0687fc1218ced64|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|57|5|V|rust
	    pub m_del: f64,
7fcc16411621cbd81dc0e4694ddd9155|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|8|18|v|rust
	geff(td, self.m_eta, 1.0, 0)
5f28ac35a0faf09acd06761f3e43ffa4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|8|49|v|rust
	self.delta.geff(td)
1575e20daa42b9fed0cf437542e58585|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|7|24|v|rust
	as f6;
ae9199d2e730c9cf1d323c59f5aa667c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|18|1|V|rust
	        let meta = self.m_eta;
	        let tsm = meta / x;
	        let xi = self.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = neq(td, self.m_eta, 1.0, 0);
	        let weq = (neq / s).ln();
7925b120ea90257ad4799489af11233e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|16|1|V|rust
	        let x = logx.exp();
	
	        let meta = self.m_eta;
	        let tsm = meta / x;
	        let xi = self.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = neq(td, self.m_eta, 1.0, 0);
	        let weq = (neq / s).ln();
	
	        let sig_ee_eeee = self.rust_thermal_cross_section_2eta_4eta(meta / td);
	        let sig_eeee_ee = sig_ee_eeee / neq / neq;
	        // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	        let sig_ee_dd = self.rust_thermal_cross_section_2eta_2del(meta / td);
	
	        let pf_e = -(PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi) * tsm * s * s;
	        let pf_d = (PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi) * meta / (x * x);
8f47b58137b02bfe0fbf7d302a73462f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|43|1|V|rust
	        let x = logx.exp();
	
	        let meta = model.eta.m;
	        let tsm = meta / x;
	        let xi = model.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = model.eta.neq(td);
	        let weq = (neq / s).ln();
	
	        let sig_ee_eeee = model.thermal_cross_section_2eta_4eta(meta / td);
	        let sig_eeee_ee = sig_ee_eeee / neq / neq;
	        // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	        let sig_ee_dd = model.thermal_cross_section_2eta_2delta(meta / td);
	
	        let pf_e = -(PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * tsm * s * s;
	        let pf_d = (PI / 45.0).sqrt() * M_PLANK * model.sqrt_gstar(tsm, xi) * meta / (x * x);
99dbcd2f003d52a86fd13ee07fe450da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|47|1|V|rust
	            if integrator.u[0] - weq > 0.1 && integrator.params.xi_fo.is_none() {
	                integrator.params.xi_fo = Some(xi);
	                integrator.params.tsm_fo = Some(tsm);
	            }
	            if tsm < T_BBN && integrator.params.xi_bbn.is_none() {
	                integrator.params.xi_bbn = Some(xi);
	            }
61c7f49462554855226b51ec103bf1da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|26|12|v|rust
	integrator.u
c94a9ae8516fc6c1d26cd40c97aaf471|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|26|1|V|rust
	        if w[0] - weq > 0.1 && self.xi_fo.is_none() {
	            integrator.params.xi_fo = Some(xi);
	            integrator.params.tsm_fo = Some(tsm);
	        }
	        if tsm < T_BBN && integrator.params.xi_bbn.is_none() {
	            integrator.params.xi_bbn = Some(xi);
	        }
f4930254f64cb871867d6d85751d4a3a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/continuous_output.rs|5|1|V|rust
	impl Radau5 {
	    #[allow(dead_code)]
	    pub(crate) fn dense_output<Params>(
	        &self,
	        t: f64,
	        integrator: &mut OdeIntegrator<Params, Radau5>,
	    ) -> Array1<f64> {
	        let sq6 = 6f64.sqrt();
	        let c1 = (4.0 - sq6) / 10.0;
	        let c2 = (4.0 + sq6) / 10.0;
	        let c1m1 = c1 - 1.0;
	        let c2m1 = c2 - 1.0;
	
	        let s = (t - integrator.t) / integrator.dtprev;
	        let n = integrator.u.shape()[0];
	
	        let mut res: Array1<f64> = Array1::<f64>::zeros(n);
	
	        res.assign(&((s - c1m1) * &integrator.cache.cont.slice(s![(3 * n)..])));
	        res = (s - c2m1) * (res + s * &integrator.cache.cont.slice(s![(2 * n)..(3 * n)]));
	        res = s * (res + &integrator.cache.cont.slice(s![n..2 * n]));
	        res + &integrator.cache.cont.slice(s![0..n])
	    }
	}
e56c64643e07ccadb0bbcf30d247b026|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|97|1|V|rust
	impl Radau5 {
bedd14820c11f260e2fe85882e88278f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|98|31|v|rust
	<Params>(
36eb4a23d761fd2745667535decac3fe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|101|39|v|rust
	<Params, Radau5>,
42440a319566a47b360ac4215a621512|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/dec.rs|7|1|V|rust
	    /// Perform a decomposition on the real matrices used for solving ODE using
	    /// Radau5
	    pub(crate) fn decomp_real<Params>(integrator: &mut OdeIntegrator<Params, Self>) -> usize {
	        // E1 = fac1 * I - dfdu
	        integrator.cache.e1.assign(
	            &(integrator.cache.fac1 * Array::eye(integrator.cache.e1.shape()[0])
	                - &integrator.cache.dfdu),
	        );
	
	        dec(
	            integrator.cache.e1.nrows(),
	            integrator.cache.e1.view_mut(),
	            integrator.cache.ip1.view_mut(),
	        )
	    }
	
	    /// Perform a decomposition on the complex matrices used for solving ODE using
	    /// Radau5
	    pub(crate) fn decomp_complex<Params>(integrator: &mut OdeIntegrator<Params, Self>) -> usize {
	        let n = integrator.cache.e2r.nrows();
	        let iden = Array::eye(n);
	
	        // E2r = alpha * I - dfdu
	        integrator
	            .cache
	            .e2r
	            .assign(&(integrator.cache.alphn * &iden - &integrator.cache.dfdu));
	        // E2i = beta * I
	        integrator
	            .cache
	            .e2i
	            .assign(&(integrator.cache.betan * &iden));
	        decc(
	            n,
	            integrator.cache.e2r.view_mut(),
	            integrator.cache.e2i.view_mut(),
	            integrator.cache.ip2.view_mut(),
	        )
	    }
	    /// Perform the needed decompositions for the Radau5 algorithm. Returns
	    /// true if the decompositions were successful. False otherwise.
	    pub(super) fn perform_decompositions<Params>(
	        integrator: &mut OdeIntegrator<Params, Self>,
	    ) -> bool {
	        // compute the matrices e1 and e2 and their decompositions
	        integrator.cache.fac1 = Radau5::U1 / integrator.dt;
	        integrator.cache.alphn = Radau5::ALPHA / integrator.dt;
	        integrator.cache.betan = Radau5::BETA / integrator.dt;
	
	        if Self::decomp_real(integrator) == 0 {
	            if Self::decomp_complex(integrator) == 0 {
	                integrator.stats.decompositions += 1;
	                return true;
	            }
	        }
	
	        integrator.cache.nsing += 1;
	        if integrator.cache.nsing >= 5 {
	            integrator.sol.retcode = OdeRetCode::SingularMatrix;
	            return false;
	        }
	        integrator.dt *= 0.5;
	        integrator.cache.dtfac = 0.5;
	        integrator.cache.reject = true;
	        integrator.cache.last = false;
	        if !integrator.cache.caljac {
	            jacobian_u(
	                integrator.dudt,
	                integrator.dfdu,
	                integrator.cache.dfdu.view_mut(),
	                integrator.u.view(),
	                integrator.t,
	                &integrator.params,
	            );
	        }
	        return false;
	    }
0210bba4f8bd8d8b6e84aca2bbb019ff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|157|39|v|rust
	<Params, Self>
631bbe477eeb8ac348a95ee7067e8529|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|133|33|v|rust
	<Params>
b604355bd4b590c9c007959519733dea|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/code.rs|1|1|V|rust
	#[derive(PartialEq, Debug)]
	pub enum OdeRetCode {
	    Continue,
	    Success,
	    MaxIters,
	    DtLessThanMin,
	    Stiff,
	    SingularMatrix,
	    Failure,
	}
6ff1b699d9e91c6d02756976db2af7fb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/linear_solve.rs|6|1|V|rust
	    /// Solve the linear systems for the Radau5 algorithm
	    pub(crate) fn linear_solve<Params>(integrator: &mut OdeIntegrator<Params, Self>) {
	        let n = integrator.cache.e1.nrows();
	        for i in 0..n {
	            let s2 = -integrator.cache.f2[i];
	            let s3 = -integrator.cache.f3[i];
	            integrator.cache.z1[i] -= integrator.cache.f1[i] * integrator.cache.fac1;
	            integrator.cache.z2[i] =
	                integrator.cache.z2[i] + s2 * integrator.cache.alphn - s3 * integrator.cache.betan;
	            integrator.cache.z3[i] =
	                integrator.cache.z3[i] + s3 * integrator.cache.alphn + s2 * integrator.cache.betan;
	        }
	        sol(
	            n,
	            integrator.cache.e1.view(),
	            integrator.cache.z1.view_mut(),
	            integrator.cache.ip1.view(),
	        );
	        solc(
	            n,
	            integrator.cache.e2r.view(),
	            integrator.cache.e2i.view(),
	            integrator.cache.z2.view_mut(),
	            integrator.cache.z3.view_mut(),
	            integrator.cache.ip2.view(),
	        );
	    }
0e0624365cedf186ed1bace0a7408c4a|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/newton.rs|6|1|V|rust
	    pub(super) fn prepare_newton<Params>(integrator: &mut OdeIntegrator<Params, Self>) {
	        let n = integrator.u.len();
	        //  starting values for Newton iteration
	        if integrator.cache.first || !integrator.opts.use_ext_col {
	            for i in 0..n {
	                integrator.cache.z1[i] = 0.0;
	                integrator.cache.z2[i] = 0.0;
	                integrator.cache.z3[i] = 0.0;
	                integrator.cache.f1[i] = 0.0;
	                integrator.cache.f2[i] = 0.0;
	                integrator.cache.f3[i] = 0.0;
	            }
	        } else {
	            let c3q = integrator.dt / integrator.dtprev;
	            let c1q = Radau5::C1 * c3q;
	            let c2q = Radau5::C2 * c3q;
	            for i in 0..n {
	                let ak1 = integrator.cache.cont[i + n];
	                let ak2 = integrator.cache.cont[i + 2 * n];
	                let ak3 = integrator.cache.cont[i + 3 * n];
	
	                integrator.cache.z1[i] = ak3
	                    .mul_add(c1q - Radau5::C1M1, ak2)
	                    .mul_add(c1q - Radau5::C2M1, ak1)
	                    * c1q;
	                integrator.cache.z2[i] = ak3
	                    .mul_add(c2q - Radau5::C1M1, ak2)
	                    .mul_add(c2q - Radau5::C2M1, ak1)
	                    * c2q;
	                integrator.cache.z3[i] = ak3
	                    .mul_add(c3q - Radau5::C1M1, ak2)
	                    .mul_add(c3q - Radau5::C2M1, ak1)
	                    * c3q;
	
	                integrator.cache.f1[i] = Radau5::TI11 * integrator.cache.z1[i]
	                    + Radau5::TI12 * integrator.cache.z2[i]
	                    + Radau5::TI13 * integrator.cache.z3[i];
	                integrator.cache.f2[i] = Radau5::TI21 * integrator.cache.z1[i]
	                    + Radau5::TI22 * integrator.cache.z2[i]
	                    + Radau5::TI23 * integrator.cache.z3[i];
	                integrator.cache.f3[i] = Radau5::TI31 * integrator.cache.z1[i]
	                    + Radau5::TI32 * integrator.cache.z2[i]
	                    + Radau5::TI33 * integrator.cache.z3[i];
	            }
	        }
	    }
	    /// Solve the non-linear systems using a simplified newton iteration.
	    /// Returns true if successful and false otherwise.
	    pub(super) fn newton<Params>(integrator: &mut OdeIntegrator<Params, Self>) -> bool {
	        let n = integrator.u.len();
	
	        Self::prepare_newton(integrator);
	
	        //  loop for the simplified Newton iteration
	        integrator.cache.newt = 0;
	        integrator.cache.faccon = integrator.cache.faccon.max(f64::EPSILON).powf(0.8);
	        integrator.cache.theta = integrator.opts.theta.abs();
	        let mut dyno: f64;
	        let mut dynold: f64 = 0.0;
	        loop {
	            if integrator.cache.newt >= integrator.opts.max_newt_iter {
	                integrator.dt *= 0.5;
	                integrator.cache.dtfac = 0.5;
	                integrator.cache.reject = true;
	                integrator.cache.last = false;
	                if !integrator.cache.caljac {
	                    jacobian_u(
	                        integrator.dudt,
	                        integrator.dfdu,
	                        integrator.cache.dfdu.view_mut(),
	                        integrator.u.view(),
	                        integrator.t,
	                        &integrator.params,
	                    );
	                }
	                return false;
	            }
	            // compute the right-hand side
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z1[i];
	            }
	            (integrator.dudt)(
	                integrator.cache.z1.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + Radau5::C1 * integrator.dt,
	                &integrator.params,
	            );
	
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z2[i];
	            }
	            (integrator.dudt)(
	                integrator.cache.z2.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + Radau5::C2 * integrator.dt,
	                &integrator.params,
	            );
	
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z3[i];
	            }
	            (integrator.dudt)(
	                integrator.cache.z3.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + integrator.dt,
	                &integrator.params,
	            );
	
	            integrator.stats.function_evals += 3;
	
	            // solve the linear systems
	            for i in 0..n {
	                let a1 = integrator.cache.z1[i];
	                let a2 = integrator.cache.z2[i];
	                let a3 = integrator.cache.z3[i];
	                integrator.cache.z1[i] = Radau5::TI11 * a1 + Radau5::TI12 * a2 + Radau5::TI13 * a3;
	                integrator.cache.z2[i] = Radau5::TI21 * a1 + Radau5::TI22 * a2 + Radau5::TI23 * a3;
	                integrator.cache.z3[i] = Radau5::TI31 * a1 + Radau5::TI32 * a2 + Radau5::TI33 * a3;
	            }
	            Self::linear_solve(integrator);
	            integrator.stats.linear_solves += 1;
	            integrator.cache.newt += 1;
	            dyno = 0.0;
	            let mut denom: f64;
	            for i in 0..n {
	                denom = integrator.cache.scal[i];
	                dyno += (integrator.cache.z1[i] / denom).powi(2)
	                    + (integrator.cache.z2[i] / denom).powi(2)
	                    + (integrator.cache.z3[i] / denom).powi(2);
	            }
	            dyno = (dyno / ((3 * n) as f64)).sqrt();
	            // bad convergence or number of iterations to large
	            if (integrator.cache.newt > 1)
	                && (integrator.cache.newt < integrator.opts.max_newt_iter)
	            {
	                let thq = dyno / dynold;
	                integrator.cache.theta = if integrator.cache.newt == 2 {
	                    thq
	                } else {
	                    (thq * integrator.cache.thqold).sqrt()
	                };
	                integrator.cache.thqold = thq;
	                if integrator.cache.theta < 0.99 {
	                    integrator.cache.faccon =
	                        integrator.cache.theta / (1.0 - integrator.cache.theta);
	                    let dyth = integrator.cache.faccon
	                        * dyno
	                        * integrator.cache.theta.powi(
	                            (integrator.opts.max_newt_iter - 1 - integrator.cache.newt) as i32,
	                        )
	                        / integrator.opts.fnewt;
	                    if dyth >= 1.0 {
	                        let qnewt: f64 = 1e-4f64.max(20f64.min(dyth));
	                        integrator.cache.dtfac = 0.8
	                            * qnewt.powf(
	                                -1f64
	                                    / (4 + integrator.opts.max_newt_iter
	                                        - 1
	                                        - integrator.cache.newt)
	                                        as f64,
	                            );
	                        integrator.dt *= integrator.cache.dtfac;
	                        integrator.cache.reject = true;
	                        integrator.cache.last = false;
	                        if integrator.cache.caljac {
	                            jacobian_u(
	                                integrator.dudt,
	                                integrator.dfdu,
	                                integrator.cache.dfdu.view_mut(),
	                                integrator.u.view(),
	                                integrator.t,
	                                &integrator.params,
	                            );
	                        }
	                        return false;
	                    }
	                } else {
	                    integrator.dt *= 0.5;
	                    integrator.cache.dtfac = 0.5;
	                    integrator.cache.reject = true;
	                    integrator.cache.last = false;
	                    if !integrator.cache.caljac {
	                        jacobian_u(
	                            integrator.dudt,
	                            integrator.dfdu,
	                            integrator.cache.dfdu.view_mut(),
	                            integrator.u.view(),
	                            integrator.t,
	                            &integrator.params,
	                        );
	                    }
	                    return false;
	                }
	            }
	            dynold = dyno.max(f64::EPSILON);
	            for i in 0..n {
	                integrator.cache.f1[i] += integrator.cache.z1[i];
	                integrator.cache.f2[i] += integrator.cache.z2[i];
	                integrator.cache.f3[i] += integrator.cache.z3[i];
	                integrator.cache.z1[i] = Radau5::T11 * integrator.cache.f1[i]
	                    + Radau5::T12 * integrator.cache.f2[i]
	                    + Radau5::T13 * integrator.cache.f3[i];
	                integrator.cache.z2[i] = Radau5::T21 * integrator.cache.f1[i]
	                    + Radau5::T22 * integrator.cache.f2[i]
	                    + Radau5::T23 * integrator.cache.f3[i];
	                integrator.cache.z3[i] =
	                    Radau5::T31 * integrator.cache.f1[i] + integrator.cache.f2[i];
	            }
	            if integrator.cache.faccon * dyno <= integrator.opts.fnewt {
	                return true;
	            }
	        }
	    }
4b0235790ca90441a3c823284ea74823|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|293|25|V|rust
	                        &integrator.params,
e786ee5e782c76aa1e256334330092c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|383|33|V|rust
	                                integrator.dudt,
412b0fa46b1ddd4bfc7908f0c5d3f6f0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|383|33|V|rust
	                                integrator.dfdu,
cffa16272884e981ce96f8de07ed37bc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|386|33|V|rust
	                                &integrator.params,
9e82e304caa7bf9cb0341fa6fd39f673|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|400|29|V|rust
	                            &integrator.params,
c0d0e4e3af78d05bbcfa179fab7db265|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/step_size_control.rs|5|1|V|rust
	    pub(super) fn step_size_control<Params>(integrator: &mut OdeIntegrator<Params, Self>) {
	        let n = integrator.u.len();
	        integrator.cache.decompose = true;
	
	        // computation of dtnew -- require 0.2 <= dtnew/integrator.dt <= 8.
	        let fac = integrator.opts.safe.min(
	            integrator.cache.cfac
	                / (integrator.cache.newt + 2 * integrator.opts.max_newt_iter) as f64,
	        );
	        let mut quot = (integrator.opts.facr).max(
	            integrator
	                .opts
	                .facl
	                .min(integrator.cache.err.powf(0.25) / fac),
	        );
	        let mut dtnew = integrator.dt / quot;
	
	        //  is the error small enough ?
	        if integrator.cache.err < 1.0 {
	            // step is accepted
	            integrator.cache.first = false;
	            integrator.stats.accepts += 1;
	            if integrator.opts.modern_pred {
	                // predictive controller of Gustafsson
	                if integrator.stats.accepts > 1 {
	                    let mut facgus = (integrator.cache.dtacc / integrator.dt)
	                        * (integrator.cache.err.powi(2) / integrator.cache.erracc).powf(0.25)
	                        / integrator.opts.safe;
	                    facgus = integrator.opts.facr.max(integrator.opts.facl.min(facgus));
	                    quot = quot.max(facgus);
	                    dtnew = integrator.dt / quot;
	                }
	                integrator.cache.dtacc = integrator.dt;
	                integrator.cache.erracc = 1e-2f64.max(integrator.cache.err);
	            }
	            integrator.tprev = integrator.t;
	            integrator.dtprev = integrator.dt;
	            integrator.t += integrator.dt;
	
	            let mut ak: f64;
	            let mut acont3: f64;
	            for i in 0..n {
	                integrator.u[i] += integrator.cache.z3[i];
	                integrator.cache.cont[i + n] =
	                    (integrator.cache.z2[i] - integrator.cache.z3[i]) / Radau5::C2M1;
	                ak = (integrator.cache.z1[i] - integrator.cache.z2[i]) / Radau5::C1MC2;
	                acont3 = integrator.cache.z1[i] / Radau5::C1;
	                acont3 = (ak - acont3) / Radau5::C2;
	                integrator.cache.cont[i + 2 * n] =
	                    (ak - integrator.cache.cont[i + n]) / Radau5::C1M1;
	                integrator.cache.cont[i + 3 * n] = integrator.cache.cont[i + 2 * n] - acont3;
	            }
	
	            for i in 0..n {
	                integrator.cache.scal[i] =
	                    integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	            }
	
	            if integrator.opts.dense {
	                for i in 0..n {
	                    integrator.cache.cont[i] = integrator.u[i];
	                }
	            }
	
	            integrator.sol.ts.push(integrator.t);
	            integrator.sol.us.push(integrator.u.clone());
	
	            integrator.cache.caljac = false;
	            if integrator.cache.last {
	                integrator.dt = integrator.cache.dtopt;
	                integrator.sol.retcode = OdeRetCode::Success;
	                return;
	            }
	            (integrator.dudt)(
	                integrator.cache.u0.view_mut(),
	                integrator.u.view(),
	                integrator.t,
	                &integrator.params,
	            );
	            integrator.stats.function_evals += 1;
	
	            dtnew = integrator.tdir * dtnew.abs().min(integrator.opts.dtmax);
	            integrator.cache.dtopt = integrator.dt.min(dtnew);
	            if integrator.cache.reject {
	                dtnew = integrator.tdir * dtnew.abs().min(integrator.dt.abs());
	            }
	            integrator.cache.reject = false;
	            if (integrator.t + dtnew / integrator.opts.quot1 - integrator.tfinal) * integrator.tdir
	                >= 0.0
	            {
	                integrator.dt = integrator.tfinal - integrator.t;
	                integrator.cache.last = true;
	            } else {
	                let qt = dtnew / integrator.dt;
	                integrator.cache.dtfac = integrator.dt;
	                if (integrator.cache.theta <= integrator.opts.theta)
	                    && (qt >= integrator.opts.quot1)
	                    && (qt <= integrator.opts.quot2)
	                {
	                    integrator.cache.decompose = false;
	                    return;
	                }
	                integrator.dt = dtnew;
	            }
	            integrator.cache.dtfac = integrator.dt;
	            if integrator.cache.theta > integrator.opts.theta {
	                jacobian_u(
	                    integrator.dudt,
	                    integrator.dfdu,
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                    &integrator.params,
	                );
	            }
	        } else {
	            // step is rejected
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if integrator.cache.first {
	                integrator.dt *= 0.1;
	                integrator.cache.dtfac = 0.1;
	            } else {
	                integrator.cache.dtfac = dtnew / integrator.dt;
	                integrator.dt = dtnew;
	            }
	            if integrator.stats.accepts >= 1 {
	                integrator.stats.rejects += 1;
	            }
	            if !integrator.cache.caljac {
	                jacobian_u(
	                    integrator.dudt,
	                    integrator.dfdu,
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                    &integrator.params,
	                );
	            }
	        }
	    }
e5a9bd49ca16709e5f207a065b57ffff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|531|21|V|rust
	                    integrator.dudt,
50ef2c842e29d7c37cf36fe8e53d0070|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|531|21|V|rust
	                    integrator.dfdu,
4e856d0bfbe9b18acdfe31749272374b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|534|21|V|rust
	                    &integrator.params,
3acd1cfe076b0cfeef5dab6b3a8531b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|25|1|V|rust
	    pub solu: Vec<Array1<f64>>,
663520c403325d97b8969b7a81950d08|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|26|19|v|rust
	Array1<f64>>,
1171e2285fcf79a652e826b19eb736bc|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|100|1|V|rust
	    fn step<Params>(integrator: &mut OdeIntegrator<Params, Self>) {
	        if integrator.t + integrator.dt * 1.0001 - integrator.tfinal * integrator.tdir >= 0.0 {
	            integrator.dt = integrator.tfinal - integrator.t;
	            integrator.cache.last = true;
	        }
	        loop {
	            if integrator.cache.decompose {
	                // Perform needed decompositions until we succeed.
	                loop {
	                    let success = Self::perform_decompositions(integrator);
	                    if success {
	                        break;
	                    } else if integrator.sol.retcode != OdeRetCode::Continue {
	                        return;
	                    }
	                }
	            }
	
	            integrator.stats.steps += 1;
	
	            // Check that we haven't passed max allowed steps
	            if integrator.stats.steps >= integrator.opts.max_steps {
	                integrator.sol.retcode = OdeRetCode::MaxIters;
	                return;
	            }
	            // Check that the step size isn't too small
	            if 0.1 * (integrator.dt).abs() <= (integrator.t).abs() * f64::EPSILON {
	                integrator.sol.retcode = OdeRetCode::DtLessThanMin;
	                return;
	            }
	
	            // Solve the non-linear systems using a simplified Newton's method.
	            if !Self::newton(integrator) {
	                continue;
	            }
	
	            // error estimation
	            Self::error_estimate(integrator);
	
	            //Adjust the step size
	            Self::step_size_control(integrator);
	
	            if !integrator.cache.reject {
	                break;
	            }
	        }
	    }
e27781cae75ea4bb7fec369f52bdfb69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|558|13|v|rust
	Params>
93e6e1554f774aaeb87ecec3f6a9ff4f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|7|1|V|rust
	    type Cache = Radau5Cache;
	    fn default_opts() -> OdeIntegratorOpts {
	        let mut opts = OdeIntegratorOpts::new();
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.theta = 0.001;
	        opts.fnewt = 0.0;
	        opts.quot1 = 1.0;
	        opts.quot2 = 1.2;
	        opts.facr = 1.0 / 8.0;
	        opts.facl = 5.0;
	        opts.max_steps = 100000;
	        opts.max_newt_iter = 7;
	        opts.use_ext_col = true;
	        opts.modern_pred = true;
	        opts
	    }
f2a13513f2d8d6eb5bf38bc14893d4a8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|24|1|V|rust
	    fn new_cache<Params>(integrator: &mut OdeIntegratorBuilder<Params, Self>) -> Self::Cache {
	        let quot = integrator.opts.abstol / integrator.opts.reltol;
	        integrator.opts.reltol = 0.1 * integrator.opts.reltol.powf(2.0 / 3.0);
	        integrator.opts.abstol = integrator.opts.reltol * quot;
	
	        let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
	
	        let n = integrator.u.shape()[0];
	        let mut u0 = Array1::<f64>::zeros(n);
	        let mut scal = Array1::<f64>::zeros(n);
	        let mut dfdu = Array2::<f64>::zeros((n, n));
	
	        for i in 0..integrator.u.len() {
	            scal[i] = integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	        }
	
	        // Initialize the cache
	        (integrator.dudt)(
	            u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	            &mut integrator.params,
	        );
	
	        jacobian_u(
	            integrator.dudt,
	            integrator.dfdu,
	            dfdu.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	            &integrator.params,
	        );
	
	        if integrator.opts.fnewt <= 0.0 {
	            integrator.opts.fnewt = (10.0 * f64::EPSILON / integrator.opts.reltol)
	                .max(0.03f64.min(integrator.opts.reltol.sqrt()));
	        }
	
	        Radau5Cache {
	            caljac: false,
	            first: true,
	            last: false,
	            reject: false,
	            decompose: true,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            dtopt: integrator.dt,
	            faccon: 1.0,
	            dtfac: integrator.dt,
	            dtacc: 0.0,
	            erracc: 0.0,
	            thqold: 0.0,
	            cfac,
	            theta: 0.0,
	            nsing: 0,
	            newt: 0,
	            u0,
	            scal,
	            /// Coninuous output vectors
	            cont: Array1::<f64>::zeros(4 * n),
	            z1: Array1::<f64>::zeros(n),
	            z2: Array1::<f64>::zeros(n),
	            z3: Array1::<f64>::zeros(n),
	            f1: Array1::<f64>::zeros(n),
	            f2: Array1::<f64>::zeros(n),
	            f3: Array1::<f64>::zeros(n),
	            ip1: Array1::<i32>::zeros(n),
	            ip2: Array1::<i32>::zeros(n),
	            e1: Array2::<f64>::zeros((n, n)),
	            e2r: Array2::<f64>::zeros((n, n)),
	            e2i: Array2::<f64>::zeros((n, n)),
	            dfdu,
	        }
	    }
9e81bbdafe2c75ed85dd1dbe53106222|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|40|78|v|rust
	::Cache
7257826c02c707395c8e6c2ddadc8a7d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|69|13|V|rust
	            &integrator.params,
1d6ef70c5ba21fd4513c4aabcb74af29|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/radau/algorithm.rs|8|1|V|rust
	    fn default_opts() -> OdeIntegratorOpts {
	        let mut opts = OdeIntegratorOpts::new();
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.theta = 0.001;
	        opts.fnewt = 0.0;
	        opts.quot1 = 1.0;
	        opts.quot2 = 1.2;
	        opts.facr = 1.0 / 8.0;
	        opts.facl = 5.0;
	        opts.max_steps = 100000;
	        opts.max_newt_iter = 7;
	        opts.use_ext_col = true;
	        opts.modern_pred = true;
	        opts
	    }
0af9d062cd40f35ce0e2cc356e62be50|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|42|1|V|rust
	        fn new_cache<Params>(integrator: &mut OdeIntegratorBuilder<Params, Self>) -> Self::Cache {
	        let quot = integrator.opts.abstol / integrator.opts.reltol;
	        integrator.opts.reltol = 0.1 * integrator.opts.reltol.powf(2.0 / 3.0);
	        integrator.opts.abstol = integrator.opts.reltol * quot;
	
	        let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
	
	        let n = integrator.u.shape()[0];
	        let mut u0 = Array1::<f64>::zeros(n);
	        let mut scal = Array1::<f64>::zeros(n);
	        let mut dfdu = Array2::<f64>::zeros((n, n));
	
	        for i in 0..integrator.u.len() {
	            scal[i] = integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	        }
	
	        // Initialize the cache
	        (integrator.dudt)(
	            u0.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	            &mut integrator.params,
	        );
	
	        jacobian_u(
	            integrator.dudt,
	            integrator.dfdu,
	            dfdu.view_mut(),
	            integrator.u.view(),
	            integrator.t,
	            &integrator.params,
	        );
	
	        if integrator.opts.fnewt <= 0.0 {
	            integrator.opts.fnewt = (10.0 * f64::EPSILON / integrator.opts.reltol)
	                .max(0.03f64.min(integrator.opts.reltol.sqrt()));
	        }
	
	        Radau5Cache {
	            caljac: false,
	            first: true,
	            last: false,
	            reject: false,
	            decompose: true,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            dtopt: integrator.dt,
	            faccon: 1.0,
	            dtfac: integrator.dt,
	            dtacc: 0.0,
	            erracc: 0.0,
	            thqold: 0.0,
	            cfac,
	            theta: 0.0,
	            nsing: 0,
	            newt: 0,
	            u0,
	            scal,
	            /// Coninuous output vectors
	            cont: Array1::<f64>::zeros(4 * n),
	            z1: Array1::<f64>::zeros(n),
	            z2: Array1::<f64>::zeros(n),
	            z3: Array1::<f64>::zeros(n),
	            f1: Array1::<f64>::zeros(n),
	            f2: Array1::<f64>::zeros(n),
	            f3: Array1::<f64>::zeros(n),
	            ip1: Array1::<i32>::zeros(n),
	            ip2: Array1::<i32>::zeros(n),
	            e1: Array2::<f64>::zeros((n, n)),
	            e2r: Array2::<f64>::zeros((n, n)),
	            e2i: Array2::<f64>::zeros((n, n)),
	            dfdu,
	        }
	    }
7983c036ba48411b7b9c2c6fe6ce6ffc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|558|1|V|rust
	    #[allow(dead_code)]
	    fn step(integrator: &mut OdeIntegrator, model: &mut DarkSun) {
	        if integrator.t + integrator.dt * 1.0001 - integrator.tfinal * integrator.tdir >= 0.0 {
	            integrator.dt = integrator.tfinal - integrator.t;
	            integrator.cache.last = true;
	        }
	        loop {
	            if integrator.cache.decompose {
	                // Perform needed decompositions until we succeed.
	                loop {
	                    let success = Radau5::perform_decompositions(integrator, model);
	                    if success {
	                        break;
	                    } else if integrator.retcode != OdeRetCode::Continue {
	                        return;
	                    }
	                }
	            }
	
	            integrator.stats.steps += 1;
	
	            // Check that we haven't passed max allowed steps
	            if integrator.stats.steps >= integrator.opts.max_steps {
	                integrator.retcode = OdeRetCode::MaxIters;
	                return;
	            }
	            // Check that the step size isn't too small
	            if 0.1 * (integrator.dt).abs() <= (integrator.t).abs() * f64::EPSILON {
	                integrator.retcode = OdeRetCode::DtLessThanMin;
	                return;
	            }
	
	            // Solve the non-linear systems using a simplified Newton's method.
	            if !Radau5::newton(integrator, model) {
	                continue;
	            }
	
	            // error estimation
	            Radau5::error_estimate(integrator, model);
	
	            //Adjust the step size
	            Radau5::step_size_control(integrator, model);
	
	            if !integrator.cache.reject {
	                break;
	            }
	        }
	    }
177da4eab9b60b42255c5f500e0e2a6f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|37|1|V|rust
	    /// Compute the error estimate for the Radau5 algorithm.
	    #[allow(dead_code)]
	    pub(crate) fn error_estimate(integrator: &mut OdeIntegrator, model: &mut DarkSun) {
	        integrator.cache.err = 0.0;
	
	        let n = integrator.cache.e1.nrows();
	        let hee1 = -(13.0 + 7.0 * 6f64.sqrt()) / (3.0 * integrator.dt);
	        let hee2 = (-13.0 + 7.0 * 6f64.sqrt()) / (3.0 * integrator.dt);
	        let hee3 = -1.0 / (3.0 * integrator.dt);
	
	        for i in 0..n {
	            integrator.cache.f2[i] = hee1 * integrator.cache.z1[i]
	                + hee2 * integrator.cache.z2[i]
	                + hee3 * integrator.cache.z3[i];
	            integrator.cache.cont[i] = integrator.cache.f2[i] + integrator.cache.u0[i];
	        }
	        sol(
	            n,
	            integrator.cache.e1.view(),
	            integrator.cache.cont.view_mut(),
	            integrator.cache.ip1.view(),
	        );
	
	        integrator.cache.err = 0.0;
	        for i in 0..n {
	            integrator.cache.err += (integrator.cache.cont[i] / integrator.cache.scal[i]).powi(2);
	        }
	        integrator.cache.err = (integrator.cache.err / n as f64).sqrt().max(1.0e-10);
	
	        if integrator.cache.err < 1.0 {
	            return;
	        }
	
	        if integrator.cache.first || integrator.cache.reject {
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.cont[i];
	            }
	            model.dudt(
	                integrator.cache.f1.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t,
	            );
	            integrator.stats.function_evals += 1;
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.cache.f1[i] + integrator.cache.f2[i];
	            }
	            sol(
	                n,
	                integrator.cache.e1.view(),
	                integrator.cache.cont.view_mut(),
	                integrator.cache.ip1.view(),
	            );
	
	            integrator.cache.err = 0.0;
	            for i in 0..n {
	                integrator.cache.err +=
	                    (integrator.cache.cont[i] / integrator.cache.scal[i]).powi(2);
	            }
	            integrator.cache.err = (integrator.cache.err / n as f64).sqrt().max(1.0e-10);
	        }
	    }
193c95e0907b1de4946a6498f9196564|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|37|1|V|rust
	    #[allow(dead_code)]
	    pub(crate) fn dense_output(&self, t: f64, integrator: &mut OdeIntegrator) -> Array1<f64> {
	        let sq6 = 6f64.sqrt();
	        let c1 = (4.0 - sq6) / 10.0;
	        let c2 = (4.0 + sq6) / 10.0;
	        let c1m1 = c1 - 1.0;
	        let c2m1 = c2 - 1.0;
	
	        let s = (t - integrator.t) / integrator.dtprev;
	        let n = integrator.u.shape()[0];
	
	        let mut res: Array1<f64> = Array1::<f64>::zeros(n);
	
	        res.assign(&((s - c1m1) * &integrator.cache.cont.slice(s![(3 * n)..])));
	        res = (s - c2m1) * (res + s * &integrator.cache.cont.slice(s![(2 * n)..(3 * n)]));
	        res = s * (res + &integrator.cache.cont.slice(s![n..2 * n]));
	        res + &integrator.cache.cont.slice(s![0..n])
	    }
10236d190a736c2c71a3e2b215b7885f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|37|1|V|rust
	    /// Perform a decomposition on the real matrices used for solving ODE using
	    /// Radau5
	    #[allow(dead_code)]
	    pub(crate) fn decomp_real(integrator: &mut OdeIntegrator) -> usize {
	        // E1 = fac1 * I - dfdu
	        integrator.cache.e1.assign(
	            &(integrator.cache.fac1 * Array::eye(integrator.cache.e1.shape()[0])
	                - &integrator.cache.dfdu),
	        );
	
	        dec(
	            integrator.cache.e1.nrows(),
	            integrator.cache.e1.view_mut(),
	            integrator.cache.ip1.view_mut(),
	        )
	    }
	
	    /// Perform a decomposition on the complex matrices used for solving ODE using
	    /// Radau5
	    #[allow(dead_code)]
	    pub(crate) fn decomp_complex(integrator: &mut OdeIntegrator) -> usize {
	        let n = integrator.cache.e2r.nrows();
	        let iden = Array::eye(n);
	
	        // E2r = alpha * I - dfdu
	        integrator
	            .cache
	            .e2r
	            .assign(&(integrator.cache.alphn * &iden - &integrator.cache.dfdu));
	        // E2i= beta * I
	        integrator
	            .cache
	            .e2i
	            .assign(&(integrator.cache.betan * &iden));
	        decc(
	            n,
	            integrator.cache.e2r.view_mut(),
	            integrator.cache.e2i.view_mut(),
	            integrator.cache.ip2.view_mut(),
	        )
	    }
	    /// Perform the needed decompositions for the Radau5 algorithm. Returns
	    /// true if the decompositions were successful. False otherwise.
	    #[allow(dead_code)]
	    pub(super) fn perform_decompositions(
	        integrator: &mut OdeIntegrator,
	        model: &mut DarkSun,
	    ) -> bool {
	        // compute the matrices e1 and e2 and their decompositions
	        integrator.cache.fac1 = Radau5::U1 / integrator.dt;
	        integrator.cache.alphn = Radau5::ALPHA / integrator.dt;
	        integrator.cache.betan = Radau5::BETA / integrator.dt;
	
	        if Self::decomp_real(integrator) == 0 {
	            if Self::decomp_complex(integrator) == 0 {
	                integrator.stats.decompositions += 1;
	                return true;
	            }
	        }
	
	        integrator.cache.nsing += 1;
	        if integrator.cache.nsing >= 5 {
	            integrator.retcode = OdeRetCode::SingularMatrix;
	            return false;
	        }
	        integrator.dt *= 0.5;
	        integrator.cache.dtfac = 0.5;
	        integrator.cache.reject = true;
	        integrator.cache.last = false;
	        if !integrator.cache.caljac {
	            model.dfdu(
	                integrator.cache.dfdu.view_mut(),
	                integrator.u.view(),
	                integrator.t,
	            );
	        }
	        return false;
	    }
	    /// Solve the linear systems for the Radau5 algorithm
	    #[allow(dead_code)]
	    pub(crate) fn linear_solve(integrator: &mut OdeIntegrator) {
	        let n = integrator.cache.e1.nrows();
	        for i in 0..n {
	            let s2 = -integrator.cache.f2[i];
	            let s3 = -integrator.cache.f3[i];
	            integrator.cache.z1[i] -= integrator.cache.f1[i] * integrator.cache.fac1;
	            integrator.cache.z2[i] =
	                integrator.cache.z2[i] + s2 * integrator.cache.alphn - s3 * integrator.cache.betan;
	            integrator.cache.z3[i] =
	                integrator.cache.z3[i] + s3 * integrator.cache.alphn + s2 * integrator.cache.betan;
	        }
	        sol(
	            n,
	            integrator.cache.e1.view(),
	            integrator.cache.z1.view_mut(),
	            integrator.cache.ip1.view(),
	        );
	        solc(
	            n,
	            integrator.cache.e2r.view(),
	            integrator.cache.e2i.view(),
	            integrator.cache.z2.view_mut(),
	            integrator.cache.z3.view_mut(),
	            integrator.cache.ip2.view(),
	        );
	    }
d6aaadcb56c37f2ecc690ef074b1ce6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|37|1|V|rust
	    #[allow(dead_code)]
	    pub(super) fn prepare_newton(integrator: &mut OdeIntegrator) {
	        let n = integrator.u.len();
	        //  starting values for Newton iteration
	        if integrator.cache.first || !integrator.opts.use_ext_col {
	            for i in 0..n {
	                integrator.cache.z1[i] = 0.0;
	                integrator.cache.z2[i] = 0.0;
	                integrator.cache.z3[i] = 0.0;
	                integrator.cache.f1[i] = 0.0;
	                integrator.cache.f2[i] = 0.0;
	                integrator.cache.f3[i] = 0.0;
	            }
	        } else {
	            let c3q = integrator.dt / integrator.dtprev;
	            let c1q = Radau5::C1 * c3q;
	            let c2q = Radau5::C2 * c3q;
	            for i in 0..n {
	                let ak1 = integrator.cache.cont[i + n];
	                let ak2 = integrator.cache.cont[i + 2 * n];
	                let ak3 = integrator.cache.cont[i + 3 * n];
	
	                integrator.cache.z1[i] = ak3
	                    .mul_add(c1q - Radau5::C1M1, ak2)
	                    .mul_add(c1q - Radau5::C2M1, ak1)
	                    * c1q;
	                integrator.cache.z2[i] = ak3
	                    .mul_add(c2q - Radau5::C1M1, ak2)
	                    .mul_add(c2q - Radau5::C2M1, ak1)
	                    * c2q;
	                integrator.cache.z3[i] = ak3
	                    .mul_add(c3q - Radau5::C1M1, ak2)
	                    .mul_add(c3q - Radau5::C2M1, ak1)
	                    * c3q;
	
	                integrator.cache.f1[i] = Radau5::TI11 * integrator.cache.z1[i]
	                    + Radau5::TI12 * integrator.cache.z2[i]
	                    + Radau5::TI13 * integrator.cache.z3[i];
	                integrator.cache.f2[i] = Radau5::TI21 * integrator.cache.z1[i]
	                    + Radau5::TI22 * integrator.cache.z2[i]
	                    + Radau5::TI23 * integrator.cache.z3[i];
	                integrator.cache.f3[i] = Radau5::TI31 * integrator.cache.z1[i]
	                    + Radau5::TI32 * integrator.cache.z2[i]
	                    + Radau5::TI33 * integrator.cache.z3[i];
	            }
	        }
	    }
	    /// Solve the non-linear systems using a simplified newton iteration.
	    /// Returns true if successful and false otherwise.
	    pub(super) fn newton(integrator: &mut OdeIntegrator, model: &mut DarkSun) -> bool {
	        let n = integrator.u.len();
	
	        Self::prepare_newton(integrator);
	
	        //  loop for the simplified Newton iteration
	        integrator.cache.newt = 0;
	        integrator.cache.faccon = integrator.cache.faccon.max(f64::EPSILON).powf(0.8);
	        integrator.cache.theta = integrator.opts.theta.abs();
	        let mut dyno: f64;
	        let mut dynold: f64 = 0.0;
	        loop {
	            if integrator.cache.newt >= integrator.opts.max_newt_iter {
	                integrator.dt *= 0.5;
	                integrator.cache.dtfac = 0.5;
	                integrator.cache.reject = true;
	                integrator.cache.last = false;
	                if !integrator.cache.caljac {
	                    model.dfdu(
	                        integrator.cache.dfdu.view_mut(),
	                        integrator.u.view(),
	                        integrator.t,
	                    );
	                }
	                return false;
	            }
	            // compute the right-hand side
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z1[i];
	            }
	            model.dudt(
	                integrator.cache.z1.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + Radau5::C1 * integrator.dt,
	            );
	
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z2[i];
	            }
	            model.dudt(
	                integrator.cache.z2.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + Radau5::C2 * integrator.dt,
	            );
	
	            for i in 0..n {
	                integrator.cache.cont[i] = integrator.u[i] + integrator.cache.z3[i];
	            }
	            model.dudt(
	                integrator.cache.z3.view_mut(),
	                integrator.cache.cont.slice(s![..n]),
	                integrator.t + integrator.dt,
	            );
	
	            integrator.stats.function_evals += 3;
	
	            // solve the linear systems
	            for i in 0..n {
	                let a1 = integrator.cache.z1[i];
	                let a2 = integrator.cache.z2[i];
	                let a3 = integrator.cache.z3[i];
	                integrator.cache.z1[i] = Radau5::TI11 * a1 + Radau5::TI12 * a2 + Radau5::TI13 * a3;
	                integrator.cache.z2[i] = Radau5::TI21 * a1 + Radau5::TI22 * a2 + Radau5::TI23 * a3;
	                integrator.cache.z3[i] = Radau5::TI31 * a1 + Radau5::TI32 * a2 + Radau5::TI33 * a3;
	            }
	            Self::linear_solve(integrator);
	            integrator.stats.linear_solves += 1;
	            integrator.cache.newt += 1;
	            dyno = 0.0;
	            let mut denom: f64;
	            for i in 0..n {
	                denom = integrator.cache.scal[i];
	                dyno += (integrator.cache.z1[i] / denom).powi(2)
	                    + (integrator.cache.z2[i] / denom).powi(2)
	                    + (integrator.cache.z3[i] / denom).powi(2);
	            }
	            dyno = (dyno / ((3 * n) as f64)).sqrt();
	            // bad convergence or number of iterations to large
	            if (integrator.cache.newt > 1)
	                && (integrator.cache.newt < integrator.opts.max_newt_iter)
	            {
	                let thq = dyno / dynold;
	                integrator.cache.theta = if integrator.cache.newt == 2 {
	                    thq
	                } else {
	                    (thq * integrator.cache.thqold).sqrt()
	                };
	                integrator.cache.thqold = thq;
	                if integrator.cache.theta < 0.99 {
	                    integrator.cache.faccon =
	                        integrator.cache.theta / (1.0 - integrator.cache.theta);
	                    let dyth = integrator.cache.faccon
	                        * dyno
	                        * integrator.cache.theta.powi(
	                            (integrator.opts.max_newt_iter - 1 - integrator.cache.newt) as i32,
	                        )
	                        / integrator.opts.fnewt;
	                    if dyth >= 1.0 {
	                        let qnewt: f64 = 1e-4f64.max(20f64.min(dyth));
	                        integrator.cache.dtfac = 0.8
	                            * qnewt.powf(
	                                -1f64
	                                    / (4 + integrator.opts.max_newt_iter
	                                        - 1
	                                        - integrator.cache.newt)
	                                        as f64,
	                            );
	                        integrator.dt *= integrator.cache.dtfac;
	                        integrator.cache.reject = true;
	                        integrator.cache.last = false;
	                        if integrator.cache.caljac {
	                            model.dfdu(
	                                integrator.cache.dfdu.view_mut(),
	                                integrator.u.view(),
	                                integrator.t,
	                            );
	                        }
	                        return false;
	                    }
	                } else {
	                    integrator.dt *= 0.5;
	                    integrator.cache.dtfac = 0.5;
	                    integrator.cache.reject = true;
	                    integrator.cache.last = false;
	                    if !integrator.cache.caljac {
	                        model.dfdu(
	                            integrator.cache.dfdu.view_mut(),
	                            integrator.u.view(),
	                            integrator.t,
	                        );
	                    }
	                    return false;
	                }
	            }
	            dynold = dyno.max(f64::EPSILON);
	            for i in 0..n {
	                integrator.cache.f1[i] += integrator.cache.z1[i];
	                integrator.cache.f2[i] += integrator.cache.z2[i];
	                integrator.cache.f3[i] += integrator.cache.z3[i];
	                integrator.cache.z1[i] = Radau5::T11 * integrator.cache.f1[i]
	                    + Radau5::T12 * integrator.cache.f2[i]
	                    + Radau5::T13 * integrator.cache.f3[i];
	                integrator.cache.z2[i] = Radau5::T21 * integrator.cache.f1[i]
	                    + Radau5::T22 * integrator.cache.f2[i]
	                    + Radau5::T23 * integrator.cache.f3[i];
	                integrator.cache.z3[i] =
	                    Radau5::T31 * integrator.cache.f1[i] + integrator.cache.f2[i];
	            }
	            if integrator.cache.faccon * dyno <= integrator.opts.fnewt {
	                return true;
	            }
	        }
	    }
4629087f3b0412241c059b4f6838348b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|37|1|V|rust
	    pub(super) fn step_size_control(integrator: &mut OdeIntegrator, model: &mut DarkSun) {
	        let n = integrator.u.len();
	        integrator.cache.decompose = true;
	
	        // computation of dtnew -- require 0.2 <= dtnew/integrator.dt <= 8.
	        let fac = integrator.opts.safe.min(
	            integrator.cache.cfac
	                / (integrator.cache.newt + 2 * integrator.opts.max_newt_iter) as f64,
	        );
	        let mut quot = (integrator.opts.facr).max(
	            integrator
	                .opts
	                .facl
	                .min(integrator.cache.err.powf(0.25) / fac),
	        );
	        let mut dtnew = integrator.dt / quot;
	
	        //  is the error small enough ?
	        if integrator.cache.err < 1.0 {
	            // step is accepted
	            integrator.cache.first = false;
	            integrator.stats.accepts += 1;
	            if integrator.opts.modern_pred {
	                // predictive controller of Gustafsson
	                if integrator.stats.accepts > 1 {
	                    let mut facgus = (integrator.cache.dtacc / integrator.dt)
	                        * (integrator.cache.err.powi(2) / integrator.cache.erracc).powf(0.25)
	                        / integrator.opts.safe;
	                    facgus = integrator.opts.facr.max(integrator.opts.facl.min(facgus));
	                    quot = quot.max(facgus);
	                    dtnew = integrator.dt / quot;
	                }
	                integrator.cache.dtacc = integrator.dt;
	                integrator.cache.erracc = 1e-2f64.max(integrator.cache.err);
	            }
	            integrator.tprev = integrator.t;
	            integrator.dtprev = integrator.dt;
	            integrator.t += integrator.dt;
	
	            let mut ak: f64;
	            let mut acont3: f64;
	            for i in 0..n {
	                integrator.u[i] += integrator.cache.z3[i];
	                integrator.cache.cont[i + n] =
	                    (integrator.cache.z2[i] - integrator.cache.z3[i]) / Radau5::C2M1;
	                ak = (integrator.cache.z1[i] - integrator.cache.z2[i]) / Radau5::C1MC2;
	                acont3 = integrator.cache.z1[i] / Radau5::C1;
	                acont3 = (ak - acont3) / Radau5::C2;
	                integrator.cache.cont[i + 2 * n] =
	                    (ak - integrator.cache.cont[i + n]) / Radau5::C1M1;
	                integrator.cache.cont[i + 3 * n] = integrator.cache.cont[i + 2 * n] - acont3;
	            }
	
	            for i in 0..n {
	                integrator.cache.scal[i] =
	                    integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	            }
	
	            if integrator.opts.dense {
	                for i in 0..n {
	                    integrator.cache.cont[i] = integrator.u[i];
	                }
	            }
	
	            integrator.solt.push(integrator.t);
	            integrator.solu.push(integrator.u.clone());
	
	            integrator.cache.caljac = false;
	            if integrator.cache.last {
	                integrator.dt = integrator.cache.dtopt;
	                integrator.retcode = OdeRetCode::Success;
	                return;
	            }
	            model.dudt(
	                integrator.cache.u0.view_mut(),
	                integrator.u.view(),
	                integrator.t,
	            );
	            integrator.stats.function_evals += 1;
	
	            dtnew = integrator.tdir * dtnew.abs().min(integrator.opts.dtmax);
	            integrator.cache.dtopt = integrator.dt.min(dtnew);
	            if integrator.cache.reject {
	                dtnew = integrator.tdir * dtnew.abs().min(integrator.dt.abs());
	            }
	            integrator.cache.reject = false;
	            if (integrator.t + dtnew / integrator.opts.quot1 - integrator.tfinal) * integrator.tdir
	                >= 0.0
	            {
	                integrator.dt = integrator.tfinal - integrator.t;
	                integrator.cache.last = true;
	            } else {
	                let qt = dtnew / integrator.dt;
	                integrator.cache.dtfac = integrator.dt;
	                if (integrator.cache.theta <= integrator.opts.theta)
	                    && (qt >= integrator.opts.quot1)
	                    && (qt <= integrator.opts.quot2)
	                {
	                    integrator.cache.decompose = false;
	                    return;
	                }
	                integrator.dt = dtnew;
	            }
	            integrator.cache.dtfac = integrator.dt;
	            if integrator.cache.theta > integrator.opts.theta {
	                model.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	        } else {
	            // step is rejected
	            integrator.cache.reject = true;
	            integrator.cache.last = false;
	            if integrator.cache.first {
	                integrator.dt *= 0.1;
	                integrator.cache.dtfac = 0.1;
	            } else {
	                integrator.cache.dtfac = dtnew / integrator.dt;
	                integrator.dt = dtnew;
	            }
	            if integrator.stats.accepts >= 1 {
	                integrator.stats.rejects += 1;
	            }
	            if !integrator.cache.caljac {
	                model.dfdu(
	                    integrator.cache.dfdu.view_mut(),
	                    integrator.u.view(),
	                    integrator.t,
	                );
	            }
	        }
	    }
a232225c542e9f3864a5ba4652cb2e73|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|36|1|V|rust
	impl Radau5 {
	}
135f4645bb6356276a9d105be723d5ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|1|1|V|rust
	use super::integrator::*;
	use super::linalg::*;
	use crate::DarkSun;
	use ndarray::prelude::*;
7d8391a3ce744cf674bdee3238bc5f77|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/prepare.rs|1|1|V|rust
	use super::integrator::*;
	use super::linalg::*;
	use super::radau5::*;
	use crate::DarkSun;
	use ndarray::prelude::*;
be3e5c38e8d8c47398d79acd3d524f19|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/newton.rs|1|1|V|rust
	use super::decomp::*;
	use super::integrator::*;
	use super::linalg::*;
	use super::radau5::*;
	use crate::DarkSun;
	use ndarray::prelude::*;
e58b2e04314c7ce6bff32b384f07d047|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/decomp.rs|1|1|V|rust
	use super::decomp::*;
f7c651c54a10a317a73319c532c0bd94|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/continuous_output.rs|2|1|V|rust
	use super::linalg::*;
5283d4ef54ed23aa2e9bd653aa47d50e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/continuous_output.rs|3|1|V|rust
	use crate::DarkSun;
f8c771c78f9791df62f321aef068b758|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|42|1|V|rust
	    #[allow(dead_code)]
	    pub fn default_opts() -> OdeIntegratorOpts {
	        let mut opts = OdeIntegratorOpts::new();
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.theta = 0.001;
	        opts.fnewt = 0.0;
	        opts.quot1 = 1.0;
	        opts.quot2 = 1.2;
	        opts.facr = 1.0 / 8.0;
	        opts.facl = 5.0;
	        opts.max_steps = 100000;
	        opts.max_newt_iter = 7;
	        opts.use_ext_col = true;
	        opts.modern_pred = true;
	        opts
	    }
	    #[allow(dead_code)]
	    pub fn new_cache(integrator: &mut OdeIntegrator, model: &mut DarkSun) -> Self {
	        let quot = integrator.opts.abstol / integrator.opts.reltol;
	        integrator.opts.reltol = 0.1 * integrator.opts.reltol.powf(2.0 / 3.0);
	        integrator.opts.abstol = integrator.opts.reltol * quot;
	
	        let cfac = integrator.opts.safe * (1 + 2 * integrator.opts.max_newt_iter) as f64;
	
	        let n = integrator.u.shape()[0];
	        let mut u0 = Array1::<f64>::zeros(n);
	        let mut scal = Array1::<f64>::zeros(n);
	        let mut dfdu = Array2::<f64>::zeros((n, n));
	
	        for i in 0..integrator.u.len() {
	            scal[i] = integrator.opts.abstol + integrator.opts.reltol * integrator.u[i].abs();
	        }
	
	        // Initialize the cache
	        model.dudt(u0.view_mut(), integrator.u.view(), integrator.t);
	
	        model.dfdu(dfdu.view_mut(), integrator.u.view(), integrator.t);
	
	        if integrator.opts.fnewt <= 0.0 {
	            integrator.opts.fnewt = (10.0 * f64::EPSILON / integrator.opts.reltol)
	                .max(0.03f64.min(integrator.opts.reltol.sqrt()));
	        }
	
	        Radau5Cache {
	            caljac: false,
	            first: true,
	            last: false,
	            reject: false,
	            decompose: true,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            dtopt: integrator.dt,
	            faccon: 1.0,
	            dtfac: integrator.dt,
	            dtacc: 0.0,
	            erracc: 0.0,
	            thqold: 0.0,
	            cfac,
	            theta: 0.0,
	            nsing: 0,
	            newt: 0,
	            u0,
	            scal,
	            /// Coninuous output vectors
	            cont: Array1::<f64>::zeros(4 * n),
	            z1: Array1::<f64>::zeros(n),
	            z2: Array1::<f64>::zeros(n),
	            z3: Array1::<f64>::zeros(n),
	            f1: Array1::<f64>::zeros(n),
	            f2: Array1::<f64>::zeros(n),
	            f3: Array1::<f64>::zeros(n),
	            ip1: Array1::<i32>::zeros(n),
	            ip2: Array1::<i32>::zeros(n),
	            e1: Array2::<f64>::zeros((n, n)),
	            e2r: Array2::<f64>::zeros((n, n)),
	            e2i: Array2::<f64>::zeros((n, n)),
	            dfdu,
	        }
	    }
4bcafd0d1e3295963f964cfdcb0aafd8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|4|5|V|rust
	    fn default_opts() -> OdeIntegratorOpts {
	        let mut opts = OdeIntegratorOpts::new();
	        opts.reltol = 1e-3;
	        opts.abstol = 1e-7;
	        opts.theta = 0.001;
	        opts.fnewt = 0.0;
	        opts.quot1 = 1.0;
	        opts.quot2 = 1.2;
	        opts.facr = 1.0 / 8.0;
	        opts.facl = 5.0;
	        opts.max_steps = 100000;
	        opts.max_newt_iter = 7;
	        opts.use_ext_col = true;
	        opts.modern_pred = true;
	        opts
	    }
	
8e52a92bb7b1154750b7bb817d162776|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|41|1|V|rust
	impl Radau5Cache {
	}
b6cfa4e0a001521d01986c96395389c4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/cache.rs|1|1|V|rust
	use super::integrator::*;
35604f142c0e4224733d56a0df667c64|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|4|1|V|rust
	pub struct OdeIntegrator {
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    pub solu: Vec<Array1<f64>>,
	    pub solt: Vec<f64>,
	    /// Code
	    pub retcode: OdeRetCode,
	    /// Cache associated with the algorithm
	    pub(crate) cache: super::cache::Radau5Cache,
	}
8e703a9e10db222585418292dcbb887f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|145|5|V|rust
	    /// Current solution vector
30412fd787cfed56531d5d188eed8ac1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|146|5|V|rust
	    /// Current time
8ccffd7d962b94024942045494042388|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|147|5|V|rust
	    /// Current step size
a0d0fdc2cb0e6e611fdcf4c4f2b42ddd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|157|5|V|rust
	    /// Code
61f48ff8aabf5365a5c99efadd0ecc70|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|11|1|V|rust
	        // Reset all variables.
	        self.xi_fo = None;
	        self.tsm_fo = None;
	        self.xi_bbn = None;
	        self.xi_cmb = None;
	        self.rd_eta = None;
	        self.rd_del = None;
	        self.dneff_cmb = None;
	        self.dneff_bbn = None;
	        self.eta_si_per_mass = None;
	        self.del_si_per_mass = None;
	        self.sol = None;
	
	        let td_init = self.lamc / 2.0;
	        let xi_init = self.compute_xi_const_td(td_init).unwrap();
	        let tsm_init = td_init / xi_init;
	
	        let xstart = self.eta.m / tsm_init;
	        let xfinal = self.eta.m / T_CMB;
	        let w_eta_init = (self.eta.neq(td_init) / sm_entropy_density(tsm_init)).ln();
	        let y_delta_init = (-self.adel * self.n as f64).exp() * self.delta.neq(td_init)
	            / sm_entropy_density(tsm_init);
	
	        let logxspan = (xstart.ln(), xfinal.ln());
	        let mut winit = Array1::<f64>::zeros(2);
	        winit[0] = w_eta_init;
	        winit[1] = y_delta_init;
f655ca234743ef5598ea6d0d4988a50d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|171|7|v|rust
	 Array1<f64>,
c67a734e3bbca96d90461947f12a5888|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|172|7|v|rust
	 f64,
7f07f95e00630413f115d572e0a6cb42|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|171|8|v|rust
	winit.clone()
f74d703e31b2767eb8bdb10ef4a6fce9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|179|11|v|rust
	OdeIntegratorOpts,
eacaaba662681d36ed3622bc016c9643|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|181|11|v|rust
	Vec<Array1<f64>>,
c72ab242758b87b377ebbe8f89cd506a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|182|11|v|rust
	Vec<f64>,
faa7bad241fe325c094433214f7bce5d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|184|23|v|rust
	super::cache::Radau5Cache,
cd8a0f396f5a1bbfdbf238d8e01f159b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|26|22|v|rust
	integrator: &mut OdeIntegrator, 
f2727df45228efe7ed0c29531b40aa02|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|38|21|v|rust
	integrator.u.len()
2263bfd6c5a217faf55409e641942b8a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|26|12|v|rust
	new_cache(model: &mut DarkSun, u:&ArrayView1<f64>, t:f64, dt:f64, opts:&mut OdeIntegratorOpts)
420602d663e272e75f3fc76dbc220431|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|170|92|v|rust
	&mut OdeIntegratorOpts
91679d4930a082944ed56bdf48d90fc8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|170|53|v|rust
	:&ArrayView1<f64>
3476bdc47b0369eb717242a015b534ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|170|36|v|rust
	: &mut DarkSun
f7cdead0d94c878a8c23fe2a7417cbb4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|181|11|v|rust
	Radau5::default_opts()
5744be488274010641ade8112cfb312c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|167|22|v|rust
	self.m_eta
97d2581224051623862174c4ed82d845|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|170|27|v|rust
	neq(td_init, me, 1.0, 0)
01c52036e03d7e3ea3f7dace4c46fefc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|169|1|V|rust
	        let neqe = neq(td_init, me, 1.0, 0);
48a069f17e60ecd7472b3a7bdbbad9d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|166|1|V|rust
	        let me = self.m_eta;
29e9f4b93ec852d85d324344e1210027|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|173|65|v|rust
	self.delta.neq(td_init)
c94f02ed6278598a001c115a053310f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|161|1|V|rust
	        self.sol = None;
0103e12f90e11e15707d63af745f6d63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|99|8|v|rust
	step(integrator: &mut OdeIntegrator, model: &mut DarkSun)
d1d9130018ddd8019ffb048af6ef8a22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|2|1|V|rust
	use super::
b5ae6ff42bf678d50bbf38ac3257cca3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/boltz.rs|40|1|V|rust
	            let x = integrator.t.exp();
	            let tsm = integrator.params.eta.m / x;
	            let xi = integrator.params.xi;
	            let td = xi * tsm;
	            let s = sm_entropy_density(tsm);
	            let neq = integrator.params.eta.neq(td);
	            let weq = (neq / s).ln();
	            if integrator.u[0] - weq > 0.1 && integrator.params.xi_fo.is_none() {
	                integrator.params.xi_fo = Some(xi);
	                integrator.params.tsm_fo = Some(tsm);
	            }
	            if tsm < T_BBN && integrator.params.xi_bbn.is_none() {
	                integrator.params.xi_bbn = Some(xi);
	            }
e00a21a1c695b8380f54e25d51433a0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|16|1|V|rust
	        let x = logx.exp();
	
	        let meta = self.m_eta;
	        let tsm = meta / x;
	        let xi = self.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = neq(td, self.m_eta, 1.0, 0);
	        let weq = (neq / s).ln();
de6f0223629d1bdcb5e232513a98779b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|212|1|V|rust
	            let x = integrator.t.exp();
e0ad2a32ab0ba7c25ac6aa933b7063ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let tsm = self.m_eta / x;
6feb46e671f4bb6c1f7e0be52c61c379|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let xi = self.xi;
c1184f8072cf3c565994f4ff1362da74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let td = xi * tsm;
0625e254b31fd1ba5d8285f3320dd89f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let s = sm_entropy_density(tsm);
b401a8b07dd998fbf387772cccaa0a90|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let neq = integrator.params.eta.neq(td);
f66b905d67cc1286240c761fe8f18649|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|13|V|rust
	            let weq = (neq / s).ln();
b2ac2883f04c291d8b9fc2dc930a13f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|213|17|v|rust
	.params
7e9340bb22661670918d95a7bc20ffeb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/integrator.rs|25|19|v|rust
	[f64; 2]
ccb189f21a7d4136156d851613236207|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/prepare.rs|72|34|v|rust
	vec![integrator.u[0], integrator
d8e08d9a79d4eb4abfc08aff699855ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|194|30|v|rust
	clone(
dde7955875c4f8fffb0ad1142b46f47e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|5|1|V|rust
	    pub fn neq_eta(&self, td: f64) -> f64 {
	        use std::f64::consts::PI;
	        let x = self.m_eta / td;
	        td * td * td / (2.0 * PI * PI) * x * x * x.cyl_bessel_kn(2)
	    }
fbb446a6f6a6d94f4684af213f858c38|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|7|1|V|rust
	        let x = self.m_eta / td;
8e2743100b0c521b00b6f738aeabcc51|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|18|44|v|rust
	(x * x * x)
6712cf8c5989c8e93f920379cde4675d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|19|23|v|rust
	PI * PI * PI * PI
ca6da63d59bb4a5ed6e930771906dcfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|15|1|V|rust
	    pub fn heff_eta(&self, td: f64) -> f64 {
	        let x = self.m_eta / td;
	        let x3 = x * x * x;
	        let pi4 = PI * PI * PI * PI;
	        45.0 / (4.0 * pi4) * x3 * x.cyl_bessel_kn(3)
	    }
08d1b06b369dfe78b40d6fd06d571d36|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|12|1|V|rust
	        let g = (self.n + 1) as f64;
3c8bfc87ad2e2c8b8f78fcde46df7d1f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|22|1|V|rust
	        let x = self.m_del / td;
	        let g = (self.n + 1) as f64;
	        let x3 = x * x * x;
	        let pi4 = PI * PI * PI * PI;
	        g * 45.0 / (4.0 * pi4) * x3 * x.cyl_bessel_kn(3)
59f940e0f8d1ee6a4f6063989e30e28e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|16|1|V|rust
	        let x = self.m_eta / td;
	        let x3 = x * x * x;
	        let pi4 = PI * PI * PI * PI;
	        45.0 / (4.0 * pi4) * x3 * x.cyl_bessel_kn(3)
c76c0149051f086b858c171a64a1de6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|31|9|V|rust
	        let pi4 = PI * PI * PI * PI;
d8e3625af4321f3c41c7ac422290d84c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|35|1|V|rust
	        let xd = self.m_del / td;
	        let gd = (self.n + 1) as f64;
	        let xd3 = x * x * x;
2748353ca4445314b6340cd40b81f556|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|38|11|v|rust
	* 45.0 / (4.0 * pi4) * 
409bb6e27d7aaf2733b84511572548be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|28|1|V|rust
	    pub fn dark_heff(&self, td: f64) -> f64 {
	        let pi4 = PI * PI * PI * PI;
	
	        let xe = self.m_eta / td;
	        let xe3 = xe * xe * xe;
	        let xd = self.m_del / td;
	        let gd = (self.n + 1) as f64;
	        let xd3 = xd * xd * xd;
	        45.0 / (4.0 * pi4) * (xe3 * xe.cyl_bessel_kn(3) + gd * xd3 * xd.cyl_bessel_kn(3))
	    }
d06cf658c22056b5210af21768f89b49|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|42|9|V|rust
	        let xe2 = xe * xe * xe;
1269af60b83857043f3f7e51a1e1af3e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|44|9|V|rust
	        let xd3 = xd * xd * xd;
1a3c9a947e716069e252f957fffad33d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|169|35|v|rust
	, me, 1.0, 0
1588e3c27a116590fcf6bf91a70cadd4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|170|40|v|rust
	, md, (self.n + 1) as f64, self.n);
3a606eef9f2a86ea732677cc8892dcd0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|166|9|V|rust
	        let md = self.m_del;
b3797b320b4020263eff714dc4af34f5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|11|18|v|rust
	geff(td, self.m_eta, 1.0, 0) + geff(td, self.m_del, (n + 1) as f64, n);
0a51a5ebabfd07cae8514fb796e9a4cd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|23|34|v|rust
	, self.m_eta, 1.0, 0);
088c6523d0379384222482aac52282ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|5|1|V|rust
	impl ThermallyDecoupledModel for DarkSun {
	    fn dark_heff(&self, td: f64) -> f64 {
	        heff(td, self.m_eta, 1.0, 0) + heff(td, self.m_del, 1.0, 1)
	    }
	    fn xi_inf(&self) -> f64 {
	        self.xi_inf
	    }
	    fn hd_inf(&self) -> f64 {
	        let n = self.n as f64;
	        7.0 / 2.0 * n + 2.0 * n * n
	    }
	    fn sum_g(&self) -> f64 {
	        1.0 + (self.n as f64 + 1.0)
	    }
	    fn gl(&self) -> f64 {
	        1.0
	    }
	    fn ml(&self) -> f64 {
	        self.m_eta
	    }
	}
	
	impl DarkSun {
	    pub fn rust_compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
	}
e09d4c2927ff2508d815d5f8faf426d6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|1|1|V|rust
	use crate::thermally_decoup::ThermallyDecoupledModel;
	use crate::DarkSun;
	use haliax_thermal_functions::thermal_functions::heff;
	
	impl ThermallyDecoupledModel for DarkSun {
	    fn dark_heff(&self, td: f64) -> f64 {
	        heff(td, self.m_eta, 1.0, 0) + heff(td, self.m_del, 1.0, 1)
	    }
	    fn xi_inf(&self) -> f64 {
	        self.xi_inf
	    }
	    fn hd_inf(&self) -> f64 {
	        let n = self.n as f64;
	        7.0 / 2.0 * n + 2.0 * n * n
	    }
	    fn sum_g(&self) -> f64 {
	        1.0 + (self.n as f64 + 1.0)
	    }
	    fn gl(&self) -> f64 {
	        1.0
	    }
	    fn ml(&self) -> f64 {
	        self.m_eta
	    }
	}
	
	impl DarkSun {
	    pub fn rust_compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
	}
5298aa9f0b4136c09ce74d7cc2ebaf01|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|7|9|v|rust
	heff(td, self.m_eta, 1.0, 0) + heff(td, self.m_del, 1.0, 1)
6232f900b804ec2f3ee6041d88889dbf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|3|1|V|rust
	use haliax_thermal_functions::thermal_functions::heff;
6eb5d2301e155132627943564d1f6587|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|174|34|v|rust
	sm_entropy_density(tsm_init)
67fe2df9d38b69412efb4146803f2b75|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|168|20|v|rust
	self.neq_eta(td_init)
7fb76e880d23a1feab48d4ae535a31b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|174|27|v|rust
	neqe
a9ca8b81034f848868b4afd47651c4d5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|175|65|v|rust
	neqd
d7baf84f462e6603713432d4d0a8dc1c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|168|42|V|rust
	        let neqe = self.neq_eta(td_init);
	        let neqd = self.neq_del(td_init);
3954d711240fdfb8156a01ff95f5297e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|9|9|V|rust
	        let n = self.n;
37c4c426612a6d31ad4c6bc499aa4a23|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|162|23|v|rust
	self.lamc / 2.0;
48cc6a99b74b795b16b51781dd71a58f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/thermally_decoup.rs|1|1|V|rust
	use crate::brent::brent;
	use cyphus_specfun::lambert_w::LambertW;
	use haliax_thermal_functions::prelude::*;
	
	const SM_HEFF_INF: f64 = 106.83;
	const SM_HEFF_0: f64 = 3.93879;
	
	pub trait ThermallyDecoupledModel {
	    /// Compute the entropic dof of the dark sector.
	    fn dark_heff(&self, td: f64) -> f64;
	    fn xi_inf(&self) -> f64;
	    fn hd_inf(&self) -> f64;
	    fn sum_g(&self) -> f64;
	    fn gl(&self) -> f64;
	    fn ml(&self) -> f64;
	
	    /// Compute xi = Td/Tsm assuming td is known
	    fn compute_xi_const_td(&self, td: f64) -> Result<f64, String> {
	        let hd = self.dark_heff(td);
	        let c1 = self.hd_inf() * self.xi_inf().powi(3) / SM_HEFF_INF;
	        let lb = 1.2 * self.xi_lower_bound_const_td(td);
	        let ub = 0.8 * self.xi_upper_bound_const_td(td);
	
	        let f = |xi: f64| hd * xi.powi(3) - sm_heff(td / xi) * c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
	    /// Compute xi = Td/Tsm assuming tsm is known
	    fn compute_xi_const_tsm(&self, tsm: f64) -> Result<f64, String> {
	        let ub = self.xi_upper_bound_const_tsm(tsm);
	        let lb = self.xi_lower_bound_const_tsm(tsm);
	        let hsm = sm_heff(tsm);
	        let c1 = hsm * self.hd_inf() * self.xi_inf().powi(3) / SM_HEFF_INF;
	
	        let f = |xi: f64| self.dark_heff(xi * tsm) * xi.powi(3) - c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
	    /// Compute the upper bound on xi assuming td is known.
	    fn xi_upper_bound_const_td(&self, td: f64) -> f64 {
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd * SM_HEFF_0 / SM_HEFF_INF).cbrt() * self.xi_inf()
	    }
	    ///Compute the lower bound on xi assuming td is known.
	    fn xi_lower_bound_const_td(&self, td: f64) -> f64 {
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd).cbrt() * self.xi_inf()
	    }
	
	    /// Compute the upper bound on xi assuming tsm is known.
	    fn xi_upper_bound_const_tsm(&self, tsm: f64) -> f64 {
	        (sm_heff(tsm) * self.hd_inf() / self.gl() / SM_HEFF_INF).cbrt() * self.xi_inf()
	    }
	
	    /// Compute the lower bound on xi assuming tsm is known.
	    fn xi_lower_bound_const_tsm(&self, tsm: f64) -> f64 {
	        if self.ml() <= 0.0 {
	            (sm_heff(tsm) * self.hd_inf() / self.gl() / SM_HEFF_INF).cbrt() * self.xi_inf()
	        } else {
	            use std::f64::consts::PI;
	
	            let xl = self.ml() / tsm;
	            let hsm = sm_heff(tsm);
	
	            let lw_arg_num = (45.0 * self.gl() * SM_HEFF_INF * xl * xl * xl).powi(2);
	            let lw_arg_den = (4.0 * self.hd_inf() * hsm * self.xi_inf()).powi(2) * PI.powi(7);
	            return 2.0 * xl / (lw_arg_num / lw_arg_den).lambert_w0();
	        }
	    }
	}
ef8dc7037d468430fc4f1b513b1ad517|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|27|1|V|rust
	use crate::brent::brent;
	use cyphus_specfun::lambert_w::LambertW;
	use haliax_thermal_functions::prelude::*;
	
	const SM_HEFF_INF: f64 = 106.83;
	const SM_HEFF_0: f64 = 3.93879;
5806d44825cda56cc3e181f6802ba082|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|10|6|v|rust
	ThermallyDecoupledModel
62fd3f87581663e4371e40eb51d66e76|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|10|6|v|rust
	for 
a331ba91393c5a1aca2d0774a1264fa2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|32|1|V|rust
	pub trait ThermallyDecoupledModel {
afb2d2c5c39cd0697852029c4d613935|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|32|1|V|rust
	    /// Compute the entropic dof of the dark sector.
	    fn dark_heff(&self, td: f64) -> f64;
	    fn xi_inf(&self) -> f64;
	    fn hd_inf(&self) -> f64;
	    fn sum_g(&self) -> f64;
	    fn gl(&self) -> f64;
	    fn ml(&self) -> f64;
10253d4e2652fb0bd4a322468e52b89f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|11|9|V|rust
	    fn dark_heff(&self, td: f64) -> f64 {
	        self.dark_heff(td)
	    }
bff9c63fbb65a0198703dce82bfbee13|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/compute_xi.rs|1|1|V|rust
	use crate::DarkSun;
	
	use crate::brent::brent;
	use cyphus_specfun::lambert_w::LambertW;
	use haliax_thermal_functions::prelude::*;
	
	const SM_HEFF_INF: f64 = 106.83;
	const SM_HEFF_0: f64 = 3.93879;
	
	impl DarkSun {
	    fn xi_inf(&self) -> f64 {
	        self.xi_inf
	    }
	    fn hd_inf(&self) -> f64 {
	        let n = self.n as f64;
	        7.0 / 2.0 * n + 2.0 * n * n
	    }
	    fn sum_g(&self) -> f64 {
	        1.0 + (self.n as f64 + 1.0)
	    }
	    fn gl(&self) -> f64 {
	        1.0
	    }
	    fn ml(&self) -> f64 {
	        self.m_eta
	    }
	
	    /// Compute xi = Td/Tsm assuming td is known
	    fn compute_xi_const_td(&self, td: f64) -> Result<f64, String> {
	        let hd = self.dark_heff(td);
	        let c1 = self.hd_inf() * self.xi_inf().powi(3) / SM_HEFF_INF;
	        let lb = 1.2 * self.xi_lower_bound_const_td(td);
	        let ub = 0.8 * self.xi_upper_bound_const_td(td);
	
	        let f = |xi: f64| hd * xi.powi(3) - sm_heff(td / xi) * c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
	    /// Compute xi = Td/Tsm assuming tsm is known
	    fn compute_xi_const_tsm(&self, tsm: f64) -> Result<f64, String> {
	        let ub = self.xi_upper_bound_const_tsm(tsm);
	        let lb = self.xi_lower_bound_const_tsm(tsm);
	        let hsm = sm_heff(tsm);
	        let c1 = hsm * self.hd_inf() * self.xi_inf().powi(3) / SM_HEFF_INF;
	
	        let f = |xi: f64| self.dark_heff(xi * tsm) * xi.powi(3) - c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
	    /// Compute the upper bound on xi assuming td is known.
	    fn xi_upper_bound_const_td(&self, td: f64) -> f64 {
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd * SM_HEFF_0 / SM_HEFF_INF).cbrt() * self.xi_inf()
	    }
	    ///Compute the lower bound on xi assuming td is known.
	    fn xi_lower_bound_const_td(&self, td: f64) -> f64 {
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd).cbrt() * self.xi_inf()
	    }
	
	    /// Compute the upper bound on xi assuming tsm is known.
	    fn xi_upper_bound_const_tsm(&self, tsm: f64) -> f64 {
	        (sm_heff(tsm) * self.hd_inf() / self.gl() / SM_HEFF_INF).cbrt() * self.xi_inf()
	    }
	
	    /// Compute the lower bound on xi assuming tsm is known.
	    fn xi_lower_bound_const_tsm(&self, tsm: f64) -> f64 {
	        if self.ml() <= 0.0 {
	            (sm_heff(tsm) * self.hd_inf() / self.gl() / SM_HEFF_INF).cbrt() * self.xi_inf()
	        } else {
	            use std::f64::consts::PI;
	
	            let xl = self.ml() / tsm;
	            let hsm = sm_heff(tsm);
	
	            let lw_arg_num = (45.0 * self.gl() * SM_HEFF_INF * xl * xl * xl).powi(2);
	            let lw_arg_den = (4.0 * self.hd_inf() * hsm * self.xi_inf()).powi(2) * PI.powi(7);
	            return 2.0 * xl / (lw_arg_num / lw_arg_den).lambert_w0();
	        }
	    }
	}
	
	impl DarkSun {
	    pub fn rust_compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
	}
49a01e2d93da4305d5195de367d88a5b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|55|1|V|rust
	use crate::DarkSun;
	
	use crate::brent::brent;
	use cyphus_specfun::lambert_w::LambertW;
	use haliax_thermal_functions::prelude::*;
	
	const SM_HEFF_INF: f64 = 106.83;
	const SM_HEFF_0: f64 = 3.93879;
40da426195fe3e951912274c69de6b69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|6|1|V|rust
	pub mod thermally_decoup;
cd687788addeef394a568dd1bf5c5541|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|7|1|V|rust
	use thermally_decoup::ThermallyDecoupledModel;
d24cf2aa98bcbcede4aad2864fb012bc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|118|13|V|rust
	            use std::f64::consts::PI;
77aaf86ca72de10f48f738d83e84ca64|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|58|1|V|rust
	    fn xi_inf(&self) -> f64 {
	        self.xi_inf
	    }
cc01f7d68899b939a53738f2c78c13a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|126|1|V|rust
	    pub fn rust_compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
c8767b0034c376a437dbf09c366c8e18|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|138|1|V|rust
	impl DarkSun {
	    pub fn rust_compute_xi(&self, tsm: f64) -> Result<f64, String> {
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
	    }
	}
9d165370802621d52bba7a9f85ee539e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|60|1|V|rust
	        7.0 / 2.0 * n + 2.0 * n * n
173670133019071f5a10a7b0a928b18d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|97|1|v|rust
	self.dark_heff(td);
3f13ccba579594c4617832d00650c1b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|112|1|V|rust
	        if self.ml() <= 0.0 {
	            (sm_heff(tsm) * self.hd_inf() / self.gl() / SM_HEFF_INF).cbrt() * self.xi_inf
	        } else {
d0c48fff71ffc3b6f4574213773a1aaa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|112|23|v|rust
	ml()
fbb62c21c25fd73108d142ffa6020094|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|115|32|v|rust
	* self.gl()
551c6447a41f88912bd1aa8b4beb0b2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|72|1|V|rust
	    /// Compute xi = Td/Tsm assuming td is known
	    fn compute_xi_const_td(&self, td: f64) -> Result<f64, String> {
	        let hd = self.dark_heff(td);
	        let c1 = self.hd_inf() * self.xi_inf.powi(3) / SM_HEFF_INF;
	        let lb = 0.8 * self.xi_lower_bound_const_td(td);
	        let ub = 1.2 * self.xi_upper_bound_const_td(td);
	
	        let f = |xi: f64| hd * xi.powi(3) - sm_heff(td / xi) * c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
	    /// Compute xi = Td/Tsm assuming tsm is known
	    fn compute_xi_const_tsm(&self, tsm: f64) -> Result<f64, String> {
	        let ub = 1.2 * self.xi_upper_bound_const_tsm(tsm);
	        let lb = 0.8 * self.xi_lower_bound_const_tsm(tsm);
	        let hsm = sm_heff(tsm);
	        let c1 = hsm * self.hd_inf() * self.xi_inf.powi(3) / SM_HEFF_INF;
	
	        let f = |xi: f64| self.dark_heff(xi * tsm) * xi.powi(3) - c1;
	
	        brent(f, lb, ub, 1e-5)
	    }
9d22bc5c7bc9cf837ca93253944eafb5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|120|1|V|rust
	        match self.tsm_fo {
	            Some(tfo) => {
	                let xi_fo = self.xi_fo.unwrap();
	                if tfo * xi_fo > self.m_eta {
	                    Ok(xi_fo)
	                } else {
	                    Ok(xi_fo * tsm / tfo)
	                }
	            }
	            None => self.compute_xi_const_tsm(tsm),
	        }
150f759df7ec7a475d902453e258b09b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|125|1|V|rust
	        let ub = 1.2 * self.xi_upper_bound_const_tsm(tsm);
	        let lb = 0.8 * self.xi_lower_bound_const_tsm(tsm);
	        let hsm = sm_heff(tsm);
	        let c1 = hsm * self.hd_inf() * self.xi_inf.powi(3) / SM_HEFF_INF;
	
	        let f = |xi: f64| self.dark_heff(xi * tsm) * xi.powi(3) - c1;
	
	        brent(f, lb, ub, 1e-5)
0dfacec127133e61bc827ab5aa9bd4d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|120|1|v|rust
	self.compute_xi_const_tsm(tsm)
43f5eec1aa138fea7ca71a4f1731cc86|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|93|26|v|rust
	(x - 2.0).powi(2) * (x - 10.0).powi(2);
723959a81b98ab86b95a84fa724e370e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|64|26|v|rust
	if min1 < min2 { min1 } else { min2 }
0e62f643b454dba1f77751b0c0fa9893|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|15|5|V|rust
	    let mut fc: f64;
e0c059ea98027a48e7f063c2fb6eceb8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|44|12|V|rust
	            dbg!(iter);
e0dda2d983c384725d6dfc5e66fdfa9f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|80|13|V|rust
	            fb = f(b);
fb186c82c53a99c19c81afe46aa07155|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/brent.rs|26|9|v|rust
	iter 
7fd5e147245466d7a31dc6bfa1005c32|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|192|24|v|rust
	winit.to_vec()
b6a67a620c1d5261000c85ea9c029635|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/solve.rs|193|24|v|rust
	logxspan.0
fa2d46b041ebed4bed98f5dccdd325c8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|27|9|V|rust
	        // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
8c97037191973a2a1d17755d88bf1185|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|28|1|V|rust
	        //let sig_ee_dd = self.rust_thermal_cross_section_2eta_2del(meta / td);
adda9c30f95742556cc0842810ead76f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|29|1|V|rust
	        //let pf_d = (PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi) * meta / (x * x);
08a5740dfff79b3706f9be9013d707fa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|30|1|V|rust
	        // dW_e / dlogx
d1678cc4ce502854f5673d4f171a290d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|31|1|V|rust
	
	        // dY_d / dlogx
	        //dw[1] = pf_d * sig_ee_dd * (2.0 * w[0]).exp();
8274bb78d994580a727508db4464cfcb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|46|1|V|rust
	        // sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	        //let sig_ee_dd = self.rust_thermal_cross_section_2eta_2del(meta / td);
91fea1dbc400cc9448f5ba509399cd1c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|48|1|V|rust
	        //let pf_d = (PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi) * meta / (x * x);
	
	        // df_d / dW_e
adac7f029516604a37c00139c08b07be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|52|1|V|rust
	        // df_e / dY_d
	        // j[[0, 1]] = 0.0;
	
	        // df_d / dW_e
	        // j[[1, 0]] = 2.0 * pf_d * sig_ee_dd * (2.0 * w[0]).exp();
	
	        // df_d / dY_d
	        // j[[1, 1]] = 0.0;
5e98b40182858f99e7d20800ba3ac28f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|43|9|V|rust
	        let we = w[0];
b5cc9208ee0d92039b45ff0cb726af83|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2045|1|V|rust
	        GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-5)
	            .epsabs(0.0)
	            .build()
9e4babfc1bbe8e63cf91ae2868b4fdd6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|51|19|v|rust
	(*TCS_INTEGRATOR)
acd8811551950a6d350ae828e9e628dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|20|1|V|toml
	[dependencies]
bcd5bc47c60c63a3da6ce8a2330a3aff|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|2|v|rust
	azy_static! {
09777ffaee2e5b451e1523a528eeba41|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|3|1|V|rust
	//use lazy_static::lazy_static;
ddc7a07d47058239cc958bf6b84bbb6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|7|9|v|rust
	static ref
d632ef331cc21e5ceaa04e475f1016d8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2020|1|V|rust
	    pub static ref ETA_CS44_INTERP: UnivariateSpline = {
	        UnivariateSplineBuilder::default(&(*LOG_ETA_ZS), &(*LOG_ETA_CS44))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
	    };
	    pub static ref ETA_CS66_INTERP: UnivariateSpline = {
	        UnivariateSplineBuilder::default(&(*LOG_ETA_ZS), &(*LOG_ETA_CS66))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
	    };
	    pub static ref ETA_CS46_INTERP: UnivariateSpline = {
	        UnivariateSplineBuilder::default(&(*LOG_ETA_ZS), &(*LOG_ETA_CS46))
	            .extrapolation(3)
	            .degree(1)
	            .smoothing_factor(0.0)
	            .build()
	            .unwrap()
	    };
	    pub static ref TCS_INTEGRATOR: GaussKronrodIntegrator = {
	        GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-5)
	            .epsabs(0.0)
	            .build()
	    };
af0f4a7a76dcb4b708948eb4ab521cfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2031|63|v|rust
	DarkSun::LOG_ETA_CS66
6482eb545549cfe62e1ae73fd9116d74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2031|39|v|rust
	DarkSun::LOG_ETA_ZS
0cc5d35aa40d0a1ea66a69908368bd82|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2023|61|v|rust
	DarkSun::LOG_ETA_CS44
25a3f039ebcc1b75a6c18cb8312c0ae9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2039|55|v|rust
	DarkSun::LOG_ETA_CS46
c15b41c7b4adb33f33defa5b6da57edc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2039|39|v|rust
	LOG_ETA_ZS
e5b052234c8b4470fb74cea35ff5b3ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|23|30|v|rust
	(Self::
ea18a62ea41a78b40e71ae9164c31b2a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|26|27|v|rust
	DarkSun::LOG_ETA_ZS_MAX
3feab953f4bd6924ad48a41074bf4081|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|71|19|v|rust
	TCS_INTEGRATOR
09bba90cd02ebe295c0817c7afdf2a80|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1518|41|v|rust
	arr1(&
8c2716f202b02dd46e25cb2e6dfe4a5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1016|29|v|rust
	Array1<f64> = arr1(&[
1734725cd8002b85a84b33ed5b169016|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|12|41|v|rust
	arr1(&[
92d21765932c2642e4eb58ccda0e16ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|12|27|v|rust
	Array1<f64> = 
cb6d6b629fef66ba5dcf0d0d4d35ac96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2031|102|v|rust
	from_vec
832a2f71fed79518e8f9a4a423ef6339|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2031|1|V|rust
	    UnivariateSplineBuilder::default(&Array::from(DarkSun::LOG_ETA_ZS.clone().to_vec()), &Array::from(DarkSun::LOG_ETA_CS66.to_vec()))
5954e1e7d5c33fea2f9c7701653804d9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2023|1|V|rust
	    UnivariateSplineBuilder::default(&DarkSun::LOG_ETA_ZS.clone(), &DarkSun::LOG_ETA_CS44)
a42019e8c66438931798fd09066d3e89|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2023|1|V|rust
	    UnivariateSplineBuilder::default(&Array::from(DarkSun::LOG_ETA_ZS.clone().to_vec()), &Array::from(DarkSun::LOG_ETA_CS44.to_vec()))
da0139025a9e452c23b13725f516c2c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2039|1|V|rust
	    UnivariateSplineBuilder::default(&DarkSun::LOG_ETA_ZS, &DarkSun::LOG_ETA_CS46)
d80d9ceb0aede1a8fe81cadd14815dc3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2022|22|v|rust
	DarkSun::
72b9dd3f6fc8a4f13278e5d85397306c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	impl kSun{
388ec3e3fa4983032b4f3e7d8fcb65ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|25|v|rust
	8888888
f6af4e523efcd261cd811b5cc83c39f6|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|1|9|v|cpp
	LANRE_DM_MODELS_DARKSUN_CROSS_SECTION_DATA_HPP
fa82540e68b1e3cc6252d44aed53f571|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|10|1|V|cpp
	static const std::vector<double> LOG_ETA_CS44 = {
	};
f39ca8598ebf9ae5aab302ca5592a2e1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|185|1|V|cpp
	} // namespace lanre
a23769eff1b42644beb249521e54ec01|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|10|1|V|cpp
	static const std::vector<double> LOG_ETA_CS44 = {
da76df714ca5add90e7d0b324736c764|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|11|1|V|cpp
	static const std::vector<double> LOG_ETA_CS4 = {
dc5f66a799d6854cbc006c8711dcff71|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|7|1|V|rust
	    pub static ref ETA_CS_INTERCEPT44: f64 = -11.11639799;
	    pub static ref ETA_CS_INTERCEPT66: f64 = -12.03846184;
	    pub static ref ETA_CS_INTERCEPT46: f64 = -11.57806204;
	    pub static ref LOG_ETA_ZS_MIN: f64 = 0.60206107706281;
	    pub static ref LOG_ETA_ZS_MAX: f64 = 2.1760912590556813;
05499732943a299f24cd19e48df4ec37|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|14|1|V|cpp
	static constexpr double LOG_ETA_ZS_MAX = 2.1760912590556813;
ae763e6323cbed21d6835e00ac87e6b0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|199|1|V|cpp
	static const boost::math::cubic_b_spline<double> _eta_cs_spline{_log_eta_cs.begin(),
	        _log_eta_cs.end(), _log_xmin, _log_xstep};
4eb1bb0074481382d87ad78a229517df|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|526|5|v|cpp
	_log_eta_cs
a32863cd8e41448ffdfb258c8824d4de|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|526|47|v|cpp
	_log_xmin, _log_xstep};
7bdd84ab328c19b36a1265204fa7c89d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|526|47|v|cpp
	_log_xmin
8b432da1053bba26428499d20224bdc3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|13|1|V|rust
	        0.60206107706281,
	        0.6048625578702993,
	        0.6076640386777887,
	        0.610465519485278,
fb149b73356271dd0588ffedc3c55298|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|17|1|v|cpp
	2.1760912590556813
d2a1468628b2c2c555a8944748599e65|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|526|63|v|cpp
	_log_xstep
6f53b36d3dbc7d27c1e669b3e89e441a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|525|1|V|cpp
	static const boost::math::cubic_b_spline<double> _eta_cs_spline{
	    LOG_ETA_CS44.begin(), LOG_ETA_CS44.end(), LOG_ETA_ZS_MIN, LOG_ETA_ZS_STEP};
c7ab96014c3d4e8a136e64871c2f0061|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun/cross_section_data.hpp|525|50|v|cpp
	_eta_cs_spline
b1957c211a4e3ca74d081e8c57ff8b31|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|27|1|V|cpp
	using namespace lanre::diffeq;
6360a1766ff1780e94ae9b20646e40bd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|66|3|V|cpp
	  static double scaled_thermal_cross_section_2eta_4eta(double);
c4c1333dcd68058d41f62f52cd11f384|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|64|3|V|cpp
	  static double cross_section_2eta_4eta(double);
b3a0af17ccf50ce76983f37a68ce162d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|333|19|v|cpp
	_eta_cs_slope
b280cc406291a58e18a324be943590ea|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|333|37|v|cpp
	LOG_ETA_CS44_INTERP
928385746976fa5a45145805089d324a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|333|37|v|cpp
	LOG_ETAT
88c5c58d972d74224520a2484cc77394|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|334|1|V|cpp
	        pow(z, 14.0) * pow(10.0, ETA_CS_INTERCEPT44)
326fdfab282a0ca0f8a712b205ff6b0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|11|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        //         v = (256 pi^4/9)^2
	        let norm = 6.9093374296577904e7 * mu.powi(14) / (lam * lam * n.powi(11));
	        let c44 = norm * self.lec1.powi(4) / 9.0;
	        let c66 = norm * self.lec2.powi(2) / 25.0;
	        let c46 = -2.0 * norm * self.lec2 * self.lec1.powi(2) / 15.0;
b47eeae276c4de81a92adbb06358a220|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|330|1|V|cpp
	        let mu = self.mu_eta;
6fabeb4e6e289caea31aa03c12ec0c65|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|330|9|V|cpp
	        let n = self.n as f64;
70e9b9753406b836ea3bbea7104e7051|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|330|9|V|cpp
	        let lam = self.lamc;
589275fdd4e5908f18310b56beaf439b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|331|16|v|cpp
	norm
b7cb1768461359830e218325e0b536a4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|331|60|v|cpp
	.powi(14)
c34a26749ff694d53676f346c8fb5769|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|331|93|v|cpp
	.powi(11)
afe10ce580ab4c6beeb47aec9558947d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|34|1|V|cpp
	  double m_lec1;      // Low-energy constant for 4-pt eta interaction
d4506cd333deb6437378214c1228dc7d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|70|43|v|cpp
	double t_lec1
2bbc8fb4fd76e5d2bfb1d6de892c9963|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|72|33|v|cpp
	m_lec1(t_L1),
4ec90dee666542538e75721e08b771ea|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|147|1|V|cpp
	  void set_lec1(double L1) { m_L1 = L1; }
8f6161e1e4074cb31c5adcba29708aa2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|349|1|V|cpp
	      pow(10.0, LOG_ETA_CS44_INTERP(logz))
180a1abe0699d48fcc9058602a54f068|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|385|3|V|cpp
	  double pf = m_1 * m_L1 * pow<7>(meta) / pow<4>(feta * m_lam);
56f5b2b6de4b698e05567f03c5ff85ba|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|385|3|V|cpp
	  pf *= pf;
6b616537229690e5fe63c75c3db75d0a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|384|1|V|cpp
	  double feta = sqrt(double(m_N)) * m_lam / (4.0 * M_PI);
8d1ba760b7439a86bc89fd42ed649496|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|383|1|V|cpp
	  double meta = m_eta.get_mass();
6088ef59af8ab39c1f259861317980b5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|384|15|v|cpp
	scaled_thermal_
e520600db8da5e180de74e4768e888f4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|353|4|V|cpp
	/**
	 * Thermal cross section for 4eta -> 2eta scaled by model-dependent constants
	 * and without a cutoff
	 * @param x Mass of the eta' divided by the dark temperature.
	 * @return Scaled thermal cross section.
	 */
	double DarkSUN::scaled_thermal_cross_section_2eta_4eta(double x) {
	  using namespace boost::math;
	  using namespace lanre::special_functions;
	  static const double z_min = 4.0;
	
	  double integral = 0.0;
	  for (int i = 0; i < gauss_laguerre_size; i++) {
	    double zp = gauss_laguerre_nodes[i] / x + z_min;
	    double weight = gauss_laguerre_weights[i];
	    integral += weight * zp * sqrt(zp * zp - 4.0) * besselk1e(x * zp) *
	                scaled_cross_section_2eta_4eta(zp);
	  }
	  const double bessel2 = besselk2(x);
	  const double pf = x / (8.0 * bessel2 * bessel2);
	  return pf * integral * exp(-z_min * x) / x;
	}
2041ac1a352ec09a4ed368075903c0b1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|364|46|v|cpp
	m_eta.get_mass()
28537d03bbc9a8165fdf20d1747aa24c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|417|1|V|cpp
	  double integral = gauss_kronrod<double, 15>::integrate(
	      integrand, 2.0 * r, std::numeric_limits<double>::infinity(), 5, 1e-9);
55f344d3d699ad26e4be14840dad4cd1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|372|7|v|cpp
	integrand
f14570667633fe8778e42c0dde4d1054|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|372|10|v|cpp
	2.0 * r
02ee58253bf6faabf67185d2fe4de50f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|384|1|V|cpp
	  using namespace boost::math::quadrature;
04993b9f82c4c2c85dd018d9aa5ade45|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|360|3|V|cpp
	  using namespace boost::math;
567a3876588c5a0138a10a7a14f7c1f7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|376|3|V|cpp
	  return cross_section_2eta_4eta(x);
043eed7f6db2909c6e7242b1f3868c6a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|388|1|V|cpp
	  /*
	  double me = m_eta.get_mass();
	  double md = m_delta.get_mass();
	  double pf = exp(-2 * m_c * m_N) * m_N * x / (128 * pow<7>(me) * M_PI *
	  pow<2>(besselk2(x))); double z_min = 2.0 * md / me;
	
	  double integral = 0.0;
	  for (int i = 0; i < gauss_laguerre_size; i++) {
	      double zp = gauss_laguerre_nodes[i] / x + z_min;
	      double weight = gauss_laguerre_weights[i];
	      integral += weight * sqrt(zp * zp - 4.0) * pow(zp * zp * me * me - 4 * md
	  * md, 3.0 / 2.0) * besselk1e(x * zp) / pow<2>(zp * zp - 1.0);
	  }
	
	
	  double result = pf * integral * exp(-z_min * x) / x;
	  return isnan(result) ? 0.0 : result;
	  */
	
7937157584b565fbe591008864698e65|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|395|67|v|cpp
	besselk2e
7f1f9116aaeaa27907fb7540e9031b3d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|403|43|v|cpp
	besselk1e
2ed4033b88aae6a6b0941048a9ace421|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|403|66|v|cpp
	(const double x)
cd344dc9176e014dd19ca535628d79a1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|403|46|v|cpp
	 + z * z
91047da22ebc38b445b4dbdf11e94d73|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|399|1|V|cpp
	  double r = md / me;
8bd70cd0a188005065aec8b2af37b4e0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|400|15|v|cpp
	md / me;
62a23bd3dc89c82e5dff6852e686fbe3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|405|22|v|cpp
	 * r
4773c2cc818c77d90433d451206f73db|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|432|10|v|cpp
	(8.0 * m_L1 * m_L1 *
	          (376.0 * pow<8>(me) - 576.0 * pow<6>(me) * s +
	           396.0 * pow<4>(me) * s * s - 136.0 * me * me * pow<3>(s) +
	           21 * pow<4>(s))) /
	         (15.0 * pow<4>(fe * m_lam));
be4c459bdb4356599d814c72110010c1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|432|24|v|cpp
	 * m_lec1
ba81da7b44072472e06a355b05cc676f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|432|1|V|cpp
	  return pow<2>(m_lec1) * pow<3>(M_PI) *(
	      ) / (
	        135.0 * pow<8>(
	      );
90278686d3df9ec931a1b77121c1fd44|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|432|121|v|cpp
	\[Mu],6
86e4a96cc702f64e960919c689b07b95|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|432|160|v|cpp
	SUNN
183932a7062bbfd4bdd88fa491695b89|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|429|16|v|cpp
	* me * me
506d2a9001af36ae7665d548172e37c0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|462|10|v|cpp
	1.5 * pow<4>(g) * mdelta * mdelta / (32.0 * M_PI) / pow<4>(msigma);
28e2bc81a6de20247820e7efc67202fd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|445|1|V|cpp
	  /* diagrams with sigma exchange
	   * ----------------------------
	   * p1 -->--.-->-- p3       p1 -->--.-->-- p4
	   *         .                       .
	   *         .          +            .
	   *         .                       .
	   * p2 -->--.-->-- p4       p2 -->--.-->-- p3
	   */
	  using namespace boost::math;
	  double g = 1.0; // TODO: not sure what to use for this
	  double msigma = m_lam;
	  double mdelta = m_delta.get_mass();
	  // NOTE: I removed extra factor of N:
	  //  Hiren gave a good argument for why there should be no factor of N
	  //  from spin sums. The spin-flipping pieces of the amplitude will go
	  //  like S.p where S is the spin and p is some momentum scale. At zero
	  //  velocity, this term should diappear.
0d99548b95f317ac0a776de8ae952697|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|366|1|V|cpp
	    double z2 = z * z;
	    double sig = cross_section_2eta_4eta(z * me);
	    double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
e4b37637d570767bb11957ff4e8b9f0b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|405|1|V|cpp
	    double z2 = z * z;
	    return exp(-x * (z - 2.0)) * sqrt(z2 - 4.0) * pow<2>(z2 - 2.0) *
	           pow(-4.0 * r2 + z2, 1.5) * gsl_sf_bessel_K1_scaled(x * z);
2d07531c1ed6e9ce5a9f81cc1c0be3bb|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|406|5|V|cpp
	    double sig = cross_section_2eta_4eta(z * me);
1f20a784513f7ac3f2c41b2dae910429|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|393|3|V|cpp
	  double feta = (std::sqrt(m_N) * m_lam / (4.0 * M_PI));
b66604d7938c6f666adb918559f487b7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|393|3|V|cpp
	  double pf_num = std::exp(-2.0 * m_c * m_N) * pow<4>(me) * x;
6c0779d070f43b416947dc02e61f938a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|394|7|V|cpp
	      2.0 * M_PI *
75dd35e15f2fa264aa938d857b9787b7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|394|7|v|cpp
	pow<2>(4.0 * feta * feta * m_lam * g
bfc064bae0093012e0355a8eabdb8914|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|394|15|v|cpp
	pf_num
25d250c134c5f3c9ff9a4c2c06941e54|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|394|19|v|cpp
	pf_den
aafd61efaa0fd5beb9268811e6da4034|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|396|3|V|cpp
	  double r2 = r * r;
4b86728f660afe67a94af3145e1277b3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|409|24|v|cpp
	 * pf;
49d87abd8beb4cbd7e35aa1a07ccfa9e|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|391|32|V|cpp
	  double me = m_eta.get_mass();
	  double md = m_delta.get_mass();
b4729ccc581ba11c89b6c34685f422f0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|389|3|V|cpp
	  // The following seems more accurate. This amplitude comes from assuming
	  // an effective interaction of deltabar.delta * del[eta,mu]^2
95f2902624fb0add0d921f429706ab93|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|96|1|V|cpp
	  double get_L1() const { return m_lec1; }
bcb06325125edc2cb37b8fbc9abc5d96|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|201|1|V|cpp
	            .def_property("lec1", &DarkSUN::get_lec1, &DarkSUN::set_lec1)
155475b00a53ad9a5cd49a9cd7081c80|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|195|41|v|cpp
	p.get_lec1()
0af30124f796e6801d2c196d98f6bfba|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|208|1|V|cpp
	                      t[2].cast<double>(),       // L1
efa42d83a4c227f8ba657c172117ef07|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|165|42|v|cpp
	py::arg("lec1")
16bbdd1448f51d50ce18d38947c33cb7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|49|1|V|cmake
		GSL::gsl
		GSL::gslcblas
bf86685cf7beed9097d71b2c68bccb44|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|15|1|V|python
	lec1_default = 1.0
eccbbe13ccb13a7bce9738cf4cf5aaa1|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|36|1|V|python
	    lec1,
5a237875f103cba8e20d9531a043896d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|71|1|V|python
	        "L1 =",
c6136b230c6f99d9305cc8a6371d049e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|86|1|V|python
	    lec1 = lec1_default
55be09973850c156b3792d55c7ad0ee3|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|122|1|V|python
	    parser.add_argument(
	        "--L1", type=float, help="Low energy constant for eta 4-pt function"
	    )
a7566a69334a33983b68770fc25a2968|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|156|1|V|python
	    if args.L1 is not None:
	        L1 = args.L1
4f890b2b5995efae431a03de7f7bf552|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/scanner/scan.py|1|1|V|python
	import numpy as np
	import pickle
	from haliax.dm_models import DarkSUN
	from haliax.diffeq import ODESolution
	import sys
	import argparse
	from tqdm import tqdm
	
	# Defaults
	lam_max_default = 1.0
	lam_min_default = 1e-7
	num_lams_default = 100
	n_max_default = 105
	n_min_default = 5
	lec1_default = 1.0
	lec2_default = 1.0
	c_default = 1.0
	a_default = 1.0
	mu_eta_default = 1.0
	mu_delta_default = 1.0
	xi_inf_default = 1e-2
	has_dp_default = False
	
	
	def solve_model(model):
	    model.solve_boltzmann()
	    return model
	
	
	def scan(
	    lam_min,
	    lam_max,
	    num_lams,
	    n_min,
	    n_max,
	    lec1,
	    lec2,
	    c,
	    a,
	    mu_eta,
	    mu_delta,
	    xi_inf,
	    has_dp,
	):
	    lams = np.logspace(np.log10(lam_min), np.log10(lam_max), num=num_lams)
	    Ns = np.arange(n_min, n_max, dtype=int)
	
	    param_matrix = [
	        [
	            (lam, N, lec1, lec2, c, a, mu_eta, mu_delta, xi_inf, has_dp)
	            for N in Ns
	        ]
	        for lam in lams
	    ]
	    return np.array(
	        [
	            [solve_model(DarkSUN(*params)) for params in param_vector]
	            for param_vector in tqdm(param_matrix)
	        ]
	    )
	
	
	if __name__ == "__main__":
	    argument_list = sys.argv[1:]
	    options = ""
	    long_options = [
	        "lam_min =",
	        "lam_max =",
	        "n_min =",
	        "n_max =",
	        "lec1 =",
	        "lec2 =",
	        "c =",
	        "a =",
	        "mu_eta =",
	        "mu_delta =",
	        "xi_inf =",
	        "has_dp =",
	    ]
	
	    lam_max = lam_max_default
	    lam_min = lam_min_default
	    num_lams = num_lams_default
	    n_max = n_max_default
	    n_min = n_min_default
	    lec1 = lec1_default
	    lec2 = lec2_default
	    c = c_default
	    a = a_default
	    mu_eta = mu_eta_default
	    mu_delta = mu_delta_default
	    xi_inf = xi_inf_default
	    has_dp = has_dp_default
	
	    parser = argparse.ArgumentParser()
	    parser.add_argument(
	        "file", type=str, help="File name where pickled data will be saved."
	    )
	    parser.add_argument(
	        "--lam_min", type=float, help="Minimum value of confinement scale"
	    )
	    parser.add_argument(
	        "--lam_max", type=float, help="Maximum value of confinement scale"
	    )
	    parser.add_argument(
	        "--num_lams",
	        type=float,
	        help="Number of values of Lambda to scan over.",
	    )
	    parser.add_argument("--n_max", type=int, help="Maximum value of N")
	    parser.add_argument("--n_min", type=int, help="Minimum value of N")
	    parser.add_argument(
	        "--c",
	        type=float,
	        help="Value of exponental suppresion for 2eta->2delta",
	    )
	    parser.add_argument(
	        "--a",
	        type=float,
	        help="Value of exponental suppresion for delta abundance after confinement",
	    )
	    parser.add_argument(
	        "--lec1", type=float, help="Low energy constant for eta 4-pt function"
	    )
	    parser.add_argument(
	        "--lec2", type=float, help="Low energy constant for eta 4-pt function"
	    )
	    parser.add_argument(
	        "--mu_eta", type=float, help="Ratio of eta' mass to Lambda/sqrt(N)"
	    )
	    parser.add_argument(
	        "--mu_delta", type=float, help="Ratio of delta mass to Lambda*N"
	    )
	    parser.add_argument(
	        "--xi_inf",
	        type=float,
	        help="Dark to SM temperature ration above EW scale.",
	    )
	    parser.add_argument(
	        "--has_dp",
	        action="store_true",
	        help="Flag specifying is dark photon is present",
	    )
	    args = parser.parse_args()
	
	    out_file = args.file
	
	    if args.lam_min is not None:
	        lam_min = args.lam_min
	    if args.lam_max is not None:
	        lam_max = args.lam_max
	    if args.n_min is not None:
	        n_min = args.n_min
	    if args.n_max is not None:
	        n_max = args.n_max
	    if args.L1 is not None:
	        lec1 = args.lec1
	    if args.lec2 is not None:
	        lec2 = args.lec2
	    if args.c is not None:
	        c = args.c
	    if args.a is not None:
	        a = args.a
	    if args.mu_eta is not None:
	        mu_eta = args.mu_eta
	    if args.mu_delta is not None:
	        mu_delta = args.mu_delta
	    if args.xi_inf is not None:
	        xi_inf = args.xi_inf
	    if args.has_dp:
	        has_dp = True
	
	    print(
	        """
	--- DarkSUN Scanner ---
	
	Running a DarkSUN parameter scan.
	
	The parameter values of this scan are:
	======================================
	output file = {}
	Lambda Range = ({}, {})
	N Range = ({}, {}),
	L1 = {}
	c = {}
	a = {}
	mu_eta = {}
	mu_delta = {}
	xi_inf = {}
	has_dp = {}
	======================================
	        """.format(
	            out_file,
	            lam_min,
	            lam_max,
	            n_min,
	            n_max,
	            lec1,
	            lec2,
	            c,
	            a,
	            mu_eta,
	            mu_delta,
	            xi_inf,
	            has_dp,
	        )
	    )
	
	    models = scan(
	        lam_min,
	        lam_max,
	        num_lams,
	        n_min,
	        n_max,
	        lec1,
	        lec2,
	        c,
	        a,
	        mu_eta,
	        mu_delta,
	        xi_inf,
	        has_dp,
	    )
	    pickle.dump(models, open(out_file, "wb"))
5bd8ebeed8d4718189612035cbfcd4b6|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|22|1|V|python
	    "lec1": 1.0,
296c0ded1b34c298ac093e7fd8ab8a36|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|31|1|V|python
	lam_max_default = 1.0
	lam_min_default = 1e-7
	num_lams_default = 100
	n_max_default = 105
	n_min_default = 5
	lec1_default = 1.0
	lec2_default = 1.0
	c_default = 1.0
	a_default = 1.0
	mu_eta_default = 1.0
	mu_delta_default = 1.0
	xi_inf_default = 1e-2
	has_dp_default = False
3069712f73b2e167b8ebf59867a56433|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|89|15|v|python
	lam_max_default
4b282779ec547839b56defa4c62776a4|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|89|15|v|python
	defaults["lam_max"]
6a8a95e31bebee6cc85036dbfbe18a1b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|90|15|v|python
	lam_min_default
15c8446e385a31ead441eab0c140c59f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|91|16|v|python
	num_lams_default
d8156d9593eac16b45413b0ec0eacd9a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|92|13|v|python
	n_max_default
97b051056fb682fa47b618b90fa7e0bb|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|93|13|v|python
	n_min_default
6730791ea1ae007ad5337973ee481969|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|94|12|v|python
	lec1_default
5f1f606e8bc4183767467a6af668b26f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|95|12|v|python
	lec2_default
7e9d32ccef53b54929105e0fe814d3ef|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|96|9|v|python
	c_default
a47b8379e55efa427d451533b23af414|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|97|9|v|python
	a_default
1f4557cee3ecbb47b29d8108619f2f55|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|98|14|v|python
	mu_eta_default
8db8414a594d4524782cbb2464d27911|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|99|16|v|python
	mu_delta_default
d30c174cebf35278a3b0770a9e4b3ed4|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|100|14|v|python
	xi_inf_default
990ff2a24c75c64bf3dc383166077a06|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|101|14|v|python
	has_dp_default
6482a3f94854f5920ef720dbf7944d49|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|3|3|v|json
	var1
e22bbc3ade91eea7c80d8be0490c8f83|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|3|1|V|json
		"scan_var_1": "lam",
59a1e86d232bc2759616f7d947417910|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|3|1|V|json
		"scan_var_1": "N",
		"scan_var_2": "lam",
f55269abb695243e031bc37d06184e74|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|3|1|V|json
	  "scan_var_1": {
	    "name": "N",
	    "min": 5,
	    "max": 105,
	    "type": "int"
	  },
38b83510cb9753cf02e91e42b8bb410b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|9|1|V|json
	  "scan_var_2": "lam"
694d00df483c690f00b9f60a1dfa5676|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|15|1|V|json
	  "c": 1.0,
3481a46a780cf24e786134bdf1a394cf|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|15|1|V|json
	  "lec1": 1.0,
d46fe895e9d1207f7a2251ccfa0c24d3|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|2|16|v|json
	cscan
e77eb218812f2ebdd854d35911f4f895|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|16|1|V|json
	    "N": {
		"min": 5,
		"max": 105,
		"num": 100
	    },
8883be9ce7bb851621a7c7d99bb6d0f1|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|15|3|V|json
	  "parameters": {
fa342209ea92d94a35d8753367873461|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|3|1|V|json
	  "scan_var_1": {
	    "name": "N",
	    "min": 5,
	    "max": 105,
	    "type": "int"
	  },
	  "scan_var_2": {
	    "name": "lam",
	    "min": 1e-7,
	    "max": 1.0,
	    "type": "float"
	  },
2b71c5b4baddf62d32c150757ce9d368|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|16|1|V|python
	# Defaults
	defaults = {
	    "lam_max": 1.0,
	    "lam_min": 1e-7,
	    "num_lams": 100,
	    "n_max": 105,
	    "n_min": 5,
	    "lec1": 1.0,
	    "lec2": 1.0,
	    "c": 1.0,
	    "a": 1.0,
	    "mu_eta": 1.0,
	    "mu_delta": 1.0,
	    "xi_inf": 1e-2,
	    "has_dp": False,
	}
50aea67d6acc7151547b97ee9b1fcf6c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|12|1|V|python
	import argparse
6c357927072401a3c9d3b5989299ad94|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|58|1|V|python
	    long_options = [
	        "lam_min =",
	        "lam_max =",
	        "n_min =",
	        "n_max =",
	        "lec1 =",
	        "lec2 =",
	        "c =",
	        "a =",
	        "mu_eta =",
	        "mu_delta =",
	        "xi_inf =",
	        "has_dp =",
	    ]
5714974c911fe421755cde46ba86accb|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|59|1|V|python
	    lam_max = defaults["lam_max"]
	    lam_min = defaults["lam_min"]
	    num_lams = defaults["num_lams"]
	    n_max = defaults["n_max"]
	    n_min = defaults["n_min"]
	    lec1 = defaults["lec1"]
	    lec2 = defaults["lec2"]
	    c = defaults["c"]
	    a = defaults["a"]
	    mu_eta = defaults["mu_eta"]
	    mu_delta = defaults["mu_delta"]
	    xi_inf = defaults["xi_inf"]
	    has_dp = defaults["has_dp"]
	
	    parser = argparse.ArgumentParser()
	    parser.add_argument(
	        "file", type=str, help="File name where pickled data will be saved."
	    )
	    parser.add_argument(
	        "--lam_min", type=float, help="Minimum value of confinement scale"
	    )
	    parser.add_argument(
	        "--lam_max", type=float, help="Maximum value of confinement scale"
	    )
	    parser.add_argument(
	        "--num_lams",
	        type=float,
	        help="Number of values of Lambda to scan over.",
	    )
	    parser.add_argument("--n_max", type=int, help="Maximum value of N")
	    parser.add_argument("--n_min", type=int, help="Minimum value of N")
	    parser.add_argument(
	        "--c",
	        type=float,
	        help="Value of exponental suppresion for 2eta->2delta",
	    )
	    parser.add_argument(
	        "--a",
	        type=float,
	        help="Value of exponental suppresion for delta abundance after confinement",
	    )
	    parser.add_argument(
	        "--lec1", type=float, help="Low energy constant for eta 4-pt function"
	    )
	    parser.add_argument(
	        "--lec2", type=float, help="Low energy constant for eta 4-pt function"
	    )
	    parser.add_argument(
	        "--mu_eta", type=float, help="Ratio of eta' mass to Lambda/sqrt(N)"
	    )
	    parser.add_argument(
	        "--mu_delta", type=float, help="Ratio of delta mass to Lambda*N"
	    )
	    parser.add_argument(
	        "--xi_inf",
	        type=float,
	        help="Dark to SM temperature ration above EW scale.",
	    )
	    parser.add_argument(
	        "--has_dp",
	        action="store_true",
	        help="Flag specifying is dark photon is present",
	    )
	    args = parser.parse_args()
	
	    out_file = args.file
	
	    if args.lam_min is not None:
	        lam_min = args.lam_min
	    if args.lam_max is not None:
	        lam_max = args.lam_max
	    if args.n_min is not None:
	        n_min = args.n_min
	    if args.n_max is not None:
	        n_max = args.n_max
	    if args.L1 is not None:
	        lec1 = args.lec1
	    if args.lec2 is not None:
	        lec2 = args.lec2
	    if args.c is not None:
	        c = args.c
	    if args.a is not None:
	        a = args.a
	    if args.mu_eta is not None:
	        mu_eta = args.mu_eta
	    if args.mu_delta is not None:
	        mu_delta = args.mu_delta
	    if args.xi_inf is not None:
	        xi_inf = args.xi_inf
	    if args.has_dp:
	        has_dp = True
	
693e8dc870b7b2ae93482019711c50d5|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|59|1|V|python
	    print(
	        """
	--- DarkSUN Scanner ---
	
	Running a DarkSUN parameter scan.
	
	The parameter values of this scan are:
	======================================
	output file = {}
	Lambda Range = ({}, {})
	N Range = ({}, {}),
	L1 = {}
	c = {}
	a = {}
	mu_eta = {}
	mu_delta = {}
	xi_inf = {}
	has_dp = {}
	======================================
	        """.format(
	            out_file,
	            lam_min,
	            lam_max,
	            n_min,
	            n_max,
	            lec1,
	            lec2,
	            c,
	            a,
	            mu_eta,
	            mu_delta,
	            xi_inf,
	            has_dp,
	        )
	    )
58147403f4a00bfc61b5b1b151a6e97d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|57|1|V|python
	    options = ""
28b67f4dec44f199dd91c1559f033d27|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|5|v|python
	argument_list
ddf34e532842b01319ad66fac4e6f8ce|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|1|V|python
	    lam = data['lam']
ce364ac9814efae1bb65e43e49a1a800|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|61|1|V|python
	    N = data['N']
32c3c047cf67d5ba7ebffe34bd12e18b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|62|1|V|python
	    lec1 = data['lec1']
4b4485518e7d0574a4588da0e99f1666|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|66|1|V|python
	    mu_eta = data['mu_eta']
19d29e2a091661aca893bc8ee1fa71fd|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|55|1|V|python
	    assert 'lam' in data
76fb461f9387314351a805a45d21ff74|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|1|V|python
	    assert 'N' in data
463196493e2aa029d2c3aac8ab77e792|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|5|v|python
	assert 
d3b40a84f5156e89ce1218adf025fc4b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|5|V|python
	    'N' in data
4dc4ec7091509ce4cb8d0265922bbe2e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|5|v|python
	and 
4dc4ec7091509ce4cb8d0265922bbe2e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|5|v|python
	and 
4dc4ec7091509ce4cb8d0265922bbe2e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|5|v|python
	and 
4dc4ec7091509ce4cb8d0265922bbe2e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|5|v|python
	and 
4dc4ec7091509ce4cb8d0265922bbe2e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|5|v|python
	and 
07149425b7fbbee17619ff6e2b88bbfd|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|60|1|V|python
	    assert ('c' in data), "missing key 'c'"
b0223c98deb62dc8165cc96a4b0baf12|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|61|1|V|python
	    assert ('a' in data), "missing key 'a'"
aee88e473d7d3299a66c95fa842e8ae4|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|58|1|V|python
	    assert ('out_file' in data), "missing key 'out_file'"
766d08c0a5447074c11428ed886cf932|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|55|13|v|python
	'out_file'
ea184d556c808e0746c68226de443e67|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|58|1|V|python
	    assert ('out_file' in data), "missing key 'out_file'"
	    assert ('lam' in data), "missing key 'lam'"
	    assert ('N' in data), "missing key 'N'"
	    assert ('lec1' in data), "missing key 'lec1'"
	    assert ('lec2' in data), "missing key 'lec2'"
	    assert ('c' in data), "missing key 'c'"
	    assert ('a' in data), "missing key 'a'"
	    assert ('mu_eta' in data), "missing key 'a'"
bf331a72d92b496c862e0c9fe3ee8c04|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|58|1|V|python
	    check_key(data, "out_file")
c36af3fde512ae2f5b03458e91af3446|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|74|25|v|python
	"out_file"
f13303fda372370d08236b0d9b59fb0f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|5|V|python
	    assert key in data, f"missing key {key}"
3d1c3abf5f5e308de0cdf4f955bf824a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|73|1|V|python
	        check_key(data, key)
83c625189586c45a77064ec0741db8e4|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|55|1|V|python
	def check_key(data, key):
409df001c8e05eab0140618cb933e6ba|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|84|1|V|python
	    lam = data["lam"]
	    N = data["N"]
	    lec1 = data["lec1"]
	    lec2 = data["lec2"]
	    c = data["c"]
	    a = data["a"]
	    mu_eta = data["mu_eta"]
	    mu_delta = data["mu_delta"]
	    xi_inf = data["xi_inf"]
	    has_dp = data["has_dp"]
494d89ee06b4324bb8f362ec2ae53b61|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|74|1|V|python
	        assert 'min' in par
feaa02bab10db83b30e360d2bc7829b6|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|76|28|v|python
	, "Ranged parameter doesn't contain 'min'"
c6e497d48685fbd5dae515806aedcfdb|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|7|1|V|json
	    "log": false,
	    "float": false
c59792b3d951accb24fe9eb766871826|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|14|1|V|json
	    "log": true
46bf1a327cae8bf6471dc844572baa8c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|78|1|V|python
	        assert 'num' in par, "Ranged parameter doesn't contain 'num'"
01573f357a714b51441808c1af9320be|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|79|1|V|python
	        assert 'log' in par, "Ranged parameter doesn't contain 'log'"
416c85ea8a9a75939d1037fb7be2ae93|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|81|17|v|python
	[val for val in range(
d55bffde951e1c0d5d8b393168e48328|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|82|1|V|python
	            param = np.logspace(np.log10(par['min'], np.log10(par['max']), np.log10(par['num']))
07e64943ccc1c4f3220d986c9d1d056a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|84|1|V|python
	            pass
384f804929e6c2bc2bd9f74b83e66438|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|84|24|v|python
	logspace
d535e7551733e223769d8c70245e19c2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|92|17|v|python
	log10
d535e7551733e223769d8c70245e19c2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|92|17|v|python
	log10
d535e7551733e223769d8c70245e19c2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|92|17|v|python
	log10
4445c7586b8b057125391c0022bd3014|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|7|1|V|json
	    "log": false,
	    "flt": false
5e93050bf3829cf7c58c71fd85aa562a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/cscan.json|11|15|v|json
	,
	    "log": false,
	    "flt": false
	
e118c38e51234da00521ddc9870c5725|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|80|1|V|python
	        assert "min" in par, "Ranged parameter doesn't contain 'min'"
	        assert "max" in par, "Ranged parameter doesn't contain 'max'"
	        assert "num" in par, "Ranged parameter doesn't contain 'num'"
c2f329a17c18a701dbe1e96e03858728|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|80|35|v|python
	Ranged
ba8f5e062f96563288f7057e3598fe9c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|78|1|V|python
	            assert "min" in par, "int range parameter doesn't contain 'min'"
	            assert "max" in par, "int range parameter doesn't contain 'max'"
	            assert "num" in par, "int range parameter doesn't contain 'num'"
e4f280c2722c6c68b1fe696cccccac2d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|82|1|V|python
	            assert "min" in par, "range parameter doesn't contain 'min'"
	            assert "max" in par, "range parameter doesn't contain 'max'"
	            assert "num" in par, "range parameter doesn't contain 'num'"
bd1d949d6ad30d492e1fc553986c2724|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|90|1|V|python
	        assert "min" in par, "Ranged parameter doesn't contain 'min'"
	        assert "max" in par, "Ranged parameter doesn't contain 'max'"
	        assert "num" in par, "Ranged parameter doesn't contain 'num'"
	        assert "log" in par, "Ranged parameter doesn't contain 'log'"
	        assert "flt" in par, "Ranged parameter doesn't contain 'flt'"
763a9634813b6e267bda3021b1162284|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|98|1|V|python
	            param = np.linspace(par["min"], par["max"], par["num"],)
7b37997a540d35a2eb284aa5b7630306|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|82|13|v|python
	param = np.linspace
312b4f4139cfd375f0dd96db414ff0a7|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|82|13|v|python
	np.int64(
6da54e9381c1a5951bbcc74380525534|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|81|1|V|python
	            param = np.linspace(par["min"], par["max"], par["num"], dtype='int')
d4a51ced480f0bc44c372ccf58a31941|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|86|1|V|python
	            param = np.linspace(par["min"], par["max"], par["num"], dtype='float')
ada6502172c31d4065159b45635a8e27|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|92|1|V|python
	        if par["log"]:
74ea69225d2394158fcf687f83371fbf|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|98|1|V|python
	        if not par["flt"]:
	            param = np.int64(param)
03144cce1fcdacdbe993e5266c0bf3f3|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|101|46|v|python
	parameter
764e9436a615a6fc558df17d57556789|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|73|5|v|python
	parse_parameter
7f30118d5d4c67977c66488a28054c80|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|134|1|V|python
	                                                'lec1': lec1,
ef43d5aaad1993c215ff3f20a4b1e327|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|108|5|v|python
	generate_parameter_list
2b4b25716c6a7ffd2a9b178568d8bb8c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|23|1|V|python
	    lam_min,
	    lam_max,
	    num_lams,
	    n_min,
	    n_max,
	    lec1,
	    lec2,
	    c,
	    a,
	    mu_eta,
	    mu_delta,
	    xi_inf,
	    has_dp,
60493c3de09045bcf16a8d641775f21d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|23|1|V|python
	    lams = np.logspace(np.log10(lam_min), np.log10(lam_max), num=num_lams)
	    Ns = np.arange(n_min, n_max, dtype=int)
	
	    param_matrix = [
	        [
	            (lam, N, lec1, lec2, c, a, mu_eta, mu_delta, xi_inf, has_dp)
	            for N in Ns
	        ]
	        for lam in lams
	    ]
59dbb33105c270da10f78f6211e7f9ff|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|25|58|v|python
	param_vector
d222879dbf16b372134ad4cd9a7ac938|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|26|13|V|python
	            for param_vector in tqdm(param_matrix)
f0368e65882f3be90ab2f902c7823f95|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|26|9|V|python
	        ]
94da0bcbe4b138cb2fbb0bc146b374fd|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|24|5|V|python
	        [
01fd09327a02db47eae2c73783c0e493|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|23|12|v|python
	np.array(
45d3cf79356cfa93c1ce13fe95e88d1c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|146|1|V|python
	    pickle.dump(models, open(out_file, "wb"))
ac1262621aafd92c77f3e1076368b22c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|25|6|v|python
	[solve_model(DarkSUN(*params)) for params in par_list]
ac5552fd6a3c08ad22387efbe42d137d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|23|17|v|python
	models
f6daad74dc694fea944065a9d6974526|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|23|1|V|python
	    pickle.dump([solve_model(DarkSUN(*params)) for params in par_list], open(out_file, "wb"))
f11b136998bea3f994d23f4faef6db65|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|135|1|V|python
	    models = scan(
	        lam_min,
	        lam_max,
	        num_lams,
	        n_min,
	        n_max,
	        lec1,
	        lec2,
	        c,
	        a,
	        mu_eta,
	        mu_delta,
	        xi_inf,
	        has_dp,
	    )
	    pickle.dump(models, open(out_file, "wb"))
aab5a1868b44ff626c284838ac92c94f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|132|1|V|python
	    #
d5da2f8bce85a4c755e9e4e4377c5cb7|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|131|5|V|python
	    # Make a list of all the parameters
b6b656bec31e73410ac7147df1497bbe|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|22|1|V|python
	def scan(par_list, o):
	    pickle.dump([solve_model(DarkSUN(*params)) for params in par_list], open(out_file, "wb"))
	return
	     [solve_model(DarkSUN(*params)) for params in par_list]
e7e57136919cf94a6e68d3d43e44af79|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|41|21|v|python
	"dict":
31215772acbc8ee979d36caa3934f8ba|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|48|1|V|python
	            par = par['intrange']
45ec86e33888b659ffaeea9443b9a6a2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|1|V|python
	            par = par['range']
76ab252ae27ea12a7f593e61c4d6b05d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|56|13|V|python
	            par = par["range"]
69ef12cac019f58c15bde31e2c85ae88|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|48|13|V|python
	            par = par["intrange"]
4e31e51b04dd493453d9f6811b4a473c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|64|13|V|python
	            par = par["logrange"]
24c99c62489a22dfee9336c8f5cb4e4a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|125|5|V|python
	    print(f"{*par_list[0]}")
932e9874569cece8cba3e4471865485d|file:///Users/loganmorrison/.skhdrc|7|1|V|conf
	# be found at https://github.com/koekeishiya/skhd/issues/1
7af929dc45acde751e8b331d91af9b6e|file:///Users/loganmorrison/.skhdrc|78|1|V|conf
	# opens iTerm2
1bfc4ec6db44869706995ea710344a24|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|20|1|V|toml
	cpuprofiler = "0.0.2"
1ef32f15c36c801596a130d1f728589b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/Cargo.toml|19|1|V|toml
	#numpy = "0.9.0"
a0bed81d3523b1d8659ba997a17fae4a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|61|13|V|python
	            assert "num" in par, "int range parameter doesn't contain 'num'"
c8066e8c6bb20a8fb0adbb6850bc6d90|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|62|41|v|python
	, par["num"], dtype="int"
7d344f736dbd93551c4cb6133357bd81|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|53|1|V|python
	        'range': A range of floats evenly spaced with 'num' values between
	                 'min' and 'max'.
642b58ba419517c47a6b94c3905aaa88|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|55|39|v|python
	evenly
3dd7aa0eaaf86ce7edebc38ddfeffb92|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|137|5|V|python
	    pass
c8cb6a9e9798a186b5cb46785eaf22ec|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|141|1|V|python
	-------+-------------
4e064dcfdaa4296aac2b968fba6e3c14|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|139|1|V|python
	---------------------
3611feaa58469cd030dc5c7fe048a1b8|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|149|1|V|python
	+----------+-----------
2c9b8f73975eb68990514ee72d723f11|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|151|1|V|python
	+----------------------
5e11bf525bfeec2468a9f7de9c9055d4|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|142|1|V|python
	| lam      | min: {}
ad578b2f5fa78b9a963c869ec1d21668|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|142|1|V|python
	| lam      | min: {}
	|          | max: {}
	|          | num: {}
0e69928cfe2ef0dc649aa58ce6b45aba|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|146|1|V|python
	| n        |
b53ae5c73122d9fe869b32967780d12e|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|150|1|V|python
	| lec1     |
82a8b1850c32d059340f765218fd330d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|157|1|V|python
	| lec2     |
4495618ffacb1871aff15e88d15f8111|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|158|1|V|python
	| c        |
100b7e14536b60f8decdfff3bd738804|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|162|1|V|python
	| a        |
b3587feac38f84d5ce2c28531d7355a6|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|166|1|V|python
	| mu_eta   |
bfc3d4d6e3798469d710ab7abfb58fca|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|170|1|V|python
	| mu_delta |
e03c95bf433e741030a9d976cb1e09ca|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|174|1|V|python
	| xi_inf   |
59e75c87c23aaab0f663761f4d3920db|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|178|1|V|python
	| has_dp   |
69df9889a43c32406049d7b30805f2e6|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|142|20|v|python
	data['lam']
a332e81095daa6fa1785e18974354de0|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|138|1|V|python
	        lam_min = data['lam']['min']
642febb545e669de76f28d8836776f35|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|138|1|V|python
	        lam_min = data['lam']['min']
	        lam_max = data['lam']['max']
	        lam_num = data['lam']['num']
09e6a35f32ff64745b128600698a4845|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|142|30|v|python
	['min']
48b99da668d7576e1810dfd9f9be9e2a|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|143|30|v|python
	['max']
bb32f0b9ae415496161887aa7f94e979|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|144|30|v|python
	['num']
4c4c9720fe251cda41ca267192cda05f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|137|1|V|python
	    if type(data['lam']):
	        lam_min = data['lam']['min']
	        lam_max = data['lam']['max']
	        lam_num = data['lam']['num']
	    else:
	        lam_min = data['lam']
	        lam_max = data['lam']
	        lam_num = 1
1dd57a2139dcd8bb167629bccca84ff5|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|145|1|V|python
	    if type(data['n']):
	        n_min = data['n']['min']
	        n_max = data['n']['max']
	        n_num = data['n']['num']
	    else:
	        n_min = data['n']
	        n_max = data['n']
	        n_num = 1
e2411cf2d481b41396cc2698342fa27b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|153|1|V|python
	    if type(data['lec1']):
	        lec1_min = data['lec1']['min']
	        lec1_max = data['lec1']['max']
	        lec1_num = data['lec1']['num']
	    else:
	        lec1_min = data['lec1']
	        lec1_max = data['lec1']
	        lec1_num = 1
6edd031a377369aaf585a3cccd892893|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|161|1|V|python
	    if type(data['lec2']):
	        lec2_min = data['lec2']['min']
	        lec2_max = data['lec2']['max']
	        lec2_num = data['lec2']['num']
	    else:
	        lec2_min = data['lec2']
	        lec2_max = data['lec2']
	        lec2_num = 1
97a0800402952fe342ce07c675a3985f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|169|1|V|python
	    if type(data['c']):
	        c_min = data['c']['min']
	        c_max = data['c']['max']
	        c_num = data['c']['num']
	    else:
	        c_min = data['c']
	        c_max = data['c']
	        c_num = 1
15ba584dd0b67f2fdf49d85bb5a0e3c0|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|177|1|V|python
	    if type(data['a']):
	        a_min = data['a']['min']
	        a_max = data['a']['max']
	        a_num = data['a']['num']
	    else:
	        a_min = data['a']
	        a_max = data['a']
	        a_num = 1
d25a6220bf2bbeffbd3fca2e4e3cbb85|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|185|1|V|python
	    if type(data['mu_eta']):
	        mu_eta_min = data['mu_eta']['min']
	        mu_eta_max = data['mu_eta']['max']
	        mu_eta_num = data['mu_eta']['num']
	    else:
	        mu_eta_min = data['mu_eta']
	        mu_eta_max = data['mu_eta']
	        mu_eta_num = 1
8afecfca2e7d40962f00bf41c3f86126|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|193|1|V|python
	    if type(data['mu_delta']):
	        mu_delta_min = data['mu_delta']['min']
	        mu_delta_max = data['mu_delta']['max']
	        mu_delta_num = data['mu_delta']['num']
	    else:
	        mu_delta_min = data['mu_delta']
	        mu_delta_max = data['mu_delta']
	        mu_delta_num = 1
51cacd12d6cfcb9bbcb4c1bd15634a02|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|201|19|v|python
	mu_delta
39a2190669bb261e7b05b3eda04d0775|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|201|1|V|python
	    if type(data['xi_inf']):
	        xi_inf_min = data['xi_inf']['min']
	        xi_inf_max = data['xi_inf']['max']
	        xi_inf_num = data['xi_inf']['num']
	    else:
	        xi_inf_min = data['xi_inf']
	        xi_inf_max = data['xi_inf']
	        xi_inf_num = 1
9d3e759b2e3aece2c0fb7744e130d0b9|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|257|1|V|python
	+----------+-----------
	| has_dp   | min: {has_p}
	|          | max: {}
	|          | num: {}
4266f444f24cf0f33bc7cac189347f7c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|209|1|V|python
	    if type(data['has_dp']):
	        has_dp_min = data['has_dp']['min']
	        has_dp_max = data['has_dp']['max']
	        has_dp_num = data['has_dp']['num']
	    else:
	        has_dp_min = data['has_dp']
	        has_dp_max = data['has_dp']
	        has_dp_num = 1
757e0b14b9ff491e6d8908a0ba4cb575|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|41|1|V|python
	        "has_dp",
d3806967fdc6e897ffda88cd3ee1ee50|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|105|5|V|python
	    has_dps = parse_parameter(data["has_dp"])
98bbd4b1c9a44e3ed3654765d87d74af|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|116|1|V|python
	                                        for has_dp in has_dps:
adb0b3c4dd8cc7cf022301970145c37f|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|127|59|v|python
	bool(has_dp),
fe8ab30fcaa1b64c2dde986981e93396|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|134|25|v|python
	 == dict
7f2469355957823ef7cb5d4270ad0c9d|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|258|5|V|python
	    display_scan_parameters(data)
d1ec3a349c2664f487504b2ea97fd8bd|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|3|8|v|json
	{
	    "intrange": {
	      "min": 10,
	      "max": 12,
	      "num": 3
	    }
	
20f464034f8a79b9e578e8cf67bda0ce|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|17|11|v|json
	{
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 3
	    }
	  }
6ddf4cf33bb93c56100ac03077a8d3e3|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|31|8|v|json
	{
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 3
	    }
	  },
	
9d33600ae72b8bcfab01c8bc4b323ba3|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|64|14|v|json
	0.5,
c11d21e93b979c9e36a7ecd7d69db3a2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|65|14|v|json
	1.5,
873a1b62b1ca09b0242a831f3bd269ff|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|117|1|V|python
	                                            {
	                                                "lam": float(lam),
	                                                "N": int(N),
	                                                "lec1": float(lec1),
	                                                "lec2": float(lec2),
	                                                "c": float(c),
	                                                "a": float(a),
	                                                "mu_eta": float(mue),
	                                                "mu_delta": float(mud),
	                                                "xi_inf": float(xi_inf),
	                                                "has_dp": False,
	                                            }
a654deb81ab67739256c1706e6e839df|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|129|45|v|python
	{
	                                                "lam": float(lam),
	                                                "N": int(N),
	                                                "lec1": float(lec1),
	                                                "lec2": float(lec2),
	                                                "c": float(c),
	                                                "a": float(a),
	                                                "mu_eta": float(mue),
	                                                "mu_delta": float(mud),
	                                                "xi_inf": float(xi_inf),
	                                                "has_dp": False,
	                                            }
	
16e73a26b5685cba29458d98d7a0b346|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|136|1|V|python
	        if par == dict and 'intrange' in par:
	            return 'intrange'
0f9613af7c294342d14744f2f18de972|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|138|31|v|python
	intrange
b19fa2eb0fc963b5ff0efdc9e936e8c1|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|135|9|v|python
	get_range_str
7fec278986ffe9b7ec288d5068877b40|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|144|30|v|python
	[rng]
720313e6c176bc9d3a3a87807d5eb447|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|144|1|V|python
	        rng = get_range_str(data["lam"])
1f9d6791169ddf353c2d56ee87cb6e75|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|153|1|V|python
	        rng = get_range_str(data["n"])
f959efdab1d17b7fe71dfa90d6173785|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|18|1|V|json
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 3
	    }
2a8a1a2a149f5d230e9e435bb7f862ee|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|19|3|V|json
	  },
499679d2014f6d745523403cb6d533de|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|18|1|V|json
	  "lec2": {
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 3
	    }
	  },
193ae8fb41477d0c631b7ede662d01fb|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/test.json|23|13|v|json
	{
	    "logrange": {
	      "min": 1e-3,
	      "max": 1e-1,
	      "num": 3
	    }
	  },
	
bd669d2c7f4a41543f8d284bbdcf33eb|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|128|1|V|python
	                                        print(dct)
8d1a8dffb86845ece2ff1dfddda93d26|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/lec1.json|17|11|v|json
	{
	    "range": {
	      "min": 1e-3,
	      "max": 10.0,
	      "num": 2
	    }
	  },
	
0e423610ed50220b328b062a7a0f80d2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/mu_delta.json|22|15|v|json
	1.0,,
4cfd1e4812a5e2d274536b45bf2c3bb2|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/mu_delta.json|22|15|v|json
	{
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 2
	    }
	  },
	
630c69c44d32755997a31d6e77753727|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/mu_eta.json|22|14|v|json
	{
	      "min": 0.5,
	      "max": 1.5,
	      "num": 2
	    }
	  },
	
99319ff795859b8e2359e7723df3aab7|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|283|1|V|python
	        [solve_model(DarkSUN(**params)) for params in tqdm(par_list)],
8f54f75625c2e4cd30f453c81afcafb7|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/run_scan.py|283|9|V|python
	        open(out_file, "wb"),
6f858dfd80c1fd35dad94cc65bc35c96|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/bm.json|2|16|v|json
	~/Documents/git_hub/Haliax/Projects/DarkSUN/
25ad420ff2792bc05c93aec696ed446d|untitled:2|30|1|V|markdown
	  - ERROR: nvr executable is not found, run `pip install neovim-remote` to install
a7a43d0a04426df437207464c3181758|file:///Users/loganmorrison/.zshrc|40|1|V|zsh
	export SSH_KEY_PATH="~/.ssh/rsa_id"
7e223eeec838650f89608f4f1b1237ea|file:///Users/loganmorrison/.config/fish/config.fish|1|1|v|fish
	xport
630851413dd1c7f4ae77e99e6934813f|file:///Users/loganmorrison/.zshrc|86|1|V|zsh
	eval "$(pyenv init -)"
	export JULIA_HOME=/Applications/Julia-1.4.app
	export JULIA_RESOURCES_HOME=${JULIA_HOME}/Contents/Resources
	export PATH=${JULIA_RESOURCES_HOME}/julia/bin:${PATH}
	export DYLD_LIBRARY_PATH=${JULIA_RESOURCES_HOME}/julia/lib:${DYLD_LIBRARY_PATH}
	export DYLD_LIBRARY_PATH=${JULIA_RESOURCES_HOME}/julia/lib/julia:${DYLD_LIBRARY_PATH}
	export JULIA_NUM_THREADS=8
	export JULIA_LOAD_PATH=":"
	export PATH="/Users/loganmorrison/.julia/bin:$PATH"
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
150afc324b7fbc3931023e96d81bd032|file:///Users/loganmorrison/.config/fish/config.fish|15|1|v|fish
	export 
27d5a1e0091327b7f9bba5feb1ad80be|file:///Users/loganmorrison/.zshrc|114|1|V|zsh
	export CPLUS_INCLUDE_PATH="$CPLUS_INCLUDE_PATH:$(python-config --prefix)/include"
b2507468f95156358fa490fd543ad2f0|file:///Users/loganmorrison/.config/fish/config.fish|17|1|v|fish
	export
d397be266ac465137398b1deea7f347e|file:///Users/loganmorrison/.zshrc|131|1|V|zsh
	export RUST_SRC_PATH=${HOME}/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/src
	export PATH="/Users/loganmorrison/.local/bin:$PATH"
5d8f811ecde76563d10fef8bf1f65397|file:///Users/loganmorrison/.config/fish/config.fish|6|1|V|fish
	eval "$(pyenv init -)"
d73314c9753eb5b0d93512aa9fb06d0f|file:///Users/loganmorrison/.config/fish/config.fish|15|1|V|fish
	set -x CPLUS_INCLUDE_PATH $CPLUS_INCLUDE_PATH:$(python-config --prefix)/include
4d953c5697263c0620636b96bd2f336d|file:///Users/loganmorrison/.config/fish/config.fish|15|1|V|fish
	'(python-config)'.set -x CPLUS_INCLUDE_PATH $CPLUS_INCLUDE_PATH:$(python-config --prefix)/include
120248176e7dad19b3804cfb1391e76c|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/a.json|20|8|v|json
	{
	    "range": {
	      "min": 0.0,
	      "max": 1.0,
	      "num": 2
	    }
	  },
	
3ff6558d523ab3f8bccd8d9222de4101|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/c%3D0.5.json|19|1|V|json
	  "c": {
	    "range": {
	      "min": 0.5,
	      "max": 1.5,
	      "num": 2
	    }
	  },
acad2eba52cc94678adce8898c22819b|file:///Users/loganmorrison/Documents/git_hub/Haliax/Projects/DarkSUN/parameter_files/xi_inf%3D1e-1.json|23|13|v|json
	{
	    "logrange": {
	      "min": 1e-4,
	      "max": 1,
	      "num": 5
	    }
	  },
	
d54c0158a111b884a3d2cc1520a41a2f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|429|3|V|cpp
	  double fe = m_lam * sqrt(m_N) / (4.0 * M_PI);
defa1bef1416122e968ffcb3f1fc50d5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|430|28|v|cpp
	pow<2>(z)
437465d806caa9e036b1b3139e2120d9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|427|3|V|cpp
	  // CME^2/meta^2.
f6f8d45e48a5cac91020261fd8cc656d|file:///Users/loganmorrison/.yabairc|4|1|V|sh
	yabai -m config mouse_follows_focus          on
6e0de35e0f5c4aae4a346bc6a6645904|file:///Users/loganmorrison/.yabairc|5|1|V|sh
	yabai -m config --space 1 mouse_follows_focus on
23bf76a45f7a23e57240e48bc3b8f7a8|file:///Users/loganmorrison/.yabairc|3|1|V|sh
	# global settings
	yabai -m config mouse_follows_focus           on
	yabai -m config focus_follows_mouse          autoraise
	yabai -m config window_placement             second_child
	yabai -m config window_topmost               off
	yabai -m config window_shadow                on
	yabai -m config window_opacity               off
	yabai -m config window_opacity_duration      0.0
	yabai -m config active_window_opacity        1.0
	yabai -m config normal_window_opacity        0.90
	yabai -m config window_border                on
	yabai -m config window_border_width          6
	yabai -m config active_window_border_color   0xff775759
	yabai -m config normal_window_border_color   0xff555555
	yabai -m config insert_feedback_color        0xffd75f5f
	yabai -m config split_ratio                  0.50
	yabai -m config auto_balance                 off
	yabai -m config mouse_modifier               fn
	yabai -m config mouse_action1                move
	yabai -m config mouse_action2                resize
a0436d9c449367eed1b9d35cdc67cddf|file:///Users/loganmorrison/.yabairc|33|1|V|sh
	# global settings
99198859ef38451280e575f65a715fdb|file:///Users/loganmorrison/.yabairc|34|56|v|sh
	autoraise
f969e598ff3b9fffbd389f558a6232cb|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|2|27|v|rust
	None, None)
b476367c8fd9fc0e1625f6370a4bb623|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|4|17|v|rust
	Radau5()
96849af3aa234c9b1883cff9745f97af|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|1|1|V|rust
	let f = ...
	let func = OdeFunction(f, jac=..)
	let prob = OdeProblem(func, uinit, tspan, p) 
	solve(prob, alg=...)
6bddc39f3deae6b735ef7d5e79854f74|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|1|1|V|rust
	let f = ...
a40a122b62865f264ee5b3b375ece49f|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/prelude.rs|3|1|V|rust
	pub use crate::qagi::*;
da2baf73bd50f8a4307a08d5d4a0cf38|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/prelude.rs|4|1|V|rust
	pub use crate::qag::*;
c3ae7038f757e0b3b079d78cd97bf518|file:///Users/loganmorrison/Documents/coding/rust/cyphus-integration/src/prelude.rs|5|1|V|rust
	pub use crate::qags::*;
4264bed65a7d1a91fffb56e39587a083|file:///Users/loganmorrison/.config/fish/config.fish|17|1|V|fish
	set PATH /Users/loganmorrison/.local/bin $PATH
6fe9642d345b0d096ec8aeeb2769a63c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|41|1|V|rust
	        let integrator = GaussKronrodIntegratorBuilder::default()
	            .epsrel(1e-8)
	            .epsabs(1e-8)
	            .build();
e1bb47daa624f06962eab6f7393d148f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|47|19|v|rust
	integrator.integrate
e74c8076af3144aa539a8fcb479947a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|66|19|v|rust
	(*TCS_INTEGRATOR).
2f2a946a2ba2cf108f12ce31c3dd7a09|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|75|5|V|rust
	    use cpuprofiler::PROFILER;
d8e2f7d3720701bf0a4f29f80bdea3ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|78|1|V|rust
	        PROFILER
	            .lock()
	            .unwrap()
	            .start("./tc.profile")
	            .expect("Couldn't start");
b0b13bbf0006531a1ea3d950819ff424|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|80|9|V|rust
	        PROFILER.lock().unwrap().stop().expect("Couldn't stop");
b463d15240da6a1705fce368cc95363d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	lazy_static! {
3437b6296c1346944d99519934f1ce45|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2|1|V|rust
	use cyphus_interpolation::prelude::{UnivariateSpline, UnivariateSplineBuilder};
64b60577dbb22d35014ad0263399da8d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|3|22|v|rust
	cross_section
686810e30bd4cd0ed070ed8e70fe6e69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|3|1|V|rust
	pub(crate) fn scaled_cs_24_44(z: f64) -> f64{
	}
4ec4a97fe00d2b401b85aff872e6448b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1|1|V|rust
	/// Compute the scaled cross section for 2eta->4eta using only the 4pt
	/// amplitude.
a93f7bb824aa8e5bd1513337e54dfe7b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	/// Compute the scaled cross section for 2eta->4eta using only the 6pt
	/// amplitude.
9dd1886e1053420db62f9c3e20520c98|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|12|5|v|rust
	amplitude.
85cceb79b0ebe3fc47f437e0596535e8|file:///Users/loganmorrison/Documents/coding/rust/cyphus-interpolation/src/interp1d/util.rs|3|1|V|rust
	#[allow(dead_code)]
	pub(super) fn bsearch(xarr: &Vec<f64>, x: f64, idx_low: usize, idx_high: usize) -> usize {
	    let mut ilow = idx_low;
	    let mut ihigh = idx_high;
	
	    while ihigh > ilow + 1 {
	        let i = (ihigh + ilow) / 2;
	        if xarr[i] > x {
	            ihigh = i;
	        } else {
	            ilow = i;
	        }
	    }
	    ilow
	}
fe2946f880df5e5ac8514e35a5b56503|file:///Users/loganmorrison/Documents/coding/rust/cyphus-interpolation/src/interp1d/linear.rs|26|1|V|rust
	        if x < self.x[0] || x > self.x[self.x.len() - 1] {
	            return f64::NAN;
	        }
	        let idx = self.bsearch(x);
	
	        let x_l = self.x[idx];
	        let x_h = self.x[idx + 1];
	        let y_l = self.y[idx];
	        let y_h = self.y[idx + 1];
	        let dx = x_h - x_l;
	
	        if dx > 0.0 {
	            y_l + (x - x_l) / dx * (y_h - y_l)
	        } else {
	            f64::NAN
	        }
2fad8eb6eec0b4466415c9ba3398130e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|36|5|V|rust
	    0.0
2e3bac5cd9145bfc3267ddbce6bbbf41|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|20|1|V|rust
	    if x < self.x[0] || x > self.x[self.x.len() - 1] {
	        return f64::NAN;
	    }
	    let idx = self.bsearch(x);
	
	    let x_l = self.x[idx];
	    let x_h = self.x[idx + 1];
	    let y_l = self.y[idx];
	    let y_h = self.y[idx + 1];
	    let dx = x_h - x_l;
	
	    if dx > 0.0 {
	        y_l + (x - x_l) / dx * (y_h - y_l)
	    } else {
	        f64::NAN
	    }
8a518e48cff363c4672332d0215f898e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|2|19|v|rust
	Vec<f64>
644a491e784071f3e4f46d090ca9559e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|19|32|v|rust
	xarr.len()
e25f04a7340edda9f5a68d85786ac9ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|19|4|V|rust
	    if x < xarr[0] || x > xarr[n - 1] {
	        return f64::NAN;
	    }
1925b67167afb8fd5c255838c96070c6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|18|5|V|rust
	    let n = xarr.len();
9e4ec5deb323f92c1c76d05f4d8e9fc1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|36|1|V|rust
	    let logz = z.log10();
	    if logz > LOG_ETA_ZS_MIN && logz < LOG_ETA_ZS_MAX {
	        linear_inter_eval(logz, &LOG_ETA_ZS, &LOG_ETA_CS44)
	    } else if logz > LOG_ETA_ZS_MAX {
	        z.powi(14) * 10f64.powf(ETA_CS_INTERCEPT44)
	    } else {
	        0.0
	    }
6e9e5ffc846debced38009a1ffa8fe79|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|21|1|V|rust
	        let logz = z.log10();
20a38cf3f8e58f0fd304d0ef55eb52f6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|25|1|V|rust
	        if logz > (*LOG_ETA_ZS_MIN) && logz < (*LOG_ETA_ZS_MAX) {
	            c44 * 10f64.powf((*ETA_CS44_INTERP).eval(logz))
	                + c66 * 10f64.powf((*ETA_CS66_INTERP).eval(logz))
	                + c46 * 10f64.powf((*ETA_CS46_INTERP).eval(logz))
	        } else if logz >= (*LOG_ETA_ZS_MAX) {
	            z.powi(14)
	                * (c44 * 10f64.powf(*ETA_CS_INTERCEPT44)
	                    + c66 * 10f64.powf(*ETA_CS_INTERCEPT66)
	                    + c46 * 10f64.powf(*ETA_CS_INTERCEPT46))
	        } else {
	            0.0
	        }
9b8eeeedd26af4d1f9d65a0c241346d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|19|1|V|rust
	    pub z1: Array1<f64>,
b4d7f349bb9461ce293c0124502232a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|19|1|V|rust
	    pub z1: Array1<f64>,
	    pub z2: Array1<f64>,
	    pub z3: Array1<f64>,
558e05d7567e0c1739d11f5c0c875a91|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|24|1|V|rust
	    pub f3: Array1<f64>,
6fa2d2fa45005fb46ada2926f028414f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|25|1|V|rust
	    pub y0: Array1<f64>,
eb0c6a876bb2ce9186df3bd559c21f52|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|26|1|V|rust
	    pub scal: Array1<f64>,
290cf10846b37df2565561bd58d09756|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|27|1|V|rust
	    pub cont: Array1<f64>,
568d8e07bbe5575518d5005e559743c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|28|9|v|rust
	cont
5df36c0b3e9b525d5d4f0b6a0c9477be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|28|1|V|rust
	    pub ip1: Array1<f64>,
9d9d204566d9e5b4432b3e0b0a9aafb8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|15|20|v|rust
	// parameter for step size selection
3db812cc377151590642bdaa67d6bf50|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|10|17|v|rust
	Array1<f64>, // vector of absolute tolerances
8ebbc01e2d790dbb1495aa463fced835|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|23|23|v|rust
	// step size control
2a5f94e4c3658dc259fe07829ac66228|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.h|370|1|V|cpp
		// stopping criterion for Newton's method, usually chosen < 1
eb25c6f07c7c0829ad1f3b14e6fbf71e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|25|64|v|rust
	, usually chosen < 1
29e9118ef6969b114aec40b29e20e076|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.h|372|22|v|cpp
	if quot1 < hnew/hold < quot2, step size = const
da125a4a65c66c317052071a4987cfbd|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.h|375|1|V|cpp
		// decides whether the Jacobian should be recomputed
fd98d418c413d734df7f1aa17a0ad934|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|28|4|V|rust
	    // decides whether the Jacobian should be recomputed
e1dc6b2069106cda4f242ececaed0a6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|7|1|V|rust
	    pub n: usize,         // Dimension of the system
	    pub y: Array1<f64>,   // state of the system
	    pub x: f64,           // independent variable
	    pub xend: f64,        // final value of independent variable
	    pub dx: f64,          // time step for intermediate output
	    pub rtoler: Vec<f64>, // vector of relative tolerances
	    pub atoler: Vec<f64>, // vector of absolute tolerances
	    pub h: f64,           // step size
2602a340ce880bb68eae305b931b8c66|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|12|1|V|rust
	    pub rtoler: Vec<f64>, // vector of relative tolerances
	    pub atoler: Vec<f64>, // vector of absolute tolerances
315ecaee3450da3be7fa8660183b8dc1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|6|1|V|rust
	    pub n: usize,       // Dimension of the system
	    pub y: Array1<f64>, // state of the system
	    pub x: f64,         // independent variable
	    pub xend: f64,      // final value of independent variable
	    pub dx: f64,        // time step for intermediate output
	    pub h: f64,         // step size
df3d8368095ccdff618489a7a7d61ec2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|13|9|v|rust
	n: usize,       // Dimension of the system
924a5d061eb367add2985bc8242ce8eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|14|1|V|rust
	    pub y: Array1<f64>, // state of the system
	    pub x: f64,         // independent variable
	    pub xend: f64,      // final value of independent variable
	    pub dx: f64,        // time step for intermediate output
	    pub h: f64,         // step size
d586f8e7cee5a3275478e7b2e2dca08a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|18|1|V|rust
	    pub rtoler: Vec<f64>, // vector of relative tolerances
	    pub atoler: Vec<f64>, // vector of absolute tolerances
	    pub hmax: f64,        // max step size,
	    pub nmax: f64,        // max number of steps
	    pub safe: f64,        // safety factor for step size prediction
	    pub facl: f64,        // parameter for step size selection
	    pub facr: f64,        // parameter for step size selection
	    pub xold: f64,        // stores past value of x
	    pub hold: f64,        // stores past value of h
	    pub xd: f64,          // x at discrete points specified by dx interval
1acdc7ca8a6a7f4ba9f40910090b2595|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|33|1|V|rust
	    pub nit: usize,   // maximum number of newton iterations
	    pub startn: bool, // switch for starting values of newton iterations
	    pub npred: usize, // step size control
	    pub pred: bool,   // step size control
	    pub fnewt: f64,   // stopping criterion for Newton's method
	    pub quot1: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: f64,    // decides whether the Jacobian should be recomputed
b9a43e91ea350690ad1d2a03529e9af1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|46|1|V|rust
	    pub fac1: f64,
	    pub alphn: f64,
	    pub betan: f64,
	    pub err: f64,
	    pub caljac: bool,
	    pub first: bool,
	    pub reject: bool,
	    pub z1: Array1<f64>,
	    pub z2: Array1<f64>,
	    pub z3: Array1<f64>,
	    pub f1: Array1<f64>,
	    pub f2: Array1<f64>,
	    pub f3: Array1<f64>,
	    pub y0: Array1<f64>,
	    pub scal: Array1<f64>,
	    pub cont: Array1<f64>,
	    pub ip1: Array1<i32>,
	    pub ip2: Array1<i32>,
	    pub e1: Array2<f64>,
	    pub e2r: Array2<f64>,
	    pub e2i: Array2<f64>,
	    pub fjac: Array2<f64>,
829c9f3d09a8ffb182fbc29d856f8425|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|78|1|V|rust
	        rtoler: Vec<f64>,
6f9c2caf76efc5a55d984f524e0985f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|95|7|v|rust
	: usize,       // Dimension of the system
8b4112cedc1bb9936d23737a57cdc81a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|96|10|v|rust
	: Array1<f64>, // state of the system
46f7de0ce0d60dd69a45a39dbee67b9c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|100|6|v|rust
	: f64,         // step size
984d335fb3f89b4e6b88d851175e721e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|99|7|v|rust
	: f64,        // time step for intermediate output
14f528170f4183c61f324a37da3927f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|98|9|v|rust
	: f64,      // final value of independent variable
fac56779badee0cb4b3f418832c9016a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|97|6|v|rust
	: f64,         // independent variable
8970b4f630bc5c9f304fb09b6dcbfa9b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|12|12|v|rust
	GenericOdeOptions {
	    pub rtoler: Vec<f64>, // vector of relative tolerances
	    pub atoler: Vec<f64>, // vector of absolute tolerances
	    pub hmax: f64,        // max step size,
	    pub nmax: f64,        // max number of steps
	    pub safe: f64,        // safety factor for step size prediction
	    pub facl: f64,        // parameter for step size selection
	    pub facr: f64,        // parameter for step size selection
	    pub xold: f64,        // stores past value of x
	    pub hold: f64,        // stores past value of h
	    pub xd: f64,          // x at discrete points specified by dx interval
	}
	
1a702b1d3ffa4d627a3e803dd3e475ee|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|103|11|v|rust
	: Vec<f64>, // vector of relative tolerances
731ce58e3d67804dfad76d0050e65e89|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|104|11|v|rust
	: Vec<f64>, // vector of absolute tolerances
263db8997cbe31aac15c8a3f72c80b90|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|105|10|v|rust
	        // max step size,
bdae2e2babf0c6e314be84d7c9db9f0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|106|10|v|rust
	        // max number of steps
42628421e54276fa958b6fc268ce1cf8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|107|10|v|rust
	        // safety factor for step size prediction
3c8044f121dd6e03cea2d58d1913bfbe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|108|10|v|rust
	        // parameter for step size selection
b4222a96ef644322120a88370569aa02|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|110|10|v|rust
	        // stores past value of x
ca925b9a10c5411e57cf5c43e9e97d0b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|111|10|v|rust
	        // stores past value of h
0bcf6ede8280183f47da130714e00f62|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|112|9|v|rust
	          // x at discrete points specified by dx interval
38e85127946ab1925a5db40a742379a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|25|12|v|rust
	Radau5Options {
	    pub nit: usize,   // maximum number of newton iterations
	    pub startn: bool, // switch for starting values of newton iterations
	    pub npred: usize, // step size control
	    pub pred: bool,   // step size control
	    pub fnewt: f64,   // stopping criterion for Newton's method
	    pub quot1: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: f64,    // decides whether the Jacobian should be recomputed
	}
	
7d8f7c0c608b95322a6fd47903387fc5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|115|9|v|rust
	   // maximum number of newton iterations
0b77164ddf5754daa9df8f2706ace013|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|116|12|v|rust
	 // switch for starting values of newton iterations
1e5394be6eb80226c363851ca9c9af1f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|117|11|v|rust
	 // step size control
5f2c6e132851df0d3a9053613e8d14e7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|118|10|v|rust
	   // step size control
8007495eb3cca0538169420709506bc9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|119|11|v|rust
	   // stopping criterion for Newton's method
b39d394f49f2eb8cc9c92056fd69231e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|120|11|v|rust
	   // if quot1 < hnew/hold < quot2, step size = const
7ed2bda578498c4fa30dcb3398966639|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|121|10|v|rust
	,   // if quot1 < hnew/hold < quot2, step size = const
73c87a72aa6154e285d7fbd91132324d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|36|12|v|rust
	Radau5Cache {
	    pub fac1: f64,
	    pub alphn: f64,
	    pub betan: f64,
	    pub err: f64,
	    pub caljac: bool,
	    pub first: bool,
	    pub reject: bool,
	    pub z1: Array1<f64>,
	    pub z2: Array1<f64>,
	    pub z3: Array1<f64>,
	    pub f1: Array1<f64>,
	    pub f2: Array1<f64>,
	    pub f3: Array1<f64>,
	    pub y0: Array1<f64>,
	    pub scal: Array1<f64>,
	    pub cont: Array1<f64>,
	    pub ip1: Array1<i32>,
	    pub ip2: Array1<i32>,
	    pub e1: Array2<f64>,
	    pub e2r: Array2<f64>,
	    pub e2i: Array2<f64>,
	    pub fjac: Array2<f64>,
	}
	
fd85c33bc7d56078fa9df9287e6ffdd7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|146|9|v|rust
	Array2
fd85c33bc7d56078fa9df9287e6ffdd7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|146|9|v|rust
	Array2
fd85c33bc7d56078fa9df9287e6ffdd7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|146|9|v|rust
	Array2
fd85c33bc7d56078fa9df9287e6ffdd7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|146|9|v|rust
	Array2
853b5fadd4627bacfe8e0673ebde7937|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|132|17|v|rust
	Array1::zeros(n),
add0d182b935d1b8e9ec7cb986336c71|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|132|17|v|rust
	Array1::zeros(n)
d8876f8444bc503331d95fd101091f7f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|132|15|v|rust
	: Array1::zeros(n)
c5e8561dc37a33d4e742f13a1f556f63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|143|15|v|rust
	: Array2::zeros((n,n))
6fb7c8315fba475da5468b7a27dc5034|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|10|16|v|rust
	Optison
ecbbec0579807806f17cb6f3cc0a891c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|23|1|V|rust
	pub struct GenericOdeOptions {
	}
669d0b4660de5ed2317c1ff3fd6d59da|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|33|1|V|rust
	pub struct Radau5Options {
	    pub nit: usize,   // maximum number of newton iterations
	    pub startn: bool, // switch for starting values of newton iterations
	    pub npred: usize, // step size control
	    pub pred: bool,   // step size control
	    pub fnewt: f64,   // stopping criterion for Newton's method
	    pub quot1: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: f64,    // decides whether the Jacobian should be recomputed
	}
01cf143b547e527553b9b6d4693d6eb0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|57|1|V|rust
	pub struct Radau5Cache {
	}
6ab82df93ac3105c0e9ea765bceb05b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|58|1|V|rust
	pub struct Radau5 {
	    pub integrator: OdeIntegrator,
	    // Generic options
	    pub gen_opts: GenericOdeOptions,
	    // Radau5 specfic options
	    pub rad_opts: Radau5Options,
	    // variables used during integration
	    pub cache: Radau5Cache,
	}
1974151725ff433e8c5f7f8d6fd334d7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|78|9|v|rust
	let integrator = 
399f346d6493046ed90cfc00ddb34adf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|85|9|V|rust
	        let opts = GenericOdeOptions {
5dc90ffec6cf9f821148c9de0da263ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|95|9|V|rust
	        let ropts = Radau5Options {
95498d8d16aaf8a4fdd46565815b8f2e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|103|9|V|rust
	        let cache = Radau5Cache {
6fdef50f9dfbf8c4fb07a8f5f68c184f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|4|1|V|rust
	    pub n: usize,       // Dimension of the system
	    pub y: Array1<f64>, // state of the system
	    pub x: f64,         // independent variable
	    pub xend: f64,      // final value of independent variable
	    pub dx: f64,        // time step for intermediate output
	    pub h: f64,         // step size
	    // Generic Options
	    pub rtoler: Vec<f64>, // vector of relative tolerances
	    pub atoler: Vec<f64>, // vector of absolute tolerances
	    pub hmax: f64,        // max step size,
	    pub nmax: f64,        // max number of steps
	    pub safe: f64,        // safety factor for step size prediction
	    pub facl: f64,        // parameter for step size selection
	    pub facr: f64,        // parameter for step size selection
	    pub xold: f64,        // stores past value of x
	    pub hold: f64,        // stores past value of h
	    pub xd: f64,          // x at discrete points specified by dx interval
	    // Radau options
	    pub nit: usize,   // maximum number of newton iterations
	    pub startn: bool, // switch for starting values of newton iterations
	    pub npred: usize, // step size control
	    pub pred: bool,   // step size control
	    pub fnewt: f64,   // stopping criterion for Newton's method
	    pub quot1: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: f64,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: f64,    // decides whether the Jacobian should be recomputed
67e32ff15483fdc4889e7f9a094c541a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|3|1|V|rust
	pub struct Radau5Builder {
	    pub n: usize,       // Dimension of the system
	    pub y: Array1<f64>, // state of the system
	    pub x: f64,         // independent variable
	    pub xend: f64,      // final value of independent variable
	    pub dx: f64,        // time step for intermediate output
	    pub h: f64,         // step size
	    // Generic Options
	    pub rtoler: Vec<f64>,  // vector of relative tolerances
	    pub atoler: Vec<f64>,  // vector of absolute tolerances
	    pub hmax: Option<f64>, // max step size,
	    pub nmax: Option<f64>, // max number of steps
	    pub safe: Option<f64>, // safety factor for step size prediction
	    pub facl: Option<f64>, // parameter for step size selection
	    pub facr: Option<f64>, // parameter for step size selection
	    pub xold: Option<f64>, // stores past value of x
	    pub hold: Option<f64>, // stores past value of h
	    pub xd: Option<f64>,   // x at discrete points specified by dx interval
	    // Radau options
	    pub nit: Option<usize>,   // maximum number of newton iterations
	    pub startn: Option<bool>, // switch for starting values of newton iterations
	    pub npred: Option<usize>, // step size control
	    pub pred: Option<bool>,   // step size control
	    pub fnewt: Option<f64>,   // stopping criterion for Newton's method
	    pub quot1: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: Option<f64>,    // decides whether the Jacobian should be recomputed
	}
11166a9a42a723803e9d5be36a0fb16d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|9|5|V|rust
	    pub dx: f64,        // time step for intermediate output
e1b8e20d176258b96506fa98451b1972|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|9|5|V|rust
	    pub h: f64,         // step size
5d202b643a8850f3f1dd64eb444cf361|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|9|1|V|rust
	    pub h: Option<f64>,   // step size
	    pub dx: Option<f64>,  // time step for intermediate output
b72a1f0d8013515ae0984ff19b172ff5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|62|1|V|rust
	    pub n: usize,       // Dimension of the system
	    pub y: Array1<f64>, // state of the system
	    pub x: f64,         // independent variable
	    pub xend: f64,      // final value of independent variable
	    // Generic Options
	    pub h: Option<f64>,    // step size
	    pub dx: Option<f64>,   // time step for intermediate output
	    pub rtoler: Vec<f64>,  // vector of relative tolerances
	    pub atoler: Vec<f64>,  // vector of absolute tolerances
	    pub hmax: Option<f64>, // max step size,
	    pub nmax: Option<f64>, // max number of steps
	    pub safe: Option<f64>, // safety factor for step size prediction
	    pub facl: Option<f64>, // parameter for step size selection
	    pub facr: Option<f64>, // parameter for step size selection
	    pub xold: Option<f64>, // stores past value of x
	    pub hold: Option<f64>, // stores past value of h
	    pub xd: Option<f64>,   // x at discrete points specified by dx interval
	    // Radau options
	    pub nit: Option<usize>,   // maximum number of newton iterations
	    pub startn: Option<bool>, // switch for starting values of newton iterations
	    pub npred: Option<usize>, // step size control
	    pub pred: Option<bool>,   // step size control
	    pub fnewt: Option<f64>,   // stopping criterion for Newton's method
	    pub quot1: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: Option<f64>,    // decides whether the Jacobian should be recomputed
f357d6045d1886d3fecfbe0941af79c7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	rtoler
53cbc1f3bb7dbd197c77209284a4e4ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	atoler
1a1d0a122444b68efa12fa81321c3fc7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	hmax
5f2b1e133dd076f2454ba96caf37f306|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	nmax
fd120834188644ea049e5f73176e26ca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	xold
af1d8213f4a22b0f9803fec9259ff7a8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|v|rust
	hold
663885daa56eacecd6c1b11a961a953e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|64|6|v|rust
	>,   
bbfcb2cd7466b61e1023a7887ef29f58|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|64|6|v|rust
	>,  
bbfcb2cd7466b61e1023a7887ef29f58|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|64|6|v|rust
	>,  
0caacd591a6d6f4558c0a77589b01727|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|64|6|v|rust
	>,    
663885daa56eacecd6c1b11a961a953e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|64|6|v|rust
	>,   
0c1a41d90a4fbe12fb97ca77cb2f8e74|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// step size
270d291e0e4e156f977f555201b88365|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// time step for intermediate output
4a299ecf08323a8e799f0bb9929c83b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// vector of relative tolerances
4a37448131721661fcf43784748fd0a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// max number of steps
e7a20a301e2591d3deadb39d32b6748f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// vector of absolute tolerances
cb3d8c9ddf558f79600fd8c08d246081|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// max step size,
190aa3a4d9558aeecec5edc5af8aafcc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// safety factor for step size prediction
c341e228b31c11cf677b507f1b138019|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// stores past value of h
a7a308d55cbf5012fd4bfa83d7e39a4b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// stores past value of x
db477905c7ca2825f21c882b105fa6c0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|7|v|rust
	// x at discrete points specified by dx interval
4dc21256a35e49f59ffd2982f81efd41|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|63|5|V|rust
	    // Generic Options
cd7f80a93335d015ac48d87830a34ab4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// maximum number of newton iterations
a652c6076e5d06713a4e9a5e89247de6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// switch for starting values of newton iterations
f2756c5bc9dd78fe84cda40b965935f8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// stopping criterion for Newton's method
5181f0f4239bbc78b7eeb3b73e874e31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// if quot1 < hnew/hold < quot2, step size = const
5181f0f4239bbc78b7eeb3b73e874e31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// if quot1 < hnew/hold < quot2, step size = const
68de684f4c6d147095aa57958c1aa70f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|83|9|v|rust
	// decides whether the Jacobian should be recomputed
962ea078ea9a05176e8dba9061e3f989|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|V|rust
	    // Radau options
39404b9642b3c3c67a99e95add2ee478|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|59|7|v|rust
	       // Dimension of the system
6fcbafa0265f130e954ac68e9706f95e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|60|6|v|rust
	<f64>, // state of the system
b1a57569f307feaea8afbeaf45827336|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|61|7|v|rust
	         // independent variable
2aaf3b40430554919c4b5333bb4bcdaf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|62|10|v|rust
	      // final value of independent variable
12c70bfa11e6aca4537121dfd8d44948|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|63|6|v|rust
	: None
f62ccd10a4ccf3976c5c139d68b345c8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|116|1|V|rust
	    pub fn h(mut self, h: f64) -> Self {
	        self.h = h;
	        self
	    }
2640bbcfcdbf89b533ceeb7e070e8ab8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|116|1|V|rust
	    pub fn h(mut self, h: f64) -> Self {
	        self.h = Some(h);
	        self
	    }
d5156ef23e2156615867ac3a8b2c3a00|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|120|1|V|rust
	    pub fn dx(mut self, dx: f64) -> Self {
	        self.dx = Some(dx);
	        self
	    }
47f345e3a55d7e7a4ba0f95a4b5e2f10|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|124|1|V|rust
	    pub fn rtoler(mut self, rtoler: Vec<f64>) -> Self {
	        self.rtoler = Some(rtoler);
	        self
	    }
9f1ac4707dadc298b3f819b34e7bedb6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|128|1|V|rust
	    pub fn atoler(mut self, atoler: Vec<f64>) -> Self {
	        self.atoler = Some(atoler);
	        self
	    }
a1ce2275ba1960abf300e781572d2780|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|132|27|v|rust
	atoler: Vec<f64>
4164d760e2fc4e9f43246eea5b5e5a31|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|132|1|V|rust
	    pub fn hmax(mut self, hmax:f64) -> Self {
	        self.hmax = Some(hmax);
	        self
	    }
ffa94cdb98e6fd32fb48f5606eac0c8d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|136|1|V|rust
	    pub fn nmax(mut self, nmax:usize) -> Self {
	        self.nmax = Some(nmax);
	        self
	    }
b61ba8afbd01e37a698187dbcce0ad7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|140|1|V|rust
	    pub fn safe(mut self, safe:f64) -> Self {
	        self.safe = Some(safe);
	        self
	    }
7ef4d1f9729c772b9455197f1bb4ad28|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|144|1|V|rust
	    pub fn facl(mut self, facl:f64) -> Self {
	        self.facl = Some(facl);
	        self
	    }
0cf44b7ef4516862ead40af64698f6c3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|101|1|V|rust
	    pub xold: Option<f64>,        // stores past value of x
	    pub hold: Option<f64>,        // stores past value of h
	    pub xd: Option<f64>,          // x at discrete points specified by dx interval
	    // Radau options
	    pub nit: Option<usize>,   // maximum number of newton iterations
	    pub startn: Option<bool>, // switch for starting values of newton iterations
	    pub npred: Option<usize>, // step size control
	    pub pred: Option<bool>,   // step size control
	    pub fnewt: Option<f64>,   // stopping criterion for Newton's method
	    pub quot1: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: Option<f64>,    // decides whether the Jacobian should be recomputed
9766dfc4701832447c4d98380b9e6bfe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|148|1|V|rust
	    pub fn facr(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
b87ca8d78cae5a7767274c2b3c926540|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|152|1|V|rust
	    pub xold: Option<f64>,        // stores past value of x
c95a80f5f4a9da66164cacccb6f3af42|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|156|1|V|rust
	    pub xold: Option<f64>,        // stores past value of x
	    pub hold: Option<f64>,        // stores past value of h
	    pub xd: Option<f64>,          // x at discrete points specified by dx interval
25460c3ad519dac82dc84380f0c39c6d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|152|1|V|rust
	    pub fn xd(mut self, xd: f64) -> Self {
	        self.xd = Some(xd);
	        self
	    }
9947b5a2a6631500586ac586c031f3a4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|152|1|V|rust
	    pub fn nit(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
d6b2d72b76d7c03b146ae2b29e28e741|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|156|1|V|rust
	    pub fn startn(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
a85fe5634fa371fbdd66ebfc809f3968|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|160|12|v|rust
	startn
7b4f1566f3e57af835f9b74ea1362ce3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|160|1|V|rust
	    pub fn pred(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
d91a2f87349da87b741376f807c777e9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|164|12|v|rust
	pred
bdd05853e2b7be85e13108b64a68d308|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|164|1|V|rust
	    pub fn fnewt(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
2e8afe91f468d4018b8b47385dca5324|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|168|1|V|rust
	    pub fn quot1(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
c9c898eeb956acec2cc0262cf95f3ab7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|172|1|V|rust
	    pub fn quot2(mut self, facr: f64) -> Self {
	        self.facr = Some(facr);
	        self
	    }
bc850a24ee2dfd1c77d999c7d5da8958|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|176|12|v|rust
	quot2
0d5c1484b98ec5d2b4e32702369b3afe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|180|1|V|rust
	    // Radau options
	    pub nit: Option<usize>,   // maximum number of newton iterations
	    pub startn: Option<bool>, // switch for starting values of newton iterations
	    pub npred: Option<usize>, // step size control
	    pub pred: Option<bool>,   // step size control
	    pub fnewt: Option<f64>,   // stopping criterion for Newton's method
	    pub quot1: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub quot2: Option<f64>,   // if quot1 < hnew/hold < quot2, step size = const
	    pub thet: Option<f64>,    // decides whether the Jacobian should be recomputed
bee045223f87fa93a238c9e0d8d7d164|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|164|28|v|rust
	facr:
b42ab8672adf6161c142c6fd6406e0cd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|183|1|V|rust
	    pub fn new(
	        n: usize,
	        y: Array1<f64>,
	        x: f64,
	        xend: f64,
	        dx: f64,
	        rtoler: Vec<f64>,
	        atoler: Vec<f64>,
	        h: f64,
	        hmax: f64,
	        nmax: f64,
	        safe: f64,
	        facl: f64,
	        facr: f64,
	        nit: usize,
	        startn: bool,
	        npred: usize,
	        fnewt: f64,
	        quot1: f64,
	        quot2: f64,
	        thet: f64,
	    ) -> Self {
	        Radau5 {
	            n,
	            y,
	            x,
	            xend,
	            dx,
	            h,
	            rtoler,
	            atoler,
	            hmax,
	            nmax,
	            safe,
	            facl,
	            facr,
	            xold: x,
	            hold: h,
	            xd: x,
	            nit,
	            startn,
	            npred,
	            pred: npred <= 1,
	            fnewt,
	            quot1,
	            quot2,
	            thet,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            caljac: true,
	            first: true,
	            reject: false,
	            z1: Array1::zeros(n),
	            z2: Array1::zeros(n),
	            z3: Array1::zeros(n),
	            f1: Array1::zeros(n),
	            f2: Array1::zeros(n),
	            f3: Array1::zeros(n),
	            y0: Array1::zeros(n),
	            scal: Array1::zeros(n),
	            cont: Array1::zeros(4 * n),
	            ip1: Array1::zeros(n),
	            ip2: Array1::zeros(n),
	            e1: Array2::zeros((n, n)),
	            e2r: Array2::zeros((n, n)),
	            e2i: Array2::zeros((n, n)),
	            fjac: Array2::zeros((n, n)),
	        };
ab685b0baa0aacc8f2336e4c5cc45e52|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|208|1|V|rust
	        Radau5 {
	            n,
	            y,
	            x,
	            xend,
	            dx,
	            h,
	            rtoler,
	            atoler,
	            hmax,
	            nmax,
	            safe,
	            facl,
	            facr,
	            xold: x,
	            hold: h,
	            xd: x,
	            nit,
	            startn,
	            npred,
	            pred: npred <= 1,
	            fnewt,
	            quot1,
	            quot2,
	            thet,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            caljac: true,
	            first: true,
	            reject: false,
	            z1: Array1::zeros(n),
	            z2: Array1::zeros(n),
	            z3: Array1::zeros(n),
	            f1: Array1::zeros(n),
	            f2: Array1::zeros(n),
	            f3: Array1::zeros(n),
	            y0: Array1::zeros(n),
	            scal: Array1::zeros(n),
	            cont: Array1::zeros(4 * n),
	            ip1: Array1::zeros(n),
	            ip2: Array1::zeros(n),
	            e1: Array2::zeros((n, n)),
	            e2r: Array2::zeros((n, n)),
	            e2i: Array2::zeros((n, n)),
	            fjac: Array2::zeros((n, n)),
	        };
e706cbdf154b1d35fa36b1302f2c371b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|188|48|v|rust
	self.n;
96b3392a1391b1539918855e4c0249c9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|188|19|v|rust
	: self.rtoler.unwrap_or(vec![1e-6; self.n])
7465bc99968e26a3a055ae59f68fd7e6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|195|21|v|rust
	self.rtoler.unwrap_or(vec![1e-6; self.n]),
	
a952c3374db1bd634a85ee4f10e888b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|184|1|V|rust
	        let rtoler = self.rtoler.unwrap_or(vec![1e-6; self.n]);
4869a0dcafe361de5cfeabae135a05a0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|210|1|V|rust
	            return Err(format!("Invalid inputs: facl, facr = {}, {}", facl, facr));
0792d8cce02ae7446000b4c54eee6d43|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|216|48|v|rust
	, facr
90deff5346be6615113ea13d797ed903|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|209|1|V|rust
	        if facl < 1.0 || facr > 1.0 {
	            return Err(format!("Invalid inputs: facl, facr = {}, {}", facl, facr));
	        }
1570b66e27bf92299dee6324640484b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|228|33|v|rust
	rtoler.iter().min()
946a9fa80b06b897ec760d7536ef0d15|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|228|37|v|rust
	er.iter().min()
80b17f62cec71b5f818e4a5ad9c7d35b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|226|37|v|rust
	min().unwrap();
f3bf4b55d720a7f0198025d0ea95baa1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|216|1|V|rust
	            return Err(format!("Invalid input: nit = {}", nit));
ca7947955457d27691700b2b85d9d783|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|237|1|V|rust
	        let quot1 = self.quot1.unwrap_or(1.0);
483f741e645c8ec9008887a1211e973e|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|126|1|V|cpp
	  // thet--decides whether the Jacobian should be recomputed
bd5de2bde1cd82ce34824970ea544362|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|246|1|V|rust
	        // thet-    
d520d2d9a7963e9fceec3d68b8294789|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|276|19|v|rust
	self.thet.unwrap_or(0.0),
b9433bf54ec4a98e6f3f473c06d31926|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|276|18|v|rust
	thet
ee03622d7633096a648fa97c9e68bb09|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|275|18|v|rust
	: self.quot2.unwrap_or(0.0),
61441904a1911d47d4357329373b3283|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|274|18|v|rust
	: self.quot1.unwrap_or(0.0),
db14e4a8089bbc2e10b7eeb361dcdf76|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|273|18|v|rust
	: self.fnewt.unwrap_or(0.0),
27c2c88c4779babb8621432605187666|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|270|19|v|rust
	: self.startn.unwrap_or(false),
7d13f9830c7b3b78f05085d129c67700|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|269|16|v|rust
	: self.nit.unwrap_or(0),
86d628a9aa8522a8b8f2a29e44bc80df|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|268|15|v|rust
	: self.x,
e9d93c7290056e1679f93ec9fb7c7337|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|267|17|v|rust
	: self.h,
960a63dd91711872e527087e1f48f6b3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|265|17|v|rust
	: self.facr.unwrap_or(0.0),
b396903635349ffe54130390b4a16bb3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|264|17|v|rust
	: self.facl.unwrap_or(0.0),
128e263bec478116214cc050f4369049|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|263|17|v|rust
	: self.safe.unwrap_or(0.0),
5948ee1c723432bba96f3175ec066f9a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|262|17|v|rust
	: self.nmax.unwrap_or(0),
30179ac3ec6c3afb6f79a141eb4be645|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|261|17|v|rust
	: self.hmax.unwrap_or(0.0),
6eb0da9d700a19bc13e8edc72a5e0eef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|188|9|V|rust
	        if nmax 
475cd7b0376ff01847bfcd1f0d5d2a87|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|189|1|V|rust
	            return Err(format!("Invalid input: nmax = {}", nmax));
620f5f751aed065fd6a6d00cbd80a2df|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|273|16|v|rust
	self.h.unwrap_or(0.0),
84f3c365c331e7adc4302c8287339fc8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|274|19|v|rust
	: self.rtoler.unwrap_or(vec![1e-6; self.n]),
7fcf988cf4f41b1ff2a63a2d85eb98b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|24|1|V|rust
	    pub(crate) npred: usize, // step size control
6a830874644ed708eed9c1a43a340a19|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|75|5|V|rust
	            npred: None,
099c63eb40934eea0c10fd3fe3594387|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|105|5|V|rust
	    pub npred: Option<usize>, // step size control
dcac6cf39dbd9ebe907a8c6baeadebde|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|283|13|V|rust
	            npred: self.npred.unwrap_or(0),
e73ab16f86725b9ff5c866eb46058c0b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|283|19|v|rust
	npred <= 1,
243d46872cafd49b67cd6a3d2d2cb2d1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|314|1|V|rust
	impl Radau5 {
	    pub fn new(
	        n: usize,
	        y: Array1<f64>,
	        x: f64,
	        xend: f64,
	        dx: f64,
	        rtoler: Vec<f64>,
	        atoler: Vec<f64>,
	        h: f64,
	        hmax: f64,
	        nmax: f64,
	        safe: f64,
	        facl: f64,
	        facr: f64,
	        nit: usize,
	        startn: bool,
	        npred: usize,
	        fnewt: f64,
	        quot1: f64,
	        quot2: f64,
	        thet: f64,
	    ) -> Self {
	        Radau5 {
	            n,
	            y,
	            x,
	            xend,
	            dx,
	            h,
	            rtoler,
	            atoler,
	            hmax,
	            nmax,
	            safe,
	            facl,
	            facr,
	            xold: x,
	            hold: h,
	            xd: x,
	            nit,
	            startn,
	            npred,
	            pred: npred <= 1,
	            fnewt,
	            quot1,
	            quot2,
	            thet,
	            fac1: 0.0,
	            alphn: 0.0,
	            betan: 0.0,
	            err: 0.0,
	            caljac: true,
	            first: true,
	            reject: false,
	            z1: Array1::zeros(n),
	            z2: Array1::zeros(n),
	            z3: Array1::zeros(n),
	            f1: Array1::zeros(n),
	            f2: Array1::zeros(n),
	            f3: Array1::zeros(n),
	            y0: Array1::zeros(n),
	            scal: Array1::zeros(n),
	            cont: Array1::zeros(4 * n),
	            ip1: Array1::zeros(n),
	            ip2: Array1::zeros(n),
	            e1: Array2::zeros((n, n)),
	            e2r: Array2::zeros((n, n)),
	            e2i: Array2::zeros((n, n)),
	            fjac: Array2::zeros((n, n)),
	        };
	    }
	}
e9af334d1e91270f2485bdd54512bb1e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|1|1|V|rust
	use crate::DarkSun
60e558b03ed57ade2770ebbd0afb8243|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|343|46|v|rust
	model: &mut DarkSun
cf6592269f57daf06a7dec483dd2a752|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|34|15|v|rust
	&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)
d529a599c4c3e8239605249396aa7706|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|344|1|V|rust
	        model: &mut DarkSun
3475efe4daee6924d4f1860550677d96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|1|14|v|rust
	{Array1, Array2};
e5072c89ce736e47eaffd152d84d4657|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|344|58|v|rust
	, &Params
b297f0319d0a5cc2814abd8043b625cb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|345|1|V|rust
	        dydx: dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
2142b57135311915d73cd9ab83da4038|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|345|1|V|rust
	        dydx: &'_ dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
90bd87a247c74f15c3468c306447579d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|346|9|v|rust
	dydx
9158e47bde15c06a4baa9831052aed6c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|350|33|v|rust
	1.0 + (2 
941c871ecb876e8ca47d4f5d465861b0|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|576|1|V|cpp
	  if ((x + h * 1.0001 - xend) * posneg >= 0.0) {
	    h = xend - x;
	    last = true;
	  }
	
	  double hopt = h;
	  double faccon = 1.0;
	
	  if (iout != 0) {
	    int irtrn = 1;
	    for (int i = 0; i < n; i++)
	      cont[i] = y[i];
	    irtrn = SolutionOutput();
	    if (irtrn < 0) {
	      std::cout << " exit of RADAU5 at x = " << x << std::endl;
	      return 2;
	    }
	  }
	
	  if (itoler == 0) {
	    for (int i = 0; i < n; i++)
	      scal[i] = atoler[0] + rtoler[0] * fabs(y[i]);
	  } else {
	    for (int i = 0; i < n; i++)
	      scal[i] = atoler[i] + rtoler[i] * fabs(y[i]);
	  }
	
	  Function(x, y, y0);
	  nfcn++;
	
	  double hhfac = h;
	  double hacc, erracc, thqold;
	  int nsing = 0, ier = 0;
	
	  // basic integration step
	  ComputeJacobian();
	  bool loop = true;
	  while (loop) {
	    loop = false;
	    // compute the matrices e1 and e2 and their decompositions
	    fac1 = u1 / h;
	    alphn = alph / h;
	    betan = beta / h;
	
	    ier = DecompReal();
	
	    if (ier != 0) {
	      if (ier == -1)
	        return -1;
	      nsing++;
	      if (nsing >= 5) {
	        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	        std::cout << " matrix is repeatedly singular, ier= " << ier
	                  << std::endl;
	        return -4;
	      }
	      h *= 0.5;
	      hhfac = 0.5;
	      reject = true;
	      last = false;
	      if (!caljac)
	        ComputeJacobian();
	      loop = true;
	      continue;
	    }
	
	    ier = DecompComplex();
	
	    if (ier != 0) {
	      if (ier == -1)
	        return (-1);
	      nsing++;
	      if (nsing >= 5) {
	        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	        std::cout << " matrix is repeatedly singular, ier= " << ier
	                  << std::endl;
	        return -4;
	      }
	      h *= 0.5;
	      hhfac = 0.5;
	      reject = true;
	      last = false;
	      if (!caljac)
	        ComputeJacobian();
	      loop = true;
	      continue;
	    }
	    ndec++;
	
	    while (true) {
	      nstep++;
	      if (nstep >= nmax) {
	        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	        std::cout << " more than nmax = " << nmax << " steps are needed"
	                  << std::endl;
	        return -2;
	      }
	
	      if (0.1 * fabs(h) <= fabs(x) * uround) {
	        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	        std::cout << " step size too small, h = " << h << std::endl;
	        return -3;
	      }
	
	      // check the index of the problem
	      if (nind2 != 0) { // is index 2
	        for (int i = nind1; i < nind1 + nind2; i++)
	          scal[i] = scal[i] / hhfac;
	      }
	
	      if (nind3 != 0) { // is index 3
	        for (int i = nind1 + nind2; i < nind1 + nind2 + nind3; i++)
	          scal[i] = scal[i] / (hhfac * hhfac);
	      }
	
	      double xph = x + h;
	      //  starting values for Newton iteration
	      if (first || startn) {
	        for (int i = 0; i < n; i++)
	          z1[i] = z2[i] = z3[i] = f1[i] = f2[i] = f3[i] = 0.0;
	      } else {
	        double c3q = h / hold;
	        double c1q = c1 * c3q;
	        double c2q = c2 * c3q;
	        double ak1, ak2, ak3;
	        for (int i = 0; i < n; i++) {
	          ak1 = cont[i + n];
	          ak2 = cont[i + 2 * n];
	          ak3 = cont[i + 3 * n];
	          z1[i] = c1q * (ak1 + (c1q - c2m1) * (ak2 + (c1q - c1m1) * ak3));
	          z2[i] = c2q * (ak1 + (c2q - c2m1) * (ak2 + (c2q - c1m1) * ak3));
	          z3[i] = c3q * (ak1 + (c3q - c2m1) * (ak2 + (c3q - c1m1) * ak3));
	          f1[i] = ti11 * z1[i] + ti12 * z2[i] + ti13 * z3[i];
	          f2[i] = ti21 * z1[i] + ti22 * z2[i] + ti23 * z3[i];
	          f3[i] = ti31 * z1[i] + ti32 * z2[i] + ti33 * z3[i];
	        }
	      }
	
	      //  loop for the simplified Newton iteration
	      int newt = 0;
	      faccon = pow(max(faccon, uround), 0.8);
	      double theta = fabs(thet);
	      double dyno, dynold;
	
	      while (true) {
	        if (newt >= nit) {
	          if (ier != 0) {
	            nsing++;
	            if (nsing >= 5) {
	              std::cout << " exit of RADAU5 at x = " << x << std::endl;
	              std::cout << " matrix is repeatedly singular, ier= " << ier
	                        << std::endl;
	              return -4;
	            }
	          }
	          h *= 0.5;
	          hhfac = 0.5;
	          reject = true;
	          last = false;
	          if (!caljac)
	            ComputeJacobian();
	          loop = true;
	          break;
	        }
	        // compute the right-hand side
	        for (int i = 0; i < n; i++)
	          cont[i] = y[i] + z1[i];
	        Function(x + c1 * h, cont, z1);
	
	        for (int i = 0; i < n; i++)
	          cont[i] = y[i] + z2[i];
	        Function(x + c2 * h, cont, z2);
	
	        for (int i = 0; i < n; i++)
	          cont[i] = y[i] + z3[i];
	        Function(xph, cont, z3);
	
	        nfcn += 3;
	
	        // solve the linear systems
	        for (int i = 0; i < n; i++) {
	          double a1 = z1[i];
	          double a2 = z2[i];
	          double a3 = z3[i];
	          z1[i] = ti11 * a1 + ti12 * a2 + ti13 * a3;
	          z2[i] = ti21 * a1 + ti22 * a2 + ti23 * a3;
	          z3[i] = ti31 * a1 + ti32 * a2 + ti33 * a3;
	        }
	        ier = LinearSolve();
	        if (ier == -1)
	          return -1;
	        nsol++;
	        newt++;
	        dyno = 0.0;
	        double denom;
	        for (int i = 0; i < n; i++) {
	          denom = scal[i];
	          dyno = dyno + pow(z1[i] / denom, 2) + pow(z2[i] / denom, 2) +
	                 pow(z3[i] / denom, 2);
	        }
	        dyno = sqrt(dyno / (3 * n));
	        // bad convergence or number of iterations to large
	        if ((newt > 1) && (newt < nit)) {
	          double thq = dyno / dynold;
	          if (newt == 2)
	            theta = thq;
	          else
	            theta = sqrt(thq * thqold);
	          thqold = thq;
	          if (theta < 0.99) {
	            faccon = theta / (1.0 - theta);
	            double dyth = faccon * dyno * pow(theta, nit - 1 - newt) / fnewt;
	            if (dyth >= 1.0) {
	              double qnewt = max(1.0e-4, min(20.0, dyth));
	              hhfac = 0.8 * pow(qnewt, -1.0 / (4.0 + nit - 1 - newt));
	              h *= hhfac;
	              reject = true;
	              last = false;
	              if (caljac)
	                ComputeJacobian();
	              loop = true;
	              break;
	            }
	          } else {
	            if (ier != 0) {
	              nsing++;
	              if (nsing >= 5) {
	                std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                std::cout << " matrix is repeatedly singular, ier= " << ier
	                          << std::endl;
	                return -4;
	              }
	            }
	            h *= 0.5;
	            hhfac = 0.5;
	            reject = true;
	            last = false;
	            if (!caljac)
	              ComputeJacobian();
	            loop = true;
	            break;
	          }
	        }
	        dynold = max(dyno, uround);
	        for (int i = 0; i < n; i++) {
	          f1[i] = f1[i] + z1[i];
	          f2[i] = f2[i] + z2[i];
	          f3[i] = f3[i] + z3[i];
	          z1[i] = t11 * f1[i] + t12 * f2[i] + t13 * f3[i];
	          z2[i] = t21 * f1[i] + t22 * f2[i] + t23 * f3[i];
	          z3[i] = t31 * f1[i] + f2[i];
	        }
	        if (faccon * dyno <= fnewt)
	          break;
	      }
	
	      if (loop)
	        break;
	
	      // error estimation
	      err = 0.0;
	      ier = ErrorEstimate();
	      if (ier == -1)
	        return -1;
	
	      // computation of hnew -- require 0.2 <= hnew/h <= 8.
	      double fac = min(safe, cfac / (newt + 2 * nit));
	      double quot = max(facr, min(facl, pow(err, 0.25) / fac));
	      double hnew = h / quot;
	
	      //  is the error small enough ?
	      if (err < 1.0) {
	        // step is accepted
	        first = false;
	        naccpt++;
	        if (pred) {
	          // predictive controller of Gustafsson
	          if (naccpt > 1) {
	            double facgus = (hacc / (h)) * pow(err * err / erracc, 0.25) / safe;
	            facgus = max(facr, min(facl, facgus));
	            quot = max(quot, facgus);
	            hnew = h / quot;
	          }
	          hacc = h;
	          erracc = max(1.0e-2, err);
	        }
	        xold = x;
	        hold = h;
	        x = xph;
	        double ak, acont3;
	        for (int i = 0; i < n; i++) {
	          y[i] = y[i] + z3[i];
	          cont[i + n] = (z2[i] - z3[i]) / c2m1;
	          ak = (z1[i] - z2[i]) / c1mc2;
	          acont3 = z1[i] / c1;
	          acont3 = (ak - acont3) / c2;
	          cont[i + 2 * n] = (ak - cont[i + n]) / c1m1;
	          cont[i + 3 * n] = cont[i + 2 * n] - acont3;
	        }
	        if (itoler == 0) {
	          for (int i = 0; i < n; i++)
	            scal[i] = atoler[0] + rtoler[0] * fabs(y[i]);
	        } else {
	          for (int i = 0; i < n; i++)
	            scal[i] = atoler[i] + rtoler[i] * fabs(y[i]);
	        }
	        if (iout != 0) {
	          for (int i = 0; i < n; i++)
	            cont[i] = y[i];
	          int irtrn = 1;
	          irtrn = SolutionOutput();
	          if (irtrn < 0) {
	            std::cout << " exit of RADAU5 at x = " << x << std::endl;
	            return 2;
	          }
	        }
	        caljac = false;
	        if (last) {
	          h = hopt;
	          return 1;
	        }
	        Function(x, y, y0);
	        nfcn++;
	        hnew = posneg * min(fabs(hnew), hmaxn);
	        hopt = min(h, hnew);
	        if (reject)
	          hnew = posneg * min(fabs(hnew), fabs(h));
	        reject = false;
	        if ((x + hnew / quot1 - xend) * posneg >= 0.0) {
	          h = xend - x;
	          last = true;
	        } else {
	          double qt = hnew / (h);
	          hhfac = h;
	          if ((theta <= thet) && (qt >= quot1) && (qt <= quot2))
	            continue;
	          h = hnew;
	        }
	        hhfac = h;
	        if (theta > thet)
	          ComputeJacobian();
	        loop = true;
	      } else {
	        // step is rejected
	        reject = true;
	        last = false;
	        if (first) {
	          h *= 0.1;
	          hhfac = 0.1;
	        } else {
	          hhfac = hnew / (h);
	          h = hnew;
	        }
	        if (naccpt >= 1)
	          nrejct++;
	        if (!caljac)
	          ComputeJacobian();
	        loop = true;
	      }
	      break;
	    }
16046ad08ffdf0b8f936b8a6a6903ab7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|357|7|v|rust
	x + h * 1.0001 - xend
29823c096d01953a77a69c51dab1ab4a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|376|2|V|rust
	  if (itoler == 0) {
	    for (int i = 0; i < n; i++)
	      scal[i] = atoler[0] + rtoler[0] * fabs(y[i]);
	  } else {
b4ef4b9f376febe88f32a555b8402125|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|376|9|v|rust
	(int i = 0; i < n; i++)
713973bab97d1d96ecfa44aff8c90d25|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|377|56|v|rust
	fabs(y[i]);
777a79eae424b76beede23347bdba260|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|381|3|V|rust
	  Function(x, y, y0);
37dfb5a9b888bcdaae7d9252c7dac1e4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|3|V|rust
	  double hacc, erracc, thqold;
bf30706e4a92df5972a05483458a71af|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|15|v|rust
	: f64 = 0.0
ff7f9e58cb1c50a324da8a266295bc17|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|391|10|v|rust
	Jacobian();
a9fe244c95b2edd09a51fb5bd4eeae5f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|391|3|V|rust
	  Compute
b446912d7af47822df13a79656d1265f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|391|1|V|rust
	  jac(sel
e48b981fb62db33b98a27fc6cf8bf40a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|393|9|v|rust
	loop
c84a99fcc416736579a877fbfe937a40|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|397|26|v|rust
	alph / h;
eb01ef724000847d6fda720458cf53df|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|400|5|v|rust
	/// ier = DecompReal();
7e6948baf0d7c316ff22e1970741a8ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|402|8|v|rust
	ier != 0
60f91c15344de83fc0452b710d2c0f84|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|403|10|v|rust
	ier == -1
9c14fc64bf3e40469db52856ace7c2cf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|407|10|v|rust
	nsing >= 5
7505ac6d9a0697a5197b8ee03813ed7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|417|10|v|rust
	!caljac
858d3e5b5f9ba81a89e935f2bf09fdd3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|391|1|V|rust
	  jac(self.fjac.view_mut(), self.y.view(), self.x);
9a5b73eda64d984091adab78f061f36e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|418|1|V|rust
	        ComputeJacobian();
d81f0c9252475bce259b616d103f97d0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|418|1|V|rust
	        jac(self.fjac.view_mut(), self.y.view(), self.x);
5ff00210971c57b67232ff985e3a622f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|449|5|v|rust
	while true
db9b95a39fe040bf3ef7966aa3a433ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|451|10|v|rust
	nstep >= nmax
9ce8158fefbc49f055f80a9c1e31f96b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|458|10|v|rust
	0.1 * fabs(h) <= fabs(x) * uround
6e9b9d729341a17cc8a0471f9f2c758c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|458|16|v|rust
	fabs(h)
3f47d72d1e6ba0293d8173ecf26ed5af|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|458|32|v|rust
	fabs(x)
5fe3cdc4078a4d9a98cc99042c9d1512|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|458|47|v|rust
	uround
0c2f0bc930548f9ee3a63db41626e81e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|465|10|v|rust
	nind2 != 0
0e86059c3a695d9b57ea374d5683f10f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|465|10|V|rust
	      if nind2 != 0 { // is index 2
	        for (int i = nind1; i < nind1 + nind2; i++)
	          scal[i] = scal[i] / hhfac;
	      }
	
	      if (nind3 != 0) { // is index 3
	        for (int i = nind1 + nind2; i < nind1 + nind2 + nind3; i++)
	          scal[i] = scal[i] / (hhfac * hhfac);
	      }
c6ff162c917c0890d52f235792ad923b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|464|1|V|rust
	      // check the index of the problem
d4815d9ac0435ad4d153122a5a425aed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|467|10|v|rust
	first || startn
120e8e3a61ac366bf2bf0859b70c63fb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|480|13|v|rust
	(int i = 0; i < n; i++) {
efe75087be878a3a490b43e12f90982f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|480|9|V|rust
	        let ak1, ak2, ak3;
075d4ffa6936123326ca995e7fbd9d7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|495|16|v|rust
	pow(max(
31eb051ccbf29263e4b891ac8c921171|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|496|22|v|rust
	fabs
31c54a569c7bd044ddb4eca318fadd47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|500|7|v|rust
	while (true)
bdbab919b55f48e364ad657fc13281aa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|501|12|v|rust
	newt >= nit
a5ef5ddf49f9e47268b08fa70daca242|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|516|1|V|rust
	            ComputeJacobian();
24ac8355d840182a7d30889f7c372cce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|522|9|v|rust
	for i in 0..self.n{
02e5ca721df5fc12be52baed6d12ff5c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|526|9|v|rust
	for (int i = 0; i < n; i++)
a0ca08dd9ea2158344ac219f566ac9ce|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|525|1|V|rust
	        dydx(self.z1, self.cont, self.x + Radau5::C1 * self.h);
830691dc067192f5100ea3018f35e566|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|526|9|V|rust
	        Function(x + c1 * h, cont, z1);
d91b28367e5f06f9088970f84f3a6076|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|525|1|V|rust
	        dydx(self.z1.view_mut(), self.cont.view(), self.x + Radau5::C1 * self.h);
9dd84476930d88c947490ca8d23be010|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|530|1|V|rust
	        Function(x + c2 * h, cont, z2);
add6ab09f935cb401f291460c9837dbc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|530|1|V|rust
	        dydx(self.z2.view_mut(), self.cont.view(), self.x + Radau5::C2 * self.h);
1d6a8348417ccede641821c612ec2e78|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|535|1|V|rust
	        Function(xph, cont, z3);
3b9fc7d9c4398dff104427b711e49468|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|535|1|V|rust
	        dydx(self.z3.view_mut(), self.cont.view(), self.x + Radau5::C2 * self.h);
09da3014d67d47ded33920273981b01f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|536|52|v|rust
	self.x + Radau5::C2 * self.h);
db33d79217adc1c18d895d3d894a133e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|563|12|v|rust
	(newt > 1) && (newt < nit)
e9788fa767c015df86ab2cc646758f4d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|563|12|v|rust
	newt > 1
df52a243f02d96c4b8deb69a79f03b69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|563|24|v|rust
	newt < nit
95199dd96bdc8293bec9689be81c5609|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|565|14|v|rust
	newt == 2
fb11a363b270c88f91c7bccf93335e9d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|571|14|v|rust
	theta < 0.99
66609eb7b815428ec801c310bdcfc80c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|575|41|v|rust
	min(
c6375d2581625104b24a909eeaefabeb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|580|18|v|rust
	caljac
75ee44593e0eec500b4504328fb8f013|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|516|1|V|rust
	            jac(self.fjac.view_mut(), self.y.view(), self.x);
a3d281f897704083f53e06cdaf892207|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|581|1|V|rust
	                ComputeJacobian();
195630abfae9fe23078e3dd72841bd1a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|574|16|v|rust
	dyth >= 1.0
8c9bd45eae7ca74a95a83cdd357d5820|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|581|1|V|rust
	                jac(self.fjac.view_mut(), self.y.view(), self.x);
2fae5978b7743cd8c84938f057219866|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|601|1|V|rust
	              ComputeJacobian();
db54ad8e93165f773d0a5d69397b20b1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|600|16|v|rust
	!self.caljac
bf218dc6688900ad3fb8a0a37315cab0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|606|18|v|rust
	max(
2b0c3afb0c1beb4e003b7114454233a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|615|12|v|rust
	faccon * dyno <= fnewt
39c287100edc50d336beb760ba0a9797|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|620|10|v|rust
	loopp
775e2d4f4aca55fe6fda57786ba6c4dc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|637|10|v|rust
	err < 1.0
d6b2631ea25603475f59a46e1b0c392b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|643|14|v|rust
	naccpt > 1
4be89570bfcdc92b153a9fbc6406866b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|655|9|V|rust
	        double ak, acont3;
d9eee713e8f33cf3c3714704ec9607f9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|656|24|v|rust
	y[i] + 
2de06c94dfd7c4cde6c8b8acbde0a845|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|664|12|v|rust
	itoler == 0
0c06cad890d7b5c12370185c1a54b240|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|664|12|V|rust
	        if itoler == 0 {
	          for (int i = 0; i < n; i++)
	            scal[i] = atoler[0] + rtoler[0] * fabs(y[i]);
	        } else {
98bd1c45684cf587ac2347a92dd7bb51|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|678|12|v|rust
	last
bf728d74d4b1f39b7caa4c2a234764a5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|682|9|V|rust
	        dydx(
5ceff2e0ce197422085d040a164724e9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|682|9|V|rust
	        Function(x, y, y0);
70a1a28850851dd4ccca33d8d7c9a495|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|684|29|v|rust
	hnew
b5ed17297009c763799b786ea1a02e34|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|685|15|v|rust
	 min(
18780f62464040329b0fcb13356eb330|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|686|12|v|rust
	self.reject
31db8bd233e13923e6db4e6268ba887b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|690|13|v|rust
	x + hnew / quot1 - xend
87662fa920f6682ad1375513982f1f7e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|690|12|v|rust
	(x + hnew / quot1 - xend) * posneg >= 0.0
d58dd120aee1945153d5260e4f299468|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|696|14|v|rust
	(theta <= thet) && (qt >= quot1) && (qt <= quot2)
d7fd60f3b2dfbcc24f26d162d9ee394f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|702|12|v|rust
	theta > thet
d3f273f6d62a69d43620b176537de163|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|704|1|V|rust
	          ComputeJacobian();
9629235f0bad9440da757956282fb300|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|718|12|v|rust
	naccpt >= 1
98dadea1a7fc9e81d8cf8891a24f4214|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|729|9|V|rust
	        if ((x
60382b125f29ca8119e8aab02e31a3f4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|383|23|v|rust
	= self.h;
27a6f0fda4ec87886d3ce70b2762816e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|752|1|V|rust
	                        self.caljac=true;
0aec3e0bfa4afdfa41082b2a3717c6be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|396|1|V|rust
	        self.caljac=true;
cf3a7a79b72d0caba79fc2cc6cdd0611|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|424|1|V|rust
	                    self.caljac=true;
8295418ef64a51d1bc1437974e8c47b8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|532|1|V|rust
	                            self.caljac=true;
ac1e08baee8702da84aeb9737a09db34|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1035|1|V|cpp
	    // mass = identity, Jacobian a full matrix
	    for (int j = 0; j < n; j++) {
	      for (int i = 0; i < n; i++) {
	        e1[i][j] = -fjac[i][j];
	      }
	      e1[j][j] += fac1;
	    }
	    ier = dec(n, e1, ip1);
028e86763dcdde7135cd97f1cf36998f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|769|9|v|rust
	(int j = 0; j < n; j++) {
24d107aaf6684ae0da0f5347032c6861|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1214|1|V|cpp
	    for (int j = 0; j < n; j++) {
	      for (int i = 0; i < n; i++) {
	        e2r[i][j] = -fjac[i][j];
	        e2i[i][j] = 0.0;
	      }
	      e2r[j][j] += alphn;
	      e2i[j][j] = betan;
	    }
	    ier = decc(n, e2r, e2i, ip2);
2e6e0dc759b2c1490944ecb18baf4d96|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|794|32|v|rust
	-> usize{
2f2afa3a22dfdce224aae25d655137cc|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1447|1|V|cpp
	    for (int i = 0; i < n; i++) {
	      s2 = -f2[i];
	      s3 = -f3[i];
	      z1[i] -= f1[i] * fac1;
	      z2[i] = z2[i] + s2 * alphn - s3 * betan;
	      z3[i] = z3[i] + s3 * alphn + s2 * betan;
	    }
	    sol(n, e1, z1, ip1);
	    solc(n, e2r, e2i, z2, z3, ip2);
507f94f1bcbadc5caf6b5fae09b61040|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1757|1|V|cpp
	  double hee1 = -(13.0 + 7.0 * sqrt(6.0)) / (3.0 * h);
	  double hee2 = (-13.0 + 7.0 * sqrt(6.0)) / (3.0 * h);
	  double hee3 = -1.0 / (3.0 * h);
5542e54ebbf4527f057297e118e1fd54|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1764|1|V|cpp
	    for (int i = 0; i < n; i++) {
	      f2[i] = hee1 * z1[i] + hee2 * z2[i] + hee3 * z3[i];
	      cont[i] = f2[i] + y0[i];
	    }
	    sol(n, e1, cont, ip1);
40e43b865ac3bf3d2e30bf8dfb140804|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1979|1|V|cpp
	  err = 0.0;
	  for (int i = 0; i < n; i++)
	    err += pow(cont[i] / scal[i], 2);
	  err = max(sqrt(err / n), 1.0e-10);
	
	  if (err < 1.0)
	    return (ier);
1d104c8008ed3de00baae097168b900b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|836|12|v|rust
	ier;
db9b326b863aff26c0f72c9426bea514|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|834|12|v|rust
	self.err < 1.0
c5a1ae31a83a487283631200e0515ef7|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1987|1|V|cpp
	  if (first || reject) {
	    for (int i = 0; i < n; i++)
	      cont[i] = y[i] + cont[i];
	    Function(x, cont, f1);
	    nfcn++;
	    for (int i = 0; i < n; i++)
	      cont[i] = f1[i] + f2[i];
	
	    switch (ijob) {
	    case (1):
	    case (3):
	    case (5):
	      // full matrix option
	      sol(n, e1, cont, ip1);
21128bb841ff345984c8a24d9da6cf5a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|839|6|v|rust
	first || reject
12b441cce2d85c392a524edf98caf73d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|841|32|v|rust
	 + cont[i];
1a415f577ac895a52a748532798dc68a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|849|1|V|rust
	    switch (ijob) {
	    case (1):
	    case (3):
	    case (5):
	      // full matrix option
148faa3bba4bdba1fd923372d544c715|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|2075|1|V|cpp
	    err = 0.0;
	    for (int i = 0; i < n; i++)
	      err += pow(cont[i] / scal[i], 2);
	    err = max(sqrt(err / n), 1.0e-10);
25912a228d386e823d08a40d66bda825|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|661|1|V|rust
	                ier = ErrorEstimate();
46d13e8602080baebc1d76a705d4857b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|842|13|V|rust
	            //Function(x, cont, f1);
3cd3957884d8e2c92a5ab05bc9cc3692|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|843|13|V|rust
	            //nfcn++;
b948d01799154d4d8821b14d17d0b7bd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|573|20|v|rust
	//ier = LinearSolve();
fe68cac10dec459c5f69fdfb64c8b0a4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|431|19|v|rust
	 = DecompComplex();
f36b158b3dbd42318f0e909016ffce0c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|406|13|V|rust
	            // ier = DecompReal()
f3b148642642311504afd08b68053d13|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|409|1|V|rust
	                if ier == -1 {
	                    // return -1;
	                }
45f5e96b1052f91ad77abd242ef80753|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|431|1|V|rust
	                if ier == -1 {
	                    // return (-1);
	                }
ef422c7eba69097364017c23d25e9db6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|571|1|V|rust
	                    if ier == -1 {
	                        //return -1;
	                    }
f0e2458f7726cd8d16c46042591075a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|391|1|V|rust
	        let mut naccpt = 0;
	        let mut nrejct = 0;
	        let mut nstep = 0;
	        let mut ndec = 0;
	        let mut nfcn = 0;
	        let mut nsol = 0;
533d743c9c56fce6faa46f1075804d29|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|355|1|V|rust
	        let mut xs: Vec<f64> = vec![];
dbf7a08eb76d4164423772d2215944a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|9|v|rust
	//  
da4e5632749fc7ecd7d5fcde67a579b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|9|v|rust
	//      
da4e5632749fc7ecd7d5fcde67a579b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|9|v|rust
	//      
da4e5632749fc7ecd7d5fcde67a579b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|9|v|rust
	//      
dbf7a08eb76d4164423772d2215944a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|384|9|v|rust
	//  
6c793f6e9d5d8a3019b7c36dcc541bb1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|375|9|V|rust
	        if (iout != 0) {
bf702d936d786601e8307d36991a0c4c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|375|1|V|rust
	            int irtrn = 1;
251c67d899dc88412b98b47d0855ea13|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|379|1|V|rust
	            if (irtrn < 0) {
	                std::cout << " exit of RADAU5 at x = " << x << std::endl;
	            return 2;
	            }
dc854c9d9c4aeb37022b2bcb3a8aaf89|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|1016|1|V|cpp
	  sq6 = sqrt(6.0);
	  c1 = (4.0 - sq6) / 10.0;
	  c2 = (4.0 + sq6) / 10.0;
	  c1m1 = c1 - 1.0;
	  c2m1 = c2 - 1.0;
	
	  s = (xd - x) / hold;
	
	  return (cont[i] +
	          s * (cont[i + n] +
	               (s - c2m1) * (cont[i + 2 * n] + (s - c1m1) * cont[i + 3 * n])));
cbec8b7229fd0ee41aa2adb10fdd6658|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|850|13|v|rust
	sqrt(6.0);
cf8a80d264c71f98d36efb9e034af5a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|861|1|V|rust
	  (cont[i] +
	          s * (cont[i + n] +
	               (s - c2m1) * (cont[i + 2 * n] + (s - c1m1) * cont[i + 3 * n])))
52b83cccef60d6d2de768be7029f79ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|863|1|V|rust
	        (cont[i]
	            + s * (cont[i + n] + (s - c2m1) * (cont[i + 2 * n] + (s - c1m1) * cont[i + 3 * n])))
fc4392ca414d0d846a3873a004c708b5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|858|13|v|rust
	self.cont[i]
	                + s * (self.cont[i + self.n]
	                    + (s - c2m1)
	                        * (self.cont[i + 2 * self.n] + (s - c1m1) * self.cont[i + 3 * self.n]))
b412fdfbd5e83ad3d9895484f0f36124|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|31|1|V|rust
	    pub(crate)
758ac3ac91386b622b47b5deb275858e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|31|22|v|rust
	:usize
839040aa562076c77d19ec33ef11ad2b|file:///Users/loganmorrison/Downloads/IntegratorT/IntegratorT.cpp|85|1|V|cpp
		if (naccpt == 0) xd = xold;
	
		while (xd < x) {
			if ((xold <= xd) && (x >= xd)) {
				cout << "Step " << naccpt << ": t = " << setw(5) <<
					setprecision(2) << xd << "  y = ";
				for (unsigned i = 0; i < n; i++)
					cout << setw(10) << setprecision(8) <<
						ContinuousOutput(i) << "  ";
				cout << endl;
				xd += dx;
			}
		}
861d42f07337f5bf13c66eb0c001a797|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|867|5|v|rust
	self.naccpt == 0
bfbcb16cd6f8863ae689cd06557ac588|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|871|8|v|rust
	xd < x
318f44aaa3839a62e11118b385cf4fef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|872|7|v|rust
	xold <= xd
764548a7dc5e0fb64cef7f940a4a036d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|872|6|v|rust
	xold <= xd && (x >= xd)
4c066922da1062092715d370e3fd1c0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|872|20|v|rust
	x >= xd
02579d02c889fccc3ca9a6b8874d8fcb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|873|1|V|rust
				cout << "Step " << naccpt << ": t = " << setw(5) <<
					setprecision(2) << xd << "  y = ";
c6da564b6b920330781c4e56793c1b2a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|873|1|V|rust
				for (unsigned i = 0; i < n; i++)
					cout << setw(10) << setprecision(8) <<
						ContinuousOutput(i) << "  ";
				cout << endl;
9245c72103037fe0dda91ee80eeb98ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|848|8|v|rust
	dense_output(&self) -> Array1<f64> {
c94919ae1e5c8a99d0e474586fc953eb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|848|8|v|rust
	dense_output
c09f71f3d87b42e4e2e1655dbce9595d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|378|17|v|rust
	SolutionOutput
3509b11ddb9a43af75ebc7c548af3410|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|378|9|v|rust
	irtrn = 
66cad0d5e1636533cf2702738993842a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|378|1|V|rust
	        self.solution_output(&mut xs, &mut ys);
30d815686aab83fe3bb6b2821d72723f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|691|1|V|rust
	                    //        if (iout != 0) {
	                    //          for (int i = 0; i < n; i++)
	                    //            cont[i] = y[i];
	                    //          int irtrn = 1;
	                    //          irtrn = SolutionOutput();
	                    //          if (irtrn < 0) {
	                    //            std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                    //            return 2;
	                    //          }
	                    //        }
e5da8b282938176ab74a62ff42ba9e22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|691|1|V|rust
	                    self.solution_output(&mut xs, &mut ys);
ae5a641e922b49166f15fa44671cb147|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|410|59|V|rust
	                    //        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                    //        std::cout << " matrix is repeatedly singular, ier= " << ier
	                    //                  << std::endl;
	                    //        return -4;
c4e05a393b43c9e9c8ae68a0608507f1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|410|1|V|rust
	                    println!("Matrix is repeatedly singular");
	                    return (xs, ys);
	                }
f62ffb3dda1476a3599b0ee5d248af69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|410|1|V|rust
	                    println!("Matrix is repeatedly singular");
	                    return (xs, ys);
5fc7d97332a0cb6d2790f0cb1d99c5fb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|449|1|V|rust
	                    //        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                    //        std::cout << " more than nmax = " << nmax << " steps are needed"
	                    //                  << std::endl;
	                    //        return -2;
fbc66821174f7c78adb5050de17afd63|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|454|1|V|rust
	                    //        std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                    //        std::cout << " step size too small, h = " << h << std::endl;
	                    //        return -3;
f975a2bdb4966fa1bafeda75975bcbfb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|449|31|v|rust
	Matrix is repeatedly singular
c03e1f0e6bc04a423c35bb87b383456a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|454|1|V|rust
	                    println!("dx = {} less than dtmin.", self.h.abs());
	                    return (xs, ys);
4dee70b69a04753a20bfae29d0d76b2f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|507|1|V|rust
	                                //              std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                                //              std::cout << " matrix is repeatedly singular, ier= " << ier
	                                //                        << std::endl;
	                                //              return -4;
da835c984a0cc8d858b82f8d010f4613|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|600|1|V|rust
	                                    //                std::cout << " exit of RADAU5 at x = " << x << std::endl;
	                                    //                std::cout << " matrix is repeatedly singular, ier= " << ier
	                                    //                          << std::endl;
	                                    //                return -4;
a30c37206ff06a801ef81c2cac75ffd5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|684|1|V|rust
	                        // return 1;
2c99b7f0f71e0a16b5fb76157d2138e7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|352|1|V|rust
	        &mut self,
	        dydx: &'_ dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        jac: &'_ dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
6ec8b25fb557c8385f3d3ae99422c656|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|359|1|V|rust
	    ) -> (Vec<f64>, Vec<Array1<f64>>) {
5a1254fd138457edab0066f5c33a0a0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|354|1|V|rust
	        ) -> 
b3fef0ebb5ad39d201477ed5b2909eb8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|350|22|V|rust
	    pub fn integrate(
	        &mut self,
	        dydx: &'_ dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        jac: &'_ dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
	    ) -> (Vec<f64>, Vec<Array1<f64>>) {
	    }
216c930b5bbfea590b81f10c88ca18d5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|350|12|v|rust
	core_integrator
ce70c0e5a6c817c1fac421fcbfe436bd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|31|1|V|rust
	    pub(crate) naccpt: usize,
	    pub(crate) nrejct: usize,
	    pub(crate) nstep: usize,
	    pub(crate) ndec: usize,
	    pub(crate) nfcn: usize,
	    pub(crate) nsol: usize,
b906e720d11c8205b6ec1df7853fa156|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|279|12|v|rust
	 usize,
9bd40df5f90eb2413536f9507a8f5617|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|874|21|v|rust
	-(1.0 - x * x) * y[1] + x;
36696eba1f15ab26dc60cc9df3813792|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|873|1|V|rust
	        let dydx = |mut dy:ArrayViewMut1<f64>, y:ArrayView1<f64>, x:f64|{
	            dy[0] = y[1];
	            dy[1] = -(1.0 - x * x) * y[1] + y[0];
	        };
73b99108a238f0e873ebf89cba64fd0a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|878|1|V|rust
	            dy[0] = y[1];
	            dy[1] = -(1.0 - x * x) * y[1] + y[0];
b806244c6a9d800301a1b7210439e0fb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|878|1|V|rust
	            dy[0] = y[1];
577eacdf9849634f3daa496c3f88c81e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|880|1|V|rust
	            dy[1] = -(1.0 - x * x) * y[1] + y[0];
e892bc3db80c30e54cc36b993c19b4db|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|878|24|v|rust
	y[1];
f1f548e5e6ea9417f5d04513af474985|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|875|29|v|rust
	x * x
c795717633a427b5c4daa99e7b8e79ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|880|32|v|rust
	y[0] * y[0]
f868675896b169defb91511cfd87a543|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|881|51|v|rust
	 + y[0];
c94048b27c2e245e0aa03a461ca8bfe3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|881|44|v|rust
	 * y[1]
2d4d82b7db4235c0292c3d9e5c58dcfa|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|880|26|v|rust
	1.0 
fee9ad0b9d226ed19b45f58115a6a16f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|880|39|v|rust
	* y[0]
bd8ca0aa1fca02623013e86cf391af04|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|880|44|v|rust
	y[0];
b91f9683841c8ea2e2aeb6de8ff61266|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|885|1|V|rust
	    let y: Array1<f64> = Array::from(vec![1.0,0.0]);
	
	    let mut integrator = Radau5::builder
690a67b3df84ce99f282a6410fa0a37e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|1|1|V|rust
	pub mod boltz;
58d381321611d31702d32539e758327c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|1|1|V|rust
	pub mod cache;
8d9ae8b6f4c4bd43273c3bc389f94f41|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|1|1|V|rust
	pub mod continuous_output;
828005247a0e24f2f135726b8f6cb823|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|1|1|V|rust
	pub mod decomp;
15a8c072f441d111365d475f096bfe9b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|1|1|V|rust
	pub mod error_estimate;
	pub mod integrator;
145ef8c07253e8fafbf418596c15c661|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|2|1|V|rust
	pub mod newton;
	pub mod prepare;
571d3a7133bef35702854be9713edf84|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|3|1|V|rust
	pub mod solve;
9899bcf4e92dc3dba808eee399c31598|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|882|25|v|rust
	1.0 - y[0] * y[0]
b4e4fb582f641b340a0f6e6cc518b43d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|612|29|V|rust
	                            hhfac = 0.5;
22425d67cdbcdc871878a335b32a26b9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|519|25|V|rust
	                        hhfac = 0.5;
2860b04d57a55cb51d1d11fa3450fa55|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|441|17|V|rust
	                hhfac = 0.5;
31dd8290fefe16fbe08583eaa3e5c6b7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|394|9|V|rust
	        let mut hhfac = self.h;
f815fc5f89adc40bda68530f272a6417|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|701|25|V|rust
	                        hhfac = self.h;
4d68d5aaf4cfa2f7e141d1a461675f76|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|706|21|V|rust
	                    hhfac = self.h;
76cf584dead55b9efe6bc573223397cd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|717|25|V|rust
	                        hhfac = 0.1;
49e13456cc8ab21843613b227656cc28|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|718|25|V|rust
	                        hhfac = hnew / self.h;
08617fed8a8f7c4291464fee3d4179ea|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|655|21|V|rust
	                    dbg!
ede14195f0368cce25fa8077f15f0873|term://.//1862%3A/usr/local/bin/fish|1501|1|V|floaterm
	x, y = 0.004680999999999999, [0.9999890441393928, -0.00468098302522363], shape=[2], strides=[1], layout=CF (0x3), const ndim=1
b6cec8cd2985398a004d60061ba76455|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|345|1|V|rust
	    pub(crate) const C1: f64 = 0.1550510257216822;
	    pub(crate) const C2: f64 = 0.6449489742783178;
	    pub(crate) const C1M1: f64 = -0.8449489742783178;
	    pub(crate) const C2M1: f64 = -0.3550510257216822;
	    pub(crate) const C1MC2: f64 = -0.4898979485566356;
	    pub(crate) const ALPHA: f64 = 2.681082873627752;
	    pub(crate) const BETA: f64 = 3.050430199247411;
	    pub(crate) const U1: f64 = 3.637834252744496;
e6fbcc526621034701e227687509bae5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|353|1|V|rust
	        dbg!(&self.y);
42a66d3e65b5b374f3b2dfa04450b345|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.cpp|547|1|V|cpp
	  const double sq6 = sqrt(6.0);
	  const double c1 = (4.0 - sq6) / 10.0;
	  const double c2 = (4.0 + sq6) / 10.0;
	  const double c1m1 = c1 - 1.0;
	  const double c2m1 = c2 - 1.0;
	  const double c1mc2 = c1 - c2;
	  const double u1 =
	      1.0 / ((6.0 + pow(81.0, 1.0 / 3.0) - pow(9.0, 1.0 / 3.0)) / 30.0);
	  double alph = (12.0 - pow(81.0, 1.0 / 3.0) + pow(9.0, 1.0 / 3.0)) / 60.0;
	  double beta = (pow(81.0, 1.0 / 3.0) + pow(9.0, 1.0 / 3.0)) * sqrt(3.0) / 60.0;
	  const double cno = alph * alph + beta * beta;
	
	  alph = alph / cno;
	  beta = beta / cno;
6208e3541a6bac7e81647ae16168f8a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|360|3|V|rust
	  1f64.cb
549bf920f25d7719643bc940184a6943|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|361|26|v|rust
	.powf(1.0 / 3.0)
8f7d9b6889f6cd87bcc4c87c0b585574|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|361|41|v|rust
	powf(1.0 / 3.0)
b9406ade49bf9412981928662f466d61|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|362|52|v|rust
	, 1.0 / 3.0)
83ebf7a814ee915741a63aec24a0c816|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|363|21|v|rust
	81f64.cbrt()
1ddfdf4b34bd4fa30dd534a99210248b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|363|30|v|rust
	9f64.cbrt()
2b0eb9456f08f3d763812067d2468938|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|365|19|v|rust
	pow(81.0, 1.0 / 3.0)
14f17549e9542d8a8a5e09399d1dc1be|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|365|28|v|rust
	pow(9.0, 1.0 / 3.0)
52072cf0ced1b397db3b0309d59aa970|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|366|3|v|rust
	const double
d6e29ea87e942aa92b6864c3774350a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|415|26|v|rust
	Radau5::ALPHA
8722df3e9da31adadb012bc4306a4bbe|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|414|25|v|rust
	Radau5::U1
028effed6091bacc30d68e0bcd4cfaa5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|416|26|v|rust
	Radau5::BETA
be38d04c207cf51cb085a4109f3f7b4d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|489|49|v|rust
	Radau5::C2M
22fb2a2b76700a9343fab1cd739fd6ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|489|53|v|rust
	Radau5::C2M1
e844e33e95f351c50e0170928e7a0d3f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|489|71|v|rust
	Radau5::C1M1
866cfdf457381d7ffff27d678f0cd001|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|548|34|v|rust
	Radau5::C2 
6c78bfd5ef3058275783a83432276e0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|682|62|v|rust
	Radau5::C1MC2
f18fbd07bfecdd18da100c8798cad44d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|671|62|v|rust
	c1mc2
83b54ff804cab171a6a6203d852d601c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|671|62|v|rust
	c2m1;
3e6c137300551ce35d3a42999f8f5903|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|680|26|v|rust
	solution_output
4c504b015d728a99dbc7f4140c069906|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|667|21|V|rust
	                    self.xold = self.x;
980e649dd4865f9e02e55af153cfdd58|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|392|24|V|rust
	        for i in 0..self.n {
	            self.cont[i] = self.y[i];
	        }
8adb0af9d0aeb2e7c144bc6c01e44069|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|563|32|v|rust
	 dyno
2eea34569dd351c46c9810b1a95df38e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|619|39|v|rust
	self.f1[i] + 
02f7858866d19d76f711aa612f696bdd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|619|39|v|rust
	self.f2[i] + 
a82f6b023008b698dc3cb9840834d329|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|619|39|v|rust
	self.f3[i] + 
5f7b973f924959ce9b984d8a57df5fb5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|664|21|V|rust
	                    println!("x,  = {}, {:?}", self.x, self.y);
d107cee5df5d26d8d5aff1d8730cb3d3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|834|17|v|rust
	self.xd
cce1c3abeaaa0074b00704cf4aa26d9c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|23|1|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta/Teta,
	    pub fn rust_thermal_cross_section_2eta_4eta(&self, x: f64) -> f64 {
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pre = x / (den * den);
	
	        let f = |z: f64| {
	            let z2 = z * z;
	            let sig = self.rust_cross_section_2eta_4eta(z * self.m_eta);
	            let kernal = z2 * (z2 - 4.0) * (x * z).cyl_bessel_k1_scaled() * (-x * (z - 2.0)).exp();
	            sig * kernal
	        };
	        let int = qagi(f, 4.0, f64::INFINITY, 1e-8, 1e-8, 500, 2).val;
	        int * pre
	    }
0c2f1d9dd5c26fdb26c9fbf45ba693f8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|9|V|rust
	        let den2 = 
44b1b15064ab3ef12b175d42bc4f4148|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|41|19|v|rust
	2.0 * 
3be01bb6648cf9b9e34ff98ba2141274|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|41|v|rust
	 * den
4a7d113f5eb24879f7cf90d9473b878a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|32|v|rust
	4.0 * 
09b66c5845e6d241e70d0b0841f31661|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|42|22|v|rust
	* PI
9c7cf7413fa63e70797b85dc99d13bca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|25|16|v|rust
	_ee_eeee = self.rust_thermal_cross_section_2eta_4eta(meta / td);
d3d8715eff8fdd6cfdd485e7f138c915|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|25|16|v|rust
	_ee_eeee
7e013c533b1ad10980a2f1d6b8b26575|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|26|9|V|rust
	        let sig_eeee_ee = sig_ee_eeee / neq / neq;
07a415868d513bee255aadd3214e9a67|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|28|27|v|rust
	_eeee_ee
37c3ad7ea2796daf35e3c5fa9e4cd8b9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|25|13|V|rust
	        if w[0] - weq > 0.1 && self.xi_fo.is_none(){
	            self.xi_fo = xi;
	            self.tsm_fo = tsm;
	        }
	        if tsm < T_BBN && self.xi_bbn.is_none(){
	
	        }
308a06b0a98634bc4e0ed5553ec82d39|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|400|1|V|rust
	        dydx(self.y0.view_mut(), self.y.view(), self.x);
1c6a9d55094dd0d969e847418ee8d104|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|412|1|V|rust
	        model.dfdu(self.fjac.view_mut(), self.y.view(), self.x);
57a5a7d0f97bc9a0101e1aa56d69d750|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|529|28|V|rust
	                            //
03d4186c7065615f5dc57334f33557ac|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|527|1|V|rust
	                            model.dfdu(self.fjac.view_mut(), self.y.view(), self.x);
a7debf21b97c16ad514a1e77a546dad2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|401|1|V|rust
	        model.dudt(self.y0.view_mut(), self.y.view(), self.x);
c6d6bd28595bfaa8d586427cfa22b00f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|538|1|V|rust
	                    //dydx(self.z1.view_mut(), self.cont.view(), self.x + c1 * self.h);
8156a60a1268d721df6ab507fcf8825b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|538|23|v|rust
	dydx(self.z1.view_mut(), self.cont.view(), self.x + c1 * self.h);
2230008e16e5976041c7de316fff9cfc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|540|21|V|rust
	                    //
ba2aa199cab6b3ea1c58125ce6be657e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|539|1|V|rust
	                    model.dfdu(self.z1.view_mut(), self.cont.view(), self.x + c1 * self.h);
8a4735546f1d782e47b453e1e36a539d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|544|1|V|rust
	                    dydx(self.z2.view_mut(), self.cont.view(), self.x + c2 * self.h);
dcd51f3edb9815c1290ab7d33ed8b1b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|545|1|V|rust
	                    model.dudt(self.z2.view_mut(), self.cont.view(), self.x + c2 * self.h);
6f1976bf17a190fa10aad7d5e9a9b9a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|551|1|V|rust
	                    dydx(self.z3.view_mut(), self.cont.view(), xph);
2774544b43f6247b4e6462465160494d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|698|1|V|rust
	                    dydx(self.y0.view_mut(), self.y.view(), self.x);
8a2fa5983b17ead2702040bbb4ec0ce9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|824|1|V|rust
	            dydx(self.f1.view_mut(), self.cont.view(), self.x);
807b33f87c696a351e228290968507a2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|649|1|V|rust
	                self.error_estimate(&dydx);
6a3668ab5d5af01d291310f38b4e9ac8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|650|37|v|rust
	&dydx)
58e88f6eede7c57588e5e699ec27f560|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|7|1|V|rust
	    fn dudt(&mut self, du: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t:f64);
32e33070426bd1d82fa7efd6211a0f1e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|8|1|V|rust
	    fn dfdu(&mut self, df: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t:f64);
800b50c26a087df788d4aa6fa1150613|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|9|1|V|rust
	    fn root1(&mut self, df: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t:f64);
d6d6f7e961300c4c4ec7eef9535ff1ec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|14|12|v|rust
	dwdlogx
3aad1cb8635c9e0cd30a6b472d7e410c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|14|12|v|rust
	boltzmann
599f576ec225cae08e51abd76f061a44|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|352|1|V|rust
	        //dydx: &'_ dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64),
	        //jac: &'_ dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64),
45a17565ecb662fedbdf789f3849c64a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|17|1|V|rust
	        let meta = self.m_eta;
	        let tsm = meta / x;
	        let xi = self.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = self.neq_eta(td);
	        let weq = (neq / s).ln();
a81f5e03f79985cb9474f5d6d1758ab0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|46|1|V|rust
	    pub fn freeze_out_cond(&self, w: ArrayView1<f64>, logx: f64) -> f64 {
	        let meta = self.m_eta; let tsm = meta / x;
	        let xi = self.compute_xi(tsm).unwrap();
	        let td = xi * tsm;
	        let s = sm_entropy_density(tsm);
	        let neq = self.neq_eta(td);
	        let weq = (neq / s).ln();
	        return w[0] - weq - 0.1;
	    }
af30d37386ed92b9f4ed4d6be4c531c1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|488|1|V|cpp
	  double Td_init = m_lam / 2.0;
	  double xi_init = compute_xi_const_td(Td_init);
	  double Tsm_init = Td_init / xi_init;
	
	  double xstart = m_eta.get_mass() / Tsm_init;
	  double xfinal = m_eta.get_mass() / kT_CMB;
	  double w_eta_init = log(m_eta.neq(Td_init) / sm_entropy_density(Tsm_init));
	  double y_delta_init =
	      exp(-m_a * m_N) * m_delta.neq(Td_init) / sm_entropy_density(Tsm_init);
	
	  auto logx_span = std::make_pair(std::log(xstart), std::log(xfinal));
948dd7ad4646358d3a30dab390061cbb|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|22|3|V|rust
	  let y_delta_init =
2ea5ed3cf41f0b93ef843fbc431ec4a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|22|7|V|rust
	      exp(-m_a * m_N) * m_delta.neq(Td_init) / sm_entropy_density(Tsm_init);
428023cc378f6aac26fe8e32f3888c8f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|28|1|V|rust
	        let model = DarkSun::new(20, 1e-3);
1940458e66a3ebf14561cb4a91e3aa69|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|16|12|v|rust
	m_lam
8222a67773735e450ed6424184286f48|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|21|30|v|rust
	kT_CMB;
32cc328aab17f51cf49f342c885b9714|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|25|20|v|rust
	log(m_eta.neq(td) / sm_entropy_density(Tsm_init));
56a0d746ad0ec074bd1a929a6c5fa1b6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|27|19|v|rust
	std::make_pair(std::log(xstart), std::log(xfinal));
7302ee76273a26388cb45891fe5d7d97|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|407|1|V|rust
	        model.boltzmann_jac(self.fjac.view_mut(), self.y.view(), self.x);
1913f7e3210c3e5d4e5268465f0ba702|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|4|1|V|rust
	
	use ndarray::prelude::*;
	
	pub trait OdeFunction {
	    fn dudt(&mut self, du: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64);
	    fn dfdu(&mut self, df: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64);
	    fn root1(&mut self, df: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64);
	    fn root2(&mut self, df: &mut ArrayViewMut1<f64>, u: ArrayView1<f64>, t: f64);
	}
9e562c8cdab9282e97db301bd42850e1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|98|1|V|rust
	    pub fn compute_xi_const_td(&self, td: f64) -> Result<f64, String> {
2b74dd975911594675fd356f4b3aea40|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|6|1|V|rust
	use thermal_functions::*;
c186fde83a8e96f128e515af2933dfe5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|20|18|v|rust
	super::thermal_functions::
cfd329dc1f9be3f7ddd570bb8b605338|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|190|1|V|rust
	    /// Compute the thermally-averaged annihilation cross section for
	    /// 2eta -> 4eta as a function of x = meta/Teta,
	    pub fn thermal_cross_section_2eta_4eta(&self, x: f64) -> PyResult<f64> {
	        Ok(self.rust_thermal_cross_section_2eta_4eta(x))
	    }
42a38e55035947b897e96aa1a2ac8a47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|31|9|V|rust
	        let mut model = DarkSun::new(20, 1e-3);
4484a0e3bdc5e8fd4e4c41672a51f504|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|19|18|v|rust
	model.lamc / 2.0;
75cf3ac5e70c76583be3efb5012bd44e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|29|51|v|rust
	20.0
fe6a73f42c5d8ded0642f98adeda5618|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|36|1|V|rust
	            println!("xifo = {:?}", model.xi_fo);
9dbb868c4c56735f0fbfe8eeeb6b61b8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|37|43|v|rust
	xi_fo
8f470e31825ab3da0b47a9fca2a50235|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|36|1|V|rust
	            println!("xifo = {:?}", model.xi_fo);
	            println!("xifo = {:?}", model.xi_bbn);
be9ac48d4ce0c7c16e48522e4cdf5f7e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|33|1|V|rust
	        let sige = self.rust_thermal_cross_section_4eta_2eta(meta / td);
081dc1b752fd834107e67c2737d99956|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|282|1|V|cpp
	    double pf_d = sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) *
	                  meta / (x * x);
268ab5ec11a02b8fdabcac74023b49c2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|37|55|v|rust
	model->
39c72a36d651cbe508607f44492217fd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|37|51|v|rust
	self.sqrt_gstar(tsm, xi)
47e44b6a24c4968b9688b4dae2e82181|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|36|26|v|rust
	self.sq
	
c8ccc5e44f235d31dbe6fe5f031cf59c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|38|20|v|rust
	(PI / 45.0).sqrt() * M_PLANK
55c056c00c37c8fce623301709074926|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|37|9|V|rust
	        let sqrt_gstar = self.sqrt_gstar(tsm, xi);
c0904721d23307e769a4746e486d723b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|38|20|v|rust
	(PI / 45.0).sqrt() * M_PLANK * sqrt_gstar
29df70a54118129111116b74b6b9c5a6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|40|1|V|rust
	        dw[0] = pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
c6e680a7d55798350c13eed0f0b69a55|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|41|29|v|rust
	 w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
dce9ac2959835635edf1e99b2a9c98f7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|33|1|V|rust
	        let sige = self.rust_thermal_cross_section_4eta_2eta(meta / td);
	        let sigd = self.rust_thermal_cross_section_2eta_2del(meta / td);
	
	        let fac = (PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi);
	        let pfe = -fac * tsm * s * s;
	        let pfd = fac * meta / (x * x);
	
	        dw[0] = pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
	        dw[1] = pfd * sigd * (2.0 * w[0]).exp();
e4fe21532a6fe9cd65648c9359af70df|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|54|1|V|rust
	        let sige = self.rust_thermal_cross_section_4eta_2eta(meta / td);
	        let pfe = -(PI / 45.0).sqrt() * M_PLANK * self.sqrt_gstar(tsm, xi) * tsm * s * s;
fff8f2e1f436f48e095993f125e2294f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|54|1|V|rust
	        j[[0, 0]] = pfe * sige * w[0].exp() * (3.0 * (2.0 * w[0]).exp() - (2.0 * weq).exp());
81cc4ce7d9105d28ecf740caee5be37d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|63|17|v|rust
	pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
5ab7a0bc421f87f5f00d04a04b03cf95|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|66|21|v|rust
	pfe * sige * w[0].exp() * (3.0 * (2.0 * w[0]).exp() - (2.0 * weq).exp());
56553525d45978f13205efb416775447|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|66|1|V|rust
	        j[[0, 0]] = pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
69075a87b8487ca41bdf7b8fd44252c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|68|1|V|rust
	        j[[1, 0]] = pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
12a1b6026ad1740b526679d6f81bf753|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|64|17|v|rust
	pfd * sigd * (2.0 * w[0]).exp();
04d85e63ab77a7a9bdb5d207fb692f67|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|66|34|v|rust
	w[0].exp() * 
fe132ad4778b249c812642826bd8382d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|67|86|v|rust
	+ w[0]
61ab02c7bf3576b5a412fb097912084f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|66|85|v|rust
	 + w[0]
4782ac0e612214a5425152d8c75da58e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/boltz.rs|61|1|V|rust
	        dw[0] = pfe * sige * w[0].exp() * ((2.0 * w[0]).exp() - (2.0 * weq).exp());
	        dw[1] = pfd * sigd * (2.0 * w[0]).exp();
07f9f2784d48e1a8732b15bb6281ba79|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|26|1|V|rust
	        let w_eta_init = (model.neq_eta(td) / s).ln();
11d4f707da94a18c74fc0e021bcbdfd4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|27|44|v|rust
	.ln();
de4c65ec18fb0649938cbba01ea9269c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|36|38|v|rust
	w[0]
6631a88ccace153531a4f16895e58a0f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|18|1|V|rust
	        let mut model = DarkSun::new(6, 1e-3);
	        let td = model.m_eta;
	        let xi = model.compute_xi_const_td(td).unwrap();
	        let tsm = td / xi;
	
	        let xstart = model.m_eta / tsm;
	        let xfinal = model.m_eta / T_CMB;
	        let s = sm_entropy_density(tsm);
	        let w_eta = (model.neq_eta(td) / s).ln();
	        let y_del = (model.neq_del(td) / s) * (-model.adel * model.n as f64).exp();
	
	        let logx_span = (xstart.ln(), xfinal.ln());
	        let dlogx = (logx_span.1 - logx_span.0) / 100.0;
	
	        let w = Array::from(vec![w_eta, y_del]);
	        let mut rad = Radau5::builder(w, logx_span).dx(dlogx).build().unwrap();
	        let (logxs, ws) = rad.integrate(&mut model);
	        for (logx, w) in logxs.iter().zip(ws.iter()) {
	            println!("{}, {:e}, {:e}", logx, w[0], w[1]);
	        }
	        println!("xifo = {:?}", model.xi_fo);
	        println!("xifo = {:?}", model.xi_bbn);
8c673e34a12c2a08f54a70f577bb1ff6|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|207|5|V|rust
	        let mut model = DarkSun::new(6, 1e-3);
723b03e332179c78728499e4f8574a62|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|206|9|V|rust
	            Ok(self.solve())
8f471b0eefa8cb4394fe262696ae2a7e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|221|41|v|rust
	&mut model
d3302acd961605329d28d07b95525668|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|222|1|V|rust
	        for (logx, w) in logxs.iter().zip(ws.iter()) {
	            println!("{}, {:e}, {:e}", logx, w[0], w[1]);
	        }
	        println!("xifo = {:?}", model.xi_fo);
	        println!("xifo = {:?}", model.xi_bbn);
f391d7b9fb4696883b7e882181783936|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|221|9|v|rust
	let (logxs, ws) = 
316843ccd17f9a72cb27560c427668c7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|426|28|v|rust
	(xs, ys);
f5a37a74ecbe2a8cc2f5cacb390bb74b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|425|31|v|rust
	Matrix is repeatedly singular"
2a528b73c3ff54f31273bd373cb130e2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|425|21|V|rust
	                    println!("Matrix is repeatedly singular");
728a13f7e56476db119d3aa89faf2420|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|444|21|v|rust
	println!
bf5fc873cc3dd77d8510d45b05ee4120|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|445|21|V|rust
	                    return (xs, ys);
4773ce47427c98e7c75a65f29fd1554a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|516|33|V|rust
	                                return (xs, ys);
7bf629db58c630e3f3fe2d9829ed123a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|609|37|V|rust
	                                    return (xs, ys);
9b105db7d0d3265d9f871e021d77b496|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/radau5.rs|694|25|V|rust
	                        self.h = hopt;
4b678ad59d7d390c6c28281cc1684816|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|228|12|v|rust
	rad.integrate(self)
659867b9f938317eaed9dcd8924ffb0d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|234|9|V|rust
	        Ok(rad.integrate(self))
4beed035d04a25caf2ddd107c5c8f83a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|225|34|v|rust
	eturn 
b9afdc07ab8179914e6df3245ef67637|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|7|1|v|rust
	//use ode::boltz::*;
910fc2d08ce93e1b72df2691833449ca|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode.rs|5|1|V|rust
	use mod::*;
fc8350ce2af2da265ed58cfd777c9498|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|205|66|v|rust
	ndarray::Array1<f64>
5d2a2ad789cad04878459ec69ff02f0b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|225|33|v|rust
	Ok(sol)}
01d8cddaef051226f7b312e6d5f85661|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|227|69|v|rust
	; 0.0
4008c910827ebb25c44d0a5c3f6ebfb4|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|209|18|v|rust
	self.m_eta;
2cb80a59a651886abc82c7ae70f96316|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|15|1|V|rust
	        neq(td, self.m_eta, 1.0, 0)
9897757cdc07ac292b06bbb4d560d571|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|28|1|V|rust
	        heff(td, self.m_eta, 1.0, 0)
c2e8da83aa57e191f6d0252a09c9ba47|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|36|1|V|rust
	        heff(td, self.m_del, 1.0, 0)
fd6b250329d39ca092743696f3e58004|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|19|18|v|rust
	model.m_eta;
654cd95afffa3077d2e2b8a54b01b2a1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1580|1|V|rust
	pub static LOG_ETA_CS46: [f64; 500] = [
51b9ba43607b3d75538c0da4eca93678|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|2|12|v|rust
	LOG_ETA_CS46
c0a16e3abb845cdf3386703262d70691|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/standard_model/data.rs|7|1|V|rust
	        2.141289997868463,
	        2.141641239600222,
	        2.1421099848988665,
	        2.1423743816414347,
	        2.143130008012523,
	        2.144764339392538,
	        2.1478799359327403,
	        2.153398739889584,
	        2.160750058048653,
	        2.1689613911348715,
	        2.180160138904919,
	        2.1962117262554206,
	        2.21692958201033,
	        2.24254151586023,
	        2.273669819788228,
	        2.310986313230254,
	        2.3545702411737506,
	        2.404790106260388,
	        2.4614499278151882,
	        2.524635068320252,
	        2.59387,
	        2.669149116920886,
	        2.7491480369692916,
	        2.8337351026484665,
	        2.9193263461693046,
	        3.003047262981907,
	        3.082637683280093,
	        3.154873274020067,
	        3.2197721598249207,
	        3.277109327543051,
	        3.324389760193869,
	        3.3585530467925744,
	        3.381070287315915,
	        3.390365806392904,
	        3.392520021653115,
	        3.3935581681999984,
	        3.392070064207229,
	        3.3884837204889333,
	        3.3833098959473715,
	        3.3770724967390504,
	        3.3701600913784824,
	        3.362910614940577,
	        3.3559998830690314,
	        3.3503255321275707,
	        3.3455599716392177,
	        3.342062527991385,
	        3.338670057114478,
	        3.3339343961380514,
	        3.329069964436909,
	        3.324891206496724,
	        3.3211499642706412,
	        3.3178337184222757,
	        3.31504997924517,
	        3.3131037469563824,
	        3.3113900091178534,
	        3.309290625724426,
	        3.3071499894038823,
	        3.305118744624142,
	        3.3031600023142444,
	        3.3012462505312565,
	        3.2995,
	        3.297967508466774,
	        3.2968500204808375,
	        3.2964543951763505,
	        3.296510029620001,
	        3.297008762366399,
	        3.2974699902875244,
	        3.297281859445965,
	        3.2968299847495746,
	        3.296327494735112,
	        3.2956800041831307,
	        3.29482436777356,
	        3.293879979861495,
	        3.292894359478376,
	        3.292019993962855,
	        3.291453126194753,
	        3.2911100058200073,
	        3.290979380500434,
	        3.291040002875626,
	        3.291279997353626,
	        3.2916599943550726,
	        3.29220375108024,
	        3.292710005860072,
	        3.2929350041172745,
	        3.2930300006077853,
	        3.2930731257995096,
	        3.2930400011235297,
	        3.2929512495626585,
	        3.2927499973479586,
	        3.2923556209013425,
	        3.2918599944748372,
	        3.2912968693404805,
	        3.2907599952104065,
	        3.290322497780271,
	        3.290080000608429,
	        3.290020628746942,
	        3.290540006356789,
	        3.292180626526222,
	        3.2944899968939008,
	        3.297181878865957,
	        3.3003,
	        3.303301747380361,
	        3.3076598717440273,
	        3.314894760073705,
	        3.324320726317179,
	        3.335240719515547,
	        3.349209522168081,
	        3.3671145918686,
	        3.3902609609837366,
	        3.420821004719461,
	        3.457079776037518,
	        3.49890530832402,
	        3.54372090890585,
	        3.589140811061479,
	        3.6344603954889956,
	        3.6784570671195094,
	        3.720299001616512,
	        3.758177309040611,
	        3.7938006389548744,
	        3.8284426491916834,
	        3.861599583609212,
	        3.8931969021713444,
	        3.9232205549403876,
	        3.9515610464133837,
	        3.9784301950276855,
	        4.003959490712717,
	        4.028309621750078,
	        4.05174021925105,
	        4.074550183025175,
	        4.097100327817213,
	        4.119860231686627,
	        4.143450100893565,
	        4.168540246354692,
	        4.19654993439492,
	        4.230929793700569,
	        4.275960254339784,
	        4.33495033569635,
	        4.405270214635249,
	        4.482479901845056,
	        4.568809784880339,
	        4.67508,
	        4.796808796884228,
	        5.002653119965267,
	        5.411365122564551,
	        5.917438769299523,
	        6.478302290230584,
	        7.179788359703159,
	        7.856429144968539,
	        8.350952119320674,
	        8.564474529235284,
	        8.543100549869138,
	        8.41707118418172,
	        8.298388149814915,
	        8.232150326290455,
	        8.214369993909546,
	        8.22516910148682,
	        8.24773937226796,
	        8.273020828696117,
	        8.297960445243808,
	        8.322710382016718,
	        8.348479657286694,
	        8.376419150066134,
	        8.407119040286302,
	        8.440620649899305,
	        8.476440273693164,
	        8.513870787361697,
	        8.552009395197521,
	        8.589768983891233,
	        8.626480291301597,
	        8.661619376988595,
	        8.694900325066234,
	        8.72643012840514,
	        8.756489466476689,
	        8.785789937649934,
	        8.81486984584274,
	        8.84423014378294,
	        8.874190155626446,
	        8.904810090448695,
	        8.93592996231311,
	        8.967199354899376,
	        8.99818,
	        9.028371810288613,
	        9.057319325098895,
	        9.08465085983787,
	        9.110068455819464,
	        9.133360413774337,
	        9.154419397963792,
	        9.173229107047057,
	        9.1898505436927,
	        9.20435916392654,
	        9.216919932920398,
	        9.227689916575413,
	        9.236850169705635,
	        9.244589944047,
	        9.251090052580713,
	        9.256529771920547,
	        9.261019899345381,
	        9.26478399575956,
	        9.26791005107098,
	        9.270478773838388,
	        9.272599975171541,
	        9.274399958939908,
	        9.275909958633646,
	        9.277190608185332,
	        9.278280007572494,
	        9.27922874950549,
	        9.280059987588558,
	        9.280802495180462,
	        9.281490005351355,
	        9.282147508893267,
	        9.28283000687285,
	        9.283564993863886,
	        9.284459981876887,
	        9.28557623771749,
	        9.287079990771886,
	        9.289083716821338,
	        9.291809947238562,
	        9.295433092478296,
	        9.300209993449117,
	        9.306395870743073,
	        9.31417,
	        9.323730643874415,
	        9.335279699076857,
	        9.34891047879047,
	        9.364701260889584,
	        9.382680356045128,
	        9.402849358492148,
	        9.425148822257064,
	        9.449540889596031,
	        9.475971140037373,
	        9.504369830711155,
	        9.534709737251081,
	        9.566930667901762,
	        9.600959724507804,
	        9.636720323191923,
	        9.674061033635413,
	        9.712799028574947,
	        9.75271133464772,
	        9.793480742350749,
	        9.834748222794437,
	        9.876099469716339,
	        9.917120927003229,
	        9.957360756626844,
	        9.996390715105953,
	        10.03380027179466,
	        10.069300712701187,
	        10.102499492181899,
	        10.133300279847873,
	        10.161400217022496,
	        10.186900352022574,
	        10.209800216138225,
	        10.229998975856804,
	        10.24770015602039,
	        10.262999969576162,
	        10.276199935539697,
	        10.287400049705742,
	        10.29680004431801,
	        10.304700020958572,
	        10.311199992925626,
	        10.316499989148781,
	        10.3208,
	        10.324300186325504,
	        10.326999942569323,
	        10.329200062947745,
	        10.330900110768116,
	        10.332200021143153,
	        10.333199973327032,
	        10.333999964695455,
	        10.334600016913614,
	        10.335000014552058,
	        10.335299998559291,
	        10.335499981553205,
	        10.335700003023437,
	        10.33579999960545,
	        10.33579999885358,
	        10.335900000905022,
	        10.335900000411378,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.33590000090692,
	        10.33579999973006,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.3358,
	        10.335799999457308,
	        10.335799997889367,
	        10.33590000062198,
	        10.33590000050333,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359,
	        10.3359
2bc1f2d0aa12ae6badec21ad61e2d342|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/standard_model/data.rs|350|1|V|rust
	        3.9387999991430975,
	        3.938857495057558,
	        3.939029992374593,
	        3.9394199992353753,
	        3.9400200023255874,
	        3.9405506072828556,
	        3.941929968118308,
	        3.94494124979267,
	        3.949710043121497,
	        3.956211989444685,
	        3.965680111137088,
	        3.978887355858084,
	        3.9971896164213354,
	        4.021680276199021,
	        4.053919806380377,
	        4.0952788395341555,
	        4.147420297837358,
	        4.211901996248075,
	        4.2904098962085415,
	        4.384668913783994,
	        4.49612,
	        4.626378131871737,
	        4.776646154015349,
	        4.9488549981466,
	        5.142435352943627,
	        5.358423489711211,
	        5.593932612798939,
	        5.847619763418146,
	        6.115889630322266,
	        6.396207697398362,
	        6.6840483271625795,
	        6.976314066429208,
	        7.266185734065843,
	        7.546111244160505,
	        7.815192311303785,
	        8.069970597690702,
	        8.310574243364147,
	        8.535986941998477,
	        8.746183651945367,
	        8.940613503447796,
	        9.119837792813225,
	        9.283908135499344,
	        9.43380271729935,
	        9.569917263121496,
	        9.694050888018502,
	        9.808173156742438,
	        9.912168428652636,
	        10.006323138799969,
	        10.091400653807613,
	        10.168033928282645,
	        10.236900653727062,
	        10.298569371753427,
	        10.354000501799236,
	        10.404287602839673,
	        10.449599772715418,
	        10.490381192332134,
	        10.526900177058348,
	        10.5594688453592,
	        10.58839996718056,
	        10.613999995164312,
	        10.6366,
	        10.656493465381608,
	        10.674099602936625,
	        10.689756627239047,
	        10.704001049182839,
	        10.717581635913213,
	        10.730199633881007,
	        10.741824928694447,
	        10.752400349336721,
	        10.76183768691201,
	        10.770199954855684,
	        10.777518766096401,
	        10.783800114717605,
	        10.789000090744732,
	        10.79330003386672,
	        10.796781221388564,
	        10.799699933161406,
	        10.802331233938004,
	        10.804700040501185,
	        10.806875008653277,
	        10.808999972471936,
	        10.811275005499555,
	        10.813600045260483,
	        10.815975038588801,
	        10.818300016744887,
	        10.820481238621866,
	        10.822499969466849,
	        10.824312487950268,
	        10.825900012079304,
	        10.827256263547364,
	        10.828300008036576,
	        10.828918754232735,
	        10.829200000632296,
	        10.829137500666139,
	        10.82890000149907,
	        10.828537501297104,
	        10.828399999572207,
	        10.828649998431738,
	        10.829899997688761,
	        10.83298125926752,
	        10.8374,
	        10.84247481176551,
	        10.849599797974443,
	        10.859644362404321,
	        10.873501180444455,
	        10.891868858517212,
	        10.916199162553223,
	        10.947137901252058,
	        10.987801613397307,
	        11.040500563233637,
	        11.108299560218962,
	        11.195294620029074,
	        11.30070233651235,
	        11.425833620835107,
	        11.568501342145268,
	        11.728079155917563,
	        11.901195582676046,
	        12.084737101847567,
	        12.277303543165111,
	        12.476794260338602,
	        12.682197327310643,
	        12.89221297568728,
	        13.105604088296108,
	        13.321019271606094,
	        13.537501613529102,
	        13.753995579108716,
	        13.969596589460812,
	        14.183902028816686,
	        14.396301710943195,
	        14.60660304413771,
	        14.815202085983392,
	        15.022300865359306,
	        15.229101961195955,
	        15.43689955149194,
	        15.648798857968181,
	        15.870501111953832,
	        16.110201294121016,
	        16.376300821770897,
	        16.673599620998395,
	        17.006299196175366,
	        17.3825,
	        17.81672773105336,
	        18.33088576853192,
	        19.046628608352666,
	        20.09418970490948,
	        21.491230281088864,
	        23.36403554732082,
	        25.78376521823396,
	        28.688107928806346,
	        31.859201234384482,
	        35.017082236799915,
	        37.95437646080889,
	        40.59985045611013,
	        42.98048210407093,
	        45.1544184613274,
	        47.16911033788443,
	        49.052955010384366,
	        50.81965651115024,
	        52.47622896820607,
	        54.02872289866365,
	        55.48438187378059,
	        56.8520614050832,
	        58.14146251402683,
	        59.36252223933174,
	        60.524308447319974,
	        61.63472254490186,
	        62.70008343383558,
	        63.72517263243636,
	        64.71280785221128,
	        65.66488300213246,
	        66.58250904660159,
	        67.466303629751,
	        68.31728492887835,
	        69.13689827598066,
	        69.92729589043422,
	        70.69130364581491,
	        71.4320037480388,
	        72.1526020814846,
	        72.8561991609682,
	        73.54488590248961,
	        74.2203,
	        74.88324012052786,
	        75.53348459632291,
	        76.17032050101513,
	        76.79236111728054,
	        77.39811113614508,
	        77.98558255332685,
	        78.55307191271253,
	        79.09881869347045,
	        79.62116841256307,
	        80.11909720281376,
	        80.5914961419686,
	        81.03780872880081,
	        81.45769679012248,
	        81.85130336155706,
	        82.2188836409303,
	        82.56109186151474,
	        82.8785848751381,
	        83.1724050992544,
	        83.44352077267085,
	        83.69319692342157,
	        83.92260698691331,
	        84.13299398095259,
	        84.32556639998398,
	        84.50160125228153,
	        84.66241852240712,
	        84.80909777955165,
	        84.94282414076376,
	        85.06460094063524,
	        85.17548255405232,
	        85.27650096881764,
	        85.36869968841168,
	        85.45309854098299,
	        85.53062397909167,
	        85.60259963171038,
	        85.67009303896315,
	        85.73479893180316,
	        85.7980431308708,
	        85.8619999216585,
	        85.92846399908225,
	        85.9999,
	        86.07860508870539,
	        86.16729773859703,
	        86.26840352296135,
	        86.38450929083348,
	        86.51800266808385,
	        86.6711950564598,
	        86.84609060310302,
	        87.04440737024345,
	        87.2678098308423,
	        87.5176984811532,
	        87.79529755011251,
	        88.101506466041,
	        88.43719723218507,
	        88.80320336842719,
	        89.19981118597049,
	        89.6272890703168,
	        90.08551563972269,
	        90.5738090901216,
	        91.09117717933043,
	        91.63589283179887,
	        92.20581324930026,
	        92.79821148185921,
	        93.40961158196752,
	        94.03640471213421,
	        94.67441331594091,
	        95.31908974501125,
	        95.96600614539847,
	        96.6104051970725,
	        97.2481091983956,
	        97.8747062252834,
	        98.48636734911523,
	        99.07970553088383,
	        99.651798798897,
	        100.19999716506996,
	        100.723002467506,
	        101.21800247342479,
	        101.68600132623887,
	        102.12499948811279,
	        102.53499909813486,
	        102.918,
	        103.27202083159587,
	        103.59999246212048,
	        103.90200943679265,
	        104.18001990091277,
	        104.43500453334619,
	        104.66699331163939,
	        104.87898979530327,
	        105.07200645631241,
	        105.24800695036602,
	        105.40699912885154,
	        105.5509862321857,
	        105.68100249933426,
	        105.7989991161511,
	        105.90499310101568,
	        106.00000245218065,
	        106.08599798052656,
	        106.16400241159704,
	        106.23300119546467,
	        106.29600090418226,
	        106.35199932091506,
	        106.40199862325085,
	        106.44700082257413,
	        106.48799714828864,
	        106.52400025180003,
	        106.55599937952627,
	        106.58499849434241,
	        106.6109993243235,
	        106.63500017410645,
	        106.65500028587994,
	        106.67400018249637,
	        106.69100006278799,
	        106.70500013594169,
	        106.71899997143262,
	        106.73099994180055,
	        106.74100005011003,
	        106.7510000444878,
	        106.75899970585455,
	        106.7669997052772,
	        106.7729999863407,
	        106.78,
	        106.78500031563006,
	        106.78999988832835,
	        106.79400013564693,
	        106.79799976787382,
	        106.80100005596874,
	        106.80399990941137,
	        106.80700020795435,
	        106.81000008164065,
	        106.81199988652543,
	        106.81399998847277,
	        106.81599998600497,
	        106.8170000167957,
	        106.81799998947737,
	        106.82000001178021,
	        106.82100002714502,
	        106.82199997532162,
	        106.82300003853845,
	        106.82399992987605,
	        106.82400001269836,
	        106.82499998928847,
	        106.82499999515238,
	        106.82599997508082,
	        106.82600001557186,
	        106.82700000124032,
	        106.82699999659057,
	        106.82799998678215,
	        106.828,
	        106.82799999865053,
	        106.82800001211264,
	        106.82899995688712,
	        106.82900000902247,
	        106.829,
	        106.829,
	        106.829,
	        106.82899999919178,
	        106.82900000427776,
	        106.83000000097483,
	        106.83000000669797,
	        106.83,
	        106.83
f61868ac10b0e7e34a84ba671fdf12ba|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/standard_model/data.rs|693|1|V|rust
	        3.3839699989395835,
	        3.3840487437644517,
	        3.3842699903810276,
	        3.384735624825629,
	        3.3854900038512112,
	        3.3862912280687207,
	        3.3880999598306882,
	        3.3917099989920962,
	        3.3973800518739967,
	        3.405183885849205,
	        3.4164701323918063,
	        3.4321248326801963,
	        3.453609551704515,
	        3.482146469649636,
	        3.519339777655313,
	        3.56667197412332,
	        3.625730336042383,
	        3.6980913883908952,
	        3.7852698853256537,
	        3.8888564215194035,
	        4.0102,
	        4.150794807316553,
	        4.311795892941468,
	        4.494954121810155,
	        4.699976214930413,
	        4.927911218293275,
	        5.176482196900135,
	        5.444893579507091,
	        5.729750258626947,
	        6.029061098885618,
	        6.337818201506156,
	        6.652822969680463,
	        6.9666562245634225,
	        7.271231690587198,
	        7.565352533586669,
	        7.845235954042654,
	        8.110553641754548,
	        8.359949946825193,
	        8.59272403967336,
	        8.807570499056927,
	        9.00494757517125,
	        9.18429186814512,
	        9.347362952209552,
	        9.495029957384766,
	        9.629400961950292,
	        9.752973734862081,
	        9.865448301893807,
	        9.967108712735158,
	        10.058700701881913,
	        10.14078523513029,
	        10.21420069474718,
	        10.2795819076444,
	        10.338100529303755,
	        10.391075108886902,
	        10.438699761340171,
	        10.481537438750442,
	        10.519800185143403,
	        10.553781350015388,
	        10.583799966065143,
	        10.610118744432556,
	        10.6332,
	        10.65343721086418,
	        10.671299597352577,
	        10.687200386274478,
	        10.701701071584862,
	        10.715606640925841,
	        10.728599621802584,
	        10.740662429708268,
	        10.751700366541062,
	        10.761618946103374,
	        10.770399952742551,
	        10.777987514603408,
	        10.784400114885585,
	        10.789543840025653,
	        10.793700032836007,
	        10.797049973942578,
	        10.79979993789156,
	        10.802181234797406,
	        10.804300036285406,
	        10.806275005726231,
	        10.80829997290033,
	        10.810675008065274,
	        10.813200049389502,
	        10.815812542296054,
	        10.818400018605427,
	        10.82083123701361,
	        10.8230999655015,
	        10.825181236330375,
	        10.827000013496429,
	        10.828493764882047,
	        10.829600008371425,
	        10.83021250346392,
	        10.830399998814471,
	        10.830106250382935,
	        10.829600002909952,
	        10.829000001894816,
	        10.828699998716642,
	        10.828868747660579,
	        10.83029999725666,
	        10.834075011178859,
	        10.8395,
	        10.845681023602184,
	        10.854299756293019,
	        10.86640072989741,
	        10.883001405083759,
	        10.904843878232874,
	        10.93379900226057,
	        10.970500500305192,
	        11.019401960977774,
	        11.083906919233751,
	        11.167799453551327,
	        11.27754482503736,
	        11.408502862062473,
	        11.559602804184298,
	        11.726601524068334,
	        11.90507898935648,
	        12.094495202826907,
	        12.293349519026512,
	        12.500103797163375,
	        12.713206829095649,
	        12.93119717296118,
	        13.152519220199826,
	        13.375904265336509,
	        13.599899423093277,
	        13.823501659544904,
	        14.045595477169236,
	        14.265496532622665,
	        14.482602050526342,
	        14.696801721875234,
	        14.908003048983103,
	        15.116602085146253,
	        15.323500863266368,
	        15.529801958508713,
	        15.737699550277814,
	        15.950798846416452,
	        16.176101137251248,
	        16.423301347251392,
	        16.70280087021931,
	        17.019999592881767,
	        17.379599126059833,
	        17.7909,
	        18.270631701571034,
	        18.886282262611214,
	        19.810533868948983,
	        21.014403816051455,
	        22.6405354400298,
	        24.837624307484827,
	        27.677842245112068,
	        31.059624742778315,
	        34.68787520006785,
	        38.20338054032787,
	        41.35827519819795,
	        44.08965109338545,
	        46.459982467376946,
	        48.56451768154225,
	        50.4770155788509,
	        52.240658134062045,
	        53.87705209265294,
	        55.39742647308172,
	        56.8108207705348,
	        58.12718365397002,
	        59.35806532439285,
	        60.51556636614012,
	        61.61151997509638,
	        62.65630760906369,
	        63.65852039676292,
	        64.62468493956084,
	        65.55887499903574,
	        66.46320720601332,
	        67.33858434423519,
	        68.18490835611833,
	        69.00220335949038,
	        69.79048602738794,
	        70.5509983988954,
	        71.28569617578638,
	        71.99760340213557,
	        72.69000351079194,
	        73.3664019579262,
	        74.02969920721264,
	        74.68198661689348,
	        75.3246,
	        75.95773837641659,
	        76.5804852316591,
	        77.19151967954201,
	        77.7886626799343,
	        78.36971067439409,
	        78.93218331877144,
	        79.47377324503925,
	        79.99251772483608,
	        80.48647021574627,
	        80.95449737927565,
	        81.39559641067538,
	        81.80920805965577,
	        82.19539706002443,
	        82.55430305264244,
	        82.88668527392075,
	        83.19329274218097,
	        83.47515986863573,
	        83.73360446463396,
	        83.96989554534252,
	        84.18549735561933,
	        84.38183905931078,
	        84.5602949171765,
	        84.72228550370983,
	        84.86910104011582,
	        85.00213108401348,
	        85.12249818494024,
	        85.23144929178228,
	        85.33000075924294,
	        85.41926354891706,
	        85.50020077443466,
	        85.57379975195202,
	        85.64109883606507,
	        85.70299918661287,
	        85.76089970199104,
	        85.81587440276637,
	        85.86979909693483,
	        85.9241182235268,
	        85.98119992864254,
	        86.04299897252092,
	        86.1122,
	        86.19130520069095,
	        86.28329762412618,
	        86.39070377964339,
	        86.51631012470597,
	        86.66260293703776,
	        86.83179452602216,
	        87.02578955993744,
	        87.2464081995925,
	        87.49491093540041,
	        87.7726983130649,
	        88.08059728588013,
	        88.41940714660666,
	        88.78989694991898,
	        89.19250369915848,
	        89.62731224417233,
	        90.09438807988965,
	        90.59311699253986,
	        91.12260983686882,
	        91.68127541057189,
	        92.26689231034163,
	        92.87691414475941,
	        93.50771219649683,
	        94.15541223413081,
	        94.81550494706401,
	        95.4832138931542,
	        96.15358937333521,
	        96.82140632176937,
	        97.48180530423376,
	        98.13000931202002,
	        98.76170624872508,
	        99.37296751786185,
	        99.9605054543766,
	        100.52199882732157,
	        101.05399726242167,
	        101.55700236082052,
	        102.02800233824621,
	        102.46800124142977,
	        102.87699952549443,
	        103.2549991740175,
	        103.603,
	        103.92201865274248,
	        104.21399332758733,
	        104.48000823751889,
	        104.72101716282664,
	        104.94000388661394,
	        105.13799432822954,
	        105.31599147646948,
	        105.4770053190239,
	        105.62100569611079,
	        105.75099929117114,
	        105.8669889656256,
	        105.97100198200053,
	        106.06399930686312,
	        106.14699461375038,
	        106.22100189569144,
	        106.28699846174712,
	        106.34600184999128,
	        106.39900090036218,
	        106.44600067813667,
	        106.48799949229294,
	        106.52499898682889,
	        106.55800060343306,
	        106.5879979226772,
	        106.61400018729906,
	        106.63799953634835,
	        106.65899893235168,
	        106.67699953292117,
	        106.69400012956741,
	        106.70900020108502,
	        106.72200012724518,
	        106.73400004534686,
	        106.74400008852021,
	        106.75299998107411,
	        106.76199995590956,
	        106.76900003556192,
	        106.77600002823267,
	        106.78099980816616,
	        106.78699977895873,
	        106.79099999165261,
	        106.795,
	        106.79900026472362,
	        106.80299992023633,
	        106.80500009223833,
	        106.80799982062926,
	        106.81000005596869,
	        106.81299992451235,
	        106.81400010944914,
	        106.81600007581007,
	        106.8179998968443,
	        106.81899999519676,
	        106.81999999160291,
	        106.82100002015498,
	        106.82199999210815,
	        106.8230000088352,
	        106.82400003166985,
	        106.82499998354879,
	        106.82500002752529,
	        106.82599991234072,
	        106.82600001269836,
	        106.82699998928847,
	        106.82700000484743,
	        106.82699999003177,
	        106.8280000062294,
	        106.828,
	        106.828,
	        106.82799999471271,
	        106.82900000316936,
	        106.829,
	        106.829,
	        106.829,
	        106.829,
	        106.829,
	        106.82899998195742,
	        106.82999999559071,
	        106.83,
	        106.83,
	        106.83,
	        106.83,
	        106.83,
	        106.83
abe6ca801505e862d74b85579f94b133|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|1|1|V|rust
	fn bsearch(xarr: &[f64], x: f64, idx_low: usize, idx_high: usize) -> usize {
	    let mut ilow = idx_low;
	    let mut ihigh = idx_high;
	
	    while ihigh > ilow + 1 {
	        let i = (ihigh + ilow) / 2;
	        if xarr[i] > x {
	            ihigh = i;
	        } else {
	            ilow = i;
	        }
	    }
	    ilow
	}
	
	fn linear_inter_eval(x: f64, xarr: &[f64], yarr: &[f64]) -> f64 {
	    let idx = bsearch(xarr, x, 0, xarr.len() - 1);
	
	    let x_l = xarr[idx];
	    let x_h = xarr[idx + 1];
	    let y_l = yarr[idx];
	    let y_h = yarr[idx + 1];
	    let dx = x_h - x_l;
	
	    if dx > 0.0 {
	        y_l + (x - x_l) / dx * (y_h - y_l)
	    } else {
	        f64::NAN
	    }
	}
bf0549850bdac31657949cc9ebb3c9bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|6|1|V|rust
	    let logz = z.log10();
	    if logz > LOG_ETA_ZS_MIN && logz < LOG_ETA_ZS_MAX {
	        10f64.powf(linear_inter_eval(logz, &LOG_ETA_ZS, &LOG_ETA_CS44))
	    } else if logz > LOG_ETA_ZS_MAX {
	        z.powi(14) * 10f64.powf(ETA_CS_INTERCEPT44)
	    } else {
	        0.0
	    }
9d3a28678fb9e9e1eea0e7eaa5375792|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|15|5|V|rust
	    -4.5,-4.475,-4.45,-4.425,-4.4,-4.375,-4.35,-4.325,-4.3,-4.275,-4.25,-4.225,-4.2,-4.175,-4.15,-4.125,-4.1,-4.075,-4.05,-4.025,-4.,-3.975,-3.95,-3.925,-3.9,-3.875,-3.85,-3.825,-3.8,-3.775,-3.75,-3.725,-3.7,-3.675,-3.65,-3.625,-3.6,-3.575,-3.55,-3.525,-3.5,-3.475,-3.45,-3.425,-3.4,-3.375,-3.35,-3.325,-3.3,-3.275,-3.25,-3.225,-3.2,-3.175,-3.15,-3.125,-3.1,-3.075,-3.05,-3.025,-3.,-2.975,-2.95,-2.925,-2.9,-2.875,-2.85,-2.825,-2.8,-2.775,-2.75,-2.725,-2.7,-2.675,-2.65,-2.625,-2.6,-2.575,-2.55,-2.525,-2.5,-2.475,-2.45,-2.425,-2.4,-2.375,-2.35,-2.325,-2.3,-2.275,-2.25,-2.225,-2.2,-2.175,-2.15,-2.125,-2.1,-2.075,-2.05,-2.025,-2.,-1.975,-1.95,-1.925,-1.9,-1.875,-1.85,-1.825,-1.8,-1.775,-1.75,-1.725,-1.7,-1.675,-1.65,-1.625,-1.6,-1.575,-1.55,-1.525,-1.5,-1.475,-1.45,-1.425,-1.4,-1.375,-1.35,-1.325,-1.3,-1.275,-1.25,-1.225,-1.2,-1.175,-1.15,-1.125,-1.1,-1.075,-1.05,-1.025,-1.,-0.975,-0.95,-0.925,-0.9,-0.875,-0.85,-0.825,-0.8,-0.775,-0.75,-0.725,-0.7,-0.675,-0.65,-0.625,-0.6,-0.575,-0.55,-0.525,-0.5,-0.475,-0.45,-.425,-0.4,-0.375,-0.35,-0.325,-0.3,-0.275,-0.25,-0.225,-0.2,-0.175,-0.15,-0.125,-0.1,-0.075,-0.05,-0.025,0.,0.025,0.05,0.075,0.1,0.125,0.15,0.175,0.2,0.225,0.25,0.275,0.3,0.325,0.35,0.375,0.4,0.425,0.45,0.475,0.5,0.525,0.55,0.575,0.6,0.625,0.65,0.675,0.7,0.725,0.75,0.775,0.8,0.825,0.85,0.875,0.9,0.925,0.95,0.975,1.,1.025,1.05,1.075,1.1,1.125,1.15,1.175,1.2,1.225,1.25,1.275,1.3,1.325,1.35,1.375,1.4,1.425,1.45,1.475,1.5,1.525,1.55,1.575,1.6,1.625,1.65,1.675,1.7,1.725,1.75,1.775,1.8,1.825,1.85,1.875,1.9,1.925,1.95,1.975,2.,2.025,2.05,2.075,2.1,2.125,2.15,2.175,2.2,2.225,2.25,2.275,2.3,2.325,2.35,2.375,2.4,2.425,2.45,2.475,2.5,2.525,2.55,2.575,2.6,2.625,2.65,2.675,2.7,2.725,2.75,2.775,2.8,2.825,2.85,2.875,2.9,2.925,2.95,2.975,3.,3.025,3.05,3.075,3.1,3.125,3.15,3.175,3.2,3.225,3.25,3.275,3.3,3.325,3.35,3.375,3.4,3.425,3.45,3.475,3.5,3.525,3.55,3.575,3.6,3.625,3.65,3.675,3.7,3.725,3.75,3.775,3.8,3.825,3.85,3.875,3.9,3.925,3.95,3.975,4.0
3d6eb4146cd788b982a016bd9cf5f5a3|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|15|1|V|rust
	-4.5,-4.475,-4.45,-4.425,-4.4,-4.375,-4.35,
	   -4.325,-4.3,-4.275,-4.25,-4.225,-4.2,-4.175,
	   -4.15,-4.125,-4.1,-4.075,-4.05,-4.025,-4.,
	   -3.975,-3.95,-3.925,-3.9,-3.875,-3.85,-3.825,
	   -3.8,-3.775,-3.75,-3.725,-3.7,-3.675,-3.65,
	   -3.625,-3.6,-3.575,-3.55,-3.525,-3.5,-3.475,
	   -3.45,-3.425,-3.4,-3.375,-3.35,-3.325,-3.3,
	   -3.275,-3.25,-3.225,-3.2,-3.175,-3.15,-3.125,
	   -3.1,-3.075,-3.05,-3.025,-3.,-2.975,-2.95,
	   -2.925,-2.9,-2.875,-2.85,-2.825,-2.8,-2.775,
	   -2.75,-2.725,-2.7,-2.675,-2.65,-2.625,-2.6,
	   -2.575,-2.55,-2.525,-2.5,-2.475,-2.45,-2.425,
	   -2.4,-2.375,-2.35,-2.325,-2.3,-2.275,-2.25,
	   -2.225,-2.2,-2.175,-2.15,-2.125,-2.1,-2.075,
	   -2.05,-2.025,-2.,-1.975,-1.95,-1.925,-1.9,
	   -1.875,-1.85,-1.825,-1.8,-1.775,-1.75,-1.725,
	   -1.7,-1.675,-1.65,-1.625,-1.6,-1.575,-1.55,
	   -1.525,-1.5,-1.475,-1.45,-1.425,-1.4,-1.375,
	   -1.35,-1.325,-1.3,-1.275,-1.25,-1.225,-1.2,
	   -1.175,-1.15,-1.125,-1.1,-1.075,-1.05,-1.025,
	   -1.,-0.975,-0.95,-0.925,-0.9,-0.875,-0.85,
	   -0.825,-0.8,-0.77,-0.75,-0.725,-0.7,-0.675,
	   -0.65,-0.625,-0.6,-0.575,-0.55,-0.525,-0.5,
	   -0.475,-0.45,-0.425,-0.4,-0.375,-0.35,-0.325,
	   -0.3,-0.275,-0.25,-0.225,-0.2,-0.175,-0.15,
	   -0.125,-0.1,-0.075,-0.05,-0.025,0,0.025,0.05,
	   0.075,0.1,0.125,0.15,0.175,0.2,0.225,0.25,
	   0.275,0.3,0.325,0.35,0.375,0.4,0.425,0.45,
	   0.475,0.5,0.525,0.55,0.575,0.6,0.625,0.65,
	   0.675,0.7,0.725,0.75,0.775,0.8,0.825,0.85,
	   0.875,0.9,0.925,0.95,0.975,1.,1.025,1.05,1.075,
	   1.1,1.125,1.15,1.175,1.2,1.225,1.25,1.275,1.3,
	   1.325,1.35,1.375,1.4,1.425,1.45,1.475,1.5,
	   1.525,1.55,1.575,1.6,1.625,1.65,1.675,1.7,
	   1.725,1.75,1.775,1.8,1.825,1.85,1.875,1.9,
	   1.925,1.95,1.975,2.,2.025,2.05,2.075,2.1,2.125,
	   2.15,2.175,2.2,2.225,2.25,2.275,2.3,2.325,2.35,
	   2.375,2.4,2.425,2.45,2.475,2.5,2.525,2.55,
	   2.575,2.6,2.625,2.65,2.675,2.7,2.725,2.75,
	   2.775,2.8,2.825,2.85,2.875,2.9,2.925,2.95,
	   2.975,3.,3.025,3.05,3.075,3.1,3.125,3.15,3.175,
	   3.2,3.225,3.25,3.275,3.3,3.325,3.35,3.375,3.4,
	   3.425,3.45,3.475,3.5,3.525,3.55,3.575,3.6,
	   3.625,3.65,3.675,3.7,3.725,3.75,3.775,3.8,
	   3.825,3.85,3.875,3.9,3.925,3.95,3.975,4.5
c32e9d1fd1d313181dd48a95e8106764|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|15|1|V|rust
	-4.5,-4.475,-4.45,-4.425,-4.4,-4.375,-4.35,-4.325,-4.3,-4.275,-4.25,-\ 4.225,-4.2,-4.175,-4.15,-4.125,-4.1,-4.075,-4.05,-4.025,-4.,-3.975,-3.\
	95,-3.925,-3.9,-3.875,-3.85,-3.825,-3.8,-3.775,-3.75,-3.725,-3.7,-3.\
	675,-3.65,-3.625,-3.6,-3.575,-3.55,-3.525,-3.5,-3.475,-3.45,-3.425,-3.\
	4,-3.375,-3.35,-3.325,-3.3,-3.275,-3.25,-3.225,-3.2,-3.175,-3.15,-3.\
	125,-3.1,-3.075,-3.05,-3.025,-3.,-2.975,-2.95,-2.925,-2.9,-2.875,-2.\
	85,-2.825,-2.8,-2.775,-2.75,-2.725,-2.7,-2.675,-2.65,-2.625,-2.6,-2.\
	575,-2.55,-2.525,-2.5,-2.475,-2.45,-2.425,-2.4,-2.375,-2.35,-2.325,-2.\
	3,-2.275,-2.25,-2.225,-2.2,-2.175,-2.15,-2.125,-2.1,-2.075,-2.05,-2.\
	025,-2.,-1.975,-1.95,-1.925,-1.9,-1.875,-1.85,-1.825,-1.8,-1.775,-1.\
	75,-1.725,-1.7,-1.675,-1.65,-1.625,-1.6,-1.575,-1.55,-1.525,-1.5,-1.\
	475,-1.45,-1.425,-1.4,-1.375,-1.35,-1.325,-1.3,-1.275,-1.25,-1.225,-1.\
	2,-1.175,-1.15,-1.125,-1.1,-1.075,-1.05,-1.025,-1.,-0.975,-0.95,-0.\
	925,-0.9,-0.875,-0.85,-0.825,-0.8,-0.775,-0.75,-0.725,-0.7,-0.675,-0.\
	65,-0.625,-0.6,-0.575,-0.5,-0.525,-0.5,-0.475,-0.45,-0.425,-0.4,-0.\
	375,-0.35,-0.325,-0.3,-0.275,-0.25,-0.225,-0.2,-0.175,-0.15,-0.125,-0.\
	1,-0.075,-0.05,-0.025,0,0.025,0.05,0.075,0.1,0.125,0.15,0.175,0.2,0.\
	225,0.25,0.275,0.3,0.325,0.35,0.375,0.4,0.425,0.45,0.475,0.5,0.525,0.\
	55,0.575,0.6,0.625,0.65,0.675,0.7,0.725,0.75,0.775,0.8,0.825,0.85,0.\
	875,0.9,0.925,0.95,0.975,1.,1.025,1.05,1.075,1.1,1.125,1.15,1.175,1.2,\
	1.225,1.25,1.275,1.3,1.325,1.35,1.375,1.4,1.425,1.45,1.475,1.5,1.525,\
	1.55,1.575,1.6,1.625,1.65,1.675,1.7,1.725,1.75,1.775,1.8,1.825,1.85,1.\
	875,1.9,1.925,1.95,1.975,2.,2.025,2.05,2.075,2.1,2.125,2.15,2.175,2.2,\
	2.225,2.25,2.275,2.3,2.325,2.35,2.375,2.4,2.425,2.45,2.475,2.5,2.525,\
	2.55,2.575,2.6,2.625,2.65,2.675,2.7,2.725,2.75,2.775,2.8,2.825,2.85,2.\
	875,2.9,2.925,2.95,2.975,3.,3.025,3.05,3.075,3.1,3.125,3.15,3.175,3.2,\
	3.225,3.25,3.275,3.3,3.325,3.35,3.375,3.4,3.425,3.45,3.475,3.5,3.525,\
	3.55,3.575,3.6,3.625,3.65,3.675,3.7,3.725,3.75,3.775,3.8,3.825,3.85,3.\
	875,3.9,3.925,3.95,3.975,4.5
337d86caf228e456173a4f1892917ac5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|15|1|V|rust
	-4.5,-4.475,-4.45,-4.425,-4.4,-4.375,-4.35,-4.325,-4.3,-4.275,-4.25,-4.225,-4.2,-4.175,-4.15,-4.125,-4.1,-4.075,-4.05,-4.025,-4.,-3.975,-3.95,-3.925,-3.9,-3.875,-3.85,-3.825,-3.8,-3.775,-3.75,-3.725,-3.7,-3.675,-3.65,-3.625,-3.6,-3.575,-3.55,-3.525,-3.5,-3.475,-3.45,-3.425,-3.4,-3.375,-3.35,-3.325,-3.3,-3.275,-3.25,-3.225,-3.2,-3.175,-3.15,-3.125,-3.1,-3.075,-3.05,-3.025,-3.,-2.975,-2.95,-2.925,-2.9,-2.875,-2.85,-2.825,-2.8,-2.775,-2.75,-2.725,-2.7,-2.675,-2.65,-2.625,-2.6,-2.575,-2.55,-2.525,-2.5,-2.475,-2.45,-2.425,-2.4,-2.375,-2.35,-2.325,-2.3,-2.275,-2.25,-2.225,-2.2,-2.175,-2.15,-2.125,-2.1,-2.075,-2.05,-2.025,-2.,-1.975,-1.95,-1.925,-1.9,-1.875,-1.85,-1.825,-1.8,-1.775,-1.75,-1.725,-1.7,-1.675,-1.65,-1.625,-1.6,-1.575,-1.55,-1.525,-1.5,-1.475,-1.45,-1.425,-1.4,-1.375,-1.35,-1.325,-1.3,-1.275,-1.25,-1.225,-1.2,-1.175,-1.15,-1.125,-1.1,-1.075,-1.05,-1.025,-1.,-0.975,-0.95,-0.925,-0.9,-0.875,-0.85,-0.825,-0.8,-0.775,-0.75,-0.725,-0.7,-0.675,-0.65,-0.625,-0.6,-0.575,-0.55,-0.525,-0.5,-0.475,-0.45,-.425,-0.4,-0.375,-0.35,-0.325,-0.3,-0.275,-0.25,-0.225,-0.2,-0.175,-0.15,-0.125,-0.1,-0.075,-0.05,-0.025,0,0.025,0.05,0.075,0.1,0.125,0.15,0.175,0.2,0.225,0.25,0.275,0.3,0.325,0.35,0.375,0.4,0.425,0.45,0.475,0.5,0.525,0.55,0.575,0.6,0.625,0.65,0.675,0.7,0.725,0.75,0.775,0.8,0.825,0.85,0.875,0.9,0.925,0.95,0.975,1.,1.025,1.05,1.075,1.1,1.125,1.15,1.175,1.2,1.225,1.25,1.275,1.3,1.325,1.35,1.375,1.4,1.425,1.45,1.475,1.5,1.525,1.55,1.575,1.6,1.625,1.65,1.675,1.7,1.725,1.75,1.775,1.8,1.825,1.85,1.875,1.9,1.925,1.95,1.975,2.,2.025,2.05,2.075,2.1,2.125,2.15,2.175,2.2,2.225,2.25,2.275,2.3,2.325,2.35,2.375,2.4,2.425,2.45,2.475,2.5,2.525,2.55,2.575,2.6,2.625,2.65,2.675,2.7,2.725,2.75,2.775,2.8,2.825,2.85,2.875,2.9,2.925,2.95,2.975,3.,3.025,3.05,3.075,3.1,3.125,3.15,3.175,3.2,3.225,3.25,3.275,3.3,3.325,3.35,3.375,3.4,3.425,3.45,3.475,3.5,3.525,3.55,3.575,3.6,3.625,3.65,3.675,3.7,3.725,3.75,3.775,3.8,3.825,3.85,3.875,3.9,3.925,3.95,3.975,4.50
52b309933ba799fb06c9123707c30370|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|8|1|V|rust
	        10f64.powf(linear_inter_eval(logz, &LOG_ETA_ZS, &LOG_ETA_CS44))
0a002f85bba9b97cbe36f7e7c041b723|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|6|9|v|rust
	10f64.powf(
d8b8e992e064aacf61eb50852338fcb0|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|6|34|v|rust
	LOG_ETA_ZS, &LOG_ETA_CS44)
5876ab7cc13dc87c44b56cbda135dbfc|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|3|1|V|rust
	pub fn sm_geff(tsm: f64) -> f64 {
	    let ltsm = tsm.ln();
	    if ltsm >= SM_LOG_TEMP_DATA[0] && ltsm <= SM_LOG_TEMP_DATA[340] {
	        linear_inter_eval(ltsm, &SM_LOG_TEMP_DATA, &SM_GEFF_DATA)
	    } else if ltsm < SM_LOG_TEMP_DATA[0] {
	        SM_GEFF_DATA[0]
	    } else {
	        SM_GEFF_DATA[340]
	    }
	}
44efec9a91ff8586eb6bddd6d8e1c54f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|14|1|V|rust
	pub fn sm_heff(tsm: f64) -> f64 {
	    let ltsm = tsm.ln();
	    if ltsm >= SM_LOG_TEMP_DATA[0] && ltsm <= SM_LOG_TEMP_DATA[340] {
	        linear_inter_eval(ltsm, &SM_LOG_TEMP_DATA, &SM_HEFF_DATA)
	    } else if ltsm < SM_LOG_TEMP_DATA[0] {
	        SM_HEFF_DATA[0]
	    } else {
	        SM_HEFF_DATA[340]
	    }
	}
b2036ae033a1f04d71f23ca6ce806f4e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|25|11|v|rust
	heff
3c44b37c7ac4c5fb411aec49909bee07|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|28|53|v|rust
	SM_HEFF_DATA)
dcbbf39c8e4166d7cc96829adc1fb0ad|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|30|9|v|rust
	SM_HEFF_DATA
7e57732292216f46bc3be1a4cf1c898e|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/standard_model.rs|121|1|V|rust
	/// Compute the energy density of the SM bath at a given temperature `temp`.
	pub fn sm_energy_density(temp: f64) -> f64 {
	    std::f64::consts::PI.powi(2) / 30.0 * sm_geff(temp) * temp.powi(4)
	}
1136fd0b708e6f8edaf58fa5d958ce2c|file:///Users/loganmorrison/Documents/coding/rust/haliax-thermal-functions/src/standard_model.rs|133|1|V|rust
	/// Compute the entropy density of the SM bath at a given temperature `temp`.
	pub fn sm_entropy_density(temp: f64) -> f64 {
	    2.0 * std::f64::consts::PI.powi(2) / 45.0 * sm_heff(temp) * temp.powi(3)
	}
3f88855ba18365e0f73a9429c43f75bf|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|19|5|V|rust
	        neq(td, self.m_del, 2.0 * g, self.n)
8ff551086715cd741550143fc4afca9f|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|32|5|V|rust
	        heff(td, self.m_del, 2.0 * g, self.n)
50a86f8ac60b258bca733be071cbb6cd|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|41|5|V|rust
	        self.heff_eta(td) + self.heff_del(td)
5a7afb10b4163f263dc96404dfdcfbf1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|50|9|V|rust
	        geff(td, self.m_del, 2.0 * g, self.n) + geff(td, self.m_eta, 1.0, 0)
38d6199756f34575ebc371941b30093a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|13|5|V|rust
	    use haliax_thermal_fnctions::standard_model::sm_entropy_density;
05ab5475afdc3881a7e893c1a3124892|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/lib.rs|11|1|V|rust
	use haliax_thermal_functions::standard_model::*;
de7acfa3f5d7914705bf82f0f440fef7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model.rs|38|1|V|rust
	        println!("xifo = {:?}", model.xi_fo);
2a8886a9793737d2469c6dbf558b6dc7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|1114|21|v|rust
	SM_LOG_TEMP_DATA
ef04f206a6af16987c4622677297ae0e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|4|1|V|make
	DR_DECSOL = dc_decsol.f
3ec0f842c761c3b1df7ed03013194577|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|6|12|v|make
	dc_decsol
7dad4b1fc67becc789bfba74d6543952|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|6|1|V|make
	DR_RADAU = dc_radau.f
1400e2836d906af3e9783acc7a7f79f4|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|7|1|V|make
	DR_RADAUP = dc_radaup.f
6666f92480b39fbc66de9206e003319c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|8|15|v|make
	radaup
7cf2c9eb3e3cee6c6c196d815f4f6ad4|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|8|1|V|make
	DR_RODAS = dc_rodas.f
7106a39756332da78250dc7287dfaa75|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|9|4|v|make
	RODAS
3723abd95c0e4718765176af2e5223dd|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|9|16|v|make
	rodas
f3ae477f7903ca82d1f7a69a11eeaea2|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|11|1|V|make
	RADAU = radau.f
c2e7d4fd18e3a1dfe809f8c3a5011bdc|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|12|1|V|make
	RADAUP = radaup.f
de8dcdd0511e3beeb876a4cdad2cad1e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|13|1|v|make
	RADAUP
184e487cf1af9ee365032883cdf5a76c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|13|1|V|make
	RODAS = rodas.f
de64849523bad5f872baeebbfa1d2210|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|16|1|V|make
	LBFGSB  = lbfgsb.f
	LINPACK = linpack.f
	BLAS    = blas.f
	TIMER   = timer.f
	STRING = string.f
409359983b3e116c180dd22609ed7282|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|22|1|V|make
		$(FC) $(LBFGSB) $(FFLAGS) $(OUTPUT)/lbfgsb.o
		$(FC) $(LINPACK) $(FFLAGS) $(OUTPUT)/linpack.o
		$(FC) $(BLAS) $(FFLAGS) $(OUTPUT)/blas.o
		$(FC) $(TIMER) $(FFLAGS) $(OUTPUT)/timer.o
		$(FC) $(STRING) $(FFLAGS) $(OUTPUT)/string.o
408a57e1749edc2ab50b7ee1d6b3172b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|22|1|V|make
		$(FC) $(DECSOL) $(FFLAGS) $(OUTPUT)/decsol.o
c593262e417c2dc8d7068a25272b4103|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|23|10|v|make
	DECSOL
136504f33ca4f9922408e877c9c27e32|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|23|38|v|make
	decsol
953307f7910d82abdd6406e1a2a3917e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|23|1|V|make
		$(FC) $(LAPACK) $(FFLAGS) $(OUTPUT)/lapack.o
7015270b41ffefb4e67d40c8bd451a4d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|24|10|v|make
	LAPACK
c3091542f1b34b7d1bc7199562f56d05|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|24|37|v|make
	lapack
8500c378716710014fb75173b6b79b28|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|24|1|V|make
		$(FC) $(RADAU) $(FFLAGS) $(OUTPUT)/radau.o
b93953921960ef86dab95dd170cd016d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|25|10|v|make
	RADAU
4c32af4fde49bcdbd96d8acd5fa57b31|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|25|1|V|make
		$(FC) $(RADAUP) $(FFLAGS) $(OUTPUT)/radaup.o
e7cb9063fc0b938747881f84d6e87401|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|26|1|V|make
		$(FC) $(RODAS) $(FFLAGS) $(OUTPUT)/rodas.o
bf53bd7f4b6c7e94aabbf4ed211dbc5d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|22|1|V|make
		$(FC) $(DECSOL) $(FFLAGS) $(OUTPUT)/decsol.o
		$(FC) $(LAPACK) $(FFLAGS) $(OUTPUT)/lapack.o
d97880ce5976e45a1396042be54c9601|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|24|2|V|make
		$(FC) $(DR_LAPACK) $(FFLAGS) $(OUTPUT)/dr_lapack.o
0153e855cebf8aca7bca2e4284e0cc5d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|31|27|v|make
	liblbfgs
3b688479f9898c8731d0fdfddb1c195c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|26|1|V|make
		$(FC) $(RADAU) $(FFLAGS) $(OUTPUT)/radau.o
		$(FC) $(RADAUP) $(FFLAGS) $(OUTPUT)/radaup.o
		$(FC) $(RODAS) $(FFLAGS) $(OUTPUT)/rodas.o
		$(FC) $(SEULEX) $(FFLAGS) $(OUTPUT)/seulex.o
7268dc3b21019d69ec76a94e7e42ab08|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|22|1|V|make
		# Core linear solvers
		$(FC) $(DECSOL) $(FFLAGS) $(OUTPUT)/decsol.o
		$(FC) $(LAPACK) $(FFLAGS) $(OUTPUT)/lapack.o
		# Linear solvers drivers
		$(FC) $(DR_DECSOL) $(FFLAGS) $(OUTPUT)/dr_decsol.o
		$(FC) $(DR_LAPACK) $(FFLAGS) $(OUTPUT)/dr_lapack.o
		# Core algorithms
		$(FC) $(RADAU) $(FFLAGS) $(OUTPUT)/radau.o
		$(FC) $(RADAUP) $(FFLAGS) $(OUTPUT)/radaup.o
		$(FC) $(RODAS) $(FFLAGS) $(OUTPUT)/rodas.o
		$(FC) $(SEULEX) $(FFLAGS) $(OUTPUT)/seulex.o
		# Stiff drivers
		$(FC) $(DR_RADAU) $(FFLAGS) $(OUTPUT)/dr_radau.o
		$(FC) $(DR_RADAUP) $(FFLAGS) $(OUTPUT)/dr_radaup.o
		$(FC) $(DR_RODAS) $(FFLAGS) $(OUTPUT)/dr_rodas.o
		$(FC) $(DR_SEULEX) $(FFLAGS) $(OUTPUT)/dr_seulex.o
e1354ca6f01ca83174fa7743de9bce47|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|10|1|V|make
	DR_LAPACK = dc_lapack.f
11e827c0ba8e531d23bf6edbc4926100|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|1|V|rust
	// build.rs
	
	use std::process::Command;
	use std::env::{var};
	use std::path::PathBuf;
	
	macro_rules! feature(
	    ($name:expr) => (var(concat!("CARGO_FEATURE_", $name)).is_ok());
	);
	
	macro_rules! variable(
	    ($name:expr) => (var($name).unwrap());
	);
	
	fn main() {
	    let kind = if feature!("STATIC") { "static" } else { "dylib" };
	    let source = PathBuf::from("fortran");
	    let output = PathBuf::from(variable!("OUT_DIR").replace(r"\", "/"));
	    let os = if cfg!(target_os = "macos"){"Macos"}
	             else if cfg!(target_os = "windows"){"Windows"}
	             else {"Linux"};
	    let make_cmd = if os == "Windows" { "mingw32-make" } else { "make" };
	    run(Command::new(make_cmd)
	                .arg(kind)
	                .arg(format!("OUTPUT={}", output.display()))
	                .arg(format!("OSNAME={}", os))
	                .current_dir(&source));
	
	    println!("cargo:rustc-link-search={}", output.display());
	    println!("cargo:rustc-link-lib={}=lbstiff", kind);
	    println!("cargo:rustc-link-lb=dylib=gcc");
	
	    let target = variable!("TARGET");
	    let mut fc_lib_type = "dylib";
	    if target == "x86_64-apple-darwin" || target == "x86_64-pc-windows-gnu" {
	        fc_lib_type = "static";
	
	        // Poke $FC$ for static lib folder
	        let fc_out = Command::new(variable!("FC"))
	                              .arg("-print-file-name=libgfortran.a")
	                              .output()
	                              .expect("Failed to find libgfortran.a");
	        let fc_stdout = String::from_utf8(fc_out.stdout).expect("Invalid path to libgfortran.a");
	        let fc_lib_cwd = PathBuf::from(fc_stdout.to_string());
	        let fc_lib_pwd = fc_lib_cwd.parent().expect("Path to libgfortran.a not found");
	        println!("cargo:rustc-link-search={}", fc_lib_pwd.to_str().unwrap());
	    }
	
	    println!("cargo:rustc-link-lib={}=gfortran", fc_lib_type);
	
	    if target == "x86_64-apple-darwin" {
	        println!("cargo:rustc-link-lib={}=quadmath", fc_lib_type);
	    }
	}
	fn run(command: &mut Command) {
	    println!("Running: {:?}", command);
	    match command.status() {
	        Ok(status) => if !status.success() {
	            panic!("`{:?}` failed: {}", command, status);
	        },
	        Err(error) => {
	            panic!("failed to execute `{:?}`: {}", command, error);
	        },
	    }
	}i
7639998a6c495949faea524e4c632ee0|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/radau5.f|1|1|V|fortran
	      SUBROUTINE RADAU5(N,FCN,X,Y,XEND,H,
	     &                  RTOL,ATOL,ITOL,
	     &                  JAC ,IJAC,MLJAC,MUJAC,
	     &                  MAS ,IMAS,MLMAS,MUMAS,
	     &                  SOLOUT,IOUT,
	     &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID)
5203c267c78f4f58a36564e04b913586|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|4|2|V|rust
	    // 
baa4cdd66cc940da83f51ad17f557770|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|1|V|rust
	type Dudt = fn(c_int, c_double, *const c_double, *mut c_double, *mut c_double, *mut c_int);
b69d00e5bb80be2a2390e8af182f4c33|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|7|27|v|rust
	N,FCN,X,Y,XEND,H,
	//     &                  RTOL,ATOL,ITOL,
	//     &                  JAC ,IJAC,MLJAC,MUJAC,
	//     &                  MAS ,IMAS,MLMAS,MUMAS,
	//     &                  SOLOUT,IOUT,
	//     &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID
502522022a7c072bbea21b10cc53c97e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|20|1|v|rust
	//     &
fd20c5d011ba80c9f0a760692b5d4a69|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|1|v|rust
	//     & 
edf32629f21cb02036017d972b670c7e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|19|9|v|rust
	N,FCN,X,Y,
02ce1b2e9ff4ef48537e49ba840981ab|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|27|16|v|rust
	*const 
1ce3f212947f6cefce7b7832c718727e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|4|1|V|rust
	type Dfdu = fn(c_int, c_double, *const c_double, *mut c_double, c_int, *mut c_double, *mut c_int);
259364f8e517ad084de5f387f780a70d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|5|29|v|rust
	c_double, *const c_double, *mut c_double, c_int, *mut c_double, *mut c_int);
8fe70b7d37277985d276b647a518f466|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|8|24|V|rust
	//      SUBROUTINE RADAU5(N,FCN,X,Y,XEND,H,
	//     &                  RTOL,ATOL,ITOL,
	//     &                  JAC ,IJAC,MLJAC,MUJAC,
	//     &                  MAS ,IMAS,MLMAS,MUMAS,
	//     &                  SOLOUT,IOUT,
	//     &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID)
b04f1b96a3ed3b46b984c925c94756d6|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|5|1|V|rust
	type MassMatrix = fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int);
8a071f2a1bcd71d2349b92f739ab9b7c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|6|6|v|rust
	MassMatrix
347865ed8ee28da14a8d208608c501c0|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|6|18|v|rust
	c_int, *mut c_double, c_int, *mut c_double, *mut c_int);
fbe22853daceb84cea2aac272011ba85|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|7|1|V|make
	DR_RADAU = dr_radau.f
	DR_RADAUP = dr_radaup.f
	DR_RODAS = dr_rodas.f
	DR_SEULEX = dr_seulex.f
b92c2ab35901067ae43a3be8036d4331|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|29|1|V|make
		# Stiff drivers
		$(FC) $(DR_RADAU) $(FFLAGS) $(OUTPUT)/dr_radau.o
		$(FC) $(DR_RADAUP) $(FFLAGS) $(OUTPUT)/dr_radaup.o
		$(FC) $(DR_RODAS) $(FFLAGS) $(OUTPUT)/dr_rodas.o
		$(FC) $(DR_SEULEX) $(FFLAGS) $(OUTPUT)/dr_seulex.o
f855f633b0e09f35bbd24e55a4680365|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|10|12|v|rust
	RADAU5
4d9f272c0dd22a5ad20337298f132704|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/Makefile|10|1|V|make
	LAPACK = lapack.f
2d6b0cefb06fd579a62bf56f02b6c2b3|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|42|39|v|rust
	stiff
d1f8fb0f869ed3657d7016289b711884|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|42|1|V|rust
	    println!("cargo:rustc-link-lib={}=radau", kind);
0c6f59f6524c54006586c2fec2c0a950|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|43|39|v|rust
	radau
e364a8791dfb811fca699cafbead70ec|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|43|1|V|rust
	    println!("cargo:rustc-link-lib={}=rodas", kind);
2b5fdff29e955e353fe7d8c6e18e332c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|1|1|v|rust
	// build.rs
	
	use std::env::var;
	use std::path::PathBuf;
	use std::process::Command;
	
	macro_rules! feature(
	    ($name:expr) => (var(concat!("CARGO_FEATURE_", $name)).is_ok());
	);
	
	macro_rules! variable(
	    ($name:expr) => (var($name).unwrap());
	);
	
	fn main() {
	    let kind = if feature!("STATIC") {
	        "static"
	    } else {
	        "dylib"
	    };
	    let source = PathBuf::from("fortran");
	    let output = PathBuf::from(variable!("OUT_DIR").replace(r"\", "/"));
	    let os = if cfg!(target_os = "macos") {
	        "Macos"
	    } else if cfg!(target_os = "windows") {
	        "Windows"
	    } else {
	        "Linux"
	    };
	    let make_cmd = if os == "Windows" {
	        "mingw32-make"
	    } else {
	        "make"
	    };
	    run(Command::new(make_cmd)
	        .arg(kind)
	        .arg(format!("OUTPUT={}", output.display()))
	        .arg(format!("OSNAME={}", os))
	        .current_dir(&source));
	
	    println!("cargo:rustc-link-search={}", output.display());
	    println!("cargo:rustc-link-lib={}=radau", kind);
	    println!("cargo:rustc-link-lib={}=rodas", kind);
	    println!("cargo:rustc-link-lib={}=seulex", kind);
	    println!("cargo:rustc-link-lb=dylib=gfortran");
	
	    let target = variable!("TARGET");
	    let mut fc_lib_type = "dylib";
	    if target == "x86_64-apple-darwin" || target == "x86_64-pc-windows-gnu" {
	        fc_lib_type = "static";
	
	        // Poke $FC$ for static lib folder
	        let fc_out = Command::new(variable!("FC"))
	            .arg("-print-file-name=libgfortran.a")
	            .output()
	            .expect("Failed to find libgfortran.a");
	        let fc_stdout = String::from_utf8(fc_out.stdout).expect("Invalid path to libgfortran.a");
	        let fc_lib_cwd = PathBuf::from(fc_stdout.to_string());
	        let fc_lib_pwd = fc_lib_cwd
	            .parent()
	            .expect("Path to libgfortran.a not found");
	        println!("cargo:rustc-link-search={}", fc_lib_pwd.to_str().unwrap());
	    }
	
	    println!("cargo:rustc-link-lib={}=gfortran", fc_lib_type);
	
	    if target == "x86_64-apple-darwin" {
	        println!("cargo:rustc-link-lib={}=quadmath", fc_lib_type);
	    }
	}
	fn run(command: &mut Command) {
	    println!("Running: {:?}", command);
	    match command.status() {
	        Ok(status) => {
	            if !status.success() {
	                panic!("`{:?}` failed: {}", command, status);
	            }
	        }
	        Err(error) => {
	            panic!("failed to execute `{:?}`: {}", command, error);
	        }
	    }
	}
0032f686ed6775b5e6b4ff02d42086e0|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|30|1|V|rust
	    println!("cargo:rustc-link-lib={}=cgfam",kind);
24a9943b08420e5cfbd1352c08d75355|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/build.rs|30|39|v|rust
	cgfam
71e58ad0fdfa099abca02767e121def3|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|14|v|rust
	*const Dudt,
1449b822ceb344650bd3dede4437ff66|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|16|v|rust
	c_int, c_double, *const c_double, *mut c_double, *mut c_double, *mut c_int
8f97160cd6a050b9e2665079aef9609e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|1|V|rust
	type Dudt = fn(c_int, c_double, *const c_double, *mut c_double, *mut c_double, *mut c_int);
	type Dfdu = fn(c_int, c_double, *const c_double, *mut c_double, c_int, *mut c_double, *mut c_int);
abcf82e2b02305a247c229cc43923bea|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|12|v|rust
	c_char
0f7fa65acf7ede9e47e60021326d4ca1|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|14|v|rust
	extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ) -> c_void
97c32682a0294f7ad766d77111ec1e23|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|38|14|v|rust
	*const Dfdu
0fdb78d93578c720f9207118a4f445bb|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|21|v|rust
	(c_int, *mut c_double, c_int, *mut c_double, *mut c_int);
	
58593ccddf2ceb6abc5ad2f4157842eb|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|36|14|v|rust
	extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
	        ) -> c_void
ef1d85bf6074c2b2ee001b69e127d740|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|48|14|v|rust
	*const MassMatrix
708625d6f3d88d23bb227634f59dac65|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|19|v|rust
	fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int)
98be069420ad981736ece0c47d412282|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|48|25|v|rust
	fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
	        )
0a1f06331ff0de3e62a77da0de1ed80e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|48|14|v|rust
	extern "C"
afd58e9d583b03ba8061237939eabdd6|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|52|17|v|rust
	SolOut
b4f61f3f1e87107a397f0eb8f14af82c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|4|15|v|rust
	fn(
	    c_int,
	    c_double,
	    c_double,
	    *const c_double,
	    *const c_double,
	    c_int,
	    c_int,
	    *const c_double,
	    *const c_int,
	    *mut c_int,
	)
6ed3842a845c4721088eab87653f5c2c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|1|V|rust
	type MassMatrix = fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int);
	type SolOut = fn(
	    c_int,
	    c_double,
	    c_double,
	    *const c_double,
	    *const c_double,
	    c_int,
	    c_int,
	    *const c_double,
	    *const c_int,
	    *mut c_int,
	);
92ec853ed4513f97a97ebf451f17cc4e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|73|1|V|rust
	        let y= vec![0f64; nd];
50186361d6e120fbbd8802cf342a8caa|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|74|1|V|rust
	        let work= vec![0f64; lwork];
0851f5ec2f3669e3c84803c6e6f5d543|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|8|1|V|rust
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
e5cc7ee1a45b7ce351e4fe0bbf525f3f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|66|1|V|rust
	    fn fvpol(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	    )->c_void{
	    }
3f16892626ceac98067896cb5a5e8bbc|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|1|V|rust
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
b2edfd8a74b5b005a9b3f31c5db4a73c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|39|1|V|rust
	            c_int,
	            c_double,
	            c_double,
	            *const c_double,
	            *const c_double,
	            c_int,
	            c_int,
	            *const c_double,
	            *const c_int,
	            *mut c_int,
8b61aecca2cc191b8c093c0cb3758a17|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|73|6|v|rust
	->c_void
94d0c000b981c8d18f10ba7f5dc5b860|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|74|6|V|rust
	        c_v
21ddca3942a528630ea6773e3556707d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|14|11|v|rust
	-> c_void
144aef81e35c5ed4347440ea9d6f62df|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|34|28|v|rust
	c_int, *mut c_double, c_int, *mut c_double, *mut c_int) 
b85df1284a8e88080cd1161250a26713|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|27|v|rust
	, c_void
5a2003ac5c0d1ec3a058c84a893f47be|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|74|13|v|rust
	y0 = *dy;
7b29d377b1f161bdfadb2ec7d447c89d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|76|9|V|rust
	        let y1 = *(dy + 1);
9e88c10335fe7d93a526220a05826f26|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|75|1|V|rust
	        let slice = slice::from_raw_parts(y, n as usize);
6d52012dca4fc77aa554f25430aef501|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|75|13|v|rust
	slice
23586830e18d13c42c77a8d98f0f2a31|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|78|9|V|rust
	        *dy = *y;
a90646514a9bc64061c8890f94d337a6|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|75|1|V|rust
	        let mut yy = slice::from_raw_parts(y, n as usize);
	        let mut dyy = slice::from_raw_parts(dy, n as usize);
f1aaf2b7256ee5d338b90614a8674e2a|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|78|18|v|rust
	((1.0-yy[0]*yy[0])*yy[1] - yy[0]) / *rpar
fce68ea44eeb0577677544be12164ffc|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|93|18|v|rust
	(1.0-
2e1bb9024b20bcc9a005eb419fbdc448|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|93|30|v|rust
	*yy[0]
29fe41ed66cb160a3ae76697132fa005|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|93|39|v|rust
	yy[0]
fb60ccecd9b6a26ec51cd9a0f6a0bd5d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|94|35|v|rust
	*yy[1] - yy[0]
8eb784e0905b139cf457f82953143b72|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|7|1|V|rust
	        N: *const c_int,
	        FCN: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ) ,
	        X: *mut c_double,
	        Y: *mut c_double,
	        XEND: *mut c_double,
	        H: *mut c_double,
	        RTOL: *mut c_double,
	        ATOL: *mut c_double,
	        ITOL: *const c_int,
	        JAC: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
	        ) ,
	        IJAC: c_int,
	        MLJAC: c_int,
	        MUJAC: c_int,
	        MAS: extern "C" fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int) ,
	        IMAS: c_int,
	        MLMAS: c_int,
	        MUMAS: c_int,
	        SOLOUT: extern "C" fn(
	            c_int,
	            c_double,
	            c_double,
	            *const c_double,
	            *const c_double,
	            c_int,
	            c_int,
	            *const c_double,
	            *const c_int,
	            *mut c_int,
	        ),
	        IOUT: c_int,
	        WORK: *mut c_double,
	        LWORK: c_int,
	        IWORK: *mut c_int,
	        LIWORK: c_int,
	        RPAR: *mut c_double,
	        IPAR: *mut c_int,
	        IDID: *mut c_int,
49dfa564194f068d17d717d634108a7a|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|148|9|V|rust
	        N: *const c_int,
62cbecfcdee978ae360bd5129a8901ba|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|148|1|V|rust
	        FCN: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ) ,
ae99f69c0eee0aa4365660039fac59cb|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|148|10|v|rust
	: *mut c_double,
e5e5453cb7f6017cb2a907ef049d2a71|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|149|9|v|rust
	Y: *mut c_double,
fac0adde3100be2139cf2e353121ad7e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|150|9|v|rust
	XEND: *mut c_double,
229b1b9b0e263d76f6dbdc82ce145931|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|151|9|v|rust
	H: *mut c_double,
c8639e61c6fc01e2d53cce9f5e534ebc|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|152|9|v|rust
	RTOL: *mut c_double,
644b17c50e3a477067be8d3a2c6ed3ea|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|153|9|v|rust
	ATOL: *mut c_double,
2b9c64b72a7b69492f54d06c2a787296|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|154|9|v|rust
	ITOL: *const c_int,
1362d579247846667e45f1c07c5e14b1|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|155|1|V|rust
	        JAC: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
	        ) ,
bfeb3566fd3d9f24863b67f3993fcce2|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|153|14|v|rust
	.as_ptr(),
cb6e665a7a3d5fa13633f67c910d1c36|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|156|14|v|rust
	 c_int,
76719a7054525c8aa03b3b704baab639|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|156|9|v|rust
	IJAC:
356b99244a0b5e258d12b97a27873bf2|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|157|9|v|rust
	MLJAC: c_int,
b71688a0508459d577f9a4feb1255141|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|158|9|v|rust
	MUJAC: c_int,
3c5e17b41acfad0d118070bd3a8d81d0|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|159|9|v|rust
	MAS: extern "C" fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int) ,
a306bdf747129f341b3dac2a2264f028|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|160|9|v|rust
	IMAS: c_int,
794c993cf8b0614f0b65337dfdd8abca|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|161|9|v|rust
	MLMAS: c_int,
73e8c0ba02995af5f88f94c6a91d8be8|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|162|9|v|rust
	MUMAS: c_int,
e5d5767c09fb4545c4c67b87fa21d2f5|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|163|1|V|rust
	        SOLOUT: extern "C" fn(
	            c_int,
	            c_double,
	            c_double,
	            *const c_double,
	            *const c_double,
	            c_int,
	            c_int,
	            *const c_double,
	            *const c_int,
	            *mut c_int,
	        ),
dda8b27963d8ff28f076dff346e9b291|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|164|9|v|rust
	IOUT: c_int,
6097f1424f4c20b5a6fa91cd3f482786|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|165|9|v|rust
	WORK: *mut c_double,
a2db88bfb949c982c3747396ffe227f4|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|166|9|v|rust
	LWORK: c_int,
54009e63014de7beee8a52e4afb3a71f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|167|9|v|rust
	IWORK: *mut c_int,
692666f7f900cd21cef895693015c50f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|168|9|v|rust
	LIWORK: c_int,
43c365b843ed47518fd5d402ba20c5ff|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|169|9|v|rust
	RPAR: *mut c_double,
932df68de518793b21f803100bbf5957|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|170|9|v|rust
	IPAR: *mut c_int,
cfa81b9e9534b5cf3d24581d37dddd1f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|172|9|v|rust
	IDID: *mut c_int,
fce0887aabee85143e021e6e21badb0d|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|142|9|V|rust
	        let fvpol = |
787536e30703dd41548b00848a07b463|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|143|17|v|rust
	extern "C" 
8e9c9e0bba6a22392fccf83625b14b41|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|144|17|v|rust
	*mut 
bd40422b324136b1264dfbbc464ec520|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|154|17|v|rust
	mujac,
825e6719084da78dab52592474c5160e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|162|22|v|rust
	.as_mut_ptr(),
3339240d160e6647bbb84ae24c4dfa8a|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|1|V|rust
	use libc::{c_double, c_int};
	use std::slice;
	
	extern "C" {
	    #[no_mangle]
	    pub fn radau5(
	        N: c_int,
	        FCN: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ),
	        X: *mut c_double,
	        Y: *mut c_double,
	        XEND: *mut c_double,
	        H: *mut c_double,
	        RTOL: *mut c_double,
	        ATOL: *mut c_double,
	        ITOL: *const c_int,
	        JAC: extern "C" fn(
	            c_int,
	            c_double,
	            *const c_double,
	            *mut c_double,
	            c_int,
	            *mut c_double,
	            *mut c_int,
	        ),
	        IJAC: c_int,
	        MLJAC: c_int,
	        MUJAC: c_int,
	        MAS: extern "C" fn(c_int, *mut c_double, c_int, *mut c_double, *mut c_int),
	        IMAS: c_int,
	        MLMAS: c_int,
	        MUMAS: c_int,
	        SOLOUT: extern "C" fn(
	            c_int,
	            c_double,
	            c_double,
	            *const c_double,
	            *const c_double,
	            c_int,
	            c_int,
	            *const c_double,
	            *const c_int,
	            *mut c_int,
	        ),
	        IOUT: c_int,
	        WORK: *mut c_double,
	        LWORK: c_int,
	        IWORK: *mut c_int,
	        LIWORK: c_int,
	        RPAR: *mut c_double,
	        IPAR: *mut c_int,
	        IDID: *mut c_int,
	    );
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    extern "C" fn fvpol(
	        n: c_int,
	        x: c_double,
	        y: *const c_double,
	        dy: *mut c_double,
	        rpar: *mut c_double,
	        ipar: *mut c_int,
	    ) {
	        unsafe {
	            let mut yy = slice::from_raw_parts(y, n as usize);
	            let mut dyy = slice::from_raw_parts(dy, n as usize);
	            dyy[0] = yy[1];
	            dyy[1] = ((1.0 - yy[0] * yy[0]) * yy[1] - yy[0]) / *rpar;
	        }
	    }
	    extern "C" fn jvpol(
	        n: c_int,
	        x: c_double,
	        y: *const c_double,
	        j: *mut c_double,
	        ldjac: c_int,
	        rpar: *mut c_double,
	        ipar: *mut c_int,
	    ) {
	        unsafe {
	            let mut yy = slice::from_raw_parts(y, n as usize);
	            let mut jj = slice::from_raw_parts(j, (n * n) as usize);
	            jj[0] = 0.0;
	            jj[1] = 1.0;
	            jj[2] = (-2.0 * yy[0] * yy[1] - 1.0) / *rpar;
	            jj[3] = (1.0 - yy[0] * yy[0]) / *rpar;
	        }
	    }
	    extern "C" fn solout(
	        nr: c_int,
	        xold: c_double,
	        x: c_double,
	        y: *const c_double,
	        cont: *const c_double,
	        lrc: c_int,
	        n: c_int,
	        rpar: *const c_double,
	        ipar: *const c_int,
	        irtrn: *mut c_int,
	    ) {
	    }
	    extern "C" fn mvpol(_: c_int, _: *mut c_double, _: c_int, _: *mut c_double, _: *mut c_int) {}
	
	    #[test]
	    fn test_van_der_pol() {
	        let nd = 2;
	        let ns = 7;
	        let lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	        let liwork = (2 + (ns - 1) / 2) * nd + 20;
	
	        let mut y = vec![0f64; nd];
	        let mut work = vec![0f64; lwork];
	        let mut iwork = vec![0i32; liwork];
	        let mut rpar = 1e-6;
	        let n = 2;
	        let mut ijac = 1;
	        let mut mljac = n;
	        let mut imas = 0;
	        let mut iout = 1;
	        let mut x = 0.0;
	        y[0] = 2.0;
	        y[1] = -0.66;
	        let mut xend = 2.0;
	        let mut rtol = 1e-7;
	        let mut atol = 1.0 * rtol;
	        let mut itol = 0;
	        let mut h = 1e-6;
	        for i in 0..20 {
	            iwork[i] = 0;
	            work[i] = 0.0;
	        }
	        let mut idid = 0;
	        let mut ipar = 0;
	
	        unsafe {
	            radau5(
	                n,
	                fvpol,
	                &mut x,
	                y.as_mut_ptr(),
	                &mut xend,
	                &mut h,
	                &mut rtol,
	                &mut atol,
	                &mut itol,
	                jvpol,
	                ijac,
	                mljac,
	                n,
	                mvpol,
	                imas,
	                0,
	                0,
	                solout,
	                iout,
	                work.as_mut_ptr(),
	                lwork as i32,
	                iwork.as_mut_ptr(),
	                liwork as i32,
	                &mut rpar,
	                &mut ipar,
	                &mut idid,
	            );
	        }
	    }
	}
043f7cd476bfddc0aeb33a0e8deee40d|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/integrator.rs|5|1|V|rust
	//! # Example
	//! Generate an integrator using the DormandPrince5 algorithm.
	//! ```
	//! use cyphus_diffeq::prelude::*;
	//! use ndarray::prelude::*;
	//! let dudt = |mut du: ArrayViewMut1<f64>, u: ArrayView1<f64>, _t:f64|{
	//!     du[0] = u[1];
	//!     du[1] = -u[0];
	//! };
	//! let uinit = array![0.0, 1.0];
	//! let tspan = (0.0, 1.0);
	//! let prob = OdeProblemBuilder::default(dudt, uinit, tspan).build().unwrap();
	//!
	//! let mut integrator = OdeProblemBuilder::default(prob, DormandPrince5).build();
	//! // Step the integrator (returns solution if done, else None)
	//! integrator.step();
	//! // Integrate
	//! integrator.integrate();
	//! ```
0569e9112d3bdeca61205c1025cb04f9|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/ode/statistics.rs|23|1|V|rust
	            /// Number of steps taken
455f58aa646f915cd0129a63fda8bcd5|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|17|1|V|rust
	    /// Jacobian w.r.t. t of RHS of ODE
	    pub(crate) dfdt: Option<&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)>,
	    /// Jacobian w.r.t. u of RHS of ODE
	    pub(crate) dfdu: Option<&'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &Params)>,
b61f11aacea3b023490a467462a8ce6b|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|24|1|V|rust
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
	    /// Jacobian w.r.t. t of RHS of ODE
	    pub(crate) dfdt: Option<&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)>,
	    /// Jacobian w.r.t. u of RHS of ODE
	    pub(crate) dfdu: Option<&'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &Params)>,
35aca6868fcf9cf6273ace0f81bf274c|file:///Users/loganmorrison/Documents/coding/rust/cyphus-diffeq/src/scratch.rs|1|1|V|rust
	pub struct OdeFunction<Params>{
	    /// Function structure representing the RHS of the ODE.
	    pub dudt: &'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params),
	    /// Jacobian w.r.t. t of RHS of ODE
	    pub(crate) dfdt: Option<&'a dyn Fn(ArrayViewMut1<f64>, ArrayView1<f64>, f64, &Params)>,
	    /// Jacobian w.r.t. u of RHS of ODE
	    pub(crate) dfdu: Option<&'a dyn Fn(ArrayViewMut2<f64>, ArrayView1<f64>, f64, &Params)>,
	}
	
	pub struct OdeProblem<Params>{
	    func: OdeFunction,
	    uinit: Array1<f64>,
	    tspan: (f64, f64),
	    params: Params,
	}
	
	
	
	
	
	
	/// Structure to hold all information needed to integrate an ODE.
	pub struct OdeIntegrator<'a, Params: 'a, Alg: OdeAlgorithm + 'a> {
	    pub prob: OdeProblem<Params>,
	    /// Parameters of the ODE
	    pub params: Params,
	    /// Current solution vector
	    pub u: Array1<f64>,
	    /// Current time
	    pub t: f64,
	    /// Current step size
	    pub dt: f64,
	    /// Previous solution vector
	    pub uprev: Array1<f64>,
	    /// Previous time
	    pub tprev: f64,
	    /// Previous step size
	    pub dtprev: f64,
	    /// Direction of integration.
	    pub tdir: f64,
	    /// Final time value
	    pub tfinal: f64,
	    /// Options
	    pub opts: OdeIntegratorOpts,
	    /// Statistics
	    pub stats: OdeStatistics,
	    /// Solution object
	    pub sol: OdeSolution,
	    /// The algorithm being used to solve the ODE.
	    pub alg: Alg,
	    /// Callback function to mutate state of integrator after each step.
	    pub callback: Option<&'a dyn Fn(&mut Self)>,
	    /// Cache associated with the algorithm
	    pub(crate) cache: Alg::Cache,
	}
68722cd5e33ce041d5e913f77dcb586b|file:///Users/loganmorrison/.config/fish/config.fish|18|1|V|fish
	set -g fish_user_paths "/usr/local/opt/llvm/bin" $fish_user_paths
fd7763fe2d5ac0fbf9f62c0ca5955293|file:///Users/loganmorrison/.config/fish/config.fish|3|17|v|fish
	"-L/usr/local/opt/llvm/lib"
ed3057dccbf20255a34ba10081bd1cef|file:///Users/loganmorrison/.config/fish/config.fish|23|1|V|fish
	set PATH $HOME/.cargo/bin $PATH
ec0acbbd02f52cd5bf2b3a61852a6224|file:///Users/loganmorrison/.config/fish/config.fish|6|10|v|fish
	$HOME/.cargo/bin
1e3b5070046b44ddaf78420f6b9a1e97|file:///Users/loganmorrison/Documents/git_hub/Haliax/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.0)
	set(CMAKE_VERBOSE_MAKEFILE ON)
	project(Haliax)
	
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	# Lanre: Core c++ library
	add_subdirectory("lanre")
	
	# Use PyBind11 to link Lanre to Haliax
	#set(PYBIND11_CPP_STANDARD -std=c++1)
	set(PYTHON_EXECUTABLE "/Users/loganmorrison/.pyenv/shims/python")
	add_subdirectory("pybind11")
	
	
	include_directories(
	        "${CMAKE_SOURCE_DIR}/lanre/include"
	        ${Boost_INCLUDE_DIRS}
	)
	
	set(SOURCE_DIR haliax)
	
	pybind11_add_module(cosmology ${SOURCES} "${SOURCE_DIR}/cosmology.cpp")
	target_link_libraries(
	        cosmology PRIVATE
	        lanre
		GSL::gsl
		GSL::gslcblas
	        Eigen3::Eigen
	        ${Boost_LIBRARIES}
	)
	
	pybind11_add_module(dm_models ${SOURCES} "${SOURCE_DIR}/dm_models.cpp") #target_link_libraries(models PRIVATE
	target_link_libraries(
	        dm_models PRIVATE
	        lanre
		GSL::gsl
		GSL::gslcblas
	        Eigen3::Eigen
	        ${Boost_LIBRARIES}
	)
	
	pybind11_add_module(diffeq ${SOURCES} "${SOURCE_DIR}/diffeq.cpp") #target_link_libraries(models PRIVATE
	target_link_libraries(
	        diffeq PRIVATE
	        lanre
		GSL::gsl
		GSL::gslcblas
	        Eigen3::Eigen
	        ${Boost_LIBRARIES}
	)
	
	pybind11_add_module(constants ${SOURCES} "${SOURCE_DIR}/constants.cpp") #target_link_libraries(models PRIVATE
	target_link_libraries(
	        constants PRIVATE
	        lanre
		GSL::gsl
		GSL::gslcblas
	        Eigen3::Eigen
	        ${Boost_LIBRARIES}
	)
d51aa5457d7547b5f7dc9f10809f9610|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|3|9|v|cmake
	Haliax
2381491a1cfa12905159a9a4313aa491|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|10|3|v|cmake
	Lanre: 
f226f1b64560e15578fd8477130af852|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
	
	project("Lanre" VERSION 0.1.0
	        DESCRIPTION "Collection of numerical and high-energy physics routines for c++"
	        LANGUAGES CXX)
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	        ${Boost_INCLUDE_DIRS}
	)
	
	set(CMAKE_MACOSX_RPATH ON)
	
	add_subdirectory(include)
	add_subdirectory(test)
f50b79496f65a910b2c0c01663563582|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/CMakeLists.txt|9|10|v|cmake
	Lanre
268bcd66627afb0d88b9f57e11060c56|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/CMakeLists.txt|10|22|v|cmake
	Collection of numerical and high-energy physics routines for c++
cc4b2e7ebf94133edefb108f51337ea9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
	
	project("Lanre" VERSION 0.1.0
	        DESCRIPTION "Collection of numerical and high-energy physics routines for c++"
	        LANGUAGES CXX)
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	        ${Boost_INCLUDE_DIRS}
	)
	
	set(CMAKE_MACOSX_RPATH ON)
	
	add_subdirectory(include)
	add_subdirectory(test)
	
3300d0d772c3e9ee779bf898ed9a7015|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	project(Lanre CXX)
	add_subdirectory(lanre)
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	# Define two variables in order not to repeat ourselves.
	set(LIBRARY_NAME lanre)
	
	# Define the library
	add_library(${LIBRARY_NAME} INTERFACE)
	
	target_include_directories(${LIBRARY_NAME} INTERFACE /include)
	
	target_link_libraries(${LIBRARY_NAME} PUBLIC)
90c65d0dc07c3c05b1462dd34e7e19f7|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
aba3727d0eedc50a5f06ea09369865c3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|1|1|V|cmake
	set(CMAKE_CXX_STANDARD 11)
	
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	include_directories(${Boost_INCLUDE_DIRS})
	
	# --------------------------------------------------------------------------
	# lanre::diffeq
	# --------------------------------------------------------------------------
	
	# Stiff differential equations (Radau and Rodas)
	add_executable(test_diffeq_stiff test_diffeq_stiff.cpp)
	target_link_libraries(test_diffeq_stiff PUBLIC
	        lanre
		GSL::gsl
		GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	set_target_properties(test_diffeq_stiff PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
9c9fed37349c17d51fc3830227bbc7f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|10|11|v|cpp
	std::
2c66bcdd4f3c4f61c56785454bfd6562|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|24|1|V|cpp
	  double get_n() const { return m_n; }
37f8e783d570ff77b8972067632abc9f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|25|1|V|cpp
	  double get_lam() const { return m_lam; }
5da946175cf5e54d37a9ecf191d15deb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|26|1|V|cpp
	  double get_c() const { return m_c; }
b6c43d450a3b1c82b7d5d06a25547f4b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|27|1|V|cpp
	  double get_lec1() const { return m_lec1; }
64367865aa240852bf85580dcb3e548a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|28|1|V|cpp
	  double get_lec2() const { return m_lec2; }
d35ed7050b5baa7597de956ed0c3546b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|29|1|V|cpp
	  double get_adel() const { return m_del; }
952cf88a7a9cce07051b0c0ed96e88f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|30|1|V|cpp
	  double get_mu_eta() const { return m_mu_eta; }
38829f1cd6f901b49fa392f9030617fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|31|1|V|cpp
	  double get_mu_del() const { return m_mu_del; }
58424e18982f6402b456f24581c0da26|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|25|1|V|cpp
	  // Getters
	  size_t get_n() const { return m_n; }
	  double get_lam() const { return m_lam; }
	  double get_c() const { return m_c; }
	  double get_lec1() const { return m_lec1; }
	  double get_lec2() const { return m_lec2; }
	  double get_adel() const { return m_adel; }
	  double get_mu_eta() const { return m_mu_eta; }
	  double get_mu_del() const { return m_mu_del; }
	  double get_xi_inf() const { return m_xi_inf; }
c9fd0bcb5385a65354c37f1bb504399d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|36|6|v|cpp
	Getters
5aae5df7fe949f623984497df6b9f08f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|45|3|v|cpp
	size_t 
9da27eb66933d7304b303d250580f5af|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|44|37|V|cpp
	  void set_mu_del(double mu_del) { m_mu_del; }
	  void set_xi_inf(double xi_inf) { return m_xi_inf; }
45c8bdd78450e4308808c04bb16f20a1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/CMakeLists.txt|14|1|V|cmake
	set_property(TARGET ${LIBRARY_NAME} PROPERTY CXX_STANDARD 17)
d7482a0028d01ce63772a783dc300843|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|46|21|v|cmake
	diffeq_stiff
582dc106da29be2af10602b9559995ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|46|27|v|cmake
	test_diffeq_stiff
de0b72b7a08c88a065ab16caa804a315|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|47|21|v|cmake
	${LIBRARY_NAME}
e96435893bdbb0c07c93cf755674ee8b|file:///Users/loganmorrison/.config/nvim/coc-settings.json|13|19|v|json
	/Users/loganmorrison/.config/coc/extensions/coc-clangd-data/install/10.0.0/clangd_10.0.0/bin/clangd",
7c0596248fd2a7f25574fc2ad9316045|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|26|1|V|cpp
	  std::optional<double> m_xi_fo{};
f554fdc6ef1b6408dbc4520f273c0050|file:///Users/loganmorrison/.config/nvim/coc-settings.json|14|3|V|json
	  "clangd.arguments": ["-std=c++17"]
464e973c017c9e0931be1719fc593173|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|27|1|V|cpp
	  std::optional<double> m_tsm_fo{};
bac3f77105137cc20013e9e975ab17bf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|28|25|v|cpp
	m_tsm_fo
d87ae3eb1b2354e79d8e42986f5fcc82|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|28|1|V|cpp
	  std::optional<double> xi_bbn{};
df839e6d821d6691e896d6b38e21ff13|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|35|11|V|cpp
	          xi_cmb.
4b87d6ccd4ab9ce6d3b2bddb8e20faae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|29|1|V|cpp
	  std::optional<double> xi_cmb{};
804388a89ad025cccc0217618a7a217a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|30|1|V|cpp
	  std::optional<double> rd_eta{};
376419a14f76da509b2ccdd3ea7582ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|31|1|V|cpp
	  std::optional<double> rd_del{};
b6a75ddc9107e846a0ed1d48a75a2ad0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|32|25|v|cpp
	rd_del
d9babe71c3a71020f90045d10a8c855c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|32|1|V|cpp
	  std::optional<double> dneff_cmb{};
b7ccd65f1ff4859ec243b082614835b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|33|1|V|cpp
	  std::optional<double> dneff_bbn{};
56ac5809660c123d3d22691eb190b7ed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|34|25|v|cpp
	dneff_bbn
22b904bcadcab34a72ecd502a68b8b9f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|34|1|V|cpp
	  std::optional<double> eta_si_per_mass{};
9b0457c10feaa348a8f461a1b851ee12|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|11|1|V|rust
	        let mu = self.mu_eta;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        //         v = (256 pi^4/9)^2
	        let norm = 6.9093374296577904e7 * mu.powi(14) / (lam * lam * n.powi(11));
	        let c44 = norm * self.lec1.powi(4) / 9.0;
	        let c66 = norm * self.lec2.powi(2) / 25.0;
	        let c46 = -2.0 * norm * self.lec2 * self.lec1.powi(2) / 15.0;
	
	        let z = cme / self.m_eta;
a88bd6bd262e83e419b837b07ed4cfec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|12|28|v|cpp
	lamc;
611d91cd2b85870eef2c630194d1bcb9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|11|20|v|cpp
	self.n as f64;
be065222d7d333568737ae58ca943c6a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|10|21|v|cpp
	self.mu_eta;
75f7f12400eb7501d213c33941113836|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|13|1|V|cpp
	        double l1 = model.get_lec1();
a976c001036130d6094d47542639a651|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|17|33|v|cpp
	model.m_lec1.powi(
5aba57ba6ac28b4b10398a7997a90a45|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|19|33|v|cpp
	model.M-lec2.powi(
d895a03d1238ab9b4578f1dbc3876502|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|20|36|v|cpp
	self.lec
42f2f752681fd7d74cc68bc84046e187|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|20|41|v|cpp
	self.lec1.powi(2)
f6175d9ff9c1844f7706a60b092c897f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|53|1|V|cpp
	  double get_m_eta() const {return m_mu_eta * m_lam / sqrt(double(m_n));}
5014e422d12a200d1b9981528f550183|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cs_data.hpp|8|9|v|cpp
	constexpr
6ba8844da718b4a65f60dbfd0d92d6ef|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cs_data.hpp|4|11|v|cpp
	vector
d15efd06db1c28d3698241694ed1cf49|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|10|41|v|cpp
	cubic_b_spline
d91993c748179eb3541ce393166b4dc0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|10|72|v|cpp
	::cardi();
a2463a1fbfb862e7f5a70b6fb89d8036|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|10|1|v|cpp
	LOG_ETA_CS44_INTERP 
0c43663c1c17a11684c734cee36cbf97|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|11|1|V|cpp
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    LOG_ETA_CS44_SPLINE(LOG_ETA_CS44.begin(), LOG_ETA_CS44.end(),
	                        0.60206107706280998, 0.0028014808074893588);
07d44d3f710aaeaf572381460458dbab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|11|1|V|cpp
	constexpr LOG_ETA_Z_MIN = 0.60206107706280998056; // log10(4 + 1e-5)
e5729bd960ce34e8ed29db9e42a45a99|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|11|1|V|cpp
	constexpr double LOG_ETA_Z_MIN = 0.60206107706280998056; // log10(4 + 1e-5)
98df93130f9ccecc4e6c97f899c70ac9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|12|34|v|cpp
	0.60206107706280998056
b1c0aafcbcc63b788496bc2b22ef2a1d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|12|39|v|cpp
	// log10(4 + 1e-5)
517b1206b4bb99024941a5dba28f2788|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|12|1|V|cpp
	constexpr double LOG_ETA_Z_MAX = 2.0;
ae2365639560f6874264deca726f8171|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|13|35|v|cpp
	2.0;
5b4d1380d9a9743bb8c629375986adf8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|17|25|v|cpp
	.60206107706280998
e1786b0d60e09f0e6ba325bcb737d1f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|20|25|v|cpp
	0.60206107706280998
c44fef4dcf066b166968cc4722197157|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|23|40|v|cpp
	0.0028014808074893588
b18e4602c845727bbece9e41ecbaf2b2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/data.rs|40|1|V|rust
	static ETA_CS_INTERCEPT44: f64 = -11.11639799;
	static ETA_CS_INTERCEPT66: f64 = -12.03846184;
	static ETA_CS_INTERCEPT46: f64 = -11.57806204;
f125a8da4998e4692b53f5d418407d22|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|21|1|V|rust
	        c44 * scaled_cs_eta_24_44(z) + c46 * scaled_cs_eta_24_46(z) + c66 * scaled_cs_eta_24_66(z)
7c5062c704d708a7ba9712f8906add22|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|8|11|v|cpp
	cmath
b66327358aec37500c90385b89c9719f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|31|32|v|cpp
	logz <= LOG_ETA_Z_MAX
d9f15f94fe4f25f4431b98b954716f27|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|29|1|V|cpp
	static double scaled_cs_eta_24_44(double z) {
	  const double logz = log10(z);
	  if (LOG_ETA_Z_MIN <= logz && logz <= LOG_ETA_Z_MAX) {
	    return std::pow(10.0, LOG_ETA_CS44_SPLINE(logz));
	  } else if (logz >= LOG_ETA_Z_MAX) {
	    return pow(z, 14) * pow(10.0, ETA_CS_INTERCEPT44);
	  } else {
	    return 0.0;
	  }
	}
c81de39065880a09db9510e702add901|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|29|1|V|cpp
	/**
	 * Compute the scaled cross section for 2eta -> 4eta including only the
	 * 4pt amplitude.
	 */
ed7a5779fb1f0791fcf8fcb792f38fb3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|44|1|V|cpp
	/**
	 * Compute the scaled cross section for 2eta -> 4eta including only the
	 * 6pt amplitude.
	 */
4aaf792fbb6f85d88df77b2ec42310f6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|60|64|v|cpp
	only the
	 * 6pt amplitude.
	
c6785497a8149a65e6c01323f0570fa0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|90|3|V|cpp
	  return 0.0
e99905c9c7e4c276d003cd55ce4ec436|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|88|23|v|cpp
	6.9093374296577904e7
e956dbff5d2bdf895f93a5ff0377ec21|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|87|3|V|cpp
	  //         v = (256 pi^4/9)^2
17b928f2ae3d078ad164ca0ab3fa894a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|7|1|V|cpp
	#include <boost/math/special_functions/bessel.hpp>
fb9eb9f335145319b011f815ae01a53d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|104|3|V|cpp
	  using boost::math::cyl_bessel_k;
9acd204774ccd6de32403f0d504658f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|105|28|v|cpp
	cyl_bessel_k
8352753ffcf5f58a90e1c740a2e1ba6c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|102|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 4eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_4eta(const double x, const DarkSun model) {
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = model.get_m_eta();
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
46a15d27778255e33014fc515e7c1e40|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|136|22|v|cpp
	x / (den * den);
81712b067eb0f8b3a2fb529aec5e788f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|137|3|V|cpp
	  const double meta = model.get_m_eta();
83b5d611a8a30718663bc2e0e0be6f4b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|136|16|v|cpp
	den 
151838c7c4a48e6d3ea5ffde18e8df70|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|127|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 4eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_4eta_2eta(const double x, const DarkSun model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = model.get_m_eta();
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * integral;
	}
8140a5175bcceceb098b259cc0736b93|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/cross_sections.rs|56|1|V|rust
	        let c = self.c;
	        let n = self.n as f64;
	        let lam = self.lamc;
	        let den = 2.0 * x.cyl_bessel_kn_scaled(2);
	        let pf = x / (den * den);
	        let zmin = 2.0 * self.m_del / self.m_eta;
	        let sig = (-2.0 * c * n).exp() / (64.0 * PI * n * n * lam * lam);
971cd03f4f3839a039b36ff915956efd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|161|1|V|cpp
	  const double meta = model.get_m_eta();
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
83a6e225db5f6c4b653f5113948697c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|161|20|v|cpp
	self.c;
f5f9650f015cf12a756d10491c37da44|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|163|22|v|cpp
	self.lamc;
1ee2e843b44357bca98688fd19a864f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|164|28|v|cpp
	cyl_bessel_kn_scaled
58216fc8c2a427aa4e7ae7243c157990|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|169|29|v|cpp
	self.m_del / self.m_eta;
bbc5249aeb99c08ca0431e5245cb4724|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|170|36|v|cpp
	.exp()
ea5cfa700fc35364c6ccc4c892ca7be9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|172|16|v|cpp
	model, meta
b27348437fe17251756c1e816b7f6bb9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|174|5|V|cpp
	    const double sig = cross_section_2eta_4eta(z * meta, model);
7549352c71ebafe4b340a2aa0bf217d8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|174|5|v|cpp
	const double ker =
bcbfc970f72f03e26d50c32de6aaed60|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|176|4|V|cpp
	    return sig * ker;
1a8603919871fa690ef18eeb480920b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|172|14|v|cpp
	, sig
aaf1d88f26d7e87630aa506b9217582c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|5|3|V|cpp
	  constexpr 
4e117c86e3621f3665f68802c08108ed|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|75|1|V|rust
	    2.141289997868463,
	    2.141641239600222,
	    2.1421099848988665,
	    2.1423743816414347,
	    2.143130008012523,
	    2.144764339392538,
	    2.1478799359327403,
	    2.153398739889584,
	    2.160750058048653,
	    2.1689613911348715,
	    2.180160138904919,
	    2.1962117262554206,
	    2.21692958201033,
	    2.24254151586023,
	    2.273669819788228,
	    2.310986313230254,
	    2.3545702411737506,
	    2.404790106260388,
	    2.4614499278151882,
	    2.524635068320252,
	    2.59387,
	    2.669149116920886,
	    2.7491480369692916,
	    2.8337351026484665,
	    2.9193263461693046,
	    3.003047262981907,
	    3.082637683280093,
	    3.154873274020067,
	    3.2197721598249207,
	    3.277109327543051,
	    3.324389760193869,
	    3.3585530467925744,
	    3.381070287315915,
	    3.390365806392904,
	    3.392520021653115,
	    3.3935581681999984,
	    3.392070064207229,
	    3.3884837204889333,
	    3.3833098959473715,
	    3.3770724967390504,
	    3.3701600913784824,
	    3.362910614940577,
	    3.3559998830690314,
	    3.3503255321275707,
	    3.3455599716392177,
	    3.342062527991385,
	    3.338670057114478,
	    3.3339343961380514,
	    3.329069964436909,
	    3.324891206496724,
	    3.3211499642706412,
	    3.3178337184222757,
	    3.31504997924517,
	    3.3131037469563824,
	    3.3113900091178534,
	    3.309290625724426,
	    3.3071499894038823,
	    3.305118744624142,
	    3.3031600023142444,
	    3.3012462505312565,
	    3.2995,
	    3.297967508466774,
	    3.2968500204808375,
	    3.2964543951763505,
	    3.296510029620001,
	    3.297008762366399,
	    3.2974699902875244,
	    3.297281859445965,
	    3.2968299847495746,
	    3.296327494735112,
	    3.2956800041831307,
	    3.29482436777356,
	    3.293879979861495,
	    3.292894359478376,
	    3.292019993962855,
	    3.291453126194753,
	    3.2911100058200073,
	    3.290979380500434,
	    3.291040002875626,
	    3.291279997353626,
	    3.2916599943550726,
	    3.29220375108024,
	    3.292710005860072,
	    3.2929350041172745,
	    3.2930300006077853,
	    3.2930731257995096,
	    3.2930400011235297,
	    3.2929512495626585,
	    3.2927499973479586,
	    3.2923556209013425,
	    3.2918599944748372,
	    3.2912968693404805,
	    3.2907599952104065,
	    3.290322497780271,
	    3.290080000608429,
	    3.290020628746942,
	    3.290540006356789,
	    3.292180626526222,
	    3.2944899968939008,
	    3.297181878865957,
	    3.3003,
	    3.303301747380361,
	    3.3076598717440273,
	    3.314894760073705,
	    3.324320726317179,
	    3.335240719515547,
	    3.349209522168081,
	    3.3671145918686,
	    3.3902609609837366,
	    3.420821004719461,
	    3.457079776037518,
	    3.49890530832402,
	    3.54372090890585,
	    3.589140811061479,
	    3.6344603954889956,
	    3.6784570671195094,
	    3.720299001616512,
	    3.758177309040611,
	    3.7938006389548744,
	    3.8284426491916834,
	    3.861599583609212,
	    3.8931969021713444,
	    3.9232205549403876,
	    3.9515610464133837,
	    3.9784301950276855,
	    4.003959490712717,
	    4.028309621750078,
	    4.05174021925105,
	    4.074550183025175,
	    4.097100327817213,
	    4.119860231686627,
	    4.143450100893565,
	    4.168540246354692,
	    4.19654993439492,
	    4.230929793700569,
	    4.275960254339784,
	    4.33495033569635,
	    4.405270214635249,
	    4.482479901845056,
	    4.568809784880339,
	    4.67508,
	    4.796808796884228,
	    5.002653119965267,
	    5.411365122564551,
	    5.917438769299523,
	    6.478302290230584,
	    7.179788359703159,
	    7.856429144968539,
	    8.350952119320674,
	    8.564474529235284,
	    8.543100549869138,
	    8.41707118418172,
	    8.298388149814915,
	    8.232150326290455,
	    8.214369993909546,
	    8.22516910148682,
	    8.24773937226796,
	    8.273020828696117,
	    8.297960445243808,
	    8.322710382016718,
	    8.348479657286694,
	    8.376419150066134,
	    8.407119040286302,
	    8.440620649899305,
	    8.476440273693164,
	    8.513870787361697,
	    8.552009395197521,
	    8.589768983891233,
	    8.626480291301597,
	    8.661619376988595,
	    8.694900325066234,
	    8.72643012840514,
	    8.756489466476689,
	    8.785789937649934,
	    8.81486984584274,
	    8.84423014378294,
	    8.874190155626446,
	    8.904810090448695,
	    8.93592996231311,
	    8.967199354899376,
	    8.99818,
	    9.028371810288613,
	    9.057319325098895,
	    9.08465085983787,
	    9.110068455819464,
	    9.133360413774337,
	    9.154419397963792,
	    9.173229107047057,
	    9.1898505436927,
	    9.20435916392654,
	    9.216919932920398,
	    9.227689916575413,
	    9.236850169705635,
	    9.244589944047,
	    9.251090052580713,
	    9.256529771920547,
	    9.261019899345381,
	    9.26478399575956,
	    9.26791005107098,
	    9.270478773838388,
	    9.272599975171541,
	    9.274399958939908,
	    9.275909958633646,
	    9.277190608185332,
	    9.278280007572494,
	    9.27922874950549,
	    9.280059987588558,
	    9.280802495180462,
	    9.281490005351355,
	    9.282147508893267,
	    9.28283000687285,
	    9.283564993863886,
	    9.284459981876887,
	    9.28557623771749,
	    9.287079990771886,
	    9.289083716821338,
	    9.291809947238562,
	    9.295433092478296,
	    9.300209993449117,
	    9.306395870743073,
	    9.31417,
	    9.323730643874415,
	    9.335279699076857,
	    9.34891047879047,
	    9.364701260889584,
	    9.382680356045128,
	    9.402849358492148,
	    9.425148822257064,
	    9.449540889596031,
	    9.475971140037373,
	    9.504369830711155,
	    9.534709737251081,
	    9.566930667901762,
	    9.600959724507804,
	    9.636720323191923,
	    9.674061033635413,
	    9.712799028574947,
	    9.75271133464772,
	    9.793480742350749,
	    9.834748222794437,
	    9.876099469716339,
	    9.917120927003229,
	    9.957360756626844,
	    9.996390715105953,
	    10.03380027179466,
	    10.069300712701187,
	    10.102499492181899,
	    10.133300279847873,
	    10.161400217022496,
	    10.186900352022574,
	    10.209800216138225,
	    10.229998975856804,
	    10.24770015602039,
	    10.262999969576162,
	    10.276199935539697,
	    10.287400049705742,
	    10.29680004431801,
	    10.304700020958572,
	    10.311199992925626,
	    10.316499989148781,
	    10.3208,
	    10.324300186325504,
	    10.326999942569323,
	    10.329200062947745,
	    10.330900110768116,
	    10.332200021143153,
	    10.333199973327032,
	    10.333999964695455,
	    10.334600016913614,
	    10.335000014552058,
	    10.335299998559291,
	    10.335499981553205,
	    10.335700003023437,
	    10.33579999960545,
	    10.33579999885358,
	    10.335900000905022,
	    10.335900000411378,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.33590000090692,
	    10.33579999973006,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.335799999457308,
	    10.335799997889367,
	    10.33590000062198,
	    10.33590000050333,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
6889405945d30cdc12bb2cba3ee3b626|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|419|1|V|rust
	    3.9387999991430975,
	    3.938857495057558,
	    3.939029992374593,
	    3.9394199992353753,
	    3.9400200023255874,
	    3.9405506072828556,
	    3.941929968118308,
	    3.94494124979267,
	    3.949710043121497,
	    3.956211989444685,
	    3.965680111137088,
	    3.978887355858084,
	    3.9971896164213354,
	    4.021680276199021,
	    4.053919806380377,
	    4.0952788395341555,
	    4.147420297837358,
	    4.211901996248075,
	    4.2904098962085415,
	    4.384668913783994,
	    4.49612,
	    4.626378131871737,
	    4.776646154015349,
	    4.9488549981466,
	    5.142435352943627,
	    5.358423489711211,
	    5.593932612798939,
	    5.847619763418146,
	    6.115889630322266,
	    6.396207697398362,
	    6.6840483271625795,
	    6.976314066429208,
	    7.266185734065843,
	    7.546111244160505,
	    7.815192311303785,
	    8.069970597690702,
	    8.310574243364147,
	    8.535986941998477,
	    8.746183651945367,
	    8.940613503447796,
	    9.119837792813225,
	    9.283908135499344,
	    9.43380271729935,
	    9.569917263121496,
	    9.694050888018502,
	    9.808173156742438,
	    9.912168428652636,
	    10.006323138799969,
	    10.091400653807613,
	    10.168033928282645,
	    10.236900653727062,
	    10.298569371753427,
	    10.354000501799236,
	    10.404287602839673,
	    10.449599772715418,
	    10.490381192332134,
	    10.526900177058348,
	    10.5594688453592,
	    10.58839996718056,
	    10.613999995164312,
	    10.6366,
	    10.656493465381608,
	    10.674099602936625,
	    10.689756627239047,
	    10.704001049182839,
	    10.717581635913213,
	    10.730199633881007,
	    10.741824928694447,
	    10.752400349336721,
	    10.76183768691201,
	    10.770199954855684,
	    10.777518766096401,
	    10.783800114717605,
	    10.789000090744732,
	    10.79330003386672,
	    10.796781221388564,
	    10.799699933161406,
	    10.802331233938004,
	    10.804700040501185,
	    10.806875008653277,
	    10.808999972471936,
	    10.811275005499555,
	    10.813600045260483,
	    10.815975038588801,
	    10.818300016744887,
	    10.820481238621866,
	    10.822499969466849,
	    10.824312487950268,
	    10.825900012079304,
	    10.827256263547364,
	    10.828300008036576,
	    10.828918754232735,
	    10.829200000632296,
	    10.829137500666139,
	    10.82890000149907,
	    10.828537501297104,
	    10.828399999572207,
	    10.828649998431738,
	    10.829899997688761,
	    10.83298125926752,
	    10.8374,
	    10.84247481176551,
	    10.849599797974443,
	    10.859644362404321,
	    10.873501180444455,
	    10.891868858517212,
	    10.916199162553223,
	    10.947137901252058,
	    10.987801613397307,
	    11.040500563233637,
	    11.108299560218962,
	    11.195294620029074,
	    11.30070233651235,
	    11.425833620835107,
	    11.568501342145268,
	    11.728079155917563,
	    11.901195582676046,
	    12.084737101847567,
	    12.277303543165111,
	    12.476794260338602,
	    12.682197327310643,
	    12.89221297568728,
	    13.105604088296108,
	    13.321019271606094,
	    13.537501613529102,
	    13.753995579108716,
	    13.969596589460812,
	    14.183902028816686,
	    14.396301710943195,
	    14.60660304413771,
	    14.815202085983392,
	    15.022300865359306,
	    15.229101961195955,
	    15.43689955149194,
	    15.648798857968181,
	    15.870501111953832,
	    16.110201294121016,
	    16.376300821770897,
	    16.673599620998395,
	    17.006299196175366,
	    17.3825,
	    17.81672773105336,
	    18.33088576853192,
	    19.046628608352666,
	    20.09418970490948,
	    21.491230281088864,
	    23.36403554732082,
	    25.78376521823396,
	    28.688107928806346,
	    31.859201234384482,
	    35.017082236799915,
	    37.95437646080889,
	    40.59985045611013,
	    42.98048210407093,
	    45.1544184613274,
	    47.16911033788443,
	    49.052955010384366,
	    50.81965651115024,
	    52.47622896820607,
	    54.02872289866365,
	    55.48438187378059,
	    56.8520614050832,
	    58.14146251402683,
	    59.36252223933174,
	    60.524308447319974,
	    61.63472254490186,
	    62.70008343383558,
	    63.72517263243636,
	    64.71280785221128,
	    65.66488300213246,
	    66.58250904660159,
	    67.466303629751,
	    68.31728492887835,
	    69.13689827598066,
	    69.92729589043422,
	    70.69130364581491,
	    71.4320037480388,
	    72.1526020814846,
	    72.8561991609682,
	    73.54488590248961,
	    74.2203,
	    74.88324012052786,
	    75.53348459632291,
	    76.17032050101513,
	    76.79236111728054,
	    77.39811113614508,
	    77.98558255332685,
	    78.55307191271253,
	    79.09881869347045,
	    79.62116841256307,
	    80.11909720281376,
	    80.5914961419686,
	    81.03780872880081,
	    81.45769679012248,
	    81.85130336155706,
	    82.2188836409303,
	    82.56109186151474,
	    82.8785848751381,
	    83.1724050992544,
	    83.44352077267085,
	    83.69319692342157,
	    83.92260698691331,
	    84.13299398095259,
	    84.32556639998398,
	    84.50160125228153,
	    84.66241852240712,
	    84.80909777955165,
	    84.94282414076376,
	    85.06460094063524,
	    85.17548255405232,
	    85.27650096881764,
	    85.36869968841168,
	    85.45309854098299,
	    85.53062397909167,
	    85.60259963171038,
	    85.67009303896315,
	    85.73479893180316,
	    85.7980431308708,
	    85.8619999216585,
	    85.92846399908225,
	    85.9999,
	    86.07860508870539,
	    86.16729773859703,
	    86.26840352296135,
	    86.38450929083348,
	    86.51800266808385,
	    86.6711950564598,
	    86.84609060310302,
	    87.04440737024345,
	    87.2678098308423,
	    87.5176984811532,
	    87.79529755011251,
	    88.101506466041,
	    88.43719723218507,
	    88.80320336842719,
	    89.19981118597049,
	    89.6272890703168,
	    90.08551563972269,
	    90.5738090901216,
	    91.09117717933043,
	    91.63589283179887,
	    92.20581324930026,
	    92.79821148185921,
	    93.40961158196752,
	    94.03640471213421,
	    94.67441331594091,
	    95.31908974501125,
	    95.96600614539847,
	    96.6104051970725,
	    97.2481091983956,
	    97.8747062252834,
	    98.48636734911523,
	    99.07970553088383,
	    99.651798798897,
	    100.19999716506996,
	    100.723002467506,
	    101.21800247342479,
	    101.68600132623887,
	    102.12499948811279,
	    102.53499909813486,
	    102.918,
	    103.27202083159587,
	    103.59999246212048,
	    103.90200943679265,
	    104.18001990091277,
	    104.43500453334619,
	    104.66699331163939,
	    104.87898979530327,
	    105.07200645631241,
	    105.24800695036602,
	    105.40699912885154,
	    105.5509862321857,
	    105.68100249933426,
	    105.7989991161511,
	    105.90499310101568,
	    106.00000245218065,
	    106.08599798052656,
	    106.16400241159704,
	    106.23300119546467,
	    106.29600090418226,
	    106.35199932091506,
	    106.40199862325085,
	    106.44700082257413,
	    106.48799714828864,
	    106.52400025180003,
	    106.55599937952627,
	    106.58499849434241,
	    106.6109993243235,
	    106.63500017410645,
	    106.65500028587994,
	    106.67400018249637,
	    106.69100006278799,
	    106.70500013594169,
	    106.71899997143262,
	    106.73099994180055,
	    106.74100005011003,
	    106.7510000444878,
	    106.75899970585455,
	    106.7669997052772,
	    106.7729999863407,
	    106.78,
	    106.78500031563006,
	    106.78999988832835,
	    106.79400013564693,
	    106.79799976787382,
	    106.80100005596874,
	    106.80399990941137,
	    106.80700020795435,
	    106.81000008164065,
	    106.81199988652543,
	    106.81399998847277,
	    106.81599998600497,
	    106.8170000167957,
	    106.81799998947737,
	    106.82000001178021,
	    106.82100002714502,
	    106.82199997532162,
	    106.82300003853845,
	    106.82399992987605,
	    106.82400001269836,
	    106.82499998928847,
	    106.82499999515238,
	    106.82599997508082,
	    106.82600001557186,
	    106.82700000124032,
	    106.82699999659057,
	    106.82799998678215,
	    106.828,
	    106.82799999865053,
	    106.82800001211264,
	    106.82899995688712,
	    106.82900000902247,
	    106.829,
	    106.829,
	    106.829,
	    106.82899999919178,
	    106.82900000427776,
	    106.83000000097483,
	    106.83000000669797,
	    106.83,
	    106.83,
c276f2e3aae5b79082079f5714485756|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|763|1|V|rust
	    3.3839699989395835,
	    3.3840487437644517,
	    3.3842699903810276,
	    3.384735624825629,
	    3.3854900038512112,
	    3.3862912280687207,
	    3.3880999598306882,
	    3.3917099989920962,
	    3.3973800518739967,
	    3.405183885849205,
	    3.4164701323918063,
	    3.4321248326801963,
	    3.453609551704515,
	    3.482146469649636,
	    3.519339777655313,
	    3.56667197412332,
	    3.625730336042383,
	    3.6980913883908952,
	    3.7852698853256537,
	    3.8888564215194035,
	    4.0102,
	    4.150794807316553,
	    4.311795892941468,
	    4.494954121810155,
	    4.699976214930413,
	    4.927911218293275,
	    5.176482196900135,
	    5.444893579507091,
	    5.729750258626947,
	    6.029061098885618,
	    6.337818201506156,
	    6.652822969680463,
	    6.9666562245634225,
	    7.271231690587198,
	    7.565352533586669,
	    7.845235954042654,
	    8.110553641754548,
	    8.359949946825193,
	    8.59272403967336,
	    8.807570499056927,
	    9.00494757517125,
	    9.18429186814512,
	    9.347362952209552,
	    9.495029957384766,
	    9.629400961950292,
	    9.752973734862081,
	    9.865448301893807,
	    9.967108712735158,
	    10.058700701881913,
	    10.14078523513029,
	    10.21420069474718,
	    10.2795819076444,
	    10.338100529303755,
	    10.391075108886902,
	    10.438699761340171,
	    10.481537438750442,
	    10.519800185143403,
	    10.553781350015388,
	    10.583799966065143,
	    10.610118744432556,
	    10.6332,
	    10.65343721086418,
	    10.671299597352577,
	    10.687200386274478,
	    10.701701071584862,
	    10.715606640925841,
	    10.728599621802584,
	    10.740662429708268,
	    10.751700366541062,
	    10.761618946103374,
	    10.770399952742551,
	    10.777987514603408,
	    10.784400114885585,
	    10.789543840025653,
	    10.793700032836007,
	    10.797049973942578,
	    10.79979993789156,
	    10.802181234797406,
	    10.804300036285406,
	    10.806275005726231,
	    10.80829997290033,
	    10.810675008065274,
	    10.813200049389502,
	    10.815812542296054,
	    10.818400018605427,
	    10.82083123701361,
	    10.8230999655015,
	    10.825181236330375,
	    10.827000013496429,
	    10.828493764882047,
	    10.829600008371425,
	    10.83021250346392,
	    10.830399998814471,
	    10.830106250382935,
	    10.829600002909952,
	    10.829000001894816,
	    10.828699998716642,
	    10.828868747660579,
	    10.83029999725666,
	    10.834075011178859,
	    10.8395,
	    10.845681023602184,
	    10.854299756293019,
	    10.86640072989741,
	    10.883001405083759,
	    10.904843878232874,
	    10.93379900226057,
	    10.970500500305192,
	    11.019401960977774,
	    11.083906919233751,
	    11.167799453551327,
	    11.27754482503736,
	    11.408502862062473,
	    11.559602804184298,
	    11.726601524068334,
	    11.90507898935648,
	    12.094495202826907,
	    12.293349519026512,
	    12.500103797163375,
	    12.713206829095649,
	    12.93119717296118,
	    13.152519220199826,
	    13.375904265336509,
	    13.599899423093277,
	    13.823501659544904,
	    14.045595477169236,
	    14.265496532622665,
	    14.482602050526342,
	    14.696801721875234,
	    14.908003048983103,
	    15.116602085146253,
	    15.323500863266368,
	    15.529801958508713,
	    15.737699550277814,
	    15.950798846416452,
	    16.176101137251248,
	    16.423301347251392,
	    16.70280087021931,
	    17.019999592881767,
	    17.379599126059833,
	    17.7909,
	    18.270631701571034,
	    18.886282262611214,
	    19.810533868948983,
	    21.014403816051455,
	    22.6405354400298,
	    24.837624307484827,
	    27.677842245112068,
	    31.059624742778315,
	    34.68787520006785,
	    38.20338054032787,
	    41.35827519819795,
	    44.08965109338545,
	    46.459982467376946,
	    48.56451768154225,
	    50.4770155788509,
	    52.240658134062045,
	    53.87705209265294,
	    55.39742647308172,
	    56.8108207705348,
	    58.12718365397002,
	    59.35806532439285,
	    60.51556636614012,
	    61.61151997509638,
	    62.65630760906369,
	    63.65852039676292,
	    64.62468493956084,
	    65.55887499903574,
	    66.46320720601332,
	    67.33858434423519,
	    68.18490835611833,
	    69.00220335949038,
	    69.79048602738794,
	    70.5509983988954,
	    71.28569617578638,
	    71.99760340213557,
	    72.69000351079194,
	    73.3664019579262,
	    74.02969920721264,
	    74.68198661689348,
	    75.3246,
	    75.95773837641659,
	    76.5804852316591,
	    77.19151967954201,
	    77.7886626799343,
	    78.36971067439409,
	    78.93218331877144,
	    79.47377324503925,
	    79.99251772483608,
	    80.48647021574627,
	    80.95449737927565,
	    81.39559641067538,
	    81.80920805965577,
	    82.19539706002443,
	    82.55430305264244,
	    82.88668527392075,
	    83.19329274218097,
	    83.47515986863573,
	    83.73360446463396,
	    83.96989554534252,
	    84.18549735561933,
	    84.38183905931078,
	    84.5602949171765,
	    84.72228550370983,
	    84.86910104011582,
	    85.00213108401348,
	    85.12249818494024,
	    85.23144929178228,
	    85.33000075924294,
	    85.41926354891706,
	    85.50020077443466,
	    85.57379975195202,
	    85.64109883606507,
	    85.70299918661287,
	    85.76089970199104,
	    85.81587440276637,
	    85.86979909693483,
	    85.9241182235268,
	    85.98119992864254,
	    86.04299897252092,
	    86.1122,
	    86.19130520069095,
	    86.28329762412618,
	    86.39070377964339,
	    86.51631012470597,
	    86.66260293703776,
	    86.83179452602216,
	    87.02578955993744,
	    87.2464081995925,
	    87.49491093540041,
	    87.7726983130649,
	    88.08059728588013,
	    88.41940714660666,
	    88.78989694991898,
	    89.19250369915848,
	    89.62731224417233,
	    90.09438807988965,
	    90.59311699253986,
	    91.12260983686882,
	    91.68127541057189,
	    92.26689231034163,
	    92.87691414475941,
	    93.50771219649683,
	    94.15541223413081,
	    94.81550494706401,
	    95.4832138931542,
	    96.15358937333521,
	    96.82140632176937,
	    97.48180530423376,
	    98.13000931202002,
	    98.76170624872508,
	    99.37296751786185,
	    99.9605054543766,
	    100.52199882732157,
	    101.05399726242167,
	    101.55700236082052,
	    102.02800233824621,
	    102.46800124142977,
	    102.87699952549443,
	    103.2549991740175,
	    103.603,
	    103.92201865274248,
	    104.21399332758733,
	    104.48000823751889,
	    104.72101716282664,
	    104.94000388661394,
	    105.13799432822954,
	    105.31599147646948,
	    105.4770053190239,
	    105.62100569611079,
	    105.75099929117114,
	    105.8669889656256,
	    105.97100198200053,
	    106.06399930686312,
	    106.14699461375038,
	    106.22100189569144,
	    106.28699846174712,
	    106.34600184999128,
	    106.39900090036218,
	    106.44600067813667,
	    106.48799949229294,
	    106.52499898682889,
	    106.55800060343306,
	    106.5879979226772,
	    106.61400018729906,
	    106.63799953634835,
	    106.65899893235168,
	    106.67699953292117,
	    106.69400012956741,
	    106.70900020108502,
	    106.72200012724518,
	    106.73400004534686,
	    106.74400008852021,
	    106.75299998107411,
	    106.76199995590956,
	    106.76900003556192,
	    106.77600002823267,
	    106.78099980816616,
	    106.78699977895873,
	    106.79099999165261,
	    106.795,
	    106.79900026472362,
	    106.80299992023633,
	    106.80500009223833,
	    106.80799982062926,
	    106.81000005596869,
	    106.81299992451235,
	    106.81400010944914,
	    106.81600007581007,
	    106.8179998968443,
	    106.81899999519676,
	    106.81999999160291,
	    106.82100002015498,
	    106.82199999210815,
	    106.8230000088352,
	    106.82400003166985,
	    106.82499998354879,
	    106.82500002752529,
	    106.82599991234072,
	    106.82600001269836,
	    106.82699998928847,
	    106.82700000484743,
	    106.82699999003177,
	    106.8280000062294,
	    106.828,
	    106.828,
	    106.82799999471271,
	    106.82900000316936,
	    106.829,
	    106.829,
	    106.829,
	    106.829,
	    106.829,
	    106.82899998195742,
	    106.82999999559071,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
5361a6339862d850821e32ac5fac063d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1045|1|V|cpp
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    SM_GEFF_SPLINE(SM_GEFF_DATA.begin(), SM_GEFF_DATA.end(), SM_LOG_TEMP_MIN,
	                   SM_LOG_TEMP_STP);
36194b60c6ead22c53f8d6af7f57478f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1052|8|v|cpp
	GEFF_SPLINE
0f3ecbdd94c5e71a746dc5d221b89a4e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1052|29|v|cpp
	GEFF_DATA
9d94ae6853bc0aa638204e214ecf8df8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1055|1|V|cpp
	double sm_geff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_GEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_GEFF_DATA[0];
	  } else {
	    return SM_GEFF_DATA[340];
	  }
	}
9dec5e91a21ae9eb0e6b5c114587dbae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1066|1|V|cpp
	double sm_heff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_HEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_HEFF_DATA[0];
	  } else {
	    return SM_HEFF_DATA[340];
	  }
	}
86b1b91958626330102d8deab948715c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1080|15|v|cpp
	HEFF_SPLINE
4e17aadd7af9717779ed02712ef080a4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1082|15|v|cpp
	HEFF_DATA
b00bcd27b27fa17c1e857289b7e2bcb4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1055|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in energy of the standard model at a
	 * temperature tsm.
	 */
4a9217e43c0662be11a2d60f19f627e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1070|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
	 */
4fa1bf649121e4b0cc58915c6928f7e2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1086|1|V|cpp
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
490e851a364c754e30da9ccdd68f4a9c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1100|1|V|cpp
	double sm_energy_density(const double tsm) {
	  using boost::math::pow;
	  return pow<2>(M_PI) / 30.0 * sm_geff(tsm) * pow<4>(tsm);
	}
ed0d30b76509dbbefcb00cc83f6e9948|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1100|1|V|cpp
	/**
	 * Compute the total energy density of the standard model at a temperature tsm.
	 */
71084c2a2e4deac2e6efdc72ba72797b|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|75|1|V|rust
	    2.141289997868463,
806421c81d9f5a8aafb8cf9d024f7111|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|12|1|V|cpp
	static constexpr double SM_SQRT_GSTAR_0 = 2.141289997868463;
c0e4f7cd19b2e3d3dcdd9a849a39b588|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|356|1|V|cpp
	    10.3359,
1fcbdb41717d3f2cdd7aeb7484f1d150|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|14|1|v|cpp
	2.141289997868463
841b23beb37beae9d5f2ba61f75017e6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|12|1|V|cpp
	static constexpr double SM_SQRT_GSTAR_STR = 2.141289997868463;
	static constexpr double SM_SQRT_GSTAR_END = 10.3359;
dc0f6128d11cb60a2dc13d171a99befb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|16|28|v|cpp
	SQRT_GSTAR_STR
77a7ce93a5ffc4e07202513a6383b2c8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|17|28|v|cpp
	SQRT_GSTAR_END = 10.3359;
ddfed699039325adccf59b095637b570|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|17|28|v|cpp
	SQRT_GSTAR_END
870359f3f90cd239a9ddb71771245d3e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|419|1|V|rust
	    3.9387999991430975,
753f42d3cb2de0899e2d4bff3d47dc19|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|759|1|V|rust
	    106.83,
a8d11b51874212a5cb3ebb5e6092b882|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|22|1|v|cpp
	10.3359
2838b823adb9bc85b4137ad48ddffda5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/standard_model.rs|763|1|V|rust
	    3.3839699989395835,
6163d82d8069334eed4ddf7970a73107|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1088|12|v|cpp
	SM_HEFF_DATA[0];
aaf0c496f5817ea92d4414b7c311f7d8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1090|12|v|cpp
	SM_HEFF_DATA[340];
54747c8be0ef6bef16ee92adb44b6d48|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1103|12|v|cpp
	SM_SQRT_GSTAR_DATA[0];
3ac156a544825544080f64b684d1eee9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1105|12|v|cpp
	SM_SQRT_GSTAR_DATA[340];
7564f0c7f86e3f1083aa031722d404d9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1073|12|v|cpp
	SM_GEFF_DATA[0];
6f184bc05eafd2c20e3014282cbc24c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1075|12|v|cpp
	SM_GEFF_DATA[340];
a1bbf1c3d972fb4b9ee524b95fb4a3ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|10|1|V|cpp
	double neq_eta(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) * gsl_sf_bessel_Kn(2, x);
	}
31ee50f567cdbe1a1bad0160cfb58ec1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|11|1|V|cpp
	/**
	 * Compute the equillibrium number density of the eta using the leading order
	 * approximation valid for large x.
	 */
874eb107b65a0718ab07c98715df7100|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|23|28|v|cpp
	large x.
4b6627986704d5b5ed5b9408a77a319a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|16|1|V|cpp
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
7e7915f50dd819bf0dc12745640da5d3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|33|1|V|cpp
	double heff_eta(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return 45.0 / (4.0 * pow<4>(M_PI)) * pow<3>(x) * gsl_sf_bessel_Kn(3, x);
	}
28e45d6b4be534f3bf191f5ff10ad314|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|27|1|V|cpp
	  const double x = model.get_m_del() / td;
	  const double g = double(model.get_n() + 1);
0331090926d93531625f62bafdb02927|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|41|1|V|cpp
	  const double x = model.get_m_eta() / td;
6e39b75315189dd5158b97d03a2d38b4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|34|1|V|cpp
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return 45.0 / (4.0 * pow<4>(M_PI)) * pow<3>(x) * gsl_sf_bessel_Kn(3, x);
1c9f001a38fa5df234ee09f741fc2902|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|40|1|V|cpp
	  using boost::math::pow;
	  const double x = model.get_m_del() / td;
	  const double g = double(model.get_n() + 1);
	  return g * 45.0 / (4.0 * pow<4>(M_PI)) * pow<3>(x) * gsl_sf_bessel_Kn(3, x);
ed53f3122595813f0f3985b524be6adf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|52|2|V|cpp
	  using boost::math::pow;
065397ccb01c531fa9d6582876dca6b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|52|3|V|cpp
	  const double x = model.get_m_del() / td;
f43803e29b5217775b6b57d3d152846a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|53|1|V|cpp
	  const double g = double(model.get_n() + 1);
ea551a204d258a314925ec288a4c28d4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|53|10|v|cpp
	45.0 / (4.0 * pow<4>(M_PI))
e33b07e984ed7466b849ab98ad77a88a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|55|14|v|cpp
	45.0 / (4.0 * pow<4>(M_PI)) * 
47c92b4092d1154dca451ed8da88e8a8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|53|1|V|cpp
	  double get_m_eta() const { return m_mu_eta * m_lam / sqrt(double(m_n)); }
	  double get_m_del() const { return m_mu_del * m_lam * double(m_n); }
c2842dbd4d7707a0b61d70cca39dd7da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|55|30|v|cpp
	return m_mu_eta * m_lam / sqrt(double(m_n));
b51084cd06d55e9608bdb09feb3592df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|30|v|cpp
	return m_mu_del * m_lam * double(m_n);
bd4176fdd777fce42dcb32df3ecd5cf3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|28|20|v|cpp
	double(model.get_n() + 1);
a7f2a890ac58108083fbd8446abf4e90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|28|1|V|cpp
	  const double g = model.get_g_del();
db8057d5c0aa8e82fb073dab7f764ee7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|33|1|V|cpp
	double heff_eta(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return 45.0 / (4.0 * pow<4>(M_PI)) * pow<3>(x) * gsl_sf_bessel_Kn(3, x);
	}
	
	double heff_del(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  return g * 45.0 / (4.0 * pow<4>(M_PI)) * pow<3>(x) * gsl_sf_bessel_Kn(3, x);
	}
309e012c235f2f658f685db5789b9dcd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|33|1|V|cpp
	double dark_heff(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double xe = model.get_m_eta() / td;
	  const double xd = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  return pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	         g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd);
	}
d940cdf833e593b48605781b4eabd09b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|51|10|v|cpp
	pow<3>(xe) * gsl_sf_bessel_Kn(3, xe)
112ea61d0335052c9308ed9edac8f375|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|49|1|V|cpp
	  const double geffe =
	      pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) + 3.0 * gsl_sf_bessel_Kn(2, xe));
549153da06bcd7a071c297ef9233f192|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|53|1|V|cpp
	  return pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	         g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd);
39ae1382ac4cfabb14469b86f82adc4b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|57|1|V|cpp
	static double dark_heff_inf(const DarkSun model) {
	  const double n = double(model.get_n());
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	}
15f1e0b255efe01806f17102d7e1fb48|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|62|20|v|cpp
	heff_inf
1402dbaa8a6ddd200938f72478d635e9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|64|24|v|cpp
	+ 2.0 * (n * n - 1.0);
7ebc47018f3ca7feaa7254e99af4efe0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|64|3|V|cpp
	  return 7.0 / 2.0 * n 
20f2297b42c1f35573bff755633f7588|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|63|19|v|cpp
	 double(model.get_n())
ad83a5e7be57ca1e8548265d08db2677|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|63|3|V|cpp
	  const double n = double(model.get_n());
cc3124df53c1ab45c6a6f13a696ded06|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|75|1|V|cpp
	static double xi_upper_bound_const_td(const double td, const DarkSun model);
175eef826f3d1b37ddd5f278c8026109|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|75|1|V|cpp
	static double xi_upper_bound_const_td(const double td, const DarkSun model);
	static double xi_lower_bound_const_td(const double td, const DarkSun model);
ea9d1157c2a0ae331a61251721e733ab|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|71|1|V|rust
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd * SM_HEFF_0 / SM_HEFF_INF).cbrt() * self.xi_inf
a384c5969346d969a5eafb5e8ec36941|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|77|4|v|cpp
	hd_inf
29958a8f680e96ee8cec81fc9a430fd8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|77|62|v|cpp
	.cbrt()
b51100f6e6ce0a91d8cdaeabde71e65e|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|76|1|V|rust
	        let hd = self.dark_heff(td);
	        (self.hd_inf() / hd).cbrt() * self.xi_inf
c2060d7c8e36b311bc3c018b0777205d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|84|30|v|cpp
	self.xi_inf
47fac0f41cdff915b1982118ea7cd6b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|84|15|v|cpp
	self.hd_inf()
4ca94d617a090bb13b2ccdee9af9aec5|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|82|1|V|rust
	        (sm_heff(tsm) * self.hd_inf() / self.sum_g() / SM_HEFF_INF).cbrt() * self.xi_inf
bdc87ee1c1e1c602cdf1db2f2fb809b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|91|51|v|cpp
	self.sum_g()
f424cc42d845e1bc9bdf9356f3492859|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|91|87|v|cpp
	 * self.xi_inf;
92f00f68f0219a40a3ae1ffc22729bf2|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|87|1|V|rust
	        let xl = self.m_eta / tsm;
	        let hsm = sm_heff(tsm);
	
	        let lw_arg_num = (45.0 * SM_HEFF_INF * xl * xl * xl).powi(2);
	        let lw_arg_den = (4.0 * self.hd_inf() * hsm * self.xi_inf).powi(2) * PI.powi(7);
	        return 2.0 * xl / (lw_arg_num / lw_arg_den).lambert_w0();
202e89dfa8f4fb0ac822297c2a49e1e4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1088|20|v|cpp
	BEG;
3450a92350f14261fcfaae6eccc95191|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1090|20|v|cpp
	END;
b309bcd5e7d3242ff0679ab442796d5d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|92|67|v|cpp
	 * xl * xl
cd53a14703b6600be06b8db1b6b787ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|94|70|v|cpp
	.powi(7)
089c7dbbbf9902e010e6c8a2bcf57307|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|96|1|V|rust
	        let hd = self.dark_heff(td);
	        let c1 = self.hd_inf() * self.xi_inf.powi(3) / SM_HEFF_INF;
	        let lb = 0.8 * self.xi_lower_bound_const_td(td);
	        let ub = 1.2 * self.xi_upper_bound_const_td(td);
de1101640bea13c6a02437be64178e9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|108|69|v|cpp
	.powi(3
0a01377efaa9d3c82bbbf11df0088d69|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|105|1|V|cpp
	double compute_xi_const_td(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double hd = dark_heff(td, model);
	  const double c1 =
	      dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	  const double lb = 0.8 * xi_lower_bound_const_td(td, model);
	  const double ub = 1.2 * xi_upper_bound_const_td(td, model);
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	}
c95aae4abde0bd3c09e5f6707ecaaaa7|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/model/thermal_functions.rs|117|1|V|rust
	                let ub = 1.2 * self.xi_upper_bound_const_tsm(tsm);
	                let lb = 0.8 * self.xi_lower_bound_const_tsm(tsm);
	                let hsm = sm_heff(tsm);
	                let c1 = hsm * self.hd_inf() * self.xi_inf.powi(3) / SM_HEFF_INF;
a8aa8cf5fb3a328e81caa9001031a4d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|120|1|V|cpp
	  const double hd = dark_heff(td, model);
	  const double c1 =
	      dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	  const double lb = 0.8 * xi_lower_bound_const_td(td, model);
	  const double ub = 1.2 * xi_upper_bound_const_td(td, model);
d8ee689f38a2f0babe29d1d00c7555b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|126|12|v|cpp
	hd * pow<3>(xi) - sm_heff(td / xi) * c1;
168c98408dc90c35a276f422f9356694|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|125|13|v|cpp
	hd, td, 
f492bb32cc0ef9c05001c4749979e56a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|27|1|V|cpp
	  std::optional<double> m_xi_fo{};
	  std::optional<double> m_tsm_fo{};
	  std::optional<double> xi_bbn{};
	  std::optional<double> xi_cmb{};
	  std::optional<double> rd_eta{};
	  std::optional<double> rd_del{};
	  std::optional<double> dneff_cmb{};
	  std::optional<double> dneff_bbn{};
	  std::optional<double> eta_si_per_mass{};
	  std::optional<double> del_si_per_mass{};
9bfa724352f8ec8a7eee1d5da0651da9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|119|3|V|cpp
	  if model.get
a935d92c67cfb4b174236dbaccce989a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|121|3|V|cpp
	  if tsm_fo.has
d485b253da7af9181764acc7cf1f4a37|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|123|1|V|cpp
	    const double xi_fo = model.get_xi_fo().value();
bb8f4e40abe68bc05cda3b8059f33277|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|123|24|v|cpp
	model.get_xi_fo().value();
3664f0ce65aed32018f8364a11bb82d5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/thermally_decoupled_model.hpp|169|1|V|cpp
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    std::pair<double, double> res = bisect(f, 0.8 * lb, 1.2 * ub, tol);
	    return (res.second + res.first) / 2.0;
2dfdfb7841ee6e74e996800e49379fd9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|147|1|V|cpp
	    // Perform bisection algorith to find xi.
a0ed9cac00af41ca7ce7f42ac7287504|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|147|1|V|cpp
	    // Perform bisection algorith to find xi.
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	    std::pair<double, double> res = bisect(f, 0.8 * lb, 1.2 * ub, tol);
	    return (res.second + res.first) / 2.0;
f989c1935374552a3324f5b1e5ebeee3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|142|1|V|cpp
	    using boost::math::pow;
fe253e1a7605c2f0a6a74c5c1cf86e31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|126|1|V|cpp
	  using namespace boost::math;
	  using namespace boost::math::tools;
4b412f547e509b34082939cb83509f2a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|136|1|V|cpp
	    const double tfo = tsm_fo.value();
	    const double xifo = model.get_xi_fo().value();
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tfo * xifo > model.get_m_eta()) {
	      return xifo;
	    } else {
	      return xifo * tsm / tfo;
	    }
14937fa0d42673593dc565d3bb4b3b8e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|137|5|V|cpp
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double ub = 1.2 * xi_upper_bound_const_tsm(tsm, model);
	    const double lb = 0.8 * xi_lower_bound_const_tsm(tsm, model);
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	    auto f = [c1, model, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, model) * pow<3>(xi) - c1;
	    };
	
	    // Perform bisection algorith to find xi.
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	    std::pair<double, double> res = bisect(f, 0.8 * lb, 1.2 * ub, tol);
	    return (res.second + res.first) / 2.0;
e1ddfe90c5fb0c8bbb19e9c2e74d3af8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|133|1|V|cpp
	  // If tsm_fo has a value, that means the eta has frozen out. In this case,
	  // there is no need to perform a root finding algorithm. We just readshift.
5700a74277de08bc0d64d4f3248a2059|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|128|16|v|cpp
	temperature 
f2e0ea407bee3ed257bb13e107112a75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|129|48|v|cpp
	tempertare.
952663007dbc07fbd52e0dd121167e5b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|127|1|V|cpp
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
12ad2188102dca093b329d45b59578f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|109|33|v|cpp
	standard model temperature.
d78759f3e182fc7fd78c04de6d2c9827|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|78|1|V|cpp
	/**
	 * Compute the upper bound on xi = Td / Tsm when Td is held fixed.
	 */
5ef3af30d56a49707f40fdbc72b4c238|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|81|18|v|cpp
	upper_
e1ec84736081610a3981e5a0f9009a86|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|89|1|V|cpp
	  return cbrt(dark_heff_inf(model) / hd) * model.get_xi_inf();
6204447005914786a695b6b874977801|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|90|1|V|cpp
	static double xi_lower_bound_const_td(const double td, const DarkSun model) {
	  const double hd = dark_heff(td, model);
	  return cbrt(dark_heff_inf(model) / hd) * model.get_xi_inf();
	}
d193937022f7089db3da28f791de64d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|104|1|V|cpp
	  return cbrt(sm_heff(tsm) * dark_heff_inf(model) / dark_sum_g(model) /
	              SM_HEFF_INF) *
	         model.get_xi_inf();
c9ed76993a7c316cf9a851c6ce58a352|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|108|32|V|cpp
	static double xi_lower_bound_const_tsm(const double tsm, const DarkSun model) {
	  return cbrt(sm_heff(tsm) * dark_heff_inf(model) / dark_sum_g(model) /
	              SM_HEFF_INF) *
	         model.get_xi_inf();
	}
dd6f19eab836257f5d8673b76755f4c9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|102|26|v|cpp
	sm_heff(tsm)
87a9c460498dfa1e0dfd22cd7aae370f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|99|20|v|cpp
	dark_heff_inf(model)
4eae3a828728883d4ad793499d3e8979|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|118|3|V|cpp
	  const double lb = 0.8 * xi_lower_bound_const_td(td, model);
c865eaf23705f3162869aa6417d3e50b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|118|3|V|cpp
	  const double ub = 1.2 * xi_upper_bound_const_td(td, model);
104f49966c9e1d73e48c22875f2db590|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|144|1|V|cpp
	    const double ub = 1.2 * xi_upper_bound_const_tsm(tsm, model);
	    const double lb = 0.8 * xi_lower_bound_const_tsm(tsm, model);
053635088c7d207a2635830c862fd936|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|90|8|v|cpp
	std::pair<double, double>
b36a6ea46b34a5c0fd88bea27381a604|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|118|1|V|cpp
	  const auto bounds = xi_bounds_const_td(td, model);
9ea795559338c5d4eadfd8d16dc83f27|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|123|3|V|cpp
	  // Perform bisection algorith to find xi.
64f7a1d3533f2d67c0761fc084f7f229|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|145|5|V|cpp
	    const auto bounds = xi_bounds_const_tsm(tsm, model);
1df4eec82cc7409640b381123e75dbc9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|152|1|V|cpp
	    // Function specifying when to stop bisection algorithm
db0e2bd1bd1dd99355fbbfd67cd0fc8a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|122|1|V|cpp
	  // Tolerance function
48ca252f776423c29a4c157dba8ddae4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|158|1|V|cpp
	    // Return average of the bounding points
d98a2b4040f59f1322951e618c99d3e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|11|12|v|cpp
	standard model
285312a91ab854e79330172e14ef8b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|45|1|V|cmake
	# Stiff differential equations (Radau and Rodas)
e132372b3f0662a6245a4efa56716f57|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|42|3|v|cmake
	lanre::diffeq
7792f7b292f003662904e318769f1982|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|41|1|V|cmake
	# --------------------------------------------------------------------------
	# Test model: Make sure everything compiles
	# --------------------------------------------------------------------------
	
	add_executable(test_model test_model.cpp)
	set_property(TARGET test_model PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_model PUBLIC
	        darksun
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_model PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
048cfd1b6031e07dd0cb573ad4ad29c5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|59|3|v|cmake
	Test model: Make sure everything compiles
602009d5aea1c1ef06fd777968f7e80e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|42|3|v|cmake
	Test model
9484699e2fcd8e62d87207e4d312da06|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|62|16|v|cmake
	test_model
26b5ae6149c953f3819d6424232a07d4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|62|24|v|cmake
	test_model.cpp
228cc010192659aba030d5529250a7ed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|62|16|v|cmake
	$TEST_XI
e6bd9d789ed863e4c0cfc65843aa8594|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|61|1|V|cmake
	set(TEST_XI test_xi)
e1b849f9631ffc1829b2e31402373e3c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|7|21|v|cpp
	Test1
0123f32a924385e1cf188b42d6dcde15|file:///Users/loganmorrison/.config/fish/config.fish|3|78|v|fish
	,/usr/local/opt/lapack/lib,/usr/local/opt/openblas/lib
c6e9f7ef33829df5d8b7e2922e8f16fd|file:///Users/loganmorrison/.config/fish/config.fish|5|48|v|fish
	,/usr/local/opt/lapack/include,/usr/local/opt/openblas/include"
56554002fbc09c6897c8228c101b7ff6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|13|3|v|cpp
	std::cout << 
d8961f9d2de31b5ad68cc3328d6cccd8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|103|49|v|cpp
	model.get_xi_inf();
d8a8eed05c1a1cf3197b1fd3c6a55d77|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|103|12|v|cpp
	dark_heff_inf(model) / hd
7734bd40d595aea17f45407554f07c89|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|103|15|v|cpp
	cbrt(
2add88319aa8f18ef3b712bf4744643e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|102|26|v|cpp
	rhd * 
497a853bba0fee2efc1d3d7b0f91b063|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|123|26|v|cpp
	dark_sum_g(model)
25882da8f8323d44f2e8f5f82f9259a2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|9|1|V|cpp
	TEST(TestComputeXi, TestFixedTd) {
	  auto model = DarkSun(20, 1e-3);
	  double td = model.get_lam() / 2.0;
	  double xi = compute_xi_const_td(td, model);
	  fmt::print("td, xi = {}, {}", td, xi);
	}
d331c0ece16b700d20fe328fcdd0b1b9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|22|16|v|cpp
	xi / td;
18d7f60f501f70ed6805cefe880f74be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|135|1|V|cpp
	  const double hd = dark_heff(td, model);
	  const double c1 =
	      dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
c9e999f7ac5e33114e7347a9f1604f90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|165|1|V|cpp
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	    auto f = [c1, model, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, model) * pow<3>(xi) - c1;
	    };
3deeb719a8613d30d2087b8d597dbb7f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|47|3|V|cpp
	  // Compute xi at smaller tsm
097bc5aabec00a40cd08f45a362ffb51|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|38|1|V|cpp
	  const double hsm = sm_heff(tsm);
	  const double c1 =
	      hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
7e5dc00749d7236a8261961c9c78a517|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|47|32|v|cpp
	 * 1e-2
8f52e1e87f26e6d36eab24b4607e5cce|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|49|14|v|cpp
	model.get_tsm_fo().has_value()
0d4d4ae796767d42ae448bdebdf80af3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|40|9|v|cpp
	m_n(n),
1611f9d663187b6b90c9fb7b8c1b80f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|40|9|v|cpp
	m_n(n), 
4f332934f04df141785d73f3e150780a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|13|54|v|cpp
	dxdt
e765ee83faadbacec7c33da95a986e03|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|12|1|V|cpp
	struct boltzmann {
	  void operator()(const vector_type &w, vector_type &dw, double logx) {}
	};
ab801b9b525b5319a490356a3b052a1e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|17|41|v|cpp
	vector_type
70c7e6187207b54ac590a976126a6365|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|17|1|V|cpp
	  boltzmann(std::shared_ptr<DarkSun> model) : model(model) {}
2d9676d4c6b94d1ef0c985a253c28116|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|15|1|V|cpp
	  std::shared_ptr<DarkSun> model;
f239b2e287f10e48d79d20cf33d51d00|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|252|1|V|cpp
	    double x = exp(logx);
	    double meta = model->m_eta.get_mass();
	    double Tsm = meta / x;
	    double xi = model->compute_xi(Tsm);
	    double Td = xi * Tsm;
	    double s = sm_entropy_density(Tsm);
	
	    double neq = model->m_eta.neq(Td);
	    double weq = log(neq / s);
dc98312a70e29b78f98171441cd6f5b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|24|17|v|cpp
	model->compute_xi(Tsm);
7a481c90b480c0a568f3464760e7ca1f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|29|18|v|cpp
	model->m_eta.neq(Td);
d9c726a16617aba7532ab2346d53be18|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|264|1|V|cpp
	    // Determine if the eta' has frozen out
	    if (w(0) - weq > 0.1 && model->m_xi_fo == -1.0) {
	      model->m_xi_fo = xi;
	      model->m_Tsm_fo = Tsm;
	    }
	    // save xi at BBN
	    if (Tsm < kT_BBN && model->m_xi_bbn == -1.0) {
	      model->m_xi_bbn = xi;
	    }
42df60349d7d78a5a02fa9d8834ca3b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|34|35|v|cpp
	->m_xi_fo == -1.0
38d00394ac46d06b845d3eff6b64b35c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|35|14|v|cpp
	m_xi_fo
35140b68e7615617f88752abf257d8c6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|58|1|V|cpp
	  std::optional<double> get_xi_fo() const { return m_xi_fo; };
	  std::optional<double> get_tsm_fo() const { return m_tsm_fo; };
	  std::optional<double> get_xi_bbn() const { return m_xi_bbn; };
	  std::optional<double> get_xi_cmb() const { return m_xi_cmb; };
	  std::optional<double> get_rd_eta() const { return m_rd_eta; };
	  std::optional<double> get_rd_del() const { return m_rd_del; };
	  std::optional<double> get_dneff_cmb() const { return m_dneff_cmb; };
	  std::optional<double> get_dneff_bbn() const { return m_dneff_bbn; };
	  std::optional<double> get_eta_si_per_mass() const {
	    return m_eta_si_per_mass;
	  };
	  std::optional<double> get_del_si_per_mass() const {
	    return m_del_si_per_mass;
	  };
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
e3f9f567fa7e480d51b059331a2bb10e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|94|3|v|cpp
	std::optional<double>
a9def88a260215861335f80d1bafab18|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|86|39|v|cpp
	value_or
bb8b7771396630038743b5619c86a5bb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|34|14|v|cpp
	set_xi_fo
50949f36ba91a6785f7616eae29834dc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|34|27|v|cpp
	 = xi;
205e15ae67c7f2498318591655c1b9f3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|35|29|v|cpp
	 = Tsm;
0b0312227bc0afb08348d09a77a4530c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|38|25|v|cpp
	model->m_xi_bbn == -1.0) {
fc6f84c7b3f987b09226c919bcba8b3a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|274|1|V|cpp
	    double sig_ee_eeee = model->thermal_cross_section_2eta_4eta(meta / Td);
	    double sig_eeee_ee = sig_ee_eeee / neq / neq;
	    sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
	
	    double sig_ee_dd = model->thermal_cross_section_2eta_2delta(meta / Td);
	
	    double pf_e =
	        -sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) * Tsm * s * s;
	    double pf_d = sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) *
	                  meta / (x * x);
	
	    // dW_e / dlogx
	    dw(0) = pf_e * sig_eeee_ee * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
	
	    // dY_d / dlogx
	    dw(1) = pf_d * sig_ee_dd * exp(2.0 * w(0));
6b8468d9939c973d017e7de514d700d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|42|4|V|cpp
	    double sig_ee_eeee = model->thermal_cross_section_2eta_4eta(meta / Td);
bc40b52ce4434a2bc1f6b99fbd5683b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|42|19|v|cpp
	sig_ee_eeee / neq / neq;
8cbbfe5a372649237832f0fe40b71b50|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|43|5|V|cpp
	    sig_eeee_ee = std::isnan(sig_eeee_ee) ? 0.0 : sig_eeee_ee;
2995eedb543f3db1543ffa568eb29752|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|45|53|v|cpp
	meta / Td
0ba829edda1db75090ac30484abf1ec9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|49|10|v|cpp
	sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi)
b303908f2bcb8bc92e95be49fe4e0671|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|49|19|v|cpp
	sqrt(M_PI / 45) * kM_PLANK * model->sqrt_gstar(Tsm, xi) *
c88111c4fec729fef4fcf49c524b92ac|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|206|1|V|cpp
	    double gd = dark_geff(Tsm * xi);
	    double gsm = sm_geff(Tsm);
	    return sm_sqrt_gstar(Tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
2f55b34a3ff40c0c4c07c3e4f9282724|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|24|1|V|cpp
	    const double x = exp(logx);
	    const double meta = model->get_m_eta();
	    const double tsm = meta / x;
	    double xi = compute_xi_const_tsm(tsm, *model);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	
	    double neq = neq_eta(td, *model);
	    double weq = log(neq / s);
	
	    // Determine if the eta' has frozen out
	    if (w(0) - weq > 0.1 && !model->get_xi_fo().has_value()) {
	      model->set_xi_fo(xi);
	      model->set_tsm_fo(tsm);
	    }
	    // save xi at BBN
	    if (tsm < T_BBN && model->get_xi_bbn().has_value()) {
	      model->set_xi_bbn(xi);
	    }
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd, *model);
	    double sigd = thermal_cross_section_2eta_2del(xd, *model);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, *model);
	    double pfe = -pf * tsm * s * s;
	    double pfd = meta / (x * x);
	
	    // dW_e / dlogx
	    dw(0) = pfe * sige * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
	
	    // dY_d / dlogx
	    dw(1) = pfd * sigd * exp(2.0 * w(0));
ae131cae293c9384e4701dcf5531d839|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|95|1|V|cpp
	    dfdu(0,0) = pfe * sige * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
623f83fa905583dfa01379bf2ac99e52|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|99|1|V|cpp
	    dfdu(1, 0) = pfd * sigd * exp(2.0 * w(0));
3cc7d84e789586e7fe2c07910dade592|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|94|5|V|cpp
	    // dW_e / dlogx
977db84d6f6f8de559b85e9f765d66b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|5|V|cpp
	    // dY_d / dlogx
d597e83363066fcee6ada1624fb9b972|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|95|18|v|cpp
	pfe * sige * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
3a0f7858cea3a31e9c91caef369be3fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|18|v|cpp
	pfd * sigd * exp(2.0 * w(0));
814996ae093daa54a6e50be92259e8b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|76|23|V|cpp
	    // Determine if the eta' has frozen out
	    if (w(0) - weq > 0.1 && !model->get_xi_fo().has_value()) {
	      model->set_xi_fo(xi);
	      model->set_tsm_fo(tsm);
	    }
	    // save xi at BBN
	    if (tsm < T_BBN && model->get_xi_bbn().has_value()) {
	      model->set_xi_bbn(xi);
	    }
1a6f2c421aa4e05f46b5683d3c0d28e2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|1|V|cpp
	    dfdt(0) = 0.0;
443c983dfb38fef5e4c1be5ec2af5a8f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|60|18|v|cpp
	(const vector_type &w, vector_type &dw, const double logx)
7b64cc35860eab1f7301e371f54647ef|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|24|43|V|cpp
	    double xi = compute_xi_const_tsm(tsm, *model);
	    double td = xi * tsm;
145107e65cea1d44042acf31dd470fcf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|102|1|V|cpp
	  void operator()(const vector_type &w, matrix_type &dfdu, const double logx,
	                  vector_type &dfdt) {
	    const double x = exp(logx);
	    const double meta = model->get_m_eta();
	    const double tsm = meta / x;
	    double xi = compute_xi_const_tsm(tsm, *model);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	
	    double neq = neq_eta(td, *model);
	    double weq = log(neq / s);
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd, *model);
	    double sigd = thermal_cross_section_2eta_2del(xd, *model);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, *model);
	    double pfe = -pf * tsm * s * s;
	    double pfd = meta / (x * x);
	
	    dfdu(0, 0) =
	        pfe * sige * exp(w(0)) * (3.0 * exp(2.0 * w(0)) - exp(2.0 * weq));
	    dfdu(0, 1) = 0.0;
	
	    dfdu(1, 0) = 2.0 * pfd * sigd * exp(2.0 * w(0));
	    dfdu(1, 1) = 0.0;
	
	    dfdt(0) = 0.0;
	    dfdt(1) = 0.0;
	  }
9e6aa54464b5ff5cd38121b9594e9a4f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|57|6|v|cpp
	operator()
b78daa3a95a766de9486f6ab1ad6021c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|88|19|V|cpp
	struct boltzmann {
	  std::shared_ptr<DarkSun> model;
	  boltzmann(std::shared_ptr<DarkSun> model) : model(model) {}
	
	  void operator()(const vector_type &w, vector_type &dw, const double logx) {
	    const double x = exp(logx);
	    const double meta = model->get_m_eta();
	    const double tsm = meta / x;
	    double xi = compute_xi_const_tsm(tsm, *model);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	
	    double neq = neq_eta(td, *model);
	    double weq = log(neq / s);
	
	    // Determine if the eta' has frozen out
	    if (w(0) - weq > 0.1 && !model->get_xi_fo().has_value()) {
	      model->set_xi_fo(xi);
	      model->set_tsm_fo(tsm);
	    }
	    // save xi at BBN
	    if (tsm < T_BBN && model->get_xi_bbn().has_value()) {
	      model->set_xi_bbn(xi);
	    }
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd, *model);
	    double sigd = thermal_cross_section_2eta_2del(xd, *model);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, *model);
	    double pfe = -pf * tsm * s * s;
	    double pfd = meta / (x * x);
	
	    // dW_e / dlogx
	    dw(0) = pfe * sige * exp(w(0)) * (exp(2.0 * w(0)) - exp(2.0 * weq));
	
	    // dY_d / dlogx
	    dw(1) = pfd * sigd * exp(2.0 * w(0));
	  }
	};
	
	struct boltzmann_jac {
	  std::shared_ptr<DarkSun> model;
	  boltzmann_jac(std::shared_ptr<DarkSun> model) : model(model) {}
	
	  void operator()(const vector_type &w, matrix_type &dfdu, const double logx,
	                  vector_type &dfdt) {
	    const double x = exp(logx);
	    const double meta = model->get_m_eta();
	    const double tsm = meta / x;
	    double xi = compute_xi_const_tsm(tsm, *model);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	
	    double neq = neq_eta(td, *model);
	    double weq = log(neq / s);
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd, *model);
	    double sigd = thermal_cross_section_2eta_2del(xd, *model);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, *model);
	    double pfe = -pf * tsm * s * s;
	    double pfd = meta / (x * x);
	
	    dfdu(0, 0) =
	        pfe * sige * exp(w(0)) * (3.0 * exp(2.0 * w(0)) - exp(2.0 * weq));
	    dfdu(0, 1) = 0.0;
	
	    dfdu(1, 0) = 2.0 * pfd * sigd * exp(2.0 * w(0));
	    dfdu(1, 1) = 0.0;
	
	    dfdt(0) = 0.0;
	    dfdt(1) = 0.0;
	  }
	};
0a4b5600f2964edeb9c0d8bde0f14f14|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|84|3|V|cpp
	  // Com
3daf73d04a4ed90146435a46fef0b362|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|58|20|v|cpp
	vector_type &dfdt, 
e6eca6c8a8154ff7ab6feb3768101733|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|84|1|V|cpp
	  dfdt(0) = 0.0;
	  dfdt(1) = 0.0;
f28222fdd03723201bfc2b957770f3ff|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|57|1|V|cpp
	void boltzmann_dfdy(const vector_type &w, matrix_type &dfdw, const double logx,
	                   DarkSun &model) {
	  const double x = exp(logx);
	  const double meta = model.get_m_eta();
	  const double tsm = meta / x;
	  double xi = compute_xi_const_tsm(tsm, model);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	
	  double neq = neq_eta(td, model);
	  double weq = log(neq / s);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, model);
	  double sigd = thermal_cross_section_2eta_2del(xd, model);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, model);
	  double pfe = -pf * tsm * s * s;
	  double pfd = meta / (x * x);
	
	  dfdw(0, 0) =
	      pfe * sige * exp(w(0)) * (3.0 * exp(2.0 * w(0)) - exp(2.0 * weq));
	  dfdw(0, 1) = 0.0;
	
	  dfdw(1, 0) = 2.0 * pfd * sigd * exp(2.0 * w(0));
	  dfdw(1, 1) = 0.0;
	}
02c04159820720309681edaefad0eb1e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|3|V|cpp
	  auto f1 = [](double logx){
49993af3cd2cdc6c4811209b89927fee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|86|1|V|cpp
	  boltzmann(w, dw, logx, model);
a7894faacf0d4bb48c20db5f93840aca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|1|V|cpp
	  vector_type dw(2);
4dd707c5f5f32e809d8f372b3c1eec52|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|1|V|cpp
	  dfdt(0) = (dwh(0) - dwl(0)) / (6.0 * dlogx)
a98bf6ab2155dd62d5d11866a9bd3411|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|92|1|V|cpp
	  dfdt(1) = 0.0;
00a7d0cf963972b4be0d8eb39505c4e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|1|V|cpp
	  vector_type dw1(2);
	  vector_type dw2(2);
09caf7685fcbb6038e3fdf19cc6facec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|1|V|cpp
	  double m11 = 
31006339a02d818f761706385203606d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|94|13|v|cpp
	(dwh(0) - dwl(0)) / (6.0 * dlogx);
45729e1cb41b520ab2487a1021340352|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|95|13|v|cpp
	(dwh(1) - dwl(1)) / (6.0 * dlogx);
fe2448dc3c5419643cb1aef7b454f6a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|94|13|v|cpp
	4.0 / 3.0 * m11 - 1.0 / 3.0 * m21;
eba6efd1ed68249a19ddc7e616a53e0b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|89|1|V|cpp
	  boltzmann(w, dw2, logx + dlogx, model);
	  boltzmann(w, dw1, logx - dlogx, model);
	  double m11 = (dw2(0) - dw1(0)) / (6.0 * dlogx);
	  double m12 = (dw2(1) - dw1(1)) / (6.0 * dlogx);
0b0b7e3d14a8a069f50f0343b64c3696|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|36|v|cpp
	(6.0 * dlogx);
9d87b2e93ff18d8c04c7fef781a97cfd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|100|17|v|cpp
	/ 3.0 
a408495ac410fdebf124e2dfe1e3689d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|101|25|v|cpp
	1.0 / 3.0 
1e074df87aa78432157ccd57d04e73e9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|100|25|v|cpp
	1.0 / 3.0 * 
970639afcfa9a0b6e26776f44da9cffc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|115|42|v|cpp
	sm_entropy_density(tsm)
ab0fc9e0111bccd9fb23083ba269c3b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|121|10|v|cpp
	weta
0facb40d52795632dc5bbae0eb14698b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|115|17|v|cpp
	log(neq_eta(td, model) / s);
19c1767cccfa1cab2e930d96081c8290|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|116|17|v|cpp
	neq_del(td, model) / s;
25e8df97bbf138759c3bc2a9f861eeaf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|115|1|V|cpp
	  double weta = log(neq_eta(td, model) / s);
	  double yeta = neq_del(td, model) / s;
5b17b660dcbf1f20c17f147421f51f8e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|114|1|V|cpp
	  double s = sm_energy_density(tsm);
d84257e958b46fec40830bdbc7c58b65|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|1|V|cpp
	  using boost::numeric::odeint::rosenbrock4_controller;
a915a041272c9d322a531361d8351811|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|106|33|v|cpp
	rosenbrock4_controller
486e764200e05681b8c385007f70b615|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|106|1|V|cpp
	  using boost::numeric::odeint::integrate_adaptive;
651a7e6770ecf8d6f7c18aa3da073e7e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|107|33|v|cpp
	integrate_adaptive
a8816c84bed39240eb6ab1f1771a366f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|124|36|v|cpp
	rosenbrock4_controller<vector_type>
34bb75ae7e6ac16be37411abf963adad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|123|3|V|cpp
	  auto stepper rosenbrock4_controller<vector_type>
47adfc27d6ac48265ba766b23cd66489|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|128|1|V|cpp
	size_t num_of_steps2 = integrate_const( make_dense_output< runge_kutta_dopri5< vector_type > >( 1.0e-6 , 1.0e-6 ) ,
	            stiff_system() , x2 , 0.0 , 50.0 , 0.01 ,
	            cout << phoenix::arg_names::arg2 << " " << phoenix::arg_names::arg1[0] << "\n" );
098e61ea41468ba8f0e7b9afca7d697c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|125|23|v|cpp
	const double logx, 
76b39ef00de24b397a5e7131be149033|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|125|1|V|cpp
	  auto dydx = [model](const vector_type &y, vector_type &dy,
	                      const double logx) { boltzmann(y, dy, logx, model); };
52236e25377e76607250dd3b266b3a6e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|124|1|V|cpp
	  auto dydx = [&model](const vector_type &y, vector_type &dy,
	                       const double logx) { boltzmann(y, dy, logx, model); };
5d40ef19b1c3f40af9fe0d0a1283c9a9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|118|3|V|cpp
	  auto logx_span = std::make_pair(log(xstart), log(xfinal));
11f171c5fc173d13396303532954fcfe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|132|68|v|cpp
	dfdy
519030daaa6e27dafdd7b7a4228e8c02|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|130|7|v|cpp
	make_dense_output<
5bab71b4fd010a34cede636b8cba15c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|130|3|V|cpp
	  auto stepper =
ad98868c24eb7c303422758a10da492f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|130|7|V|cpp
	      make_dense_output<rosenbrock4_controller<>>(1e-6, 1e-6);
3ef3b12f1a275a1c506a6d5c8ef7652d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|59|1|V|cmake
	# --------------------------------------------------------------------------
	# test_xi.cpp: Make sure xi is computed correctly
	# --------------------------------------------------------------------------
	add_executable(test_xi test_xi.cpp)
	set_property(TARGET test_xi PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_xi PUBLIC
	        darksun
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_xi PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
0684d39010922c902001b754293783ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|77|3|v|cmake
	test_xi
8ec48ce0fcd463d08051fb5f4843a7c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|77|29|v|cmake
	Make sure xi is computed correctly
5cef0c314b8429c919f879917f0cc997|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|5|36|v|cpp
	cardinal_
cc658e527871139b2b2ce0fedc1b3f68|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1054|27|v|cpp
	interpolators
d3d4afbd08cf80d482acbd95d9d18973|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|106|3|V|cpp
	  using boost::numeric::odeint::make_dense_output;
eaf2691326c14531eef10148fc397a81|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|106|33|v|cpp
	rosenbrock4_dense_output
72fd68095d30f83c631008bed802684f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|107|33|v|cpp
	rosenbrock4_controller;
594c103f2c6e04c3d8ab059f031e0c1a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|129|15|v|cpp
	controller
0558a8b1906da79608d4d78cd92b38c2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|76|3|V|cpp
	  std::vector<std::array
07b6512fbf5be6e7baca415a40a4dcb5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|1|v|cpp
	vod store 
50d76490e54dd11f6ce2a2387bf486b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|1|V|cpp
	static void store_solution(
20d4ce6493b1c6fd1718420c3785011e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|133|3|v|cpp
	size_t nsteps = 
b0ccefd7590b271f484947701fbd8a9e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|4|1|V|cpp
	#include <fmt/core.h>
bd3cd83dbc78e7320710b173183d21b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|136|34|v|cpp
	(log_xfinal-log
d2c5d67bbcdbbd7476dd394b99ca6956|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|108|3|V|cpp
	  using boost::numeric::odeint::rosenbrock4_dense_output;
1ddb656d00695b72b8c5a2db5f19b99e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|136|22|v|cpp
	make_constepper
3395000196c5084f3746193fc3e24116|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|136|45|v|cpp
	, 1e-6
23295f2fc003dbb45a8494407ab5badb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|136|22|v|cpp
	make_controlled(
5ce1026a32c86fdeda9632be1a4244c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|134|23|v|cpp
	stepper
0b7c287a6c1a1a9a860fa7c93741b0ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|101|1|V|cpp
	dfdt(0) = 0.0;
2762b4118a082adcb9c53a1deac48e3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|28|1|V|cpp
	  std::optional<double> m_xi_fo{};
	  std::optional<double> m_tsm_fo{};
	  std::optional<double> m_xi_bbn{};
	  std::optional<double> m_xi_cmb{};
	  std::optional<double> m_rd_eta{};
	  std::optional<double> m_rd_del{};
	  std::optional<double> m_dneff_cmb{};
	  std::optional<double> m_dneff_bbn{};
	  std::optional<double> m_eta_si_per_mass{};
	  std::optional<double> m_del_si_per_mass{};
	
	  std::vector<std::array<double, 3>> m_solution;
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
d57c24f3fe52d16e7169b912dd647f0d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|56|3|v|cpp
	optional
4e83ce3882eb069aedbb67ebe9a0cd7c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|58|3|v|cpp
	std::vector<std::array<double, 3>> 
f6d432435948c8317321e5e4bea82b36|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/decsol.hpp|22|1|V|cpp
	#include "decsol.h"
ae38a6460297546aafa11dcec3cafce9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/decsol.hpp|5|1|V|cpp
	/***************************************************************************
	                                decsol.c
	                             -------------------
	    modified for C by:   : Blake Ashby
	    last modified        : Nov 15, 2002
	    email                : bmashby@stanford.edu
	
	Helper routines for StiffIntegratorT class. Modified from original Fortran
	code provided by:
	
	        E. Hairer & G. Wanner
	        Universite de Geneve, dept. de Mathematiques
	        CH-1211 GENEVE 4, SWITZERLAND
	        E-mail : HAIRER@DIVSUN.UNIGE.CH, WANNER@DIVSUN.UNIGE.CH
	
	 ***************************************************************************/
1422156a3b01a0cbd725a7711b6c8a93|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/decsol.hpp|23|1|V|cpp
	#include <cmath>
4af90541671d670bcbe652df203e8bf6|file:///Users/loganmorrison/Downloads/IntegratorT/IntegratorT.h|26|1|V|cpp
	#include <iostream>
	#include <iomanip>
	#include <cmath>
	#include <cstdlib>
	#include <limits>
	#include "decsol.h"
222f5f94ccab7651d46e1228ce846029|file:///Users/loganmorrison/Downloads/IntegratorT/IntegratorT.h|33|1|V|cpp
	void Function(double x, double *y, double *f);
	
	class IntegratorT
	{
	
	public:
		// Constructor
		IntegratorT(const int nin, double yin[], double xin, const double xendin, double dxin,
					int itolerin = 0, double *rtolerin = 0, double *atolerin = 0, const int ioutin = 1,
					double hin = 0.0, double hmaxin = 0.0, int nmaxin = 0, double uroundin = 0.0,
					double safein = 0.0, double faclin = 0.0, double facrin = 0.0);
	
		// Still need to implement copy constructor and default constructor
	
		// Destructor
		virtual ~IntegratorT();
	
		virtual void Integrate() = 0;
	
		// Function that controls the output of the results.
		//Modify this routine according to your needs
		int SolutionOutput();
	
		// get number of function evaluations
		int NumFunction() const { return nfcn; }
		// get number of attempted steps
		int NumStep() const { return nstep; }
		// get number of accepted steps
		int NumAccept() const { return naccpt; }
		// get number of rejected steps
		int NumReject() const { return nrejct; }
	
	protected:
		// CoreIntegrator
		virtual int CoreIntegrator() = 0;
	
		virtual double ContinuousOutput(unsigned i) = 0;
	
		// Member variables
	
		// dimension of system
		const int n;
		// vector for y values
		double *y;
		// independent variable (usually time)
		double x;
		// final value for independent variable
		const double xend;
		// time step for intermediate output
		double dx;
		// switch for rtol and atol; if itol = 0, rtol and atol are scalars
		// if itol = 1, rtol and atol are vectors
		int itoler;
		// relative error tolerance
		double *rtoler;
		// absolute error tolerance
		double *atoler;
		// variables that indicate whether rtoler and atoler are NULL on input
		// or not--needed for proper memory management in destructor
		bool rtolerNULL;
		bool atolerNULL;
		// routine for dense output at every time step is called if iout = 1
		const int iout;
		// integration step length
		double h;
	
		// Derived variables
	
		// maximal step size
		double hmax;
		// maximal number of steps
		int nmax;
		// smallest number satisfying 1.0 + uround > 1.0
		double uround;
		// safety factor in step size prediction
		double safe;
		// facl, facr--parameters for step size selection
		double facl;
		double facr;
	
		// Counting variables
	
		// number of function evaluations (not counting those in numerical
		// Jacobian calculations)
		int nfcn;
		// number of attempted steps
		int nstep;
		// number of accepted steps
		int naccpt;
		// number of rejected steps
		int nrejct;
	
		// stores past value of x
		double xold;
		// stores past value of h
		double hold;
		// x at discrete points specified by dx interval
		double xd;
	};
36bde73b2c535a3443b1573eb3192b67|file:///Users/loganmorrison/Downloads/IntegratorT/StiffIntegratorT.h|279|1|V|cpp
	void Jacobian(double x, double *y, double **J);
	void Mass(double **M);
	
	class StiffIntegratorT: public IntegratorT
	{
	
	public:
		//Constructors
	
		StiffIntegratorT(const int nin, double yin[], double xin, double xendin,
			double dxin, int itolerin, double *rtolerin, double *atolerin,
			const int ioutin, double hin, double hmaxin, int nmaxin, double uroundin,
			double safein, double faclin, double facrin, const int ijacin,
			int mljacin, int mujacin, const int imasin, int mlmasin,
			int mumasin, int nitin = 0, bool startnin = false, int nind1in = 0,
			int nind2in = 0, int nind3in = 0, int npredin = 0, int m1in = 0, int m2in = 0,
			bool hessin = false, double fnewtin = 0, double quot1in = 0, double quot2in = 0,
			double thetin = 0);
	
		StiffIntegratorT(int nin, double yin[], double xin, double xendin, double dxin,
			const int ijacin, int mljacin, int mujacin, const int imasin,
			int mlmasin, int mumasin);
	
		// Still need to implement copy constructor and default constructor
		
		~StiffIntegratorT();
	
		void Integrate();
		
		// get number of Jacobian evaluations
		int NumJacobian() const { return njac; }
		
		// get number of lu-decompositions of both matrices
		int NumDecomp() const { return ndec; }
		
		// get number of forward-backward substitutions, of both systems;
		int NumSol() const { return nsol; }
	
	private:
	
	// member routines
	
		virtual int CoreIntegrator();
	
		virtual double ContinuousOutput(unsigned i);
		
		void ComputeJacobian();
	
	// Linear Algebra routines:
		
		int DecompReal();
	
		int DecompComplex();
	
		int LinearSolve();
	
		int ErrorEstimate();
	
	// member variables
	
		// compute the Jacobian analytically (ijac = 1) or not (ijac = 1)
		const int ijac;
		// number of non-zero diagonals below main diagonal of Jacobian matrix
		//(if mljac = dimx, matrix is full)
		int mljac;
		// number of non-zero diagonals above main diagonal of Jacobian matrix
		int mujac;
		// differential equation is in explicit form (imas = 0) or not (imas = 1)
		const int imas;
		// number of non-zero diagonals below main diagonal of mass matrix
		//(if mlmas = dimx, matrix is full)
		int mlmas;
		// number of non-zero diagonals above main diagonal of mass matrix
		int mumas;
		// maximal number of Newton iterations
		int nit;
		// switch for starting values of Newton iterations
		bool startn;
		// parameters for differential-algebraic components
		int nind1;
		int nind2;
		int nind3;
		// step size control
		int npred;
		bool pred;
		// parameters for second order equations
		int m1;
		int m2;
		int nm1;
		// Convert Jacobian to Hessenberg form?
		int hess;
		// stopping criterion for Newton's method, usually chosen < 1
		double fnewt;
		// quot1 and quot2--if quot1 < hnew/hold < quot2, step size = const
		double quot1;
		double quot2;
		// decides whether the Jacobian should be recomputed
		double thet;
		// implicit, banded or not?
		bool implct;
		bool jband;
		// row-dimensions of the 2-D arrays -- fjac, e1, e2, and fmas
		int ldjac;
		int lde1;
		int ldmas;
		// job number (used in linear algebra routines for type of problem--banded or not, etc)
		int ijob;
		
		// number of Jacobian evaluations
		int njac;
		// number of lu-decompositions of both matrices
		int ndec;
		// number of forward-backward substitutions, of both systems;
		// the nstep forward-backward substitutions, needed for step
		//size selection, are not counted
		int nsol;
	
		// constants that are used in linear algebra routines
		int mle;
		int mue;
		int mbjac;
		int mbb;
		int mdiag;
		int mdiff;
		int mbdiag;
	
		double fac1;
		double alphn;
		double betan;
	
		// variables used in program
		double err;
		bool caljac;
		bool calhes;
		bool first;
		bool reject;
	
		// arrays used in program
		double *z1;
		double *z2;
		double *z3;
		double *y0;
		double *scal;
		double *f1;
		double *f2;
		double *f3;
		double *cont;
		int *ip1;
		int *ip2;
		int *iphes;
		double **e1;
		double **e2r;
		double **e2i;
	
		// Jacobian matrix
		double **fjac;
		// mass matrix
		double **fmas;
	
	};
4554443caced048dc4581c33fa2d231a|file:///Users/loganmorrison/Downloads/IntegratorT/IntegratorT.cpp|14|1|V|cpp
	IntegratorT::IntegratorT(const int nin, double yin[], double xin, const double xendin,
		double dxin, int itolerin, double *rtolerin, double *atolerin, const int ioutin,
		double hin, double hmaxin, int nmaxin, double uroundin, double safein,
		double faclin, double facrin) :
		n(nin), y(yin), x(xin), xend(xendin), dx(dxin), itoler(itolerin),
		rtoler(rtolerin), atoler(atolerin), rtolerNULL(false), atolerNULL(false),
		iout(ioutin), h(hin), hmax(hmaxin),
		nmax(nmaxin), uround(uroundin), safe(safein), facl(faclin), facr(facrin),
		nfcn(0), nstep(0), naccpt(0), nrejct(0), xold(xin), hold(hin), xd(xin)
	{
		// n, the dimension of the system
		if (n == UINT_MAX) {
			cout << "System too big, max. n = " << UINT_MAX - 1 << endl;
			throw -1;
		}
		
		// rtoler, the relative tolerance of the integration
		if (!rtoler) {
			itoler = 0;
			rtoler = new double;
			*rtoler = 1.0e-7;
			rtolerNULL = true;
		}
		
		// atoler, the absolute tolerance of the integration
		if (!atoler) {
			itoler = 0;
			atoler = new double;
			*atoler = 1.0e-7;
			atolerNULL = true;
		}
	
		// -------- maximal step size
		if (hmax == 0.0) hmax = xend - x;
	
		// -------- nmax--maximal number of steps
		if (nmax == 0) nmax = 100000;
		if (nmax <= 0) {
			cout << " wrong input, nmax = " << nmax << endl;
			throw -1;
		}
		
		// -------- uround--smallest number satisfying 1.0 + uround > 1.0
		if (uround == 0.0) uround = 1.0e-16;
		if ((uround <= 1.0e-19) || (uround >= 1.0)) {
			cout << " coefficients have 20 digits, uround = " << uround << endl;
			throw -1;
		}
		
		// --------- safe--safety factor in step size prediction
		if (safe == 0.0) safe = 0.9;
		if ((safe <= 0.001) || (safe >= 1.0)) {
			cout << " curious input for safety factor, safe = " << safe << endl;
			throw -1;
		}
	
	}  // Constructor
	
	// Destructor
	IntegratorT::~IntegratorT()
	{
		if (rtolerNULL) delete rtoler;
		if (atolerNULL) delete atoler;
	}
	
	// Function that controls the output of the results.
	// Modify this routine according to your needs
	int IntegratorT::SolutionOutput()
	{
		cout << setiosflags(ios::showpoint);// | ios::fixed);
	
		if (naccpt == 0) xd = xold;
	
		while (xd < x) {
			if ((xold <= xd) && (x >= xd)) {
				cout << "Step " << naccpt << ": t = " << setw(5) <<
					setprecision(2) << xd << "  y = ";
				for (unsigned i = 0; i < n; i++)
					cout << setw(10) << setprecision(8) <<
						ContinuousOutput(i) << "  ";
				cout << endl;
				xd += dx;
			}
		}
	
		return 0;
	
	}  // SolutionOutput
12e25d5c172cce29418ee80b8943ef81|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|2504|5|V|cpp
	    bool a = (1 < 2) or (2 < 3);
109580d9b25567a124eca4fcbfdbd895|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|15|1|V|cpp
	template <class Func>
61c32828c8fe6223ae13074ad62f4696|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|16|9|v|cpp
	(void)(double x, double *y, double *f) OdeFunction;
bb07102cd4da0266d1dda79353f8e5f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|16|9|v|cpp
	std::function<(void)(double, double *, double *)> OdeFunction;
9d55780817c1c8ee9fe9c6169a6d5d6f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|16|9|v|cpp
	void (
0db444c324e0b570b268bd1cdf5b91b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|14|1|V|cpp
	void Function(double x, double *y, double *f);
73d18766a59efb09304f11a02c54552e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|278|1|V|cpp
	void Jacobian(double x, double *y, double **J);
	void Mass(double **M);
680757ab9edd8b3ba3f316e8c4e8fac7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|282|1|V|cpp
	typedef std::function<void(double, double*, double**)> OdeJacobian;
c1a055a60c50f7fba64ff4fbb6d2fead|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|283|28|v|cpp
	double, double*, 
aefc4b60a526220cb0f0d8785497c15f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|283|42|v|cpp
	Jacobian;
21de295b4ac8fa8984e4ccb479376e2a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|287|20|v|cpp
	OdeFunction func, OdeJacobian jac, OdeMassMatrix mass_matrix,
ff2864d6f652ee0ac254814f1ae4f4a8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|1006|5|v|cpp
	Mass
e54aa0f510685bd0be4cbe3750fa7fc5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/radau5.hpp|1434|5|v|cpp
	Jacobian
c4ec701c08c249a03e46f938306b82c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|10|1|V|cpp
	#include <boost/numeric/odeint.hpp>
	#include <boost/numeric/ublas/matrix.hpp>
	#include <boost/numeric/ublas/vector.hpp>
3b02f4bb15f9bb50ea81db820e062bdc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|16|1|V|cpp
	typedef boost::numeric::ublas::vector<double> vector_type;
	typedef boost::numeric::ublas::matrix<double> matrix_type;
662324429770a1dddd5879c724975ae5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|16|16|v|cpp
	const vector_type &w, vector_type &dw,
fd12a9a55d60b943d3499c2b70e44cff|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|52|20|v|cpp
	const vector_type &w, matrix_type &dfdw, 
ee8fe59c6097b69ed26bf13c7f6f9566|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|71|3|v|cpp
	dfdw
65c62be516948e3294066ca83db4bb3d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|78|1|V|cpp
	  // Compute derivative w.r.t. logx using finite differences
	  vector_type dw1(2);
	  vector_type dw2(2);
	  double dlogx = 1e-3;
	
	  // boltzmann(w, dw2, logx + dlogx, model);
	  // boltzmann(w, dw1, logx - dlogx, model);
	  // double m11 = (dw2(0) - dw1(0)) / dlogx;
	  // double m12 = (dw2(1) - dw1(1)) / dlogx;
	  // boltzmann(w, dw2, logx + 2.0 * dlogx, model);
	  // boltzmann(w, dw1, logx - 2.0 * dlogx, model);
	  // double m21 = (dw2(0) - dw1(0)) / (4.0 * dlogx);
	  // double m22 = (dw2(1) - dw1(1)) / (4.0 * dlogx);
	  // dfdt(0) = (4.0 * m11 - m21) / 3.0;
	  // dfdt(1) = (4.0 * m12 - m22) / 3.0;
	  dfdt(0) = 0.0;
	  dfdt(1) = 0.0;
dc0b5a71b54e9d7ae4c230391fd016a8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|78|1|V|cpp
	  using boost::numeric::odeint::integrate_adaptive;
	  using boost::numeric::odeint::make_controlled;
	  using boost::numeric::odeint::rosenbrock4;
cdd5d2661bee7dfca2b4fbb0d637350c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|3|V|cpp
	  vector_type w(2);
ccfb6d03655ce6abdd8dd2167e5a89f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|95|24|v|cpp
	const vector_type &y, vector_type &dy,
71a473f6e261cdb262245b8917f92a4a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|96|15|v|cpp
	y, dy, 
6cedadaf9d024ed49c2719db831b4c99|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|23|v|cpp
	const vector_type &y, matrix_type &dfdy,
45771a408d765775edaff925928ec54f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|23|v|cpp
	
	                      
eab67d397a7df949c30850ac8685de2a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|42|v|cpp
	vector_type &dfdt
f9d10e034f9ebeed1dc1b2aeb75021c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|99|19|v|cpp
	y, dfdy, logx, dfdt
cf07bac21ed710743257e58f3b4b75ee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|102|1|V|cpp
	  auto observer = [&model](const vector_type &y, const double logx) {
	    fmt::print("{}, {}, {}\n", logx, y(0), y(1));
	    model.solution_push_back(logx, y(0), y(1));
	  };
084cc42a2a4f756e50b7b4eee4788b3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|103|1|V|cpp
	  auto stepper = make_controlled<rosenbrock4<double>>(1e-6, 1e-6);
af5c1aeca36dd34a9d385207511335fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|103|1|V|cpp
	  const double dt = (log_xfinal - log_xstart) / 30.0;
	  integrate_adaptive(stepper, std::make_pair(dydx, jac), w, log_xstart,
	                     log_xfinal, dt, observer);
d6df9b2bf144867a7eba9178ab0ba9f9|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|8|1|V|cpp
		// dimension of problem
		const int n = 2;
		// initial values for y
		double y[n] = {2.0, 0.0};
		// initial value for x
		double xbeg = 0.0;
		// final value for x
		const double xend = 11.0;
		// interval of x for printing output
		double dx = 1.0;
		// rtoler and atoler are scalars
		int itoler = 0;
		// relative tolerance
		double *rtoler = new double(1.0e-10);
		// absolute tolerance
		double *atoler = new double(1.0e-10);
		// use SolutionOutput routine
		const int iout = 1;
		// initial step size
		double hinit = 0.0;
		// analytical Jacobian function provided
		const int ijac = 1;
		// number of non-zero rows below main diagonal of Jacobian
		int mljac = n;
		// number of non-zero rows above main diagonal of Jacobian
		int mujac = n;
		// Mass matrix routine is identity
		const int imas = 0;
		int mlmas = 0;
		int mumas = 0;
ab2f68ca5e3f53abc6840ab4f6f8c89d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		// initial values for y
0bfab1f2c4b82937d80c125dc46aebad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		double y[n] = {2.0, 0.0};
ea1f58408ed282309677ec4c566686fd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		// initial value for x
c03cd89276d97f80321c3572f463def4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		double xbeg = 0.0;
e1c4f6e487c003db27b77d0985109a4d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		// final value for x
99093de9614e4bc94e30e0d9e2352733|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|2|V|cpp
		const double xend = 11.0;
df2538b0295f84be02248135047f7274|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|40|1|V|cpp
		double hmax(0.0);
		int nmax(0);
		double uround(0.0), safe(0.0), facl(0.0), facr(0.0);
		int nit(0);
		bool startn(false);
		int nind1(0), nind2(0), nind3(0), npred(0), m1(0), m2(0);
		bool hess(false);
		double fnewt(0.0), quot1(0.0), quot2(0.0), thet(0.0);
642f9f6072876a0903ba893cffcb9e6b|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|39|1|V|cpp
		// Use default values (see header files) for these parameters:
		double hmax(0.0);
		int nmax(0);
		double uround(0.0), safe(0.0), facl(0.0), facr(0.0);
		int nit(0);
		bool startn(false);
		int nind1(0), nind2(0), nind3(0), npred(0), m1(0), m2(0);
		bool hess(false);
		double fnewt(0.0), quot1(0.0), quot2(0.0), thet(0.0);
	
60e672a032a6242fffd5f376d3e1f29d|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|49|1|V|cpp
		StiffIntegratorT stiffT(n, y, xbeg, xend, dx, itoler, rtoler, atoler,
			iout, hinit, hmax, nmax, uround, safe, facl, facr, ijac, mljac,
			mujac, imas, mlmas, mumas, nit, startn, nind1, nind2, nind3, npred,
			m1, m2, hess, fnewt, quot1, quot2, thet);
372bf4693eb565ce15826e35653b9d61|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|137|40|v|cpp
	xbeg
144452a2f65cf0c76a8b2d29e2426fe3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|48|3|V|cpp
	  // dY_d / dlogx
41df9eaf0542668950378790914b266e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|49|3|V|cpp
	  std::cout << dw[1] << std::endl;
d5c8664d8b4f92fa54d9a21893b85259|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|96|1|V|cpp
	    std::cout << "dw = " << dw[0] << " " << dw[1] << std::endl;
3468cd6d14ec27976f29616b823d80b7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|101|19|v|cpp
	dw = 
7056e6c664f43af40269786ac7027b24|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|76|1|V|cmake
	# --------------------------------------------------------------------------
	# test_solve_boltzmann.cpp: Make sure rd's are computed correctly
	# --------------------------------------------------------------------------
	add_executable(test_solve_boltzmann test_solve_boltzmann.cpp)
	set_property(TARGET test_solve_boltzmann PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_solve_boltzmann PUBLIC
	        darksun
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_solve_boltzmann PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
d9ca888f106b2902c3b5de15725c1616|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|77|3|v|cmake
	test_solve_boltzmann
5c772c0c32e9faeb6162c6dfbff9fbec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|77|19|v|cmake
	Make sure rd's are computed correctly
5ba3054d97914257995b58fec3eb0e35|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_vdpol.cpp|5|1|V|cpp
	  auto f = [](double x, double *y, double *f){
	  };
183565036715f55a33f26bd8b75c3eb1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_vdpol.cpp|8|1|V|cpp
	  auto jac = [](double x, double *y, double *f){
	  };
92703b118fb1c0c9eec023418c814bc0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_vdpol.cpp|11|16|v|cpp
	double x, double *y, d
f78a5b7c0b07f375bcd53226767c4e63|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|99|1|V|cpp
		f[0] = y[1];
		prod = 1.0 - y[0]*y[0];
		f[1] = (prod*y[1] - y[0])/eps;
ce3d9f674b9eda18652572a625e05dc6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_vdpol.cpp|8|1|V|cpp
	    f[0] = 
5050b32641e62ee32a882cc345c66cc6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_vdpol.cpp|9|5|V|cpp
	    double prod = 1.0 - y[0] * y[0];
7bb2330f853e9837d9b9f3d369184ef8|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|111|1|V|cpp
		J[0][0] = 0.0;
		J[0][1] = 1.0;
		J[1][0] = (-2.0*y[0]*y[1] - 1.0)/eps;
		J[1][1] = (1.0 - y[0]*y[0])/eps;
f5534c91666efdfcf240d5a888627fab|file:///Users/loganmorrison/Downloads/IntegratorT/TESTSETS/vdpol.cpp|8|1|V|cpp
		// dimension of problem
		const int n = 2;
		// initial values for y
		double y[n] = {2.0, 0.0};
		// initial value for x
		double xbeg = 0.0;
		// final value for x
		const double xend = 11.0;
		// interval of x for printing output
		double dx = 1.0;
		// rtoler and atoler are scalars
		int itoler = 0;
		// relative tolerance
		double *rtoler = new double(1.0e-10);
		// absolute tolerance
		double *atoler = new double(1.0e-10);
		// use SolutionOutput routine
		const int iout = 1;
		// initial step size
		double hinit = 0.0;
		// analytical Jacobian function provided
		const int ijac = 1;
		// number of non-zero rows below main diagonal of Jacobian
		int mljac = n;
		// number of non-zero rows above main diagonal of Jacobian
		int mujac = n;
		// Mass matrix routine is identity
		const int imas = 0;
		int mlmas = 0;
		int mumas = 0;
		
		// Use default values (see header files) for these parameters:
		double hmax(0.0);
		int nmax(0);
		double uround(0.0), safe(0.0), facl(0.0), facr(0.0);
		int nit(0);
		bool startn(false);
		int nind1(0), nind2(0), nind3(0), npred(0), m1(0), m2(0);
		bool hess(false);
		double fnewt(0.0), quot1(0.0), quot2(0.0), thet(0.0);
	
		StiffIntegratorT stiffT(n, y, xbeg, xend, dx, itoler, rtoler, atoler,
			iout, hinit, hmax, nmax, uround, safe, facl, facr, ijac, mljac,
			mujac, imas, mlmas, mumas, nit, startn, nind1, nind2, nind3, npred,
			m1, m2, hess, fnewt, quot1, quot2, thet);
d07f4e65e12321fc87e0d21b8e85f52b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|65|3|V|cpp
	  double weq = log(neq / s);
00b86f254f030f377b572e8306e4bfbd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|64|1|V|cpp
	  double weq = log(neq_eta(td, model) / s);
f25410a3a782f92fb26ddc1d5d9631d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|27|1|V|cpp
	  double neq = neq_eta(td, model);
	  double weq = log(neq / s);
de5e4bdb3a17ea24b45ea705574da2cd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|27|1|V|cpp
	#include <gsl/gsl_errno.h>
6188e577409a24f61b108f4bea0cbf8b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|187|1|V|cpp
	    std::cout << "USING SIMPLE XI" <<std::endl;
7c564087d10ca7e561ec45ad3cfa4a54|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|195|7|V|cpp
	      std::cout << "USING SIMPLE XI REL" << std::endl;
646af59c0c5ee875235f05a6ecac67ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|197|7|V|cpp
	      std::cout << "USING SIMPLE XI NR" << std::endl;
33d5b43ecd74a361b68c6103c1780745|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|198|14|v|cpp
	xifo * tsm / tfo
2e0f395b2e93393624b9790f4f278452|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|197|21|v|cpp
	USING SIMPLE XI NR
ba6191de7a0d31b0b7405b74fa0132e9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|197|1|V|cpp
	      std::cout << "xi" << xifo * tsm / tfo << std::endl;
f327c35528eb2bc29290c3beaca7f61d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|186|12|v|cpp
	(res.second + res.first) / 2.0
52fb84082db4f1dd7e40417a9d88a330|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|198|7|V|cpp
	      std::cout << "xi2" << xifo * tsm / tfo << std::endl;
e4cc7a6146e65378ddc9142e09423562|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|185|5|V|cpp
	    std::cout << "xi1" << (res.second + res.first) / 2.0 << std::endl;
fb2ddb1412efa3e1d3c3e4ed706670d2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|170|7|v|cpp
	!tsm_fo.has_value()
9118b8d17ed14a13b6d07648904fc15e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|22|1|V|cpp
	  const double we = y[0];
0f4789a63f2b8d9f8b0e97c91ca049e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|54|29|v|cpp
	gsl_sf_bessel
d8cefcf535425637876eb46eeaab4d2a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|56|1|V|cpp
	  const double ke2 = gsl_sf_bessel_Kn_scaled(2, xd);
c275441f6173a03bb002d1219460b745|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|23|1|V|cpp
	  const double we = y[0]; // log(Yeta)
	  const double yd = y[1]; // Ydelta
	  const double xi = y[2]; // xi = Td / Tsm
8b42ae8974d0ad532f440aed3fdd8e65|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|67|1|V|cpp
	  const double we = w[0];
171c0e60399e3630a2f9fcbbea332ccf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|55|1|V|cpp
	  const double ke1 = gsl_sf_bessel_K1_scaled(xd);
	  const double ke2 = gsl_sf_bessel_Kn_scaled(2, xd);
	  const double ke3 = gsl_sf_bessel_Kn_scaled(2, xd);
	  dy[2] =
	      1.0 - x / (xd * xd * xi) * ke2 * ke3 / (ke2 * ke2 - ke1 * ke3) * dy[0];
12624d4de26a84dbb516c8cb199885e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|87|1|V|cpp
	  dy[2] =
	      1.0 - x / (xd * xd * xi) * ke2 * ke3 / (ke2 * ke2 - ke1 * ke3) * dy[0];
09e12fd470fdb943b5b32573489679d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|52|1|V|cpp
	  dy[0] = pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
	  dy[1] = pfd * sigd * exp(2.0 * we);
50f3df07e45a3aaecba53e38b4267ace|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|89|11|v|cpp
	pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq))
b92f914ab6a38080919c07f27544dce4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|1|V|cpp
	  df[0][1] = 0.0;
b033f303f0df5b2b6602e5813744af8e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|1|V|cpp
	  df[1][1] = 0.0;
9dd71baa9cc780a510ab8005de794817|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|101|7|V|cpp
	      1.0 - x / (xd * xd * xi) * ke2 * ke3 / (ke2 * ke2 - ke1 * ke3) * dy[0];
f1aaf352ec8b9aa5d1c5fe99412bb450|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|100|1|V|cpp
	  df[2][0] = 0.0;
d1fde9c4976b457023979a7876f09f94|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|127|1|V|cpp
	  auto mm = [](double **) {};
8effcf73caf2fc0aaf894adea82e7218|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|122|27|v|cpp
	const double logx, const double *w, double **jac
becf5b6cef8fb8511f8018de0d30b5bf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|127|16|v|cpp
	double **
34bf0f09ae8e46690de0b2dacf92d980|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|121|1|V|cpp
	    // std::cout << "dw = " << dw[0] << " " << dw[1] << std::endl;
33af3ee2e55b2ff761fd253a9407de18|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|121|51|v|cpp
	<< " " << dw[2]
cb58d60528bf980ef79ef0144fe8ab00|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|25|3|V|cpp
	  const double xi = exp(y[1]); // xi = Td / Tsm
3de6c6a135cbf56664894bdbc2574e2d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|24|1|V|cpp
	  const double yd = y[1]; // Ydelta
0b39791e19d3a2b5791d8ede42e569fc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|52|1|V|cpp
	
	  const double ke1 = gsl_sf_bessel_K1_scaled(xd);
	  const double ke2 = gsl_sf_bessel_Kn_scaled(2, xd);
	  const double ke3 = gsl_sf_bessel_Kn_scaled(3, xd);
	  dy[1] =
	      1.0 - x / (xd * xd * xi) * ke2 * ke3 / (ke2 * ke2 - ke1 * ke3) * dy[0];
4d70fe3fcf04b83a0dcf1307015c93e4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|49|3|V|cpp
	  // dW_e / dlogx
cf6f5a570e0a7d160583c8fb1b5cfd50|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|75|1|V|cpp
	  const double ke1 = gsl_sf_bessel_K1_scaled(xd);
	  const double ke2 = gsl_sf_bessel_Kn_scaled(2, xd);
	  const double ke3 = gsl_sf_bessel_Kn_scaled(2, xd);
176baa7f8f170a8267ccf814a390071f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|78|1|V|cpp
	  df[0][2] = 0.0;
e9f76f5e7f0833ca563ef05ed2067c33|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|81|1|V|cpp
	  df[1][2] = 0.0;
c81fffac4b9a7df418aa4d182ab6a0ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|82|1|V|cpp
	  df[2][0] = 0.0;
	  df[2][1] = 0.0;
	  df[2][2] = 0.0;
45a3f2ea69134750388ca26c3f89cd71|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|109|3|V|cpp
	  auto jac = [](const double, const double *, double **) {};
770b432bccfcfbeca27c4ea38df98dec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|3|V|cpp
	  w[1] = log(xi);
48d0eeb52b8aa2bfde78a9291e72d6d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|60|3|V|cpp
	  const double xi = y[2]; // xi = Td / Tsm
fc83a1054996eac160e510ea9e1e7b79|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/CMakeLists.txt|6|1|V|cmake
	set(StiffLib stiff)
	set(StiffSrc ${CMAKE_SOURCE_DIR}/stiff/src)
	set(StiffLib ${CMAKE_SOURCE_DIR}/stiff_lib)
6d47fc2eebd14e69bc025ac142667d9f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|4|1|V|cpp
	namespace darksun{
8175706885d32ec5a15ca6de1e59dcbb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|4|25|v|cpp
	void RADAU5(
6fa36a493d89f33cc15ba489207e761e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|96|1|V|cmake
	# --------------------------------------------------------------------------
	# test_solve_boltzmann.cpp: Make sure rd's are computed correctly
	# --------------------------------------------------------------------------
	add_executable(test_solve_boltzmann test_solve_boltzmann.cpp)
	set_property(TARGET test_solve_boltzmann PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_solve_boltzmann PUBLIC
	        darksun
		libstiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_solve_boltzmann PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
43d223bd9fd8fb21341ab22ff510a4f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|115|27|v|cmake
	 Make sure rd's are computed correctly
274837569db9c26dbaa446e323f1d85a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|21|15|v|cpp
	void cradau(
acd843f4d2c8b15679a3d323dd83150e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|83|1|V|cpp
	  WORK = new double[LWORK];
93a0f71f1432f2e3d409f2c8baf4f3f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|86|1|V|cpp
	  WORK = malloc((LWORK) * sizeof(double));
	  IWORK = malloc(LIWORK * sizeof(int));
c9dc32dbfb4fb9592eed6a50775582db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|102|3|v|cpp
	free(WORK);
8238ed6bf57bfec248ec7047c42db620|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|103|3|v|cpp
	free(IWORK);
fa6813a1c548ae8cc3ba27da39ef8e43|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|83|10|v|cpp
	new double[LWORK];
8a4458b9797f1be552cea27818880029|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|84|3|V|cpp
	  LWORK = new int[LIWORK];
26e6b72f211a7f87cf7d29430729c99d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|52|3|V|cpp
	  int *IWORK;
28c838ce64dc9da28ac695995aa374da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|50|3|V|cpp
	  double *WORK;
37936d0607ec970b184ad1f99244e68b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|102|3|V|cpp
	  delete[] WORK;
5e381c4c9a745246a2331693347706ed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|102|3|V|cpp
	  delete[] LWORK;
16407b37450d32114d765a45a0813d24|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|23|8|v|cpp
	CONTRA
5409fe84ae88b63b1c7c225cce2affd4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|29|1|V|cpp
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
9571ca8cf901aa691a208fa29021ffbe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|113|9|v|cpp
	CONTR5
24e4497e625256d100302e4dc52cd59a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|28|1|V|cpp
	void radau5(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int LWORK;
	  int LIWORK = 1;
	
	  int nsmax = iwork[11];
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  if (nsmax == 0)
	    nsmax = 7;
	
	  /* allocation of workspace */
	
	  LWORK = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
	  LIWORK = (2 + (nsmax - 1) / 2) * n + 20;
	
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  radau5_(&N, fcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC, &MLJAC,
	          &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT, WORK.data(),
	          &LWORK, IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
	}
	
	double contr5(int i, double s, double *cont, int *lrc) {
	  int I = i;
	  double S = s;
	
	  return contra_(&I, &S, cont, lrc);
	}
	
fd0b3c8ff9a2c97851fb2583393273df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|6|1|V|cpp
	/**
	 * Fortran Radau5 algorithm
	 */
	extern "C" void radau5_(
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    double *X, double *Y, double *XEND, double *H, double *RTOL, double *ATOL,
	    int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
	
	/**
	 * Fortran function for continuous output.
	 */
	extern "C" double contra_(int *I, double *S, double *CONT, int *LRC);
	
29df942c5276b6c87a1c63c856de4570|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|69|7|v|cpp
	*IWORK;
23192bb9e1816bdcdc287fda1ab89aa8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|68|3|V|cpp
	  int LWORK;
e522249f4ada675d71afdd5d0165e3dc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|69|3|V|cpp
	  int LIWORK = 1;
eea80bc3ae292f55e412f8b86c9d80d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|67|1|V|cpp
	  std::vector<double> WORK;
	  std::vector<int> IWORK;
69b6e8db6ce33fbba5e83fa23a920125|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|114|3|V|cpp
	  free(WORK);
795dc5d0ae99fc254b263ccbf19b3786|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|114|3|V|cpp
	  free(IWORK);
a370473477ceff22ad62bd4ab4a7a8bc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|144|16|V|cpp
	  double *WORK;
	  int LWORK;
	  int *IWORK;
	  int LIWORK = 1;
61e19b0f52ec55091a877e7e4ddee250|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|169|1|V|cpp
	  WORK = malloc(LWORK * sizeof(double));
	  IWORK = malloc(LIWORK * sizeof(int));
88d36d3d436633435d52ce023f00046f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|187|1|V|cpp
	  free(WORK);
	  free(IWORK);
a85b78965644cb9964b7ebf269dc3f12|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|15|25|v|cmake
	/usr/bin/g++-4.2
ce39108a5c3c200f77b098804eb343b9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|14|1|V|cmake
	set(CMAKE_C_COMPILER "/usr/local/bin/gcc")
	set(CMAKE_CXX_COMPILER "/usr/local/bin/g++")
574e24df2d7db7d3f3a46c9b4b9caf8b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|13|1|V|cmake
	
	set(CMAKE_C_COMPILER "/usr/local/bin/gcc")
	set(CMAKE_CXX_COMPILER "/usr/local/bin/g++")
92ced968f8acd67439bb35968dff1e02|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/CMakeLists.txt|9|1|V|cmake
	add_library(stiff STATIC ${sources})
3284e8bda6df920e715d2eb0ea3122aa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/CMakeLists.txt|10|1|v|cmake
	add_library
5aa4dfef375b7db82523ad6802433bf5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/CMakeLists.txt|10|29|v|cmake
	STATIC ${sources})
870adf1e8d023a615e1c6974f9d7474d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/integrator.hpp|10|1|V|cpp
	#include <limits>
3266f65b05aab16f48b4dd62f42eb920|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|36|1|V|cpp
	extern "C" void rodas_();
4a411f8be46cfd3b88358cc8aa56b497|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|37|17|v|cpp
	rodas_
d531af64f3cb6ba51b2c11d3f9b3a929|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/rodas.f|1|1|V|fortran
	      SUBROUTINE RODAS(N,FCN,IFCN,X,Y,XEND,H,
	     &                  RTOL,ATOL,ITOL,
	     &                  JAC ,IJAC,MLJAC,MUJAC,DFX,IDFX,
	     &                  MAS ,IMAS,MLMAS,MUMAS,
	     &                  SOLOUT,IOUT,
	     &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID)
3c5ab8a8c5bf2478efa2a13725cfdc62|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|37|7|v|cpp
	SUBROUTINE RODAS(
334ca73d542dda19cdccb312720f1b6c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|22|13|v|cpp
	void FCN(int *, double *, double *, double *, double *, int *)
93fb7c540638e2083e73d370ff885233|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|25|1|V|cpp
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
dda4cb474f8b4490d483c6e4cd164ce2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|39|5|V|cpp
	                       
5b03035696e9e8b2004eaff3675a168d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|39|5|v|cpp
	void JAC(int *, double *, double *, double *, int *, double *, double *)
b6bdfc9ad9e214d636c91587b45798e8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|41|1|v|cpp
	 DFX
4af2d9a8e0d80bc24f6862a5a1ec9d00|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|29|5|v|cpp
	void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *)
becde8e2a720c7c61068c23c8111559b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|43|24|v|cpp
	SOLOUT
f74c558689f6d85f75b0d36ece5fba6f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|27|5|v|cpp
	void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar)
8061a992058973a99e03be886f9c4a4a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|42|82|v|cpp
	, double *
50a19a3a54a3b59d76bd7c423f0b4c51|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|54|1|V|cpp
	extern "C" void seulex_();
bb30017ec2363b2149a443e0c6e84b5b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|55|17|v|cpp
	seulex_
5f701651ca7cc98406b702df3e99d11a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/seulex.f|1|25|v|fortran
	N,FCN,IFCN,X,Y,XEND,H,
	     &                  RTOL,ATOL,ITOL,
	     &                  JAC ,IJAC,MLJAC,MUJAC,
	     &                  MAS ,IMAS,MLMAS,MUMAS,
	     &                  SOLOUT,IOUT,
	     &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID
10968e27f16087bb803451c57d7523a1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|36|4|V|cpp
	extern "C" void rodas_(
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    int *IFCN, double *X, double *Y, double *XEND, double *H, double *RTOL,
	    double *ATOL, int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void DFX(int *N, double *X, double *Y, double *FX, int *RPAR, double *IPAR),
	    int *IDFX, void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar),
	    int *IMAS, int *MLMAS, int *MUMAS,
	    void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID)
	
	    ;
	extern "C" void contro_(int *I, double *X, double *CONT, int *LRC);
53d25130f6e5788ce3e099eb4e32cc3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|38|1|v|cpp
	FCN,
8ada11ebd374d2022f5247d08b458734|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|47|1|v|cpp
	JAC 
315b6edb21d1fd0acb601fef2dd203b6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|51|1|v|cpp
	MAS 
137a3f835fcdfa631d17ec53ead453e9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|46|27|v|cpp
	, int *
16b91efcd840cf0b4be109d6856f4f7a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|36|1|V|cpp
	extern "C" void seulex_(
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    int *IFCN, double *X, double *Y, double *XEND, double *H, double *RTOL,
	    double *ATOL, int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
	
	extern "C" void contex_(int *II, double *X, double *RC, double *LRC, double *IC,
	                        double *LIC);
cd33b44e6f78d4b681764767b00a985e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|142|1|V|cpp
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  /* allocation of workspace */
	  int LWORK = n * (ljac + lmas + 3 * le + 12) + 20;
	  int LIWORK = 3 * n + 20;
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  radau5_(&N, fcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC, &MLJAC,
	          &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT, WORK.data(),
	          &LWORK, IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
8a552e1d09f02b787340175d8f5ff952|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|206|46|v|cpp
	XEND
d9c23feb670af67eba8d4c828bd24c38|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|206|67|v|cpp
	RTOL
66631c799602467c171226f2c6188a2d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|207|12|v|cpp
	ATOL
3f34127e10680ba79564d7110b7f9135|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|207|22|v|cpp
	ITOL
8a89ae76b9dd4aef9ec6ec52166fff9f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|209|9|v|cpp
	IJAC
8f1d69d6007a5722d98e1e381e3fcbc9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|209|19|v|cpp
	MLJAC
e15720e24a7ca48ddea9c1ab3c6df4fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|209|30|v|cpp
	MUJAC
1f396a4c71db63b765ca60aab2362114|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|210|72|v|cpp
	IMAS
07af3e7fe0d0f40a609364683ce7a3fc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|211|9|v|cpp
	MLMAS
e1a0c83a4a06eaaecf591f508029bafd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|211|20|v|cpp
	MUMAS
248cb8c7afb6fef6e8d7be6d3d879c56|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|10|v|cpp
	IOUT
9f20f1fb4bd4638144d4f642b3159812|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|24|v|cpp
	WORK
dfe70e00a4f71260e16212d83f5f1496|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|35|v|cpp
	LWORK
6ce283df1e1d501e23377ec5c3cc0698|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|47|v|cpp
	IWORK
9a440e3671d2587573cc74917fba2910|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|59|v|cpp
	LIWORK
d8e57ede809eb7d5cdb3021a436a57cd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|52|v|cpp
	, int *liwork
b1ab37c9a1b16532004be69c68d5e900|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|29|v|cpp
	 int *lwork
e482720450fa15c20ab7207535687be2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|215|51|v|cpp
	RPAR
23d044844f9c38e6d090f129d20c5b41|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|216|10|v|cpp
	IPAR
094c367727273b4da2b960ca3b3edc06|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|216|21|v|cpp
	IDID
307bc8cfcae67929a615bfc93482ed50|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|206|17|v|cpp
	 int itol,
31af1e13a3ccbf95a2066f5b94b63364|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|266|3|v|cpp
	radau5_
cd1e0a87092c1cb03be4303b5f1bf01e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|37|1|V|cpp
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    int *IFCN, double *X, double *Y, double *XEND, double *H, double *RTOL,
	    double *ATOL, int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
6852262ee600116cd2ca324ba3b2ff12|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|192|5|v|cpp
	int *N, void FCN(int *, double *, double *, double *, double *, int *),
363cc58a3f144d69b406ae8a0df289e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|134|5|V|cpp
	    int ifcn,
30224dced14674ac3c01bb16c75bc8d8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|193|5|V|cpp
	    int *IFCN, double *X, double *Y, double *XEND, double *H, double *RTOL,
	    double *ATOL, int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
aea1b067210b5368c21411120d53a0b5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|206|10|v|cpp
	IFCN
03cc0ac517add10448f63e49178b09f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|24|v|cpp
	const double logx, const double *w, double *dw) {
09def9ba31aab8d617706c53fa3f9fd2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|102|23|v|cpp
	const double logx, const double *w, double **jac) {
54c9c49e894cd0caf37bea1d103deeca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|10|12|v|cpp
	int *n, double *x, double *y, double *dfy, int *ldfy, double *rpar,
	           double *ipar
d0b8a25bc34f05e4f7da7abf202c56b4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|1|V|cpp
	  std::vector<double> w(2);
d1612243ff13b5a917bb01f2e79ded5b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|3|V|cpp
	  //Temperary array 
a3ed5aa6189fbd9b610d9a7c2ee2b3ba|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|3|V|cpp
	  std::vector<std::vector<doue>> fjac{2, std::vector<double>(2)};
f216e4cfd9e06aee2c1062aea18cb84e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|105|1|V|cpp
	  fjac[0] = new double*[2];
8a4bfb2407d82888788cd62f898a15ee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|30|v|cpp
	.data()
6f692388b8231c6be1a1bf3033f907f3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|1|V|cpp
	    // std::cout << "jac = " << jac[0][0] << " " << jac[0][1] << std::endl;
	    // std::cout << "      " << jac[1][0] << " " << jac[1][1] << std::endl;
4d14ce42d9c080a3dd57b4729ce681e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|5|V|cpp
	    dfy
549c1ba62c4e2dac607d32c55f1785df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|103|20|v|cpp
	 = new double *[2];
d67b060d11e1b9752954334e782d94c8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|3|V|cpp
	  fjac[0] = new double[2];
61c86ad137d55c4d6d3e9b12055ec619|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|3|V|cpp
	  fjac[1] = new double[2];
e1b4f6d0e0bcaccf84044354f9b6c7de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|1|V|cpp
	    dfy[0] = 0.0;
4c2a1292db5b3faf09f89948762a3ece|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|5|V|cpp
	    // A(i, j) = A[n * i + j]
8439918cfbd69527a70bf61fa846bd12|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|14|1|V|cpp
	  double *J[2];
c37d71ba34936a5d9e00818d4f5fcee7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|14|1|V|cpp
	  double *J[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i)
	    J[i] = &dfy[i * *ldfy];
0ed206309d587bae9e5a11ca021b0f92|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|114|26|v|cpp
	fjac
5e1a252365d33660147faf551b56deb5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|115|1|V|cpp
	    dfy[0] = fjac[0][0];
	    dfy[1] = fjac[1][0];
	    dfy[2] = fjac[0][1];
	    dfy[3] = fjac[1][1];
a6d97a11f92e64e072aa951fb4693948|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|103|12|V|cpp
	  auto fjac = new double *[2];
	  fjac[0] = new double[2];
	  fjac[1] = new double[2];
4e0f66e2aea4506c49b3a5e99a1c9a3b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|102|1|V|cpp
	  // Temporary array for jacobian
beb4204d18dad0bc3718b5c9cc7ae4a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|103|15|v|cpp
	&fjac, 
58d98d3bd9af081b6ee7da6e0b430068|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|31|v|cpp
	rpar
0a8967e8e55585ef4f0c73ec7746d154|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|41|v|cpp
	ipar
7069d2d6aac5d8e5df01886bb6eef387|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|26|17|v|cpp
	int *n, double *am, int *lmas, int *rpar, int *ipar
48666ec572e78dfb8452785c0d33147d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|28|13|v|cpp
	int *nr, double *xold, double *x, double *y, double *cont, int *lrc,
	            int *n, double *rpar, int *ipar, int *irtrn
70ffbbd7c0072e1dae1457d5a3b10ff8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|34|1|V|cpp
	  printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, *x, y[0], y[1]);
88beb8ecabc0874946bd442333addc75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|72|1|V|cpp
	#define ND 2
	#define NS 7
	#define LWORK (NS + 1) * ND *ND + (3 * NS + 3) * ND + 20
	#define LIWORK (2 + (NS - 1) / 2) * ND + 20
	
	  double y[ND], work[LWORK];
	  int iwork[LIWORK];
	  double x, xend;
	  int i, idid;
	
	  /*parameter in the differential equation*/
	  double rpar = 1e-6;
	  /*dimension of the system*/
	  int n = 2;
	  /* compute the jacobian analytically */
	  int ijac = 1;
	  /* jacobian is a full matrix*/
	  int mljac = n;
	  int mujac = 0;
	  /* differential equation is in explicit form*/
	  int imas = 0;
	  int mlmas = 0;
	  int mumas;
	  int ipar = 0;
	  /* output routine is used during integration*/
	  int iout = 1;
	
	  /* required tolerance*/
	  double rtol = 1.0e-7;
	  double atol = 1.0 * rtol;
	  int itol = 0;
	  /* initial step size*/
	  double h = 1.0e-6;
	
	  int lwork = LWORK;
	  int liwork = LIWORK;
	
	  /* initial values*/
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  /* endpoint of integration*/
	  xend = 2.0;
	  /* set default values */
	  for (i = 0; i < 20; i++) {
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
4eefb04870438ebd53417632307194be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|116|1|V|cpp
	
	  // dimension of problem
	  const int n = 2;
	  // interval of x for printing output
	  double dx = (log_xfinal - log_xstart) / 30.0;
	  // rtoler and atoler are scalars
	  int itoler = 0;
	  // relative tolerance
	  double *rtoler = new double(1e-6);
	  // absolute tolerance
	  double *atoler = new double(1e-6);
	  // use SolutionOutput routine
	  const int iout = 1;
	  // initial step size
	  double hinit = 1e-6;
	  // analytical Jacobian function provided
	  const int ijac = 1;
	  // number of non-zero rows below main diagonal of Jacobian
	  int mljac = n;
	  // number of non-zero rows above main diagonal of Jacobian
	  int mujac = n;
	  // Mass matrix routine is identity
	  const int imas = 0;
	  int mlmas = 0;
	  int mumas = 0;
	  // Use default values (see header files) for these parameters:
	  double hmax(0.0);
	  int nmax(0);
	  double uround(0.0), safe(0.0), facl(0.0), facr(0.0);
	  int nit(0);
	  bool startn(false);
	  int nind1(0), nind2(0), nind3(0), npred(0), m1(0), m2(0);
	  bool hess(false);
	  double fnewt(0.0), quot1(0.0), quot2(0.0), thet(0.0);
	
	  gsl_set_error_handler_off();
	
	  StiffIntegratorT stiffT(dydx, jac, mm, n, w.data(), log_xstart, log_xfinal,
	                          dx, itoler, rtoler, atoler, iout, hinit, hmax, nmax,
	                          uround, safe, facl, facr, ijac, mljac, mujac, imas,
	                          mlmas, mumas, nit, startn, nind1, nind2, nind3, npred,
	                          m1, m2, hess, fnewt, quot1, quot2, thet);
	  stiffT.Integrate();
b1531cd4fc0ffc0be57705d4e6ed9e96|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|72|1|V|cpp
	#define ND 2
	#define NS 7
	#define LWORK (NS + 1) * ND *ND + (3 * NS + 3) * ND + 20
	#define LIWORK (2 + (NS - 1) / 2) * ND + 20
	
	  double y[ND], work[LWORK];
	  int iwork[LIWORK];
	  double x, xend;
	  int i, idid;
	
	  /*parameter in the differential equation*/
	  double rpar = 1e-6;
	  /*dimension of the system*/
	  int n = 2;
	  /* compute the jacobian analytically */
	  int ijac = 1;
	  /* jacobian is a full matrix*/
	  int mljac = n;
	  int mujac = 0;
	  /* differential equation is in explicit form*/
	  int imas = 0;
	  int mlmas = 0;
	  int mumas;
	  int ipar = 0;
	  /* output routine is used during integration*/
	  int iout = 1;
	
	  /* required tolerance*/
	  double rtol = 1.0e-7;
	  double atol = 1.0 * rtol;
	  int itol = 0;
	  /* initial step size*/
	  double h = 1.0e-6;
	
	  int lwork = LWORK;
	  int liwork = LIWORK;
	
	  /* initial values*/
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  /* endpoint of integration*/
	  xend = 2.0;
	  /* set default values */
	  for (i = 0; i < 20; i++) {
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  printf("\n**********\n* radau  *\n**********\n\n");
	  /* directly calling fortran */
	  radau_(&n, vdpol, &x, y, &xend, &h, &rtol, &atol, &itol, jvpol, &ijac, &mljac,
	         &mujac, mass_dummy, &imas, &mlmas, &mumas, solout, &iout, work, &lwork,
	         iwork, &liwork, &rpar, &ipar, &idid);
	
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
	
	  /* new call of radau using the c-wrapper */
	  /* reset values */
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
	  for (i = 0; i < 20; i++) {
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  /* note that some values can here be passed directly */
	  radau(n, vdpol, 0.0, y, 2.0, 1e-6, rtol, atol, jvpol, ijac, mljac, mujac,
	        mass_dummy, imas, mlmas, mumas, solout, iout, work, iwork, &rpar, &ipar,
	        &idid);
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
	
	  /* radau5 */
	  printf("\n**********\n* radau5 *\n**********\n\n");
	
	  /* reset values */
	  x = 0.0;
	  h = 1.0e-6;
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  /* directly calling fortran */
	  radau5_(&n, vdpol, &x, y, &xend, &h, &rtol, &atol, &itol, jvpol, &ijac,
	          &mljac, &mujac, mass_dummy, &imas, &mlmas, &mumas, solout5, &iout,
	          work, &lwork, iwork, &liwork, &rpar, &ipar, &idid);
	
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
	
	  /* new call of radau using the c-wrapper */
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  radau5(n, vdpol, 0.0, y, 2.0, 1e-6, rtol, atol, jvpol, ijac, mljac, mujac,
	         mass_dummy, imas, mlmas, mumas, solout5, iout, work, iwork, &rpar,
	         &ipar, &idid);
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
e39ba0a7790848467b176685f0a23cbe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|122|1|v|cpp
	#define 
d1038181d1723f87b087f311aaed0dae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|124|1|v|cpp
	#define
f1edc500eb1136f10c17eeffb9eecbc5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|125|1|v|cpp
	define
ef129e3dc160ec358dd3b8c0e4dfd30b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|83|1|V|cpp
	  double meta = model.get_m_eta();
	
	  double td = model.get_lam() / 2.0;
	  double xi = compute_xi_const_td(td, model);
	  double tsm = td / xi;
	  double s = sm_entropy_density(tsm);
	
	  double log_xstart = log(meta / tsm);
	  double log_xfinal = log(meta / T_CMB);
	
	  std::vector<double> w(2);
	  w[0] = log(neq_eta(td, model) / s);
	  w[1] = neq_del(td, model) / s;
	
f6a8ce8bd25e1995ae1f6dbf0c72c880|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|129|3|v|cpp
	double y[ND], 
2d4376416ee4c39c613d41b9c52a0632|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|131|3|V|cpp
	  double x, xend;
ad0084078898754a98ae53ad7cb4f895|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|131|1|V|cpp
	  /*parameter in the differential equation*/
	  double rpar = 1e-6;
1e0ea17056bd1ad3e84986d3c40d0881|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|156|1|V|cpp
	  /* initial values*/
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
3d67481f2acf6ae691a78143b1d8a25c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|157|1|V|cpp
	  /* endpoint of integration*/
	  xend = 2.0;
b17fc953ca34a19ceb466cd51914e185|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|153|1|V|cpp
	  int lwork = LWORK;
	  int liwork = LIWORK;
249f51b801bedfefc7afd9391143cad1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|1|V|cpp
	  printf("\n**********\n* radau  *\n**********\n\n");
	  /* directly calling fortran */
	  radau_(&n, vdpol, &x, y, &xend, &h, &rtol, &atol, &itol, jvpol, &ijac, &mljac,
	         &mujac, mass_dummy, &imas, &mlmas, &mumas, solout, &iout, work, &lwork,
	         iwork, &liwork, &rpar, &ipar, &idid);
	
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
a54272bdfd41ccdd32615444f35bc27e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|1|V|cpp
	
	  /* new call of radau using the c-wrapper */
	  /* reset values */
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
	  for (i = 0; i < 20; i++) {
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
b977c21326844003459935b7bce6f405|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|1|V|cpp
	
	  /* note that some values can here be passed directly */
	  radau(n, vdpol, 0.0, y, 2.0, 1e-6, rtol, atol, jvpol, ijac, mljac, mujac,
	        mass_dummy, imas, mlmas, mumas, solout, iout, work, iwork, &rpar, &ipar,
	        &idid);
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
	
	  /* radau5 */
	  printf("\n**********\n* radau5 *\n**********\n\n");
765a18c6df63eff87be8671bd0bf1777|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|1|V|cpp
	
	  /* reset values */
	  x = 0.0;
	  h = 1.0e-6;
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  /* directly calling fortran */
	  radau5_(&n, vdpol, &x, y, &xend, &h, &rtol, &atol, &itol, jvpol, &ijac,
	          &mljac, &mujac, mass_dummy, &imas, &mlmas, &mumas, solout5, &iout,
	          work, &lwork, iwork, &liwork, &rpar, &ipar, &idid);
	
	  /* print final solution */
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
	
	  /* print statistics */
	  printf("rtol = %1.2e\n", rtol);
	  printf("fcn= %i jac= %i step= %i accpt= %i rejct= %i dec= %i sol= %i\n",
	         iwork[13], iwork[14], iwork[15], iwork[16], iwork[17], iwork[18],
	         iwork[19]);
d8f748934beb3fd4b7112b193faa885e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|1|V|cpp
	
	  /* new call of radau using the c-wrapper */
	  x = 0.0;
	  y[0] = 2.0;
	  y[1] = -0.66;
3b160bb3da311ff00c14f8cf109a3aaf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|13|v|cpp
	vdpol
5a2baba13fe78e395c14b6daeb32c75a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|7|1|V|cpp
	#include "darksun/radau5.hpp"
e82bbb46bbff94f8bddbcfcc864134f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|10|v|cpp
	mass_dummy
bc471493639c84d935b6072eb1e42058|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|61|v|cpp
	&rpar,
a88909b76b065318f77142c27936c74d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|161|10|v|cpp
	&ipar
119552cff9c0d7609f7f0050239cb55b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|159|50|v|cpp
	jvpol
c02101bf1529efed0d6535941f913a2d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|57|v|cpp
	nullptr
72700e4ff599adf5a6cd5b9432cbb5fc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|142|1|V|cpp
	  int ipar = 0;
26fd73b7ddc68e589201622767c6a272|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|84|39|v|cpp
	int *n, double *x, double *y, double *fy, double *rpar,
	                       int *ipar
ec7613e0929d446c9f424dd206fbe1cc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|84|1|V|cpp
	  std::function<void (*)(int *n, double *x, double *y, double *fy, double *rpar,
	                         int *ipar)>
812db81a8a7922e054a51557a21004f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|84|1|V|cpp
	  auto dydx = [&model](int *n, double *x, double *y, double *fy, double *rpar,
	                      int *ipar) { boltzmann(*x, y, fy, model); };
1466b2d899ea5d482376df33e6fdb847|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|20|16|v|cpp
	const double logx, const double *y, double *dy
c5e1909de7766cc9424fbf19c97fbf05|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|28|v|cpp
	int *n, double *x, double *y, double *fy,
	                           double *rpar,
	                           int *ipar
89c2e297df4ab50d2cb784e8b811f144|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|90|16|v|cpp
	&model
0bf9db3db936c7247578885179b27a93|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|92|5|v|cpp
	boltzmann(*x, y, fy, model); 
88facb06f58f00a92fecbf34fa5f1d37|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|86|21|v|cpp
	, &model
0d6252619ab421067f6e0db2e3e73d0b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|89|1|V|cpp
	  // Now, we make a non capturing function
	  auto dydx = [](int *n, double *x, double *y, double *fy, double *rpar,
	                 int *ipar) {
	    (*static_cast<decltype(dydx_cap) *>(*x, y, fy));
	  };
a679b0e08fb827aa90ebf5c33ac0e41a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|82|49|v|cpp
	 const DarkSun model
2d709156770cea6a8f380073bf365448|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|88|1|V|cpp
	  const double mu = model.get_mu_eta();
	  const double n = model.get_n();
	  const double lam = model.get_lam();
	  const double l1 = model.get_lec1();
	  const double l2 = model.get_lec2();
c9cdd3ad7e11857375a170826c8bbfc5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|94|23|v|cpp
	int *n, double *x, double *y, double *dfy, int *ldfy,
	                      double *, double *
e079e8f400291bc7900746d772f02e3c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|55|20|v|cpp
	const double logx, const double *y, double **df
808014a1228ed996277bbb78ebdbc3a1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|1|V|cpp
	  // Construct the function
	  // First, we make a capturing function
	  auto dydx_cap = [&model](const double logx, const double *y, double *dy) {
	    boltzmann(logx, y, dy, model);
	  };
	  // Now, we make a non capturing function
	  auto dydx = [](int *n, double *x, double *y, double *fy, double *rpar,
	                 int *ipar) { (*static_cast < decltype(dydx_cap) *) > };
	
	  auto jac = [&model](int *n, double *x, double *y, double *dfy, int *ldfy,
	                      double *, double *) {
	    double *J[2];
	    int i;
	    /* set J to first elt. of each column */
	    for (i = 0; i < *n; ++i) {
	      J[i] = &dfy[i * *ldfy];
	    }
	    boltzmann_jac(*x, y, J, model);
	  };
50b34f8721ad27b96b2339f73a054376|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|85|1|V|cpp
	  auto mm = [](int *n, double *am, int *lmas, int *rpar, int *ipar) {};
	  auto solout = [&model](int *nr, double *xold, double *x, double *y,
	                         double *cont, int *lrc, int *n, double *rpar,
	                         int *ipar, int *irtrn) {
	    printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, *x, y[0], y[1]);
	  };
38fba1c4fc1c589de6ee80127cc62a8a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|96|1|V|cpp
	    double *J[2];
	    int i;
	    /* set J to first elt. of each column */
	    for (i = 0; i < *n; ++i) {
	      J[i] = &dfy[i * *ldfy];
	    }
093b1535fbb189a25f58c6b99f74ca83|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|91|15|v|cpp
	= [&model]
c70fcc5512cd07944604e12406999912|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|1|V|cpp
	
	  // Construct the function
	  // First, we make a capturing function
	  auto dydx_cap = [&model](const double logx, const double *y, double *dy) {
	    boltzmann(logx, y, dy, model);
	  };
	  // Now, we make a non capturing function
	  auto dydx = [](int *n, double *x, double *y, double *fy, double *rpar,
	                 int *ipar) { (*static_cast < decltype(dydx_cap) *) > };
	
	  auto jac = [&model](int *n, double *x, double *y, double *dfy, int *ldfy,
	                      double *, double *) {
	    double *J[2];
	    int i;
	    /* set J to first elt. of each column */
	    for (i = 0; i < *n; ++i) {
	      J[i] = &dfy[i * *ldfy];
	    }
	    boltzmann_jac(*x, y, J, model);
	  };
	  auto mm = [](int *n, double *am, int *lmas, int *rpar, int *ipar) {};
	  auto solout = [&model](int *nr, double *xold, double *x, double *y,
	                         double *cont, int *lrc, int *n, double *rpar,
	                         int *ipar, int *irtrn) {
	    printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, *x, y[0], y[1]);
	  };
31530ed80011d7f75c5ec28fe8eb7adc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|99|1|V|cpp
	  auto dydx = std::bind(boltzmann, _1, _2, _3, _4, _5, _6, model);
b8b434531a3894315f32953700ea80e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|3|V|cpp
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", x, y[0], y[1]);
e19cac3121711e93144457a4a8bf6f5c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|1|V|cpp
	  /* print final solution */
57262b25a2b5966074c9984547d5d29f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|99|15|v|cpp
	std::ptr_fun(
6eaaa8269b35ad6bec368aeaed6d25b9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|18|v|cpp
	ptr_fun
a25c5bf2d499a4f4526af6d00ca94ac0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|13|v|cpp
	std::function(
461d39e665fe6a4d0e1cb16ec96f0935|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|109|15|v|cpp
	std::bind(boltzmann, _1, _2, _3, _4, _5, _6, std::ref(model));
9ee150d8a3ec3ec80bf3224bf3f00725|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|111|7|V|cpp
	      std::bind(boltzmann_jac, _1, _2, _3, _4, _5, _6, _7, std::ref(model));
457035d70d0f317fc967a8956813cf7c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|30|16|v|cpp
	int *, double *logx, double *y, double *dy, double *rpar,
	               int *ipar,
8942a4b54a99fde10ad351b8b81ff7e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|65|20|v|cpp
	int *n, double *logx, double *y, double *dfy, int *ldfy,
	                   double *, double *
6a63ce5706bc730369e832ac42747be7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|117|1|V|cpp
	  auto dydx = lambda_expression<decltype(dydx_cap), void, int *, double *,
	                                double *, double *, double *, int *>(dydx_cap);
d3fc420e316f9020d18b1b75d57bee54|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|120|41|v|cpp
	dydx_cap
e71f3e85dc2616bedff2079503d362ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|117|1|V|cpp
	  auto dydx = lambda_expression<decltype(dydx_cap), void, int *, double *,
	                                double *, double *, double *, int *>(dydx_cap);
	
	  auto jac =
	      lambda_expression<decltype(jac_cap), void, int *, double *, double *,
	                        double *, int *, double *, double *>(jac_cap);
3bda272dc051e8233cce092cd3250bfe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|22|1|V|cpp
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    double *X, double *Y, double *XEND, double *H, double *RTOL, double *ATOL,
	    int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
4c8e2caa479268726f04a7aee4f22450|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|5|v|rust
	int *N
9508d260c39f0c0f52f3352b45316925|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|25|5|v|rust
	int *IWORK
2ef55dee6bff35c1ba75b8f9763699eb|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|26|5|v|rust
	int *LIWORK
c2854069f57efc5ecbdf657eb33dec6e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|27|5|v|rust
	double *RPAR
e4de609c0bdb023e1bcf8508ce6f4d5b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|28|5|v|rust
	int *IPAR
691da1690c9962f516f1fd92dd3217f7|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|29|5|v|rust
	int *IDID
eef3257a5f3827768f3a2852f0cdffae|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|5|25|v|rust
	*mut c_double
5ef7013e02f31e7e4f3a585c736eb865|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|6|5|V|rust
	    void FCN(int *, double *, double *, double *, double *, int *),
86f45ac88cb4cad4997a6e597d777b67|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|5|1|V|rust
	    fcn: fn(*mut c_int, *mut c_double, *mut c_double,*mut c_double,*mut c_double,*mut c_int),
88a537e44d73e6923a8ca3a1bc668f2b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|13|1|V|rust
	    jac: fn(*mut c_int, *mut c_double, *mut c_double,*mut c_double,*mut c_int, *mut c_double,*mut c_int),
390b333ae796a137d3b8443098850493|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|17|13|v|rust
	*mut c_int, *mut c_double, *mut c_double,*mut c_double,*mut c_int, *mut c_double,*mut c_int),
0374b2e47c793f8649a0e5b2cdd577af|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|19|5|v|rust
	int *IMAS,
f323f21d64f10acfbc5d0916a4c99025|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|18|5|V|rust
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), 
fda10143c08be1ce78ff36f265d87fa1|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|17|1|V|rust
	    mas: fn(*mut c_int, *mut c_double, *mut c_int, *mut c_double, *mut c_int),
96730bd0d23c0d900f3309d7c19e210f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|21|28|v|rust
	*mut c_double,
a70dcc202c2aba72d52fd6b36850a391|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|5|V|rust
	    void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
9cb09c25ad850e61f67e2fdbb11fe6ca|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|23|17|V|rust
	                double *, int *, int *),
38023333e6f76695fa305591db936ece|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|25|V|rust
	fish: Unknown command: se
	~/.config/fish/config.fish (line 7): 
	se -gx PKG_CONFIG_PATH "/usr/local/opt/openblas/lib/pkgconfig,/usr/local/opt/lapack/lib/pkgconfig"
	^
	from sourcing file ~/.config/fish/config.fish
		called during startup
21fe2fe561c26758eae8a1ab08c77885|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|6|1|V|rust
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
5df3d58877d63d66c6559f206bfaecab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/glue.f|1|1|V|fortran
	use iso_c_binding
e0b311e43a37c82b225d1959bbb18d63|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|135|1|V|cpp
	    //void fcn(int *, double *, double *, double *, double *, int *),
28c6b1216d00614470fe6f0358b2e1c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|136|5|V|cpp
	    std::function<void(int *, double *, double *, double *, double *, int *)>
0949a50c1386d1c1fd9e37b774952a08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|136|9|V|cpp
	        fcn,
1e558cc2bace299cb0dc330574f7ebb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|v|cpp
	//         
1e558cc2bace299cb0dc330574f7ebb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|v|cpp
	//         
1e558cc2bace299cb0dc330574f7ebb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|v|cpp
	//         
1e558cc2bace299cb0dc330574f7ebb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|v|cpp
	//         
0e14f6aa39c682b5a51c1e052d61b1a2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|173|3|V|cpp
	  &dydx.operator();
38cc9a63540437a54b4f70d0eb2959dd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|20|1|v|cpp
	template <typename OT, typename RT, typename... A> struct lambda_expression {
	  OT _object;
	  RT (OT::*_function)(A...) const;
	
	  lambda_expression(const OT &object)
	      : _object(object), _function(&decltype(_object)::operator()) {}
	
	  RT operator()(A... args) const { return (_object.*_function)(args...); }
	};
ce63ee7b1d69ae05a4752dc32e1e70a1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|123|1|V|cpp
	fun(..., double *, int *)
9859b24e63abfb12ecfc7a7e9405665c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|123|1|V|cpp
	std::vector<double> model_to_vec(DarkSun&model){
2920bf627a595428ed4d9f8d7730b58e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|13|1|V|cpp
	  /* Order of the dark gauge group, i.e. N in SU(N)*/
	  size_t m_n;
	  /* Confinement scale of the dark sector in GeV */
	  double m_lam;
	  /** Suppression factor for creating deltas from etas: A(2eta -> 2delta) ~
	   *  exp(-cn)
	   */
	  double m_c;
	  double m_lec1;
	  double m_lec2;
	  double m_adel;
	  double m_mu_eta;
	  double m_mu_del;
	  double m_xi_inf;
	
	  std::optional<double> m_xi_fo{};
	  std::optional<double> m_tsm_fo{};
	  std::optional<double> m_xi_bbn{};
	  std::optional<double> m_xi_cmb{};
	  std::optional<double> m_rd_eta{};
	  std::optional<double> m_rd_del{};
	  std::optional<double> m_dneff_cmb{};
	  std::optional<double> m_dneff_bbn{};
	  std::optional<double> m_eta_si_per_mass{};
	  std::optional<double> m_del_si_per_mass{};
	
	  std::vector<std::array<double, 3>> m_solution;
eabf9f78950646f538063cc633cbffc8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|1|V|cpp
	 * rpar[0] = n
	 * rpar[1]
c696e579fba0698e5efa89fe32a8aca0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|3|V|cpp
	  /* Order of the dark gauge group, i.e. N in SU(N)*/
09d8aba96bf174c5a179a0a25fc7ef73|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|3|V|cpp
	  size_t m_n;
d3d229602bc03edc7ba10b7669787912|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|3|V|cpp
	  /* Confinement scale of the dark sector in GeV */
aa935ba6a69c227dfde13bce8cda75fe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|127|3|V|cpp
	  /** Suppression factor for creating deltas from etas: A(2eta -> 2delta) ~
5a30eeaa01a4404348f0f1a4220c223f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|127|4|V|cpp
	   *  exp(-cn)
63d7771617cd124474dc5e072e48c2ef|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|127|4|V|cpp
	   */
cbde4a5e923cff3a446d536341a9df31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|3|v|cpp
	double m_
a24c9c5551981762c1d32eff4dc04770|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|145|1|V|cpp
	 * rpar[19...19 + nsol] = logxs
d0757308e98f60a31ef851b82d12fdd6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|146|21|v|cpp
	19 + nsol
4bb0e66b5546d56bee39baa1f07a5190|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|146|29|v|cpp
	logxs
70c327f178cee7383d5fd748dbd85bb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|146|1|V|cpp
	 * rpar[19 + nsol + 1...] = w_eta
58ad2f69c31e0d3879143a01971b4a1f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|146|9|v|cpp
	19 + nsol + 1
3f1357176d214ad7102aa9c69973ea9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|149|3|V|cpp
	  std::vector<std::array<double, 3>> m_solution;
4b27fdab412623e3d2eec44c64f0fd40|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|151|1|V|cpp
	 * ipar[2] = has xi_fo been set? 0 or 1
ba30ab07a0bdd3f75ac25faa8fff70c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|1|V|cpp
	double get_lam(double * rpar, double *ipar){
	  return rpar[1];
	}
481acb36de686f1ac89748e710dc7a3a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|161|1|V|cpp
	double get_c(double * rpar, int*){
	  return rpar[1];
	}
56113ee3662f1c972bddf0001744ee82|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|164|1|V|cpp
	double get_lec1(double * rpar, int*){
	  return rpar[1];
	}
ebe1221a87cb71b2fc3e67ae683a6f79|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|1|V|cpp
	double get_lec2(double * rpar, int*){
	  return rpar[1];
	}
378f0c5a7977d6e277ddd3f085ae1085|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|170|1|V|cpp
	double get_adel(double * rpar, int*){
	  return rpar[1];
	}
518bf49f67c070201ce1f8c6d0a35d08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|173|1|V|cpp
	double get_mu_eta(double * rpar, int*){
	  return rpar[1];
	}
eec7295742822ec2084f2e625b2d803d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|176|1|V|cpp
	double get_mu_del(double * rpar, int*){
	  return rpar[1];
	}
6a20469f6a1cf9348b1b0bdf7bc3b2d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|65|1|V|cpp
	  size_t get_n() const { return m_n; }
	  double get_lam() const { return m_lam; }
	  double get_c() const { return m_c; }
	  double get_lec1() const { return m_lec1; }
	  double get_lec2() const { return m_lec2; }
	  double get_adel() const { return m_adel; }
	  double get_mu_eta() const { return m_mu_eta; }
	  double get_mu_del() const { return m_mu_del; }
	  double get_xi_inf() const { return m_xi_inf; }
	  double get_m_eta() const { return m_mu_eta * m_lam / sqrt(double(m_n)); }
	  double get_m_del() const { return m_mu_del * m_lam * double(m_n); }
	  double get_g_eta() const { return 1.0; }
	  double get_g_del() const { return double(m_n + 1); }
	
	  std::optional<double> get_xi_fo() const { return m_xi_fo; };
	  std::optional<double> get_tsm_fo() const { return m_tsm_fo; };
	  std::optional<double> get_xi_bbn() const { return m_xi_bbn; };
	  std::optional<double> get_xi_cmb() const { return m_xi_cmb; };
	  std::optional<double> get_rd_eta() const { return m_rd_eta; };
	  std::optional<double> get_rd_del() const { return m_rd_del; };
	  std::optional<double> get_dneff_cmb() const { return m_dneff_cmb; };
	  std::optional<double> get_dneff_bbn() const { return m_dneff_bbn; };
	  std::optional<double> get_eta_si_per_mass() const {
	    return m_eta_si_per_mass;
	  };
	  std::optional<double> get_del_si_per_mass() const {
	    return m_del_si_per_mass;
	  };
351cf094b5735e098c8a8bb08e1152f1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|1|V|cpp
	double get_n(double * rpar, int*){
	  return rpar[0];
	}
	double get_lam(double * rpar, int*){
	  return rpar[1];
	}
	double get_c(double * rpar, int*){
	  return rpar[1];
	}
	double get_lec1(double * rpar, int*){
	  return rpar[1];
	}
	double get_lec2(double * rpar, int*){
	  return rpar[1];
	}
	double get_adel(double * rpar, int*){
	  return rpar[1];
	}
	double get_mu_eta(double * rpar, int*){
	  return rpar[1];
	}
	double get_mu_del(double * rpar, int*){
	  return rpar[1];
	}
	double get_xi_inf(double * rpar, int*){
	  return rpar[1];
	}
2ae0563543ceeb3ae9ea54894823d48b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|158|48|v|cpp
	m_lec1
9f7c9fcb89a7e5f26701842426a1c777|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|159|48|v|cpp
	m_lec2
5907e5fef578011d06629797f877e6fc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|160|48|v|cpp
	m_adel
8d3d09bcdb3840a711acd0701792f4d4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|161|50|v|cpp
	m_mu_eta
a6f72df6d00079a6cd910dda64babdea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|162|50|v|cpp
	m_mu_del
90e80e27b1340ce1d306391183524e88|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|165|60|v|cpp
	mu_eta 
d60406235d179cd2abe2551d683f1605|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|165|77|v|cpp
	m_lam 
775345aeb78ced9d89f01a28647df21a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|169|10|v|cpp
	get_mu_eta(rpar, nullptr)
213cc936c03c3fd0bcd40a2a97544be7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|169|19|v|cpp
	get_lam(rpar, nullptr)
34bf48ea036cdcf41e32bca41a92969e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|170|15|v|cpp
	get_n(rpar, nullptr)
433aecc86284161ab5328504c98ca595|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|166|1|V|cpp
	  double mu_eta = get_mu_eta(rpar, nullptr);
	  double lam = get_lam(rpar, nullptr);
	  double n = get_n(rpar, nullptr);
832c83016d5f353a6019df4455fc34ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|1|V|cpp
	  return m_mu_del * m_lam * double(m_n); 
d955ce5e89740675c10148f36032215b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|178|48|v|cpp
	double(m_n + 1)
628e355fee5c07fdc9e8fe46d4eed25b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|180|1|V|cpp
	  if (ipar[2]){
	    return m_xi_fo; 
	  }
8642973dd701283f81fd1fb23218d337|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|181|53|v|cpp
	m_xi_bbn
c3f6618a88985c1026f7af7b638fbbee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|182|53|v|cpp
	m_xi_cmb
4b334d653e82c14a12cff93e7f75ff68|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|183|53|v|cpp
	m_rd_eta
93a1ceeca77497f3558bb9c81e91ce67|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|184|53|v|cpp
	m_rd_del
8cc16ae944e15a0f6d6cf9b7925fcf5c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|185|56|v|cpp
	m_dneff_cmb
e9e44315bf0c8f7761df392f32369a7f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|186|56|v|cpp
	m_dneff_bbn
e90b5beb33bf4dd1cdda9186fd0c333a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|188|3|V|cpp
	  return m_eta_si_per_mass;
ab9dd098401214ff730a3b40354016c5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|190|3|V|cpp
	  return m_del_si_per_mass;
408d51bdb5f33f7c66ed06803be3f17b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|151|2|V|cpp
	 * similar for rest of options
f82c61eb47140bd4df4efef3a622c425|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|186|40|v|cpp
	, int *)
5c1a3286676cf078db9b4a531855237f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|176|50|v|cpp
	, nullptr
982e7acb7ddc0ac7bd2a8e330952706f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|82|1|V|cpp
	double cross_section_2eta_4eta(const double cme, const DarkSun model) {
	  using boost::math::pow;
	  const double mu = model.get_mu_eta();
	  const double n = model.get_n();
	  const double lam = model.get_lam();
	  const double l1 = model.get_lec1();
	  const double l2 = model.get_lec2();
	
	  // Common prefactos of the cross section terms
	  const double pref = pow<2>((256.0 * pow<4>(M_PI) / 9.0));
	  const double norm = pref * pow<14>(mu) / (lam * lam * pow<11>(n));
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = norm * pow<4>(l1) / 9.0;
	  const double c66 = norm * pow<2>(l2) / 25.0;
	  const double c46 = -2.0 * norm * l2 * pow<2>(l1) / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / model.get_m_eta();
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
	}
7c5afe246d82feef80c232c701e9b42d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|104|50|v|cpp
	const DarkSun model
3291aad5e085aa15ef80dea8db98231d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|130|1|V|cpp
	double thermal_cross_section_2eta_4eta(const double x, const DarkSun model) {
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = model.get_m_eta();
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
dd695ada0adf168f4543e538d483948a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|151|54|v|cpp
	, const DarkSun model
8a261f003b5297eb81eb82bab7aaa781|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|104|1|V|cpp
	double cross_section_2eta_4eta(const double cme, double *rpar) {
	  using boost::math::pow;
	  const double mu = get_mu_eta(rpar);
	  const double n = get_n(rpar);
	  const double lam = get_lam(rpar);
	  const double l1 = get_lec1(rpar);
	  const double l2 = get_lec2(rpar);
	
	  // Common prefactos of the cross section terms
	  const double pref = pow<2>((256.0 * pow<4>(M_PI) / 9.0));
	  const double norm = pref * pow<14>(mu) / (lam * lam * pow<11>(n));
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = norm * pow<4>(l1) / 9.0;
	  const double c66 = norm * pow<2>(l2) / 25.0;
	  const double c46 = -2.0 * norm * l2 * pow<2>(l1) / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / get_m_eta(rpar);
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
	}
a85beef240d4744158dada68c61b6750|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|130|1|V|cpp
	double thermal_cross_section_2eta_4eta(const double x, double*rpar) {
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = get_m_eta(rpar);
	
	  auto f = [x, &rpar, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, rpar);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
24dbfaf1836aeb989d4c38c1a587b4d6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|131|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 4eta -> 2eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_4eta_2eta(const double x, const DarkSun model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = model.get_m_eta();
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 2delta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_2del(const double x, const DarkSun model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double c = model.get_c();
	  const double n = double(model.get_n());
	  const double lam = model.get_lam();
	  const double meta = model.get_m_eta();
	  const double mdel = model.get_m_del();
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double zmin = 2.0 * mdel / meta;
	  const double sig = exp(-2.0 * c * n) / (64.0 * M_PI * n * n * lam * lam);
	
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * sig * integral;
	}
0cbc1b623ad94df11a4c17c849b910c5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|273|20|v|cpp
	double(.get_n());
6959ec8cb915c8dccd1fef74e8f40e1d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|187|2|V|cpp
	 * ----------------------------------
1d191a14830fa4e7cafe032ad400521a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|78|1|V|cpp
	/**
	 * Compute the full cross section for 2eta -> 4eta, include the 4pt and 6pt
	 * amplitudes and all the prefactors.
	 */
3fc3d9b0fa84d8c8c29477de0e0c754c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|104|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 4eta given a scaled temperature x = meta / T.
	 */
fb0de13244dd85779df5f3455807c1d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|31|1|V|cpp
	/**
	 * Compute the equillibrium number density of the eta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_eta(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) * gsl_sf_bessel_Kn(2, x);
	}
	
	/**
	 * Compute the equillibrium number density of the delta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_del(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double x = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  return g * pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) *
	         gsl_sf_bessel_Kn(2, x);
	}
	
	double dark_heff(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double xe = model.get_m_eta() / td;
	  const double xd = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  return pre * (pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	                g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd));
	}
	
	double dark_geff(const double td, const DarkSun model) {
	  using boost::math::pow;
	  const double xe = model.get_m_eta() / td;
	  const double xd = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  const double geffe =
	      pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) + 3.0 * gsl_sf_bessel_Kn(2, xe));
	  const double geffd =
	      g * pow<2>(xd) *
	      (xe * gsl_sf_bessel_K1(xd) + 3.0 * gsl_sf_bessel_Kn(2, xd));
	  return pre * (geffe + geffd);
	}
	
	double sqrt_gstar(const double tsm, const double xi, const DarkSun model) {
	  double gd = dark_geff(tsm * xi, model);
	  double gsm = sm_geff(tsm);
	  return sm_sqrt_gstar(tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
	}
	
	/**
	 * Compute the degrees-of-freedom in entropy above confinement.
	 */
	static double dark_heff_inf(const DarkSun model) {
	  const double n = double(model.get_n());
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	}
	
	/**
	 * Compute the sum of the internal degrees-of-freedom in the energy of the
	 * dark sector below the confinement scaled (i.e. the relativistic d.o.f. of
	 * the eta + delta.)
	 */
	static double dark_sum_g(const DarkSun model) {
	  return 2.0 + double(model.get_n());
	}
	
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
	static auto xi_bounds_const_td(const double td, const DarkSun model)
	    -> std::pair<double, double> {
	  const double hd = dark_heff(td, model);
	  const double xi_inf = model.get_xi_inf();
	  const double cr_rhd = cbrt(dark_heff_inf(model) / hd);
	
	  double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	  double ub = cr_rhd * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	static auto xi_bounds_const_tsm(const double tsm, const DarkSun model)
	    -> std::pair<double, double> {
	  using boost::math::pow;
	  const double xl = model.get_m_eta() / tsm;
	  const double hsm = sm_heff(tsm);
	  const double hdinf = dark_heff_inf(model);
	  const double xi_inf = model.get_xi_inf();
	  const double sg = dark_sum_g(model);
	
	  const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	  const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	  const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	  const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
	double compute_xi_const_td(const double td, const DarkSun model) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double hd = dark_heff(td, model);
	  const double c1 =
	      dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	  // Function specifying when to stop bisection algorithm
	  auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	  // Perform bisection algorith to find xi.
	  const auto bounds = xi_bounds_const_td(td, model);
	  const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	  // Return average of the bounding points
	  return (res.second + res.first) / 2.0;
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
	double compute_xi_const_tsm(const double tsm, const DarkSun model) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const std::optional<double> tsm_fo = model.get_tsm_fo();
	  const bool frozen = tsm_fo.has_value();
	  const double tfo = tsm_fo.value_or(-1.0);
	
	  if (frozen || tsm > tfo) {
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	    auto f = [c1, model, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, model) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, model);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
	  } else {
	    // If tsm_fo has a value, that means the eta has frozen out. In this case,
	    // there is no need to perform a root finding algorithm. We just readshift.
	    const double tfo = tsm_fo.value();
	    const double xifo = model.get_xi_fo().value();
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tfo * xifo > model.get_m_eta()) {
	      return xifo;
	    } else {
	      return xifo * tsm / tfo;
	    }
	  }
	}
4acf20292b0f9ffe7a6faa3110f294ce|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|241|41|v|cpp
	DarkSun model
b2672f3110ebc67752fb0e1341e6981f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|265|20|v|cpp
	double(model.get_n());
ab3ad1b811c0b63a734cc5312fb1499a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|275|16|v|cpp
	double(model.
2e5d654ea41a1196d090ca4791d114c7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|369|24|v|cpp
	tsm_fo
474a45b47bdb8bea2e32081eff30ef19|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|369|23|v|cpp
	value();
3157dafcc7e29c8c151c290b04205c4c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|344|3|v|cpp
	const std::optional<double>
f0d896e3f89190300284a5187b69d0b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|345|23|v|cpp
	tsm_fo.has_value();
6e6d75dca02a30d4b2abe18fff160a53|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|346|3|V|cpp
	  const double tfo = tsm_fo.value_or(-1.0);
85d8a5e9ffc526661b3fd1813dd8a956|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|368|5|V|cpp
	    const double tfo = get_tsm_fo(rpar);
5c7c00d604b37339eee85de5af151643|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|21|25|v|cpp
	, DarkSun &model
c5e84cc03aa042d7ebb64e4603de054b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|33|25|v|cpp
	!model.get_xi_fo().has_value()
5e07faa819043bd9a0231ce704e1d6d3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|178|1|V|cpp
	double get_xi_fo(const double *rpar) { return rpar[9]; };
	double get_tsm_fo(const double *rpar) { return rpar[10]; };
	double get_xi_bbn(const double *rpar) { return rpar[11]; };
	double get_xi_cmb(const double *rpar) { return rpar[12]; };
	double get_rd_eta(const double *rpar) { return rpar[13]; };
	double get_rd_del(const double *rpar) { return rpar[14]; };
	double get_dneff_cmb(const double *rpar) { return rpar[15]; };
	double get_dneff_bbn(const double *rpar) { return rpar[16]; };
	double get_eta_si_per_mass(const double *rpar) { return rpar[17]; };
	double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
ea9a0feace6fea1957f78acbc0c7853c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|153|1|V|cpp
	double get_n(const double *rpar) { return rpar[0]; }
	double get_lam(const double *rpar) { return rpar[1]; }
	double get_c(const double *rpar) { return rpar[2]; }
	double get_lec1(const double *rpar) { return rpar[3]; }
	double get_lec2(const double *rpar) { return rpar[4]; }
	double get_adel(const double *rpar) { return rpar[5]; }
	double get_mu_eta(const double *rpar) { return rpar[6]; }
	double get_mu_del(const double *rpar) { return rpar[7]; }
	double get_xi_inf(const double *rpar) { return rpar[8]; }
6e7f3188e1b16d35f34773a907733054|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|189|1|V|cpp
	// ---------------
	// Fortran setters
	// ---------------
723d99d9ade078f4a0db18f1bac1317d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|39|22|v|cpp
	!model.get_xi_bbn().has_value()
d4b7caa00913b9cf1d2f81df3693c1b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|68|53|v|cpp
	rmodel
38987c4f383987b4ada1ed32da0f666d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|70|63|v|cpp
	rapr
0e7af301673b1dcb6c56dfcf6a2b9043|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|99|1|V|cpp
	  auto dydx = [&model](int *n, double *logx, double *y, double *dy,
	                       double *rpar, int *ipar) {
	    boltzmann(n, logx, y, dy, rpar, ipar, model);
	  };
	  auto jac = [&model](int *n, double *logx, double *y, double *dfy, int *ldfy,
	                      double *rpar, double *ipar) {
	    boltzmann_jac(n, logx, y, dfy, ldfy, rpar, ipar, model);
	  };
c6bcb758283d80374a0f0f99c99e83c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|126|1|V|cpp
	 * rpar[0] = n
	 * rpar[1] = lam;
	 * rpar[2] = c;
	 * rpar[3] = lec1;
	 * rpar[4] = lec2;
	 * rpar[5] = adel;
	 * rpar[6] = mu_eta;
	 * rpar[7] = mu_del;
	 * rpar[8] = xi_inf
	 * rpar[9] = xi_fo - holds -1 if not set.
	 * rpar[10] = tsm_fo
	 * rpar[11] = xi_bbn
	 * rpar[12] = xi_cmb
	 * rpar[13] = rd_eta
	 * rpar[14] = rd_del
	 * rpar[15] = dneff_cmb;
	 * rpar[16] = dneff_bbn;
	 * rpar[17] = eta_si_per_mass
	 * rpar[18] = del_si_per_mass
9525ce22cd746c78aad4fe73e826d892|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|1|V|cpp
	  vec[0]
a1d75c0bc7e726ea575ffe70cc4149ad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|164|27|v|cpp
	 - holds -1 if not set.
7a0ed5f2ec277176bcc6d32641725629|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|77|1|V|cmake
	
	# --------------------------------------------------------------------------
	# test_vdpol.cpp: Make sure integrator works
	# --------------------------------------------------------------------------
	add_executable(test_vdpol test_vdpol.cpp)
	set_property(TARGET test_vdpol PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_vdpol PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_vdpol PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
6c03d8939c0cdd2e2a4f06dc43189cb3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|164|1|V|cpp
	  printf("rtol = %1.2e\n", rtol);
6a330bd32ff98ea6f4f68f9809f9c8b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|165|11|v|cpp
	rtol
6eb393c411b4a777c075f0ddf1c125a9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|165|19|v|cpp
	1.2e
340328e3da9931060c4a49108c1f08a9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|9|1|V|cpp
	  auto model = DarkSun(20, 1e-3);
dbb948acd70d6a64aa34484c43ffb0cc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|3|v|cpp
	static double d;
bbf0755d9a97ad707b1cb2096bd8fffd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|153|56|v|cpp
	double xout, 
47f3b7fa8239a6f2e706983a60976d3b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|175|3|V|cpp
	  vec[19] = xout;
d704dc07c2cace6466ea6215f8186164|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|222|1|V|cpp
	double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
4a82724c291fbbf0e5df31721e6bd566|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|223|8|v|cpp
	get_del_si_per_mass
1246f53ac8a6ca60b036ff3f74bc21fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|6|v|cpp
	0.2;
d0b4bd2b9a8a09bf7a3cf526683bbc64|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|153|11|v|cpp
	std::vector<double>
681cb9178a24b8510879beced8ac1fa6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|153|44|v|cpp
	ouble
8090aa4096ec6e735d982ed71c533498|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|153|1|v|cpp
	std::pair<std::vector<double>, std::vector<int>>
0938ab5b0d21dcb8d869edcee2dcca4c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|1|V|cpp
	  std::vector<double> vec(20 + 3 * sol_size);
19cc47de93967e498680d1f5492d6621|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|156|28|v|cpp
	20 + 3 * sol_size
efe3d145cf63c6bc775c56862270dacb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|157|3|v|cpp
	std::vector<double> rpar
a985dd6631fb979e8168db3f74a5992c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|5|V|cpp
	    auto lsol = ipar[1
4cb581f6340aab8bd8de2ace12b58f16|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|195|1|V|cpp
	int get_sol_idx(const int *ipar) {return ipar[0];}
294eef6c2159a0ee985554f50669d7e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|196|1|V|cpp
	int get_sol_len(const int *ipar) {return ipar[0];}
99f495390ef6700fa57f346825deadd0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|150|14|v|cpp
	length of each solution segment
ed3ab19253b51b5cbdc19e9a46aaa736|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|151|14|v|cpp
	current length of solution
f7f6aab9f82cc5e13610eb80de083a22|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|160|13|v|cpp
	sol_size
645a2488ddd8e790016856161a047eac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|108|33|v|cpp
	yd[0];
44e6fa036df83d8335ab1ec91d0f3e95|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|108|1|V|cpp
	    rpar[idx + 0 * cap + len] = d;
a74ffb2de53b389b32ad135ec803b4f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|112|5|V|cpp
	    // ... 1 2 3 4 5 6 7 8 9
62c749570327eb413dcd8c213d366959|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|182|1|V|cpp
	  rpar[19] = dx;
e6efd25611cac925a4cf4525ede32787|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|183|14|v|cpp
	Cdx;
24bd396238ad95a63a85320618032ec6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|96|3|V|cpp
	  auto d = &;
1f1db6d09c027163d45d626e98cf1b7c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|235|1|V|cpp
	double get_dx(const double *rpar) { return rpar[19]; };
16f43c514b3b6b1bd6d12bd9be8b773e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|236|1|V|cpp
	double get_xout(const double *rpar) { return rpar[20]; };
a5e4013fc164412fdd9a60e54369cca5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|260|1|V|cpp
	void set_del_si_per_mass(double *rpar, double val) { rpar[18] = val; };
a6dd7826dc63ecf71ef848c196fc2c77|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|261|10|v|cpp
	el_si_per_mass
4f82e531a51ea74a8fc1b2fb31ca5e29|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|100|5|v|cpp
	else {
	    d = *x;
	  }
	
cb931e33b06158777d2aa152999ecba4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|104|1|V|cpp
	    printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, d, yd[0], yd[1]);
f78abb886ed4b4ec23add75619078694|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|11|v|cpp
	Step %3i: t=%1.3e, y=(%1.3e,%1.3e)
414e6f31ea85c99d06d54b907fa1a1e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|28|v|cpp
	*nr, d, yd[0], yd[1]);
d9801ac3a00250cbe11d450e971af01a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|111|10|v|cpp
	get_dx(rpar)
53286a52c5c228cd6b28a6f536ff4b79|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|22|v|cpp
	%1.3e
9ddf276004a71ecfc74278f22aa30fab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|29|v|cpp
	log_xfinal
ecb66df35f18d3f71f107b8c9cfbb6f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|98|3|V|cpp
	  printf("xout, dx = %1.3e, %1.3e\n", d, dx);
3be24b2ce3a27ffcef3fde5b2b255224|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|111|10|v|cpp
	get_dx(rpar);
ab1b7d067bd71eacf725c76efe478f78|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|1|V|cpp
	  int idx = get_sol_idx(ipar);
	  int len = get_sol_len(ipar);
	  int cap = get_sol_cap(ipar);
47c03edd3ee2e5792de2f11350e2b825|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|196|1|V|cpp
	  printf("y(%1.4f) = ( %1.4e, %1.4e)\n", log_xfinal, y[0], y[1]);
229aef5030a5fe2e5971cf17acb2b0f3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|187|3|V|cpp
	  int len = get_sol_len(ipar.data());
7aa8b4c4beb3b884a87d1365d0197731|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|190|1|V|cpp
	    double logx = rpar[idx + 0 * cap + i];
6ac198752b74f555c4a9bf23fd85c06f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|191|12|v|cpp
	logx 
f7b50f24685b712693960dc12ac5ff83|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|193|50|v|cpp
	y[0], y[1]
473a88612fc8ca72083dfff8c8b046fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|261|1|V|cpp
	void set_xout(double *rpar, double val) { rpar[20] = val; };
275776af602094229da99d794baefc22|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|94|3|V|cpp
	  int len = get_sol_len(ipar);
598a7543d746a14d6bd4e8c49d8fc278|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|189|3|V|cpp
	  std::cout << "Solution:" << std::endl;
711d5d38d72e138dffa787282e07e492|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|108|1|V|cpp
	    rpar[idx + 0 * cap + len] = d;
	    rpar[idx + 1 * cap + len] = yd[0];
	    rpar[idx + 2 * cap + len] = yd[1];
a6bbe13bb5e7fdec85369a3b0823e277|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|193|1|V|cpp
	  int idx = get_sol_idx(ipar.data());
	  int cap = get_sol_cap(ipar.data());
9c1510834a06012932972c4f06963118|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|201|1|V|cpp
	  /* print final solution */
	  // printf("y(%1.4f) = ( %1.4e, %1.4e)\n", log_xfinal, y[0], y[1]);
84b2df542359413899236ac3bad17a02|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|194|1|V|cpp
	  for (size_t i = 0; i < cap + 1; i++) {
	    double logx = rpar[idx + 0 * cap + i];
	    double we = rpar[idx + 1 * cap + i];
	    double yd = rpar[idx + 2 * cap + i];
	    printf("y(%1.4f) = ( %1.4e, %1.4e)\n", logx, we, yd);
	  }
04a12aba18b036f9f6e7c89d8e2aa570|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|45|1|V|cpp
	    m_solution.reserve(1000);
7bd14a231864e618e1840c7e117e59c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|115|45|v|cpp
	capacity
dc3d3b1a336fbbd51585e31c95f45c83|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|115|45|v|cpp
	resize
9c3b62949032a7361e2f0642fcb118d6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|115|45|v|cpp
	reserve
08c292dfaeae0f1c3ec080299ea6b6bd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|214|5|V|cpp
	    printf("y(%1.4f) = ( %1.4e, %1.4e)\n", logx, we, yd);
91194ecab9126a8f746da049819ebd88|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|211|7|v|cpp
	(size_t i = 0; i < cap + 1; i++) {
1452d8679055559eff8625ccdf6a3c9e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|212|1|V|cpp
	    double logx = rpar[idx + 0 * cap + i];
	    double we = rpar[idx + 1 * cap + i];
	    double yd = rpar[idx + 2 * cap + i];
f7bd60b75b29d79b660a2859395c1a24|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|115|16|v|cpp
	size
c8a69dfc4907695319c944c2715cb05d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|211|1|V|cpp
	    printf("y(%1.4f) = ( %1.4e, %1.4e)\n", val[0], val[1], val[2]);
f7704aecfd6c1272c52ddc8a1536e70b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|184|48|v|cpp
	val[0], val[1], val[2]);
a80acd568a2665abbaf4edfc667fa926|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|96|1|V|cpp
	  double d = get_xout(rpar);
0f93277076946b983f648e1d48eb4049|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|v|cpp
	double d = g
203d6fe72349df0f3a50514029c07c41|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|185|3|V|cpp
	  set_xout(rpar.data(), log_xstart);
8c1cb80b1479ac1b766bf954cb550917|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|106|5|V|cpp
	    // printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, d, yd[0], yd[1]);
72cf130c0679c090dadddc0f40b9ce65|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|97|1|V|cpp
	  // printf("xout, dx = %1.3e, %1.3e\n", d, dx);
e806a51d27a1dd20b30299377f238405|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|92|3|V|cpp
	  // printf("Step %3i: t=%1.3e, y=(%1.3e,%1.3e)\n", *nr, *x, y[0], y[1]);
e15827a5993857a4775aee7f6206c178|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|149|3|V|cpp
	  /*dimension of the system*/
2474bc31d2bd4cc9bb04ee62aa885287|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|150|3|V|cpp
	  /* compute the jacobian analytically */
a2a565ec8c9b1c9ae366cd01d1549d69|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|151|3|V|cpp
	  /* jacobian is a full matrix*/
8494568454d95f014b39472fe018d77e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|153|3|V|cpp
	  /* differential equation is in explicit form*/
03fac8b4bbacbe97470ae170f833d751|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|149|3|V|cpp
	  constexpr int n = 2;
	  constexpr int ijac = 1;
	  constexpr int mljac = n;
	  constexpr int mujac = 0;
	  constexpr int imas = 0;
	  constexpr int mlmas = 0;
	  constexpr int mumas = 0;
618bf72a85cf2a652e0799db77712868|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|144|3|V|cpp
	  constexpr int n = 2;
c81d5fc954b7c2eb427d2c040de7111d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|120|1|V|cpp
	
	  /* --------------
	   * Call to Fortan
	   * --------------
	   */
01553b62c3c0ac67afe276f9bc04cf0c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|116|3|V|cpp
	  using namespace std::placeholders;
54c842acf183c337091a0044108475da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|25|V|cpp
	  for (i = 0; i < 20; i++) {
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
c4aacc0521d974050fdef55ea76221e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|161|1|V|cpp
	  double rtol = 1.0e-7;
	  double atol = 1.0 * rtol;
	  int itol = 0;
	  /* initial step size*/
	  double h = 1.0e-6;
34e17f0991f790e5b8dafda102434207|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|165|1|V|cpp
	  /* required tolerance*/
	  double rtol = 1.0e-7;
	  double atol = 1.0 * rtol;
	  int itol = 0;
	  /* initial step size*/
	  double h = 1.0e-6;
0657cb3504191b062fe8d3cba3eafac8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|1|V|cpp
	  int iout = 1;
d7940760a2a62a6b155e80b12fa741fc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|154|3|V|cpp
	  /* initial step size*/
0d0fb59d60809596e407f309bfeb479d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|153|17|v|cpp
	// Have radau call `solout`
e1930a72c28954a85f2ef44d281a2909|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|134|1|V|cpp
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
2f1482bb93ea5a795ed6b793d90b6543|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|142|52|v|cpp
	// Length of work
f4931ddccf5d17b9df70a54221874c6e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|164|3|V|cpp
	  /* output routine is used during integration*/
8f624a3623a2c3f9e49db467e9f69836|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|165|1|V|cpp
	  /* set default values */
d6ae9dbba3dd42d9a88293882dfeddf3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|14|29|v|cpp
	(19)
102ca67b999f49638551f5018b758fb0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|46|1|V|cpp
	      : m_n(n), m_lam(lam), m_c(1.0), m_lec1(1.0), m_lec2(1.0), m_adel(1.0),
	        m_mu_eta(1.0), m_mu_del(1.0), m_xi_inf(1e-2) {}
a2d5c1c4205a3fd845d286c9cd503d3a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|23|1|V|cpp
	  double m_c;
	  double m_lec1;
	  double m_lec2;
	  double m_adel;
	  double m_mu_eta;
	  double m_mu_del;
	  double m_xi_inf;
7ebdfef74e80ab33012431dced1dfbc8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|31|1|V|cpp
	  std::optional<double> m_xi_fo{};
	  std::optional<double> m_tsm_fo{};
	  std::optional<double> m_xi_bbn{};
	  std::optional<double> m_xi_cmb{};
	  std::optional<double> m_rd_eta{};
	  std::optional<double> m_rd_del{};
	  std::optional<double> m_dneff_cmb{};
	  std::optional<double> m_dneff_bbn{};
	  std::optional<double> m_eta_si_per_mass{};
	  std::optional<double> m_del_si_per_mass{};
dd5dd1bf937beafdc42e9de90017af60|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|49|17|v|cpp
	m_c;
988c829b28fca516f74d2f842889e1f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|16|1|V|cpp
	  /* Order of the dark gauge group, i.e. N in SU(N)*/
	  size_t m_n;
	  /* Confinement scale of the dark sector in GeV */
	  double m_lam;
	  /** Suppression factor for creating deltas from etas: A(2eta -> 2delta) ~
	   *  exp(-cn)
	   */
	  double m_c;
	  double m_lec1;
	  double m_lec2;
	  double m_adel;
	  double m_mu_eta;
	  double m_mu_del;
	  double m_xi_inf;
	
79b0ea13dce87f955a5636ee807beac3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|30|1|V|cpp
	    m_rpar[9] = -1.0;  // xi_fo
	    m_rpar[10] = -1.0; // tsm_fo
	    m_rpar[11] = -1.0; // xi_bbn
	    m_rpar[12] = -1.0; // xi_cmb
	    m_rpar[13] = -1.0; // rd_eta
	    m_rpar[14] = -1.0; // rd_del
	    m_rpar[15] = -1.0; // dneff_cmb
	    m_rpar[16] = -1.0; // dneff_bbn
	    m_rpar[17] = -1.0; // eta_si_per_mass
	    m_rpar[18] = -1.0; // del_si_per_mass
a7d2dbaa81a972689e941384a17b30ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|43|1|V|cpp
	    m_xi_fo.reset();
	    m_tsm_fo.reset();
	    m_xi_bbn.reset();
	    m_xi_cmb.reset();
	    m_rd_eta.reset();
	    m_rd_del.reset();
	    m_dneff_cmb.reset();
	    m_dneff_bbn.reset();
	    m_eta_si_per_mass.reset();
	    m_del_si_per_mass.reset();
9bf97a2409012bbfc8bf6603408af611|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|81|12|v|cpp
	m_eta_si_per_mass
796c5b55c560965aa14f15e3b88d436c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|84|12|v|cpp
	m_del_si_per_mass
56261596833f5f63f2b870dd5ece2e20|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|67|1|V|cpp
	  double get_m_eta() const { return m_mu_eta * m_lam / sqrt(double(m_n)); }
	  double get_m_del() const { return m_mu_del * m_lam * double(m_n); }
	  double get_g_eta() const { return 1.0; }
	  double get_g_del() const { return double(m_n + 1); }
173714bdf1dba7f3dfb07441be3ab69a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|79|37|v|cpp
	m_mu_eta 
e585decd7b8c8980813c16c24ad83caa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|79|67|v|cpp
	double(m_n)
149e6581bbe64c0b06af35da0f9a87b8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|80|37|v|cpp
	m_mu_del 
ce50fe0b447fd7d725ba52cee1ae0220|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_n 
eb843af03d5d513902c74be953d29656|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_c 
4f8d60cb4a14cbd6cb5070810c4a2163|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_lec1 
923cf37ed505506a3ef08e1fd442ceb8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_lec2 
5806a33c0455acb688273506496acf89|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_adel 
39131537f323b253dee4c8700cadfd32|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_xi_inf 
40144f0f7e7b0931919c1d2a3771de0b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_tsm_fo 
8b467e3f7fb7dfa8b01da83a4b6b3cac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_xi_fo 
1a8f30517d6614dbc26f918a9114ef9b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_xi_bbn 
3e23593e86d0e4911623af3479e43846|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_rd_eta 
8ac578fee2ae5779b0eab35318835747|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_rd_del 
5f84f675697d93104b656dd322d60e31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_xi_cmb 
fa342d0656443f975ac901e79131cac1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_dneff_cmb 
abd135d1e54f654343b27750ccee15a2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_dneff_bbn 
51fc3558992502a5dfb987eb23400aa9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_eta_si_per_mass 
a507965fa22eb514adfb18964b7a2b55|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|105|41|v|cpp
	m_del_si_per_mass 
1f18c739ae534241c40c1603cc0e8548|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|60|4|V|cpp
	   * Get a pointer to the model data.
f7740d1067161ac024162e8271e4e9f6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|59|3|V|cpp
	  /**
9ca80924d90594580da03ee97b5f7d3d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|15|37|v|cpp
	ODE.
05b6cfba8d9ba6a7cddd9effd0c25733|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|62|1|V|cpp
	  size_t get_n() const { return m_rpar[0]; }
	  double get_lam() const { return m_rpar[1]; }
	  double get_c() const { return m_rpar[2]; }
	  double get_lec1() const { return m_rpar[3]; }
	  double get_lec2() const { return m_rpar[4]; }
	  double get_adel() const { return m_rpar[5]; }
	  double get_mu_eta() const { return m_rpar[6]; }
	  double get_mu_del() const { return m_rpar[7]; }
	  double get_xi_inf() const { return m_rpar[8]; }
	  double get_xi_fo() const { return m_rpar[9]; };
	  double get_tsm_fo() const { return m_rpar[10]; };
	  double get_xi_bbn() const { return m_rpar[11]; };
	  double get_xi_cmb() const { return m_rpar[12]; };
	  double get_rd_eta() const { return m_rpar[13]; };
	  double get_rd_del() const { return m_rpar[14]; };
	  double get_dneff_cmb() const { return m_rpar[15]; };
	  double get_dneff_bbn() const { return m_rpar[16]; };
	  double get_eta_si_per_mass() const { return m_rpar[17]; };
	  double get_del_si_per_mass() const { return m_rpar[18]; };
	
	  double get_m_eta() const { return get_mu_eta() * get_lam() / sqrt(get_n()); }
	  double get_m_del() const { return get_mu_del() * get_lam() * get_n(); }
	  double get_g_eta() const { return 1.0; }
	  double get_g_del() const { return get_n() + 1.0; }
c92d7d88158c8de8f00588a533e759b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|87|1|V|cpp
	  // Static getters
	  static size_t get_n(double *rpar) { return rpar[0]; }
	  static double get_lam(double *rpar) { return rpar[1]; }
	  static double get_c(double *rpar) { return rpar[2]; }
	  static double get_lec1(double *rpar) { return rpar[3]; }
	  static double get_lec2(double *rpar) { return rpar[4]; }
	  static double get_adel(double *rpar) { return rpar[5]; }
	  static double get_mu_eta(double *rpar) { return rpar[6]; }
	  static double get_mu_del(double *rpar) { return rpar[7]; }
	  static double get_xi_inf(double *rpar) { return rpar[8]; }
	  static double get_xi_fo(double *rpar) { return rpar[9]; };
	  static double get_tsm_fo(double *rpar) { return rpar[10]; };
	  static double get_xi_bbn(double *rpar) { return rpar[11]; };
	  static double get_xi_cmb(double *rpar) { return rpar[12]; };
	  static double get_rd_eta(double *rpar) { return rpar[13]; };
	  static double get_rd_del(double *rpar) { return rpar[14]; };
	  static double get_dneff_cmb(double *rpar) { return rpar[15]; };
	  static double get_dneff_bbn(double *rpar) { return rpar[16]; };
	  static double get_eta_si_per_mass(double *rpar) { return rpar[17]; };
	  static double get_del_si_per_mass(double *rpar) { return rpar[18]; };
	
	  static double get_m_eta(double *rpar) {
	    return get_mu_eta(rpar) * get_lam(rpar) / sqrt(get_n(rpar));
	  }
	  static double get_m_del(double *rpar) {
	    return get_mu_del(rpar) * get_lam(rpar) * get_n(rpar);
	  }
	  static double get_g_eta(double *rpar) { return 1.0; }
	  static double get_g_del(double *rpar) { return get_n(rpar) + 1.0; }
b205c77bf11c86978414abdd87c5a498|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|92|33|v|cpp
	m_rpar[0]
36fa3c923674943f39bc4eb0d50e9062|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_n
ea8ca15241e5f3b48c21227c38506faa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_lec1
36a695377867be228eab2b0d9afdae28|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_lam
ff86d5d6b5b6309e9718a32abe974480|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_c
b4ef393a2ae61f5e2cf84b101af785f6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_adel
b52ab6515d1653e43294e95535ebd1f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_mu_eta
8439b209344f72f34a1d3b39e0ced8a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_mu_del
889802fb6f48ee16b66640091e291c8a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_lec2
3f9c34b89d315dfdec67b42023c5d622|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_xi_inf
1a598942ba6a8a7a1d59805b6368ee8c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_xi_fo
096bea0de2592fa394bcd23a2c4248b4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_tsm_fo
2fa90fe804e0d883a66f28e664a66f49|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_xi_bbn
567766784a4a096f48405f08023702f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_xi_cmb
1cbcf723b973ccb8331a9ea214d32080|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_rd_eta
57ff861fbedb9b83d14117503c1d5c5c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_rd_del
1944abb3453182abf810505ffc902afe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_dneff_cmb
898d97c4ef19ad10c2f29f98e8e80e6b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_dneff_bbn
dfb1336228271fea67d7c474944cee3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|10|v|cpp
	get_eta_si_per_mass
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
4697be87d65382665788c04ed19c0b75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	m_rpar[
73781083f1696a3347d02c2257f1e335|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|116|37|v|cpp
	get_mu_eta() * get_lam() / sqrt(get_n()); }
2f2a812ec802fbbcb355efe138d785e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|117|61|v|cpp
	 * get_lam() * get_n(); }
46248aaddf1820a2ac2ce20437b666a4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|119|37|v|cpp
	get_n() + 1.0; }
7fb7f4d669a6f10e0a682f0fbb71ccb6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|118|37|v|cpp
	1.0; }
30aa49b004126315a75686a3febd09ae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|124|1|V|cpp
	  void set_n(size_t n) { m_rpar[0] = n; }
	  void set_lam(double lam) { m_rpar[1] = lam; }
	  void set_c(double c) { m_rpar[2] = c; }
	  void set_lec1(double lec1) { m_rpar[3] = lec1; }
	  void set_lec2(double lec2) { m_rpar[4] = lec2; }
	  void set_adel(double adel) { m_rpar[5] = adel; }
	  void set_mu_eta(double mu_eta) { m_rpar[6] = mu_eta; }
	  void set_mu_del(double mu_del) { m_rpar[7] = mu_del; }
	  void set_xi_inf(double xi_inf) { m_rpar[8] = xi_inf; }
	  void set_xi_fo(double xi) { m_rpar[9] = xi; };
	  void set_tsm_fo(double tsm) { m_rpar[10] = tsm; };
	  void set_xi_bbn(double xi) { m_rpar[11] = xi; };
	  void set_xi_cmb(double xi) { m_rpar[12] = xi; };
	  void set_rd_eta(double rd) { m_rpar[13] = rd; };
	  void set_rd_del(double rd) { m_rpar[14] = rd; };
	  void set_dneff_cmb(double dneff) { m_rpar[15] = dneff; };
	  void set_dneff_bbn(double dneff) { m_rpar[16] = dneff; };
	  void set_eta_si_per_mass(double si) { m_rpar[17] = si; };
	  void set_del_si_per_mass(double si) { m_rpar[18] = si; };
c9f0e7e4d5c2d03f244b535822887db0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_n
e69bcd7d6f117cc0bf3dfdea6b5ccbc9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_c
5f8968ae385cea6633c9b58d6ab667cd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_lam
e8c3be9c964f0f8e7c316d22f22390ee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_lec1
a8636d82a19a6994b4e9df93230de9ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_lec2
0444a50894626514843d247a7927493a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_adel
206c1c632e0d3dd31a83b9a8d5992765|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_mu_eta
8f00560b10597c7ce82a3283a297c7dc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_xi_inf
979cea696b3476b242859649e0341803|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_mu_del
6586de2c1bd64fc21090ac9a6ad6b2e4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_tsm_fo
5acb813e5077cfd4b647065763f0f7f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_xi_bbn
94d97e768a14dca4f8177ff41fcb985c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_xi_cmb
3a9403cf9f2d9d1587e51ca403bec479|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_rd_eta
4f752459019961b093da4aa2072872db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_rd_del
bc9fb79d22396dbd49e99ede05d1193e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_dneff_cmb
c8c20897969c5c5800de3b9a39d02373|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_eta_si_per_mass
473e4bce4136e3df579d3c4fb9e9f1d5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_del_si_per_mass
2807eda514d980d0c0bd14df8f02e69c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|8|v|cpp
	set_dneff_bbn
29df78c4caee4813f9423d6b4c746dd9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|57|6|v|cpp
	------------------------------------------------------------------------
fc8d67bddf9796424ea9fc7061bca90c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|57|1|V|cpp
	  // ======================================================================== 
	  // ---- Static getters ----------------------------------------------------
	  // ======================================================================== 
2c2360b8e22388beeb7d47ba8a6c319a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|89|1|V|cpp
	  // --------------
	  // Static setters
	  // --------------
06dd3a2170df23dbd37729adb6b74197|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|89|1|V|cpp
	  // ======================================================================== 
	  // ---- Static setters ----------------------------------------------------
	  // ======================================================================== 
444b55dd4de80fc21db70377bb4a35df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|112|1|V|cpp
	  // --------------
	  // Normal Getters
	  // --------------
ae86927c8d4d41b9dd47d490f250044c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|113|11|v|cpp
	Static 
5b531b86b182076b2162eaaadc2d4a43|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|112|1|V|cpp
	  // ======================================================================== 
	  // ---- Normal setters ----------------------------------------------------
	  // ======================================================================== 
c3d55d9d2f74cff3c1f5794d7ecb4fec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|150|1|V|cpp
	  // --------------
	  // Normal Setters
	  // --------------
2c113101325caae4b680803964d27795|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|217|1|V|cpp
	auto model_to_vec(const DarkSun &model, double dx, size_t sol_size)
	    -> std::pair<std::vector<double>, std::vector<int>> {
	  std::vector<double> rpar(21 + 3 * (sol_size + 1));
	  std::vector<int> ipar(3);
	
	  ipar[0] = 21;
	  ipar[1] = 0;
	  ipar[2] = sol_size;
	
	  rpar[0] = model.get_n();
	  rpar[1] = model.get_lam();
	  rpar[2] = model.get_c();
	  rpar[3] = model.get_lec1();
	  rpar[4] = model.get_lec2();
	  rpar[5] = model.get_adel();
	  rpar[6] = model.get_mu_eta();
	  rpar[7] = model.get_mu_del();
	  rpar[8] = model.get_xi_inf();
	  rpar[9] = model.get_xi_fo().value_or(-1.0);
	  rpar[10] = model.get_tsm_fo().value_or(-1.0);
	  rpar[11] = model.get_xi_bbn().value_or(-1.0);
	  rpar[12] = model.get_xi_cmb().value_or(-1.0);
	  rpar[13] = model.get_rd_eta().value_or(-1.0);
	  rpar[14] = model.get_rd_del().value_or(-1.0);
	  rpar[15] = model.get_dneff_cmb().value_or(-1.0);
	  rpar[16] = model.get_dneff_bbn().value_or(-1.0);
	  rpar[17] = model.get_eta_si_per_mass().value_or(-1.0);
	  rpar[18] = model.get_del_si_per_mass().value_or(-1.0);
	  rpar[19] = dx;
	  rpar[20] = 0.0;
	
	  for (int i = 21; i < 21 + 3 * (sol_size + 1); i++) {
	    rpar[i] = 0.0;
	  }
	
	  return std::make_pair(rpar, ipar);
	}
f82e2bb370969605c06a232ecbbac3be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|226|1|V|cpp
	double get_m_eta(const double *rpar) {
	  double mu_eta = get_mu_eta(rpar);
	  double lam = get_lam(rpar);
	  double n = get_n(rpar);
	  return mu_eta * lam / sqrt(n);
	}
	double get_m_del(const double *rpar) {
	  double mu_del = get_mu_del(rpar);
	  double lam = get_lam(rpar);
	  double n = get_n(rpar);
	  return mu_del * lam * n;
	}
	double get_g_eta(const double *) { return 1.0; }
	double get_g_del(const double *rpar) { return get_n(rpar) + 1.0; }
	
	double get_xi_fo(const double *rpar) { return rpar[9]; };
	double get_tsm_fo(const double *rpar) { return rpar[10]; };
	double get_xi_bbn(const double *rpar) { return rpar[11]; };
	double get_xi_cmb(const double *rpar) { return rpar[12]; };
	double get_rd_eta(const double *rpar) { return rpar[13]; };
	double get_rd_del(const double *rpar) { return rpar[14]; };
	double get_dneff_cmb(const double *rpar) { return rpar[15]; };
	double get_dneff_bbn(const double *rpar) { return rpar[16]; };
	double get_eta_si_per_mass(const double *rpar) { return rpar[17]; };
	double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
	double get_dx(const double *rpar) { return rpar[19]; };
	double get_xout(const double *rpar) { return rpar[20]; };
0dc1b028c2ecf94d37673329b7813deb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|225|1|V|cpp
	
	// ---------------
	// Fortran setters
	// ---------------
	
	void set_n(double *rpar, double val) { rpar[0] = val; }
	void set_lam(double *rpar, double val) { rpar[1] = val; }
	void set_c(double *rpar, double val) { rpar[2] = val; }
	void set_lec1(double *rpar, double val) { rpar[3] = val; }
	void set_lec2(double *rpar, double val) { rpar[4] = val; }
	void set_adel(double *rpar, double val) { rpar[5] = val; }
	void set_mu_eta(double *rpar, double val) { rpar[6] = val; }
	void set_mu_del(double *rpar, double val) { rpar[7] = val; }
	void set_xi_inf(double *rpar, double val) { rpar[8] = val; }
	void set_xi_fo(double *rpar, double val) { rpar[9] = val; };
	void set_tsm_fo(double *rpar, double val) { rpar[10] = val; };
	void set_xi_bbn(double *rpar, double val) { rpar[11] = val; };
	void set_xi_cmb(double *rpar, double val) { rpar[12] = val; };
	void set_rd_eta(double *rpar, double val) { rpar[13] = val; };
	void set_rd_del(double *rpar, double val) { rpar[14] = val; };
	void set_dneff_cmb(double *rpar, double val) { rpar[15] = val; };
	void set_dneff_bbn(double *rpar, double val) { rpar[16] = val; };
	void set_eta_si_per_mass(double *rpar, double val) { rpar[17] = val; };
	void set_del_si_per_mass(double *rpar, double val) { rpar[18] = val; };
703b36ba6f6cf14c7ef1061828ee8251|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|186|1|V|cpp
	/*
	 * Functions which take in pointer of data:
	 * fun(..., double* rpar, double* ipar)
	 * rpar[0] = n
	 * rpar[1] = lam;
	 * rpar[2] = c;
	 * rpar[3] = lec1;
	 * rpar[4] = lec2;
	 * rpar[5] = adel;
	 * rpar[6] = mu_eta;
	 * rpar[7] = mu_del;
	 * rpar[8] = xi_inf
	 * rpar[9] = xi_fo - holds -1 if not set.
	 * rpar[10] = tsm_fo
	 * rpar[11] = xi_bbn
	 * rpar[12] = xi_cmb
	 * rpar[13] = rd_eta
	 * rpar[14] = rd_del
	 * rpar[15] = dneff_cmb;
	 * rpar[16] = dneff_bbn;
	 * rpar[17] = eta_si_per_mass
	 * rpar[18] = del_si_per_mass
	 * rpar[19...] = logxs
	 * rpar[...] = w_eta
	 * rpar[...] = y_eta
	 *
	 * ipar[0] = index where solution starts
	 * ipar[1] = current length of solution
	 * ipar[2] = capacity of the solution
	 */
	
	// ---------------
	// Fortran getters
	// ---------------
	
596350b7399cf768e6234c84a675e904|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|14|1|V|cpp
	  std::vector<double> m_rpar;
626194791d24b6ec94cd5d2656bde660|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|42|1|V|cpp
	    m_rpar[19] = 0.0;  // xout for radau
22c78db5c48713b6121a655be7dc0c61|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|16|1|V|cpp
	  std::vector<double> m_ipar;
e4484fbb09d852f32a6181036ba42ad8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|22|5|V|cpp
	    m_rpar.resize(20);
a4fa7ffe5f27f15c0b2f8babe747f488|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|12|14|v|cpp
	<int Size = 100>
62d11ce159e05f12775fa6342bc257b3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|13|1|V|cpp
	  static constexpr size_t m_sol_size = 100;
2097f81c0df737eb2ef23ca4f8d1ad63|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|19|3|V|cpp
	  // Vector holding the solution to Boltzmann equation.
2bdf61e70a8f9fb659dd0ba66fe7dc54|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|45|27|v|cpp
	 m_num_pars
436220a4e78107964c978f21b00d104e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|48|1|V|cpp
	    // Zero out the solution vector
	    for (size_t i = m_num_pars; i < m_rpar.size(); i++) {
	      m_rpar[i] = 0;
	    }
a73da525d4d2ac50ccc0c8b2c225c396|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|66|1|V|cpp
	    m_solution.clear();
d437e7495758b6e5f01e6e48d36395d6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|46|1|V|cpp
	    m_ipar[2] = 0;          // Current # of solutions recorded
ba3eba5d2e283d85311328caa29d61bb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|66|23|v|cpp
	Current # of solutions recorded
7c98032404bea5438344e0a5fec44193|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|134|1|V|cpp
	  double *get_rpar() { return m_rpar.data(); }
e686457cf789bd9b2222027a5f541722|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|166|3|V|cpp
	  auto get_solution() const { return m_solution; }
c2599defe7c7cd59c550f791663f957a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|202|1|V|cpp
	int get_sol_idx(const int *ipar) { return ipar[0]; }
	int get_sol_len(const int *ipar) { return ipar[1]; }
	int get_sol_cap(const int *ipar) { return ipar[2]; }
e40dddea0dd172a20b040fbe879a0ecc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|106|1|V|cpp
	  static int get_sol_idx(const int *ipar) { return ipar[0]; }
	  static int get_sol_len(const int *ipar) { return ipar[1]; }
	  static int get_sol_cap(const int *ipar) { return ipar[2]; }
23ed707e649d72a7eb7ae6f52ed3f032|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|19|v|cpp
	const int *ipar
23ed707e649d72a7eb7ae6f52ed3f032|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|19|v|cpp
	const int *ipar
23ed707e649d72a7eb7ae6f52ed3f032|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|19|v|cpp
	const int *ipar
e21950b4973d34a41c60c1bb2a8dbc4d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|30|v|cpp
	ipar[0]
60755db78fc7f118f1144d52cec55b3a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|30|v|cpp
	ipar[2]
86b045f6d957268718507125298125ed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|172|30|v|cpp
	ipar[1]
f7ef729751b3a3e4003fda425d1bbaad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|201|1|V|cpp
	  void set_sol_cap(size_t cap) {
	    m_solution.clear();
	    m_solution.reserve(cap);
	  }
b649005b85e9a2905d069221c9b869f4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|202|5|v|cpp
	m_solution.push_back(
9cf045894cdfa93437e446e8572dfe35|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|44|1|V|cpp
	    m_ipar[0] = m_num_pars; // # of params or idx where sol starts
	    m_ipar[1] = m_sol_size; // # of solution points
	    m_ipar[2] = 0;          // Current # of solutions recorded
d8ee4ad26c462c9135b01276b192b361|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|204|23|v|cpp
	= m_num_pars
6f3cdbf25a15d6808e4187f9bc2008ce|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|205|24|v|cpp
	= m_sol_size
9a4f82f556f2f2d07ae077babfd67d84|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|207|12|v|cpp
	m_ipar[0]
957656a64218d9ddb124dca541d96694|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|207|1|V|cpp
	    m_rpar[npars + 3 * len + 0] = logx;
661a5edd4c0621de2a18e0e1d337328a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|202|5|V|cpp
	    std::array<double, 3>{logx, weta, yeta};
7432add330010dd7d619d973b40c4390|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|204|5|V|cpp
	    int sol_size = m_ipar[1]; // # of solution points
24620b9958152e6cf62635724c0ae7a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|208|12|v|cpp
	npars + 3 * len
24620b9958152e6cf62635724c0ae7a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|208|12|v|cpp
	npars + 3 * len
24620b9958152e6cf62635724c0ae7a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|208|12|v|cpp
	npars + 3 * len
aeeee578254aa7649e0b14817a1ba44d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|202|1|V|cpp
	  void solution_push_back(double logx, double weta, double yeta) {
	    int npars = m_ipar[0]; // # of params or idx where sol starts
	    int len = m_ipar[2];   // Current # of solutions recorded
	    int idx_start = npars + 3 * len;
	    m_rpar[idx_start + 0] = logx;
	    m_rpar[idx_start + 1] = weta;
	    m_rpar[idx_start + 2] = yeta;
	  }
f6127ee1c5de197fc61903b9b15fa75a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|141|5|v|cpp
	m_rpar
f6127ee1c5de197fc61903b9b15fa75a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|141|5|v|cpp
	m_rpar
f6127ee1c5de197fc61903b9b15fa75a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|141|5|v|cpp
	m_rpar
b18da2aabf1e6940f79f0d64818f05e4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|213|1|V|cpp
	    int npars = m_ipar[0]; // # of params or idx where sol starts
	    int len = m_ipar[2];   // Current # of solutions recorded
	    int idx_start = npars + 3 * len;
	    m_rpar[idx_start + 0] = logx;
	    m_rpar[idx_start + 1] = weta;
	    m_rpar[idx_start + 2] = yeta;
3d609c4abc84d4e868802e78ec55c30e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|134|1|V|cpp
	  static void set_xout(double *rpar, double val) { rpar[20] = val; };
ce2bb80be54fd8c1ef18fc3cc09f94a2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|218|17|v|cpp
	double *rpar, 
0adbf2ae47d6714917e233b0ffb55023|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|218|31|v|cpp
	m_rpar[20] = val; };
48cc9c1b93c8e75d93c3b14869f7c811|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|221|1|V|cpp
	int get_sol_idx(const int *ipar) { return ipar[0]; }
	int get_sol_len(const int *ipar) { return ipar[1]; }
	int get_sol_cap(const int *ipar) { return ipar[2]; }
	
	void set_xout(double *rpar, double val) { rpar[20] = val; };
	void set_sol_len(int *ipar, int val) { ipar[1] = val; };
bbcca762b86b794f7e6079c6d1230766|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|78|1|V|cpp
	/**
	 * Compute the full cross section for 2eta -> 4eta, include the 4pt and 6pt
	 * amplitudes and all the prefactors.
	 */
	double cross_section_2eta_4eta(const double cme, const DarkSun &model) {
	  using boost::math::pow;
	  const double mu = model.get_mu_eta();
	  const double n = model.get_n();
	  const double lam = model.get_lam();
	  const double l1 = model.get_lec1();
	  const double l2 = model.get_lec2();
	
	  // Common prefactos of the cross section terms
	  const double pref = pow<2>((256.0 * pow<4>(M_PI) / 9.0));
	  const double norm = pref * pow<14>(mu) / (lam * lam * pow<11>(n));
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = norm * pow<4>(l1) / 9.0;
	  const double c66 = norm * pow<2>(l2) / 25.0;
	  const double c46 = -2.0 * norm * l2 * pow<2>(l1) / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / model.get_m_eta();
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 4eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_4eta(const double x, const DarkSun &model) {
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = model.get_m_eta();
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 4eta -> 2eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_4eta_2eta(const double x, const DarkSun &model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = model.get_m_eta();
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 2delta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_2del(const double x, const DarkSun &model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double c = model.get_c();
	  const double n = double(model.get_n());
	  const double lam = model.get_lam();
	  const double meta = model.get_m_eta();
	  const double mdel = model.get_m_del();
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double zmin = 2.0 * mdel / meta;
	  const double sig = exp(-2.0 * c * n) / (64.0 * M_PI * n * n * lam * lam);
	
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * sig * integral;
	}
e686e0c1230da87a08e73d4d7505f436|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|152|31|v|cpp
	std::unique_ptr<*double>(
b7b6aa9b3364c75f3f75added6995422|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|198|1|V|cpp
	  using boost::math::pow;
	  const double mu = model.get_mu_eta();
	  const double n = model.get_n();
	  const double lam = model.get_lam();
	  const double l1 = model.get_lec1();
	  const double l2 = model.get_lec2();
	
	  // Common prefactos of the cross section terms
	  const double pref = pow<2>((256.0 * pow<4>(M_PI) / 9.0));
	  const double norm = pref * pow<14>(mu) / (lam * lam * pow<11>(n));
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = norm * pow<4>(l1) / 9.0;
	  const double c66 = norm * pow<2>(l2) / 25.0;
	  const double c46 = -2.0 * norm * l2 * pow<2>(l1) / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / model.get_m_eta();
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
07c2fe36885a3f34250a2f7826c2fc86|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|205|1|V|cpp
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = model.get_m_eta();
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
63bb934a4f35bddf2b79b5804c54e727|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|212|1|V|cpp
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = model.get_m_eta();
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
70d16b493e44a47358b0b20d0e73a6a7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|219|1|V|cpp
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double c = model.get_c();
	  const double n = double(model.get_n());
	  const double lam = model.get_lam();
	  const double meta = model.get_m_eta();
	  const double mdel = model.get_m_del();
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double zmin = 2.0 * mdel / meta;
	  const double sig = exp(-2.0 * c * n) / (64.0 * M_PI * n * n * lam * lam);
	
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * sig * integral;
1e67f2ff0161fbaf51eccefa9abc6ad2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|196|44|v|cpp
	cref
22db343bc5a4d1faf4db1552566dd0e8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|152|1|V|cpp
	  double *get_rpar() { return m_rpar.data(); }
	  int *get_ipar() { return m_ipar.data(); }
49bfff7116de3bfe3b0e25c11bd467f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|197|34|v|cpp
	std::add_const_t<double *>(
f38ece4974e9d566e754df5f046f29cc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|211|8|v|cpp
	thermal_cross_section_4eta_2eta
38955a9ce5dfd5a3323738165cd5cb62|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|212|1|V|cpp
	  ther
a7582ca6a5dd60cfc9d061a2fb5cf1d4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|219|8|v|cpp
	thermal_cross_section_2eta_2del
176cf789b468f3069964a9457f0c1954|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|191|1|V|cpp
	/**
	 * Compute the full cross section for 2eta -> 4eta, include the 4pt and 6pt
	 * amplitudes and all the prefactors.
	 */
	double cross_section_2eta_4eta(const double cme, const DarkSun &model) {
	  return cross_section_2eta_4eta(cme, model.get_rpar());
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 4eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_4eta(const double x, const DarkSun &model) {
	  return thermal_cross_section_2eta_4eta(x, model.get_rpar());
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 4eta -> 2eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_4eta_2eta(const double x, const DarkSun &model) {
	  return thermal_cross_section_4eta_2eta(x, model.get_rpar());
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 2delta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_2del(const double x, const DarkSun &model) {
	  return thermal_cross_section_2eta_2del(x, model.get_rpar());
	}
beaf06473da2edd15640d4ed5d60cdd1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|78|1|V|cpp
	  // ========================================================================
	  // ---- Static getters ----------------------------------------------------
	  // ========================================================================
1fdb5e20e4a2a6af3654e71ac3ff355c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|76|1|V|cpp
	  //
3f184d3788f84ccf62eccd3a3c95e149|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|77|11|v|cpp
	Static getters
61e063b2cdc7853c50ee6eb8ea905442|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|84|41|v|cpp
	model.get_rpar()
1f3315694e196765970f59acfc7baf18|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|83|50|v|cpp
	, const DarkSun &model
606d1e841f663193793abac81bbab576|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|9|1|V|cpp
	#include <darksun/model.hpp>
e692ccea314e7ebe8cbecc8229e03c31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|112|1|V|cpp
	  // ========================================================================
	  // ---- Static getters ----------------------------------------------------
	  // ========================================================================
	  static size_t get_n(const double *rpar) { return rpar[0]; }
	  static double get_lam(const double *rpar) { return rpar[1]; }
	  static double get_c(const double *rpar) { return rpar[2]; }
	  static double get_lec1(const double *rpar) { return rpar[3]; }
	  static double get_lec2(const double *rpar) { return rpar[4]; }
	  static double get_adel(const double *rpar) { return rpar[5]; }
	  static double get_mu_eta(const double *rpar) { return rpar[6]; }
	  static double get_mu_del(const double *rpar) { return rpar[7]; }
	  static double get_xi_inf(const double *rpar) { return rpar[8]; }
	  static double get_xi_fo(const double *rpar) { return rpar[9]; };
	  static double get_tsm_fo(const double *rpar) { return rpar[10]; };
	  static double get_xi_bbn(const double *rpar) { return rpar[11]; };
	  static double get_xi_cmb(const double *rpar) { return rpar[12]; };
	  static double get_rd_eta(const double *rpar) { return rpar[13]; };
	  static double get_rd_del(const double *rpar) { return rpar[14]; };
	  static double get_dneff_cmb(const double *rpar) { return rpar[15]; };
	  static double get_dneff_bbn(const double *rpar) { return rpar[16]; };
	  static double get_eta_si_per_mass(const double *rpar) { return rpar[17]; };
	  static double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
	
	  static double get_m_eta(const double *rpar) {
	    return get_mu_eta(rpar) * get_lam(rpar) / sqrt(get_n(rpar));
	  }
	  static double get_m_del(const double *rpar) {
	    return get_mu_del(rpar) * get_lam(rpar) * get_n(rpar);
	  }
	  static double get_g_eta(const double *rpar) { return 1.0; }
	  static double get_g_del(const double *rpar) { return get_n(rpar) + 1.0; }
	
	  static int get_sol_idx(const int *ipar) { return ipar[0]; }
	  static int get_sol_len(const int *ipar) { return ipar[1]; }
	  static int get_sol_cap(const int *ipar) { return ipar[2]; }
	
	  // ========================================================================
	  // ---- Static setters ----------------------------------------------------
	  // ========================================================================
	  static void set_n(double *rpar, size_t n) { rpar[0] = n; }
	  static void set_lam(double *rpar, double lam) { rpar[1] = lam; }
	  static void set_c(double *rpar, double c) { rpar[2] = c; }
	  static void set_lec1(double *rpar, double lec1) { rpar[3] = lec1; }
	  static void set_lec2(double *rpar, double lec2) { rpar[4] = lec2; }
	  static void set_adel(double *rpar, double adel) { rpar[5] = adel; }
	  static void set_mu_eta(double *rpar, double mu_eta) { rpar[6] = mu_eta; }
	  static void set_mu_del(double *rpar, double mu_del) { rpar[7] = mu_del; }
	  static void set_xi_inf(double *rpar, double xi_inf) { rpar[8] = xi_inf; }
	  static void set_xi_fo(double *rpar, double xi) { rpar[9] = xi; };
	  static void set_tsm_fo(double *rpar, double tsm) { rpar[10] = tsm; };
	  static void set_xi_bbn(double *rpar, double xi) { rpar[11] = xi; };
	  static void set_xi_cmb(double *rpar, double xi) { rpar[12] = xi; };
	  static void set_rd_eta(double *rpar, double rd) { rpar[13] = rd; };
	  static void set_rd_del(double *rpar, double rd) { rpar[14] = rd; };
	  static void set_dneff_cmb(double *rpar, double dneff) { rpar[15] = dneff; };
	  static void set_dneff_bbn(double *rpar, double dneff) { rpar[16] = dneff; };
	  static void set_eta_si_per_mass(double *rpar, double si) { rpar[17] = si; };
	  static void set_del_si_per_mass(double *rpar, double si) { rpar[18] = si; };
	
	  static void set_xout(double *rpar, double val) { rpar[20] = val; };
	
	  static void solution_push_back(double *rpar, int *ipar, double logx,
	                                 double weta, double yeta) {
	    int npars = ipar[0]; // # of params or idx where sol starts
	    int len = ipar[2];   // Current # of solutions recorded
	    int idx_start = npars + 3 * len;
	    rpar[idx_start + 0] = logx;
	    rpar[idx_start + 1] = weta;
	    rpar[idx_start + 2] = yeta;
	  }
9cde98d8566032487df06e04e70b6114|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|8|1|V|cpp
	static constexpr size_t IDX_N = 0;
8162defc21f5ff59308a22d8539d2ad4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|14|1|V|cpp
	static double get_n(const double *rpar) { return rpar[0]; }
	static double get_lam(const double *rpar) { return rpar[1]; }
	static double get_c(const double *rpar) { return rpar[2]; }
	static double get_lec1(const double *rpar) { return rpar[3]; }
	static double get_lec2(const double *rpar) { return rpar[4]; }
	static double get_adel(const double *rpar) { return rpar[5]; }
	static double get_mu_eta(const double *rpar) { return rpar[6]; }
	static double get_mu_del(const double *rpar) { return rpar[7]; }
	static double get_xi_inf(const double *rpar) { return rpar[8]; }
	static double get_xi_fo(const double *rpar) { return rpar[9]; };
	static double get_tsm_fo(const double *rpar) { return rpar[10]; };
	static double get_xi_bbn(const double *rpar) { return rpar[11]; };
	static double get_xi_cmb(const double *rpar) { return rpar[12]; };
	static double get_rd_eta(const double *rpar) { return rpar[13]; };
	static double get_rd_del(const double *rpar) { return rpar[14]; };
	static double get_dneff_cmb(const double *rpar) { return rpar[15]; };
	static double get_dneff_bbn(const double *rpar) { return rpar[16]; };
	static double get_eta_si_per_mass(const double *rpar) { return rpar[17]; };
	static double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
6e424fd589400c4324d7dbe5edaf8c18|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[0]; }
9987443deb41b9bfca27dc6a0c6235e8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[1]; }
e59c8e5672d49f6fa124ce9164a50917|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[2]; }
0e3e6600ffe45502ac180d0ad9165a73|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[3]; }
fb04932140fc6713a49f8bc1e6b8182d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[4]; }
8edd4bb0c5b896a67ee84b41217f2be5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[5]; }
e0126837abb5309e053138bd51e7759b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[6]; }
38d61d60d90144703d25bf2fcc2a141d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[7]; }
11acf88ce9f8891dcff9f94821e77050|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[8]; }
77c22b3c2ea259a597694b7a7cee09b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[9]; };
9d8a88e0cbeff12b93e7df140414490f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[10]; };
e67025f1ac71ccb49bc6c60e6a8c20ad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[11]; };
c618858fd8516c6367fc513465046fc7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[12]; };
cee5b269cd019b41712965aa916bfb1c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[13]; };
82b57471ae5ca8efa15c4d7c4d09ef67|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[14]; };
2a8e540c8d4565aed1d7aaed5c8ae018|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[15]; };
224ddbc5bfc5b2b8d2e612fd83de9ec3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[17]; };
8709f0262801dc7d9c8dfad658880f3e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[18]; };
1f347cad33aca06f55e37dc4bcaa7ec0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|33|v|cpp
	(const double *rpar) { return rpar[16]; };
f5e32ddc1e2edbe44e07221ed9add741|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|13|29|v|cpp
	lam;
ad0b3273211966466f2c7d3a116fbe1d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|15|29|v|cpp
	lec1;
7ca0ff2ecda1bd5caf69cab927a9536a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|16|29|v|cpp
	lec2;
d06747a2ff207fe283665b360c78ef9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|17|29|v|cpp
	adel;
ceb9cb7c7a351f42125168dfc5c2549d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|18|29|v|cpp
	mu_eta;
22abced2492c6c7c5a41764b8b9f809b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|19|29|v|cpp
	mu_del;
1f68616922239676e57ad833b7ce78d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|20|29|v|cpp
	xi_inf;
655157f1e56a4603ad8a131d61824b4d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|21|28|v|cpp
	xi_fo;
12c076b437a9315ea55dedaedfff90c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|22|29|v|cpp
	tsm_fo;
e4030cc9a7e16d8ee1c5e493ea7b40dd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|23|29|v|cpp
	xi_bbn;
04d7d10bb8fbca4035b8b1d74613d729|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|24|29|v|cpp
	xi_cmb;
09c915e77dc50807673c1d9dcdbf7933|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|25|29|v|cpp
	rd_eta;
40c3f607bed597e49f0b1c40026bdd42|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|26|29|v|cpp
	rd_del;
f1c62d04852acf5857cddaf01a8f5567|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|27|29|v|cpp
	dneff_cmb;
7383205217075c48da7fa9be133040c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|28|29|v|cpp
	dneff_bbn;
f1e4c27d3b11954d16c73f723d682923|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|29|29|v|cpp
	eta_si_per_mass;
9ed8eb71e921f46a2945633b35d120d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|29|v|cpp
	del_si_per_mass;
36aa5705b288c6785c58b293daa6c294|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|8|1|V|cpp
	static constexpr size_t IDX_N = 0;
	static constexpr size_t IDX_N = 0;
ff3f68ae9475867c6a2291db78dd14af|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|113|1|V|cpp
	  // ========================================================================
	  // ---- Static getters ----------------------------------------------------
	  // ========================================================================
	  static size_t get_n(const double *rpar) { return rpar[0]; }
	  static double get_lam(const double *rpar) { return rpar[1]; }
	  static double get_c(const double *rpar) { return rpar[2]; }
	  static double get_lec1(const double *rpar) { return rpar[3]; }
	  static double get_lec2(const double *rpar) { return rpar[4]; }
	  static double get_adel(const double *rpar) { return rpar[5]; }
	  static double get_mu_eta(const double *rpar) { return rpar[6]; }
	  static double get_mu_del(const double *rpar) { return rpar[7]; }
	  static double get_xi_inf(const double *rpar) { return rpar[8]; }
	  static double get_xi_fo(const double *rpar) { return rpar[9]; };
	  static double get_tsm_fo(const double *rpar) { return rpar[10]; };
	  static double get_xi_bbn(const double *rpar) { return rpar[11]; };
	  static double get_xi_cmb(const double *rpar) { return rpar[12]; };
	  static double get_rd_eta(const double *rpar) { return rpar[13]; };
	  static double get_rd_del(const double *rpar) { return rpar[14]; };
	  static double get_dneff_cmb(const double *rpar) { return rpar[15]; };
	  static double get_dneff_bbn(const double *rpar) { return rpar[16]; };
	  static double get_eta_si_per_mass(const double *rpar) { return rpar[17]; };
	  static double get_del_si_per_mass(const double *rpar) { return rpar[18]; };
	
	  static double get_m_eta(const double *rpar) {
	    return get_mu_eta(rpar) * get_lam(rpar) / sqrt(get_n(rpar));
	  }
	  static double get_m_del(const double *rpar) {
	    return get_mu_del(rpar) * get_lam(rpar) * get_n(rpar);
	  }
	  static double get_g_eta(const double *rpar) { return 1.0; }
	  static double get_g_del(const double *rpar) { return get_n(rpar) + 1.0; }
	
	  static int get_sol_idx(const int *ipar) { return ipar[0]; }
	  static int get_sol_len(const int *ipar) { return ipar[1]; }
	  static int get_sol_cap(const int *ipar) { return ipar[2]; }
	
	  // ========================================================================
	  // ---- Static setters ----------------------------------------------------
	  // ========================================================================
	  static void set_n(double *rpar, size_t n) { rpar[0] = n; }
	  static void set_lam(double *rpar, double lam) { rpar[1] = lam; }
	  static void set_c(double *rpar, double c) { rpar[2] = c; }
	  static void set_lec1(double *rpar, double lec1) { rpar[3] = lec1; }
	  static void set_lec2(double *rpar, double lec2) { rpar[4] = lec2; }
	  static void set_adel(double *rpar, double adel) { rpar[5] = adel; }
	  static void set_mu_eta(double *rpar, double mu_eta) { rpar[6] = mu_eta; }
	  static void set_mu_del(double *rpar, double mu_del) { rpar[7] = mu_del; }
	  static void set_xi_inf(double *rpar, double xi_inf) { rpar[8] = xi_inf; }
	  static void set_xi_fo(double *rpar, double xi) { rpar[9] = xi; };
	  static void set_tsm_fo(double *rpar, double tsm) { rpar[10] = tsm; };
	  static void set_xi_bbn(double *rpar, double xi) { rpar[11] = xi; };
	  static void set_xi_cmb(double *rpar, double xi) { rpar[12] = xi; };
	  static void set_rd_eta(double *rpar, double rd) { rpar[13] = rd; };
	  static void set_rd_del(double *rpar, double rd) { rpar[14] = rd; };
	  static void set_dneff_cmb(double *rpar, double dneff) { rpar[15] = dneff; };
	  static void set_dneff_bbn(double *rpar, double dneff) { rpar[16] = dneff; };
	  static void set_eta_si_per_mass(double *rpar, double si) { rpar[17] = si; };
	  static void set_del_si_per_mass(double *rpar, double si) { rpar[18] = si; };
	
ffcb9d3fdca7a85a1a1be4c2ece81608|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|113|1|V|cpp
	  static void set_xout(double *rpar, double val) { rpar[20] = val; };
	
	  static void solution_push_back(double *rpar, int *ipar, double logx,
	                                 double weta, double yeta) {
	    int npars = ipar[0]; // # of params or idx where sol starts
	    int len = ipar[2];   // Current # of solutions recorded
	    int idx_start = npars + 3 * len;
	    rpar[idx_start + 0] = logx;
	    rpar[idx_start + 1] = weta;
	    rpar[idx_start + 2] = yeta;
	  }
ed92a1d3e5ba07207182022ce3b4564f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|110|47|v|cpp
	get_rpar()
e0e572f40b4697127ea57b9210b0db98|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|31|1|V|cpp
	/**
	 * Compute the equillibrium number density of the eta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_eta(const double td, const DarkSun &model) {
	  using boost::math::pow;
	  const double x = model.get_m_eta() / td;
	  return pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) * gsl_sf_bessel_Kn(2, x);
	}
	
	/**
	 * Compute the equillibrium number density of the delta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_del(const double td, const DarkSun &model) {
	  using boost::math::pow;
	  const double x = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  return g * pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) *
	         gsl_sf_bessel_Kn(2, x);
	}
	
	double dark_heff(const double td, const DarkSun &model) {
	  using boost::math::pow;
	  const double xe = model.get_m_eta() / td;
	  const double xd = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  return pre * (pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	                g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd));
	}
	
	double dark_geff(const double td, const DarkSun &model) {
	  using boost::math::pow;
	  const double xe = model.get_m_eta() / td;
	  const double xd = model.get_m_del() / td;
	  const double g = model.get_g_del();
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  const double geffe =
	      pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) + 3.0 * gsl_sf_bessel_Kn(2, xe));
	  const double geffd =
	      g * pow<2>(xd) *
	      (xe * gsl_sf_bessel_K1(xd) + 3.0 * gsl_sf_bessel_Kn(2, xd));
	  return pre * (geffe + geffd);
	}
	
	double sqrt_gstar(const double tsm, const double xi, const DarkSun &model) {
	  double gd = dark_geff(tsm * xi, model);
	  double gsm = sm_geff(tsm);
	  return sm_sqrt_gstar(tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
	}
	
	/**
	 * Compute the degrees-of-freedom in entropy above confinement.
	 */
	static double dark_heff_inf(const DarkSun &model) {
	  const double n = double(model.get_n());
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	}
	
	/**
	 * Compute the sum of the internal degrees-of-freedom in the energy of the
	 * dark sector below the confinement scaled (i.e. the relativistic d.o.f. of
	 * the eta + delta.)
	 */
	static double dark_sum_g(const DarkSun &model) {
	  return 2.0 + double(model.get_n());
	}
	
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
	static auto xi_bounds_const_td(const double td, const DarkSun &model)
	    -> std::pair<double, double> {
	  const double hd = dark_heff(td, model);
	  const double xi_inf = model.get_xi_inf();
	  const double cr_rhd = cbrt(dark_heff_inf(model) / hd);
	
	  double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	  double ub = cr_rhd * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	static auto xi_bounds_const_tsm(const double tsm, const DarkSun &model)
	    -> std::pair<double, double> {
	  using boost::math::pow;
	  const double xl = model.get_m_eta() / tsm;
	  const double hsm = sm_heff(tsm);
	  const double hdinf = dark_heff_inf(model);
	  const double xi_inf = model.get_xi_inf();
	  const double sg = dark_sum_g(model);
	
	  const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	  const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	  const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	  const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
	double compute_xi_const_td(const double td, const DarkSun &model) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double hd = dark_heff(td, model);
	  const double c1 =
	      dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	  // Function specifying when to stop bisection algorithm
	  auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	  // Perform bisection algorith to find xi.
	  const auto bounds = xi_bounds_const_td(td, model);
	  const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	  // Return average of the bounding points
	  return (res.second + res.first) / 2.0;
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
	double compute_xi_const_tsm(const double tsm, const DarkSun &model) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const std::optional<double> tsm_fo = model.get_tsm_fo();
	  const bool frozen = tsm_fo.has_value();
	  const double tfo = tsm_fo.value_or(-1.0);
	
	  if (frozen || tsm > tfo) {
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	    auto f = [c1, model, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, model) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, model);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
	  } else {
	    // If tsm_fo has a value, that means the eta has frozen out. In this case,
	    // there is no need to perform a root finding algorithm. We just readshift.
	    const double tfo = tsm_fo.value();
	    const double xifo = model.get_xi_fo().value();
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tfo * xifo > model.get_m_eta()) {
	      return xifo;
	    } else {
	      return xifo * tsm / tfo;
	    }
	  }
	}
8c51dfdde2f03fd126ea38709e6407a9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|30|1|V|cpp
	
	
	/* ---------------------------------------
	 * Function for use with fortran interface
	 * ---------------------------------------
	 */
c6c893091f4bad0b1fb19faecf12c045|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|118|1|V|cpp
	    using boost::math::pow;
	    const double x = model.get_m_eta() / td;
	    return pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) *
	           gsl_sf_bessel_Kn(2, x);
db0a724bae66f5bccf073601713e60a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|79|1|V|cpp
	  // ========================================================================
	  // ---- Cross sections ----------------------------------------------------
	  // ========================================================================
b7bd607781d44a1950df9f0a1b5c1be9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|116|11|v|cpp
	Cross sections
93dfb8a55f2d3dad880d1e5f060272de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|124|1|V|cpp
	    return darksun::neq_eta(td, m_rpar.data());
825e3f75a87a556bcc9d75d659bab9a2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|132|1|V|cpp
	    using boost::math::pow;
	    const double x = model.get_m_del() / td;
	    const double g = model.get_g_del();
	    return g * pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) *
	           gsl_sf_bessel_Kn(2, x);
2f9b34ff63b857201b5b3380485a93e2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|131|1|V|cpp
	    return darksun::neq_del(td, m_rpar.data());
3d8bfafe8d5d5b95f61ca3c0ad4bdc5e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|135|1|V|cpp
	    using boost::math::pow;
	    const double xe = model.get_m_eta() / td;
	    const double xd = model.get_m_del() / td;
	    const double g = model.get_g_del();
	    const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	    return pre * (pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	                  g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd));
8991ed21c635676c4ed767f87a45800a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|135|21|v|cpp
	neq_del
5634ffd68ca93a5c95217fdc9f9982f5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|135|1|V|cpp
	    return darksun::dark_heff(td, m_rpar.data());
b786841c6111f8da60e386bdc6d72f0f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|139|1|V|cpp
	    using boost::math::pow;
	    const double xe = model.get_m_eta() / td;
	    const double xd = model.get_m_del() / td;
	    const double g = model.get_g_del();
	    const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	    const double geffe = pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) +
	                                       3.0 * gsl_sf_bessel_Kn(2, xe));
	    const double geffd =
	        g * pow<2>(xd) *
	        (xe * gsl_sf_bessel_K1(xd) + 3.0 * gsl_sf_bessel_Kn(2, xd));
	    return pre * (geffe + geffd);
da0e4b30123f5a369bd3b39cb7ef6b20|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|139|1|V|cpp
	    return darksun::dark_geff(td, m_rpar.data());
030bf4597ce44e731c1121dbfc84159c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|143|1|V|cpp
	    double gd = dark_geff(tsm * xi, model);
	    double gsm = sm_geff(tsm);
	    return sm_sqrt_gstar(tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
6bf83c9a08954da0ec7fca611ca3f642|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|143|21|v|cpp
	dark_geff
06fb29f19d078ef06ed8121cfe41ad42|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|143|1|V|cpp
	    return darksun::sqrt_gstar(tsm, xi, m_rpar.data());
adf7984577e1b442616cfa61c1c047c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|150|1|V|cpp
	    const double n = double(model.get_n());
	    return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
b65293d624d97475b0a11bcd45a26dfa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|150|21|v|cpp
	sqrt_gstar
d8b213f15b7135fed7ee0010c99dd3b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|150|35|v|cpp
	tsm, xi, 
95db03e953a10a470743c599cfe35367|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|149|31|v|cpp
	const DarkSun &model
8b831a704ad730e77f663385125b6003|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|157|12|v|cpp
	2.0 + double(model.get_n());
311810c3375cbd4f4f7134998d1759e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|157|1|V|cpp
	    return darksun::dark_sum_g(m_rpar.data());
c1a81999013fb919a006ba1a108a6b81|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|163|1|V|cpp
	    const double hd = dark_heff(td, model);
	    const double xi_inf = model.get_xi_inf();
	    const double cr_rhd = cbrt(dark_heff_inf(model) / hd);
	
	    double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	    double ub = cr_rhd * xi_inf;
	
	    return std::make_pair(lb, ub);
15e60b87af9e24389b77d32d9f89d1f3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|161|8|v|cpp
	xi_bounds_const_td
a87b4a3166c62bef9f3cdb03b20239ef|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|161|41|v|cpp
	d, const DarkSun &model
659fefb61d6b84301c9505ef464a6faf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|162|1|V|cpp
	    return darksun::xi_bounds_const_td(td, m_rpar.data());
53b7856ecba374bb188c089d1f45d5dd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|167|1|V|cpp
	    using boost::math::pow;
	    const double xl = model.get_m_eta() / tsm;
	    const double hsm = sm_heff(tsm);
	    const double hdinf = dark_heff_inf(model);
	    const double xi_inf = model.get_xi_inf();
	    const double sg = dark_sum_g(model);
	
	    const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	    const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	    const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	    const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	    return std::make_pair(lb, ub);
992c8df03b198ee970203e8a23cca2c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|166|1|V|cpp
	    return darksun::xi_bounds_const_tsm(tsm, m_rpar.data());
10dda3d351d14667f9446bd620fb3a0e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|174|1|V|cpp
	    using namespace boost::math;
	    using namespace boost::math::tools;
	
	    const double hd = dark_heff(td, model);
	    const double c1 =
	        dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	    auto f = [hd, td, c1](double xi) -> double {
	      return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_td(td, model);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
21fbb9442989852135a1849303c15d54|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|174|21|v|cpp
	xi_bounds_const_tsm
00edafbc399cb6ee94c11b736d6564f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|173|45|v|cpp
	, const DarkSun &model) {
37e214d0c4010e4282402a0043a14b8e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|174|1|V|cpp
	    return darksun::compute_xi_const_td(td, m_rpar.data());
c32d215dd068b74cc4d11876897e2f77|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|182|1|V|cpp
	    using namespace boost::math;
	    using namespace boost::math::tools;
	
	    const std::optional<double> tsm_fo = model.get_tsm_fo();
	    const bool frozen = tsm_fo.has_value();
	    const double tfo = tsm_fo.value_or(-1.0);
	
	    if (frozen || tsm > tfo) {
	      // The eta hasn't frozen out: assume that it is still in thermal
	      // equillibrium with itself.
	      const double hsm = sm_heff(tsm);
	      const double c1 =
	          hsm * dark_heff_inf(model) * pow<3>(model.get_xi_inf()) / SM_HEFF_INF;
	
	      auto f = [c1, model, tsm](double xi) -> double {
	        return dark_heff(xi * tsm, model) * pow<3>(xi) - c1;
	      };
	      // Function specifying when to stop bisection algorithm
	      auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	      // Perform bisection algorith to find xi.
	      const auto bounds = xi_bounds_const_tsm(tsm, model);
	      const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	      // Return average of the bounding points
	      return (res.second + res.first) / 2.0;
	    } else {
	      // If tsm_fo has a value, that means the eta has frozen out. In this case,
	      // there is no need to perform a root finding algorithm. We just
	      // readshift.
	      const double tfo = tsm_fo.value();
	      const double xifo = model.get_xi_fo().value();
	      // Check if the eta is relativistic. If it is, its temperature redshifts
	      // like the standard model temperature. Otherwise, it redshifts like
	      // matter.
	      if (tfo * xifo > model.get_m_eta()) {
	        return xifo;
	      } else {
	        return xifo * tsm / tfo;
	      }
	    }
1c7ab43b4e63473fd20b50e4a078868b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|3|V|cpp
	  auto pars = model_to_vec(model, dx, num_xs);
97a30bef828631dac90b0681d9f3ba85|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|18|v|cpp
	pars.first;
e4d897d7226fff715b0463779cdc0cf7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|16|v|cpp
	pars.second;
686213a147dd61a8d373239f35fde266|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|120|1|V|cpp
	  double meta = model.get_m_eta();            // Mass of the eta
	  double td = model.get_lam() / 2.0;          // Start Td at confinement
	  double xi = compute_xi_const_td(td, model); // Starting value of xi
	  double tsm = td / xi;                       // Initial SM temperature
	  double s = sm_entropy_density(tsm);         // Initial SM entropy density
	  double log_xstart = log(meta / tsm);        // Log of initial x
	  double log_xfinal = log(meta / T_CMB);      // Log of final x (end at CMB)
4531bb6508611ead7ddf1c0ea7028a58|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|87|3|V|cpp
	    2.2890e+01
c12db1101dae2d8a9c597aba2b42165a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|25|1|V|cpp
	  double logx_start;
	  double logx_end;
	  double xi_init;
	  double td_init;
	  double tsm_init;
	  double ye
3b135a405386094867db2235c87d50da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|129|1|V|cpp
	  y[0] = log(neq_eta(td, model) / s); // y[0] is log(Y_eta)
	  y[1] = neq_del(td, model) / s;      // y[1] is Y_delta
ffded2866e9310d1d6003b174b108593|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|120|1|V|cpp
	  double meta = model.get_m_eta();            // Mass of the eta
	  double td = model.get_lam() / 2.0;          // Start Td at confinement
	  double xi = compute_xi_const_td(td, model); // Starting value of xi
	  double tsm = td / xi;                       // Initial SM temperature
	  double s = sm_entropy_density(tsm);         // Initial SM entropy density
46e52d0024da2810eda5294d39d1c334|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|120|21|v|cpp
	= log(meta / tsm)
892e2d7fef6449bf1e629553d9092e26|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|121|21|v|cpp
	= log(meta / T_CMB)
bcded659105551150f23c9f451cc4424|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|108|1|V|cpp
	    set_sol_len(ipar, len + 1);
739da7145724cba18395d8c731cf6ba9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|47|1|V|cpp
	    m_rpar[19] = 0.0;  // xout for radau
	    m_rpar[20] = 0.0;  // dxout for radau
84228e3aa99801106f2b675d8a5c8e40|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|27|1|V|cpp
	static constexpr size_t IDX_XOUT = 19;_
c291c5011180ab63e5b6958cab8224df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|30|1|V|cpp
	m_rpar[19] = 0.0; // xout for radau
	m_rpar[20] = 0.0; // dxout for radau
ece31e80ec0ce48a6840ef203481ec55|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|66|1|V|cpp
	double get_xout(const double *rpar) {return rpar[IDX_XOUT];}
a693b2f9be93d7874136dd0e00caf24b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|65|1|V|cpp
	
	double get_xout(const double *rpar) {return rpar[IDX_XOUT];}
255d6bcdfea331a94abb010c82246374|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|56|1|V|cpp
	double get_xout(const double *rpar) { return rpar[IDX_XOUT]; }
b326ff1ff59d8786cc723bf8236e48c7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|160|1|V|cpp
	  int idx = get_sol_idx(ipar.data()); // get the index of rpar where sol starts
	  int cap = get_sol_cap(ipar.data()); // get the length of the solution
96a60a2fa6b2bb680f9154c044f49ad0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|1|V|cpp
	  rpar[idx + 0 * cap + cap] = log_xfinal;
	  rpar[idx + 1 * cap + cap] = y[0];
	  rpar[idx + 2 * cap + cap] = y[1];
de54efc2e495bffcac90b383ce2e3115|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|161|1|V|cpp
	  // Add on final solution to the end of the solution
3f342c107afbde464cba7523389d266c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|170|1|V|cpp
	  // Move values into model
	  model.set_sol_cap(cap + 1);
	  for (size_t i = 0; i < cap + 1; i++) {
	    double logx = rpar[idx + 0 * cap + i];
	    double we = rpar[idx + 1 * cap + i];
	    double yd = rpar[idx + 2 * cap + i];
	    model.solution_push_back(logx, we, yd);
	  }
5348812dcbb56eb3858bd9d2f603a864|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|249|1|V|cpp
	    sol[0] = m_rpar[m_num_pars + 3*i + 0];
727d9398b47aea0df447a0f0afe76826|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|250|1|V|cpp
	      sol[0] = m_rpar[m_num_pars + 3 * i + 0];
	      sol[1] = m_rpar[m_num_pars + 3 * i + 1];
	      sol[2] = m_rpar[m_num_pars + 3 * i + 2];
70cafb7cb2855ec948b1948ad14f9eed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|254|40|v|cpp
	(m_sol_size-1)
2a16538949569e00e6d14bcf2e9ab617|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|170|3|V|cpp
	  auto sol = model.get_solution();
bf24b7d67a71d851e442e18e1f8933f9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|17|1|V|cpp
	private:
204549b95f771e074d28fb339d54243e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|17|1|V|cpp
	  static constexpr size_t m_num_pars = 20;
	  static constexpr size_t m_sol_size = 100;
	  // Vector containing all of the parameters of the model and ODE solution.
	  // ODE solution is stored as [logx1, weta1, ydel1, logx2, weta2, ydel2,...]
	  std::array<double, m_num_pars + 3 * m_sol_size> m_rpar;
	  // Vector contianing parameter info about solution
	  std::array<int, 3> m_ipar;
102d2a13667036aad706b0e2a4130e2e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|239|1|V|cpp
	  int get_sol_idx() const { return darksun::get_sol_idx(ipar.data()); }
	  int get_sol_len() const { return darksun::get_sol_idx(ipar.data()); }
	  int get_sol_cap() const { return darksun::get_sol_idx(ipar.data()); }
9f76d4af9d42250731dea40ef6292017|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|170|7|v|cpp
	(auto &val : Dark)
acac8fe9df71bf2ef3f93ad433febd90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|19|1|V|cpp
	  static constexpr size_t nupars = 20;
	  static constexpr size_t sol_size = 100;
	  // Vector containing all of the parameters of the model and ODE solution.
	  // ODE solution is stored as [logx1, weta1, ydel1, logx2, weta2, ydel2,...]
	  std::array<double, nupars + 3 * sol_size> rpar;
	  // Vector contianing parameter info about solution
	  std::array<int, 3> ipar;
91561f3d47ee671a87ad5d612d55628f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|18|3|V|cpp
	  2.2890e+01
f4657a12c32b2ba58eda28d151c5ea78|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|18|27|v|cpp
	nupars
a5437bdd69374daa30ab3d7c29a0109e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|244|23|v|cpp
	nupars 
a5437bdd69374daa30ab3d7c29a0109e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|244|23|v|cpp
	nupars 
a5437bdd69374daa30ab3d7c29a0109e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|244|23|v|cpp
	nupars 
1381c0f2a49e0516e55add85dd47c0c5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|35|3|V|cpp
	  static constexpr size_t m_num_pars = 20;
08bed7f75819e0b90fcdda442fe43e1a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|38|22|v|cpp
	m_num_pars 
abff3ecbeb4b74c3cbcf92dd1dfe2a03|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|7|1|V|cpp
	static constexpr size_t NUM_PARS = 21;
8bce6d2b80d74a98a127bb44b0be886e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|8|25|v|cpp
	NUM_PARS 
2201f906d360d1d2b758d94b84103f67|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|37|37|v|cpp
	m_sol_size
1d66a903b4d724d348ce578d7aa4c2d3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|70|21|v|cpp
	m_num_pars
1dc397991a16a84fe870cdc9e49faef2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|52|1|V|cpp
	    m_rpar[IDX_XI_FO] = -1.0;  // xi_fo
	    m_rpar[IDX_TSM_FO] = -1.0; // tsfo
	    m_rpar[IDX_XI_BBN] = -1.0; // xi_bbn
	    m_rpar[IDX_XI_CMB] = -1.0; // xi_cmb
	    m_rpar[IDX_RD_ETA] = -1.0; // rd_eta
	    m_rpar[IDX_RD_DEL] = -1.0; // rd_del
	    m_rpar[IDX_DNEFF_CMB] = -1.0; // dneff_cmb
	    m_rpar[IDX_DNEFF_BBN] = -1.0; // dneff_bbn
	    m_rpar[IDX_ETA_SI_PER_MASS] = -1.0; // eta_si_per_mass
	    m_rpar[IDX_DEL_SI_PER_MASS] = -1.0; // del_si_per_mass
cdfddff6bf16300f2451aebe0a1651db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|76|1|V|cpp
	    m_rpar[9] = -1.0;  // xi_fo
	    m_rpar[10] = -1.0; // tsfo
	    m_rpar[11] = -1.0; // xi_bbn
	    m_rpar[12] = -1.0; // xi_cmb
	    m_rpar[13] = -1.0; // rd_eta
	    m_rpar[14] = -1.0; // rd_del
	    m_rpar[15] = -1.0; // dneff_cmb
	    m_rpar[16] = -1.0; // dneff_bbn
	    m_rpar[17] = -1.0; // eta_si_per_mass
	    m_rpar[18] = -1.0; // del_si_per_mass
571accc5a27e3477bcca1566b0a3ef78|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|66|5|V|cpp
	    m_ipar[1] = m_sol_size; // # of solution points
579758376b33cea247b24dd9a2f60904|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|65|5|V|cpp
	    m_ipar[0] = m_num_pars; // # of params or idx where sol starts
332fc10f5815b46fe760313f9d772249|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|39|3|v|cpp
	std::array<int, 3>
cc37cfc0467fc60c3bd3c5cc3e31dc20|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|218|40|v|cpp
	std::cref(
1401886bb5b57064efb0d133993c02db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|258|5|V|cpp
	    if (i < ) {
7438d2c056eabfdbaa98e45d094a4242|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|265|39|v|cpp
	m_sol_size 
7438d2c056eabfdbaa98e45d094a4242|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|265|39|v|cpp
	m_sol_size 
7438d2c056eabfdbaa98e45d094a4242|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|265|39|v|cpp
	m_sol_size 
0d850613df89d61ae07e5d08d914ea0f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|173|5|V|cpp
	    double yd;
795764d3755aabbd0823aa34f2687823|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|172|5|V|cpp
	    double we;
351efc20a4e46db62e60eaf38ca58ab7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|171|5|V|cpp
	    double logx;
b44183df439fe5ef67704c73dc019a46|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|14|1|V|cpp
	  for (auto &sol : model.get_solution()) {
	    fmt::print("logx, w, y = {}, {}, {}\n", sol[0], sol[1], sol[2]);
	  }
52f8497b9333a9582a63693f657249f6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_xi.cpp|15|43|v|cpp
	, model
624863183b84184a3d1d90f9deecd6df|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|101|1|V|cpp
	  int npars = ipar[0]; // # of params or idx where sol starts
f6cea26e9c948ce9f557ab871f38ddae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|102|19|v|cpp
	npars 
52f5ae61c7c20174d7677d6ac822a9ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|3|V|cpp
	  int idx = get_sol_idx(ipar);
ad9170fffe88fd19c1ff8815f6462448|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|93|3|V|cpp
	  int cap = get_sol_cap(ipar);
c72270b9e8f3955a2417122707942c22|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|100|15|v|cpp
	get_sol_len(ipar);
3d376441b1fe4765f51d6a0cd6802ed0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|95|3|V|cpp
	  std::cout << dx << std::endl;
8a26e753a0840e1daa8f587fe4158e00|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|148|3|v|cpp
	double dx = 
501641ea535b019aa6bebfcb3ca962f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|97|1|V|cpp
	void set_xout(double *rpar, double val) { rpar[IDX_XOUT] = val; };
7087a4a26256fb46ca6baef03fb6bc84|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|305|1|V|cpp
	  void set_xout(double val) { darksun::set_xout(m_rpar.data(), val); }
90e386f4f7e075f3b9a8a786a19b2716|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|161|1|V|cpp
	  model.set_rd_eta(model.get_m_eta() * exp(y[0]) * S_TODAY / RHO_CRIT);
8cecab99a1e145c2b491ec828cdec206|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|40|v|cpp
	exp(y[0])
5a354b594f5406480585bd8f0c1cb2f5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|153|3|V|cpp
	  printf("init: y(%1.4f) = ( %1.4e, %1.4e)\n", log_xstart, y[0], y[1]);
c508f94f339b37ff1f2c485a751c33de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|1|V|cpp
	  model.set_dneff_bbn(0.0);
673c55e41d4bc3fe87aa10b41233d5bb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|163|1|V|cpp
	  model.set_dneff_bbn(0.0);
	  model.set_dneff_cmb(0.0);
19921d40ec440a9e75d7121662b073a8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|166|13|v|cpp
	dneff_cmb(0.0);
53782747d03186d3ce56c4b356a21025|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|166|13|v|cpp
	dneff_cmb
8ef805ff420fc1db5d1157ef0cb64348|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|180|11|v|cpp
	y(%1.4f) = ( %1.4e, 
9efafad43a980b03caec3863b37f4343|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|180|1|V|cpp
	  printf("rd_eta = %1.4e\n", model.get_rd_eta());
211fd88e280e04cab1f3857f31c4ca29|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|180|1|V|cpp
	  printf("rd_eta = %1.4e\n", model.get_rd_eta());
	  printf("rd_del = %1.4e\n", model.get_rd_del());
b405a5152f9bc2596a5ebb7dae30742c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|182|11|v|cpp
	rd_eta
41b2a5dbd3ac9723209e5ba2b59b9918|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|182|1|V|cpp
	  printf("xi_cmb = %1.4e\n", model.get_xi_cmb());
95d848656002dbde85e1685b17d41acb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|184|3|V|cpp
	  printf("rd_del = %1.4e\n", model.get_rd_del());
a794b586f0de1620feab14889c93bb4d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|182|1|V|cpp
	  printf("xi_cmb = %1.4e\n", model.get_xi_cmb());
	  printf("xi_bbn = %1.4e\n", model.get_xi_bbn());
2c4232c2c6de9ca2fcf319fe81e595e6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|182|11|v|cpp
	xi_cmb 
0cd70a03ff8b5b3ed4c455c7f465f658|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|183|11|v|cpp
	xi_bbn
c7ff1067069c845e10380366ffd915f0|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|412|1|V|cpp
	/**
	 * Compute the zero-temperature self-interaction cross section for
	 * eta + eta -> eta + eta.
	 * @return Self-interaction cross-section 2eta->2eta.
	 */
	double DarkSUN::cross_section_2eta_2eta() const {
	  using namespace boost::math;
	
	  // compute dark temperature today in order to compute eta velocity
	  double Tsm_today = 2.7255 * 8.6173303e-14;
	  double xi_today = compute_xi(Tsm_today);
	  double Td_today = xi_today * Tsm_today;
	
	  double me = m_eta.get_mass();
	  double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
	  double z2 = 4.0 / (1.0 - vrel * vrel);         // CME^2/meta^2.
	
	  return (pow<2>(m_lec1) * pow<3>(M_PI) *
	          (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	           21.0 * pow<4>(z2)) *
	          pow<6>(m_mu_eta)) /
	         (135.0 * pow<2>(m_lam) * pow<5>(m_N) * z2);
	}
340a77c7e357b7e409797d8967768614|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|209|1|V|cpp
	  double lec1 = get_lec1(rpar);
815cddf1309a8ad4b3f08d28f7d24d2b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|210|10|v|cpp
	lec1 
b004711fcda556a145ee393f827a3ad1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|210|1|V|cpp
	  double mu_eta = get_mu_eta(rpar);
98211a40043c1be40e20edeaf2e5d379|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|211|1|V|cpp
	  double lam = get_lam(rpar);
d76b953675aa16bb36424f09a84107ff|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|212|10|v|cpp
	lam 
442907443992c6d94e367fa04b9428cd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|436|1|V|cpp
	/**
	 * Compute the zero-temperature self-interaction cross section for
	 * delta + delta -> delta + delta.
	 * @return Self-interaction cross-section delta->delta.
	 */
	double DarkSUN::cross_section_2delta_2delta() const {
	  using namespace boost::math;
	  return 4.0 * pow<3>(M_PI) / pow<2>(m_lam);
	}
477cde85b99bf0d7a0396b02f9e46d3d|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/dm_models/darksun.hpp|446|1|V|cpp
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at CMB.
	 * @return Delta N_eff at CMB
	 */
	double DarkSUN::delta_n_eff_cmb() const {
	  using namespace boost::math;
	  return 4.0 / 7.0 * pow(11.0 / 4.0, 4.0 / 3.0) * dark_geff(kT_CMB * m_xi_cmb) *
	         pow<4>(m_xi_cmb);
	}
	
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at BBN.
	 * @return Delta N_eff at BBN
	 */
	double DarkSUN::delta_n_eff_bbn() const {
	  using namespace boost::math;
	  return 4.0 / 7.0 * dark_geff(kT_BBN * m_xi_bbn) * pow<4>(m_xi_bbn);
	}
33e8cc1913ef7ede4dcf3a7fd241672b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|193|1|V|cpp
	/**
	 * Compute the zero-temperature self-interaction cross section for
	 * eta + eta -> eta + eta.
	 * @return Self-interaction cross-section 2eta->2eta.
	 */
	double cross_section_2eta_2eta(const double *rpar) {
	  using namespace boost::math;
	
	  // compute dark temperature today in order to compute eta velocity
	  const double Tsm_today = 2.7255 * 8.6173303e-14;
	  const double xi_today = compute_xi_const_tsm(Tsm_today, rpar);
	  const double Td_today = xi_today * Tsm_today;
	
	  const double me = get_m_eta(rpar);
	  const double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
	  const double z2 = 4.0 / (1.0 - vrel * vrel);         // CME^2/meta^2.
	  const double lec1 = get_lec1(rpar);
	  const double mu_eta = get_mu_eta(rpar);
	  const double lam = get_lam(rpar);
	  const double n = get_n(rpar);
	
	  return (pow<2>(lec1) * pow<3>(M_PI) *
	          (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	           21.0 * pow<4>(z2)) *
	          pow<6>(mu_eta)) /
	         (135.0 * pow<2>(lam) * pow<5>(n) * z2);
	}
	
	/**
	 * Compute the zero-temperature self-interaction cross section for
	 * delta + delta -> delta + delta.
	 * @return Self-interaction cross-section delta->delta.
	 */
	double cross_section_2delta_2delta(const double *rpar) {
	  using namespace boost::math;
	  const double lam = get_lam(rpar);
	  return 4.0 * pow<3>(M_PI) / pow<2>(lam);
	}
	
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at CMB.
	 * @return Delta N_eff at CMB
	 */
	double delta_n_eff_cmb(const double *rpar) {
	  using namespace boost::math;
	  const double xi_cmb = get_xi_cmb(rpar);
	  return 4.0 / 7.0 * pow(11.0 / 4.0, 4.0 / 3.0) *
	         dark_geff(T_CMB * xi_cmb, rpar) * pow<4>(xi_cmb);
	}
	
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at BBN.
	 * @return Delta N_eff at BBN
	 */
	double delta_n_eff_bbn(const double *rpar) {
	  using namespace boost::math;
	  const double xi_bbn = get_xi_bbn(rpar);
	  return 4.0 / 7.0 * dark_geff(T_BBN * xi_bbn, rpar) * pow<4>(xi_bbn);
	}
70e4c2387cbafaffa4008f761a72eb73|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|141|1|V|cpp
	  // ========================================================================
	  // ---- Thermal Functions -------------------------------------------------
	  // ========================================================================
c97c30f735ff73f9d70a8ca068f25843|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|216|1|V|cpp
	  /**
	   * Compute the zero-temperature self-interaction cross section for
	   * eta + eta -> eta + eta.
	   * @return Self-interaction cross-section 2eta->2eta.
	   */
	  double cross_section_2eta_2eta(const double *rpar) {
	    using namespace boost::math;
	
	    // compute dark temperature today in order to compute eta velocity
	    const double Tsm_today = 2.7255 * 8.6173303e-14;
	    const double xi_today = compute_xi_const_tsm(Tsm_today, rpar);
	    const double Td_today = xi_today * Tsm_today;
	
	    const double me = get_m_eta(rpar);
	    const double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
	    const double z2 = 4.0 / (1.0 - vrel * vrel);         // CME^2/meta^2.
	    const double lec1 = get_lec1(rpar);
	    const double mu_eta = get_mu_eta(rpar);
	    const double lam = get_lam(rpar);
	    const double n = get_n(rpar);
	
	    return (pow<2>(lec1) * pow<3>(M_PI) *
	            (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	             21.0 * pow<4>(z2)) *
	            pow<6>(mu_eta)) /
	           (135.0 * pow<2>(lam) * pow<5>(n) * z2);
	  }
	
	  /**
	   * Compute the zero-temperature self-interaction cross section for
	   * delta + delta -> delta + delta.
	   * @return Self-interaction cross-section delta->delta.
	   */
	  double cross_section_2delta_2delta(const double *rpar) {
	    using namespace boost::math;
	    const double lam = get_lam(rpar);
	    return 4.0 * pow<3>(M_PI) / pow<2>(lam);
	  }
1c5fac59ef88ed31a16b0eecefdf43bc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|147|1|V|cpp
	    using namespace boost::math;
	
	    // compute dark temperature today in order to compute eta velocity
	    const double Tsm_today = 2.7255 * 8.6173303e-14;
	    const double xi_today = compute_xi_const_tsm(Tsm_today, rpar);
	    const double Td_today = xi_today * Tsm_today;
	
	    const double me = get_m_eta(rpar);
	    const double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
	    const double z2 = 4.0 / (1.0 - vrel * vrel);         // CME^2/meta^2.
	    const double lec1 = get_lec1(rpar);
	    const double mu_eta = get_mu_eta(rpar);
	    const double lam = get_lam(rpar);
	    const double n = get_n(rpar);
	
	    return (pow<2>(lec1) * pow<3>(M_PI) *
	            (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	             21.0 * pow<4>(z2)) *
	            pow<6>(mu_eta)) /
	           (135.0 * pow<2>(lam) * pow<5>(n) * z2);
0898e2b5f914a70533b43c085b7f5e52|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|156|1|V|cpp
	    using namespace boost::math;
	    const double lam = get_lam(rpar);
	    return 4.0 * pow<3>(M_PI) / pow<2>(lam);
1e337592149d7d112d1132436b955775|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|38|v|cpp
	const double *rpar
5ea3c34ac0943b514dbf65b611d9ca57|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|231|11|v|cpp
	Thermal 
9ff6c274a5995c97fccb010256fe49c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|231|11|v|cpp
	Functions 
efe5f3cdb70ab90b8b4addcea86cd412|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|239|1|V|cpp
	    using namespace boost::math;
	    const double xi_cmb = get_xi_cmb(rpar);
	    return 4.0 / 7.0 * pow(11.0 / 4.0, 4.0 / 3.0) *
	           dark_geff(T_CMB * xi_cmb, rpar) * pow<4>(xi_cmb);
7ea0b79a9746e111cd4e496ad04e5ff9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|247|1|V|cpp
	    using namespace boost::math;
	    const double xi_bbn = get_xi_bbn(rpar);
	    return 4.0 / 7.0 * dark_geff(T_BBN * xi_bbn, rpar) * pow<4>(xi_bbn);
a914280bc70f18365e1ebaf04d41a0f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|189|11|v|cpp
	xi_bbn 
b30794c6c5e8a679f53024d1ecee9e98|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|188|1|V|cpp
	  printf("dneff_cmb = %1.4e\n", model.get_dneff_cmb());
	  printf("dneff_bbn = %1.4e\n", model.get_dneff_bbn());
d6db2ef19840a66c98770b5372a921ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|190|11|v|cpp
	dneff_cmb 
8d30441929f78a61d8d421cfdde46808|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|191|11|v|cpp
	dneff_bbn 
f1cd2c1db36e51c587d385d00014f7ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|162|1|V|cpp
	  model.set_rd_eta(model.get_m_eta() * exp(y[0]) * S_TODAY / RHO_CRIT);
	  model.set_rd_del(model.get_m_del() * y[1] * S_TODAY / RHO_CRIT);
	  model.set_xi_cmb(model.compute_xi_const_tsm(T_CMB));
	  model.set_dneff_bbn(model.delta_n_eff_bbn());
	  model.set_dneff_cmb(model.delta_n_eff_cmb());
	  model.set_eta_si_per_mass(model.cross_section_2eta_2eta() /
	                            model.get_m_eta());
	  model.set_del_si_per_mass(model.cross_section_2del_2del() /
	                            model.get_m_del());
5ef097a03112d6f93db8dfe1e44ed411|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|172|20|v|cpp
	model.get_m_eta() * exp(y[0]) * S_TODAY / RHO_CRIT
41b445c114d09273c84f6352503c5edf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|173|20|v|cpp
	model.get_m_del() * y[1] * S_TODAY / RHO_CRIT
b44c71d23128de156a36f9f47c576ff8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|174|20|v|cpp
	model.compute_xi_const_tsm(T_CMB)
37a188134585199ee1d69518638f5889|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|175|23|v|cpp
	model.delta_n_eff_bbn()
d73eba26b3952e64fef00693f23b3aaa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|176|23|v|cpp
	model.delta_n_eff_cmb()
1041613fd02d60d665c9f3badbedeaaa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|177|29|v|cpp
	model.cross_section_2eta_2eta() /
	                            model.get_m_eta()
4454188d5042589b0a3dd528d31f9347|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|178|29|v|cpp
	model.cross_section_2del_2del() /
	                            model.get_m_del()
fb90311ec62ebb8f07cf5521a5cfd02c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|294|1|V|cpp
	  std::array<double, 3> get_solution(size_t i) {
	    std::array<double, 3> sol;
	    if (i < SOL_SIZE) {
	      sol[0] = m_rpar[NUM_PARS + 3 * i + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * i + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * i + 2];
	    } else {
	      sol[0] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 2];
	    }
	    return sol;
	  }
e82baab4aac92d807f31cb754f170ab9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|308|38|v|cpp
	size_t i
9429d26e42caf7acd0110016e74f2f90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|313|1|V|cpp
	    if (i < SOL_SIZE) {
	      sol[0] = m_rpar[NUM_PARS + 3 * i + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * i + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * i + 2];
	    } else {
	      sol[0] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 2];
	    }
960d71af903e19ddfa7179e6dd6efa75|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|308|3|v|cpp
	std::array<double, 3>
0fca08542cc8f81f5585649dd1efca9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|309|5|v|cpp
	std::array<std::array<double, 3>, SOL_SIZE>
65c57ae565e0ece5e509ef10b6939fc4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|27|1|v|cmake
	#         
2d885415c87ab60475e4899cf2d5867b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|33|21|v|cmake
	cosmology 
1f2037067aec00da2cc89e7927fc956e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|33|55|v|cmake
	cosmology
ad5e2cd28e641904a821ece940613347|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|41|1|V|cmake
	# 
	# pybind11_add_module(dm_models ${SOURCES} "${SOURCE_DIR}/dm_models.cpp") #target_link_libraries(models PRIVATE
	# target_link_libraries(
	#         dm_models PRIVATE
	#         lanre
	# 	GSL::gsl
	# 	GSL::gslcblas
	#         Eigen3::Eigen
	#         ${Boost_LIBRARIES}
	# )
	# 
	# pybind1_add_module(diffeq ${SOURCES} "${SOURCE_DIR}/diffeq.cpp") #target_link_libraries(models PRIVATE
	# target_link_libraries(
	#         diffeq PRIVATE
	#         lanre
	# 	GSL::gsl
	# 	GSL::gslcblas
	#         Eigen3::Eigen
	#         ${Boost_LIBRARIES}
	# )
	# 
	# pybind11_add_module(constants ${SOURCES} "${SOURCE_DIR}/constants.cpp") #target_link_libraries(models PRIVATE
	# target_link_libraries(
	#         constants PRIVATE
	#         lanre
	# 	GSL::gsl
	# 	GSL::gslcblas
	#         Eigen3::Eigen
	#         ${Boost_LIBRARIES}
	# )
	# 1
1b58013f9e3a3e3601de0b7b8fac9f68|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|6|1|V|cpp
	#include <pybind11/pybind11.h>
	#include <pybind11/stl.h>
f457d5eebc322c143b17f2ceafa6ac47|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|104|1|V|cpp
	PYBIND11_MODULE(dm_models, m) {
6848b16220287254551369ac12681a1f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/darksun.cpp|8|17|v|cpp
	dm_models
db3d02b64485034fc7537622f4e97a67|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|168|1|V|cpp
	      .def_property("lam", &DarkSUN::get_lam, &DarkSUN::set_lam)
	      .def_property("N", &DarkSUN::get_N, &DarkSUN::set_N)
	      .def_property("lec1", &DarkSUN::get_lec1, &DarkSUN::set_lec1)
	      .def_property("lec2", &DarkSUN::get_lec2, &DarkSUN::set_lec2)
	      .def_property("c", &DarkSUN::get_c, &DarkSUN::set_c)
	      .def_property("a", &DarkSUN::get_a, &DarkSUN::set_a)
	      .def_property("mu_eta", &DarkSUN::get_mu_eta, &DarkSUN::set_mu_eta)
	      .def_property("mu_delta", &DarkSUN::get_mu_delta, &DarkSUN::set_mu_delta)
	      .def_property("xi_inf", &DarkSUN::get_xi_inf, &DarkSUN::set_xi_inf)
	      .def_property("has_dp", &DarkSUN::get_has_dp, &DarkSUN::set_has_dp)
	      .def_property("xi_fo", &DarkSUN::get_xi_fo, nullptr)
	      .def_property("Tsm_fo", &DarkSUN::get_Tsm_fo, nullptr)
	      .def_property("xi_bbn", &DarkSUN::get_xi_bbn, nullptr)
	      .def_property("xi_cmb", &DarkSUN::get_xi_cmb, nullptr)
	      .def_property("rd_eta", &DarkSUN::get_rd_eta, nullptr)
	      .def_property("rd_delta", &DarkSUN::get_rd_delta, nullptr)
	      .def_property("dneff_cmb", &DarkSUN::get_dneff_cmb, nullptr)
	      .def_property("dneff_bbn", &DarkSUN::get_dneff_bbn, nullptr)
	      .def_property("eta_si_per_mass", &DarkSUN::get_eta_si_per_mass, nullptr)
16ef72f52bd2ab3b72bf7b1da11d4011|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/darksun.cpp|11|1|V|cpp
	    .def_property("
74051c79fbdf35a98bba4f18a85e7c5e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/darksun.cpp|20|7|V|cpp
	      .def_property("has_dp", &DarkSun::get_has_dp, &DarkSun::set_has_dp)
d2afb671694e69992b84464cd86f7181|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/darksun.cpp|28|1|V|cpp
	      .def_property("eta_si_per_mass", &DarkSun::get_eta_si_per_mass, nullptr)
02b3372eb6dfaac93370cd995af38bb3|file:///Users/loganmorrison/Documents/git_hub/Haliax/haliax/dm_models.cpp|189|1|V|cpp
	      .def_property("solution", &DarkSUN::get_solution, nullptr)
a3786a3fe820de4cfcad0dcc10fadd14|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/CMakeLists.txt|15|19|v|cmake
	darksun
6d4ad26ef7990ea74739110142dbc4c7|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/CMakeLists.txt|10|15|v|cmake
	Project for studying DM particles from a dark SU(N)"
db79304a08f96beb7e699a4005bc3614|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/CMakeLists.txt|2|9|v|cmake
	darksun 
176d5bf2742aad1c3ec4e6471203a363|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/CMakeLists.txt|2|1|V|cmake
	project(FullBoltzmann CXX)
823bfd8ad98cbead28733d58f39cf1a9|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/test/CMakeLists.txt|60|1|V|cmake
	# --------------------------------------------------------------------------
	# test_xi.cpp: Make sure xi is computed correctly
	# --------------------------------------------------------------------------
	add_executable(test_xi test_xi.cpp)
	set_property(TARGET test_xi PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_xi PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_xi PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
	
	# --------------------------------------------------------------------------
	# test_solve_boltzmann.cpp: Make sure rd's are computed correctly
	# --------------------------------------------------------------------------
	add_executable(test_solve_boltzmann test_solve_boltzmann.cpp)
	set_property(TARGET test_solve_boltzmann PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_solve_boltzmann PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_solve_boltzmann PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
	
	# --------------------------------------------------------------------------
	# test_fortran_radau5.cpp: Test the Fortran Radau5 algorithm
	# --------------------------------------------------------------------------
	add_executable(test_fortran_radau5 test_fortran_radau5.cpp)
	set_property(TARGET test_fortran_radau5 PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_fortran_radau5 PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_fortran_radau5 PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
34ac40ed28d28ef18b0f20ab49a6dea1|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|4|20|v|cpp
	::toy_model {
6a698ef0a965efcbbba0c6949d588e53|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|20|1|V|cpp
	  // ========================================================================
ef2481ebe00dd836e4b414d1d8aeb161|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|10|1|V|cpp
	static constexpr size_t IDX_MX = 0;
c07408cfdc4d0b1764a9a61ad96b7c18|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|14|1|V|cpp
	double get_mx(const double *rpar) { return rpar[IDX_MX]; }
b7483421ce045c1c2a87f4b258cd14ef|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|14|1|V|cpp
	double get_mx(const double *rpar) { return rpar[IDX_MX]; }
	double get_c0(const double *rpar) { return rpar[IDX_C0]; }
	double get_c1(const double *rpar) { return rpar[IDX_C1]; }
935cb287be29cc46edda8e7cbd8cf669|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|14|1|V|cpp
	double get_mx(const double *rpar) { return rpar[IDX_MX]; }
	double get_c0(const double *rpar) { return rpar[IDX_C0]; }
	double get_c1(const double *rpar) { return rpar[IDX_C1]; }
	
	void set_mx(double *rpar, double val) { rpar[IDX_MX] = val; }
	void set_c0(double *rpar, double val) { rpar[IDX_C0] = val; }
	void set_c1(double *rpar, double val) { rpar[IDX_C1] = val; }
639e4a6b4c24a6a14995398925af9937|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|34|v|cpp
	rpar[IDX_C0]
3936540d1dc0a9270f06475e00adf798|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|34|v|cpp
	rpar[IDX_MX]
4b58e5edf5f3847e6205f66a75eaf126|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|34|v|cpp
	rpar[IDX_C1]
3c1c37c50af1e07e0bb1118b7361856f|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|10|v|cpp
	get_mx
582ea17734d3c0c4583d6a43decac502|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|10|v|cpp
	get_c0
08d4f178cfe2c9f28be592f397d5b193|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|39|10|v|cpp
	get_c1
64a911f901ffca7c729724f00fc79111|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|8|v|cpp
	set_mx
2208c46f9cfebc74c8e27f277b353356|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|8|v|cpp
	set_c1
7e0c833f5011d16cfb7fe73d97326182|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|8|v|cpp
	set_c0
57d71252efdd6959eb8d32c9fad0d277|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|40|v|cpp
	[IDX_MX]
784d39ee1996e0a8e85bc105c7b041ad|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|40|v|cpp
	[IDX_C0]
98fff901763c68c7366862b158970215|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|43|40|v|cpp
	[IDX_C1]
6dde9bd72eccbf5c1e1556cd3a233f19|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|33|1|V|cpp
	  // ========================================================================
	  // ---- Getters -----------------------------------------------------------
	  // ========================================================================
c5272920c09af40ab4eea693df22dc1a|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|30|18|v|cpp
	pow<3>(1 
daa9ee98a3704f1ecb8e37fd45e6ca29|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|5|10|v|cpp
	<boost/math/special_functions/pow.hpp>
65f6333a2be487fc0f5acabb396ff457|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|5|1|V|cpp
	#include <boost/
04b8c1ca2e87df060829f527278749f7|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|6|1|V|cpp
	#include<boost
3bb5d67ebbce5ffc1521affcda6f7ff4|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|24|42|v|cpp
	, const double *
8c1d6371a9045934b45567cc03cb56fc|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|24|1|V|cpp
	double feq(const double x, const double q) { return exp(-sqrt(x * x + q * q)); }
	
	double gamma_hinv(const double T, const double *rpar) {
	  using boost::math::pow;
	  const double x = get_mx(rpar) / T;
	  return 100.0 * pow<3>(10.0 / x);
	}
	
	double sigmav(const double x, const double q, const double qt,
	              const double *rpar) {
	  using boost::math::pow;
	  const double t = (x * x + q * q) * (x * x + qt * qt);
	  const double c0 = get_c0(rpar);
	  const double c1 = get_c1(rpar);
	  return c0 +
	         c1 * (1.0 - pow<4>(x) / (q * qt * sqrt(t)) * atanh(q * qt / sqrt(t)));
	}
61ec2d45fb189c304d43ac196b681a98|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|57|35|v|cpp
	, const double *rpar
64b3cc1a701ca102783c46f88c47d0cc|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|41|1|V|cpp
	
	class ToyModel {
	private:
	  std::array<double, 3> m_rpar;
	
	public:
	  ToyModel(double mx, double c0, double c1) {
	    m_rpar[0] = mx;
	    m_rpar[1] = c0;
	    m_rpar[2] = c1;
	  }
	
	  double feq(const double x, const double q) {
	    return exp(-sqrt(x * x + q * q));
	  }
	
	  double gamma_hinv(const double T) {
	    using boost::math::pow;
	    const double x = get_mx() / T;
	    return 100.0 * pow<3>(10.0 / x);
	  }
	
	  double sigmav(const double x, const double q, const double qt) {
	    using boost::math::pow;
	    const double t = (x * x + q * q) * (x * x + qt * qt);
	    const double c0 = get_c0();
	    const double c1 = get_c1();
	    return c0 + c1 * (1.0 -
	                      pow<4>(x) / (q * qt * sqrt(t)) * atanh(q * qt / sqrt(t)));
	  }
	
	  // ========================================================================
	  // ---- Getters -----------------------------------------------------------
	  // ========================================================================
	
	  double get_mx() const { return toy_model::get_mx(m_rpar.data()); }
	  double get_c0() const { return toy_model::get_c0(m_rpar.data()); }
	  double get_c1() const { return toy_model::get_c1(m_rpar.data()); }
	
	  // ========================================================================
	  // ---- Setters -----------------------------------------------------------
	  // ========================================================================
	
	  void set_mx(double val) { toy_model::set_mx(m_rpar.data(), val); }
	  void set_c0(double val) { toy_model::set_c0(m_rpar.data(), val); }
	  void set_c1(double val) { toy_model::set_c1(m_rpar.data(), val); }
	};
71f98067fdb57ca3987b61ede259deda|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/standard_model.hpp|1|9|v|cpp
	DARK_SUN_STANDARD_MODEL_HPP
374f07111544094b48d6dc2c30ff5015|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/constants.hpp|1|9|v|cpp
	DARK_SUN
9d0e0ac27de2d0f2dcb5cfae617ff737|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/constants.hpp|14|11|v|cpp
	DARK_SUN_CONSTANTS_HPP
5ec2461df5f55d8ce8e9151bad6cca54|file:///Users/loganmorrison/Documents/coding/rust/projects/full_boltzmann/src/boltz/full.rs|11|1|V|rust
	pub fn gefft(temp: f64) -> f64 {
	    sm_sqrt_gstar(temp) * sm_geff(temp).sqrt() / sm_heff(temp) - 1.0
	}
	
	pub fn hubblet(temp: f64) -> f64 {
	    let h = (4.0 * PI.powi(3) * sm_geff(temp) / 45.0).sqrt() * temp * temp / M_PLANK;
	    h / (1.0 + gefft(temp))
	}
b26207b229246dd126c878502dad4cfe|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|46|27|v|cpp
	->f64
9d6269973f6c703a8768d6b0fdf3e21c|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|46|16|v|cpp
	temp : f64
58908b6dcb8c0515321c6ba6cc792c96|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|48|54|v|cpp
	temp 
31c69e69259124a00167b4ff1293d45d|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/stiff.hpp|205|1|V|cpp
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
d61810714a1b2e49fd138b9445411a5e|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|54|3|v|cpp
	int n, 
795c14c641930c6404223b320816f33f|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|13|3|V|cpp
	  static constexpr std::array<double, 100>
dd6560150c3ee1e2f5f801761245965b|file:///Users/loganmorrison/Documents/git_hub/Haliax/CMakeLists.txt|5|1|V|cmake
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
ca95a47f136bd6febeef6c3db11b46ab|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|7|1|V|cmake
	find_package(GSL REQUIRED)
75e44c63fc79782173a711537bbbe769|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|9|1|V|cmake
	project("stiff" VERSION 0.1.0
	        DESCRIPTION "Collection of numerical and high-energy physics routines for c++"
	        LANGUAGES CXX)
af241990085ff94a5a87d8a114f5303d|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|3|1|V|cmake
	project(stiff)
b045b7be8634f577c7621c126ece74fb|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|4|22|v|cmake
	Collection of numerical and high-energy physics routines for c++"
06e386dac5ea299b813e4acfcc61fc1b|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|9|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
362526e4e6f622ccdca134ad721df8f5|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|17|1|V|cmake
	add_subdirectory(include)
d436eb0fd9de10b54a828ce6435f7e81|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|18|18|v|cmake
	include
6c1b45af5f99e7d36cecba6f60159d91|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|17|1|V|cmake
	add_subdirectory(src)
500755007e362aa8449449c549f12067|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|47|1|V|cmake
	target_link_libraries(test_diffeq_stiff PUBLIC
	        lanre
		GSL::gsl
		GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
8ad2076572b0fe23712a0fd46682c2f2|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|19|23|v|cmake
	test_diffeq_stiff 
b49b88079eac2faca01493cf1e8dcc51|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|20|9|V|cmake
	        lanre
826f45fde716c6fdd22dc31d47b9aaff|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|20|2|V|cmake
		GSL::gsl
f9c70a5cf5dd78bf1bb24a8da062d380|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|20|2|V|cmake
		GSL::gslcblas
705799022ccf0d3ffce3d163265424e1|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|20|9|V|cmake
	        gtest_main
9102bd28281632887a92005342c5f9d2|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|7|1|V|cmake
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(Eigen3 REQUIRED)
62eac9e5b5883aec347024b5cdb682dd|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|41|1|V|cmake
	# --------------------------------------------------------------------------
	# lanre::diffeq
	# --------------------------------------------------------------------------
202e434862b60378619a81415cdda5ac|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|14|3|v|cmake
	::diffeq
438d55ee932aa53709dc70f5e92ff937|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|23|1|V|cmake
	set(CMAKE_MACOSX_RPATH ON)
049518eb4dc1859c7cebbe15876cfd63|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|24|19|v|cmake
	SHARED
c512b612aefa7ead2b7c805849d803f4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|1|1|V|cmake
	set(CMAKE_CXX_STANDARD 11)
	
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	include_directories(${Boost_INCLUDE_DIRS})
	
	# --------------------------------------------------------------------------
	# lanre::diffeq
	# --------------------------------------------------------------------------
	
	# Stiff differential equations (Radau and Rodas)
	add_executable(test_diffeq_stiff test_diffeq_stiff.cpp)
	target_link_libraries(test_diffeq_stiff PUBLIC
	        lanre
		GSL::gsl
		GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	set_target_properties(test_diffeq_stiff PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
	
010b44cefc546a3821af34b1ca6e7316|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/test/CMakeLists.txt|40|1|V|cmake
	# -------------------------------------------------------------------------- # lanre::diffeq
	# --------------------------------------------------------------------------
00d5b0f7cc9e5b139783982539031a46|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/lanre.hpp|14|1|V|cpp
	template <class Type, int n = Eigen::Dynamic>
	using Vector = Eigen::Matrix<Type, n, 1>;
066c2f3e0f7d1f9874c097970875c94d|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/include/stiff/common.hpp|7|1|V|cpp
	typedef :
d55d62892f73b4bc73ceb9e999c47cd8|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/lanre.hpp|20|1|V|cpp
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Matrix = Eigen::Matrix<Type, n, m>;
73fe0d5f1ad91e35d91da97231586b76|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/include/stiff/radau5.hpp|9|1|V|cpp
	class Radau5 {
	private:
	public:
	  Radau5(
	};
8fd3f3eb1b52f8d5c8759d0349167ed1|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/include/stiff/radau5.hpp|12|1|V|cpp
	  virtual size_t mujac() = 0;
a14ba455a9b0c0e97bd85d0c3c64ffb5|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/include/stiff/radau5.hpp|9|37|V|cpp
	template <size_t N> class Jacobian {
	  virtual void operator()(double x, const Vector<double, N> y,
	                          Vector<double, N> f) = 0;
	  virtual size_t mujac() = 0;
	  virtual size_t mljac() = 0;
	};
4a472d96f29fb7e1d26adbf8ac72cae3|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/include/stiff/radau5.hpp|9|1|V|cpp
	template <int N, class Fcn, class Jac, class Mass, class SolOut>
	void radau5(Fcn &fcn, double x, Vector<double, N> y, double xend, double h,
	            double rtol, double atol, int itol, Jac &jac, int ijac, int mljac,
	            int mujac, Mass &mas, int imas, int mlmas, int mumas,
	            SolOut &solout, int iout);
6682a99b7e19742676941340c077991f|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/src/radau5.cpp|1|17|v|cpp
	common.hpp"
7cf8838e0da7241e4845738aca15e707|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|18|1|V|cmake
	        ${PROJECT_SOURCE_DIR}/include
2499ac77ea164de5a8e14b204cee564b|file:///Users/loganmorrison/Documents/git_hub/stiff/stiff/CMakeLists.txt|1|37|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
	
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	# --------------------------------------------------------------------------
	# Construct the stiff library
	# --------------------------------------------------------------------------
	message("include = ${PROJECT_SOURCE_DIR}/include")
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	        ${Boost_INCLUDE_DIRS}
	)
	
	file(GLOB_RECURSE STIFF_SOURCES "src/*.cpp")
	add_library(stiff STATIC ${STIFF_SOURCES})
	target_link_libraries(stiff PUBLIC
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	add_subdirectory(test)
676b81b63bcc811e722551f84a28680f|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|8|1|V|cmake
	add_subdirectory(stiff)
d59f266d3e3c27ee7f2ee9bf69566e2c|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|5|1|V|cpp
	#include <
19ccd83d6eccd755682c19759fc3339d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|14|1|V|cpp
	template <class Func> class Jacobian {
	public:
	  Jacobian(Func jac, size_t ubw, size_t lbw);
	};
e579c7bcf566d910c9fd12d6baf3b3b2|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|12|1|V|cpp
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
a49ada503ae5c26cb3226e788e462495|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|16|23|v|cpp
	int n = Eigen::Dynamic, int m = Eigen::Dynamic
6c27ca5ea2c62c655916d7d6cf91747f|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|16|17|v|cpp
	Type 
a2f2ed4f8ebc2cbb4c21a29dc40ab61d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|16|11|v|cpp
	class
1a4fc2ae03e330f7e21febc6b59aec3d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|15|1|V|cpp
	template <size_t N, class Params>
	using OdeFunc = std::function<void(double, const Vector<double, N>,
	                                   Vector<double, N>, Params)>;
73d5bdce48905e46b64aef9b3ea7ec0d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|18|1|V|cpp
	template <size_t N, class Params>
	using OdeJac = std::function<void(double, const Vector<double, N>,
	                                  Matrix<double, N>, Params)>;
6e1044c99cfe81fbb2ab926615af1a88|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|22|10|v|cpp
	Jac 
03b9f77d4324894200cec3e82e7fec54|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|15|21|v|cpp
	class Params
853ef25eea29d2812c8428ee68128fc8|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|18|11|v|cpp
	size_t N, 
5e27d38053e7b176cc2bf638379b1b2b|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|29|15|v|cpp
	OdeFunc<Params, N>
af8b2776aee8470dc29e1333c34adb3b|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|27|1|V|cpp
	OdeFunc<Params, N> func;
00d0b4f2d7dcdaaef835b97cf5d1e0df|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|28|4|v|cpp
	Func
687bef2b0f93e341dea8b24c3ca6c856|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|32|1|V|cpp
	  OdeFunction(OdeFunc<Params, N> func, OdeJac<Params, N> jac,
	              OdeMass<Params, N> mass)
	      : p_func(func), p_jac(jac), p_mass(mass) {}
4a4c5a527c570f8abe7aa662d9f7c849|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|32|38|v|cpp
	, OdeJac<Params, N> jac,
	              OdeMass<Params, N> mass
40766ff50dab55cb25598f0cf00951d1|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|35|15|v|cpp
	OdeMass<Params, N> mass
e08be936179890ecdf95ae68feff41b5|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|36|38|v|cpp
	, OdeJac<Params, N> jac,
0afda6b658073eec23a1be3dd88fa4c5|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|22|36|v|cpp
	double, const Vector<double, N>,
22fe2dbb374783601802787da1e6f5d7|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|24|1|V|cpp
	templ
d6d57cac0703e20dc4f47ddac49fec39|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|25|1|V|cpp
	template <class Params, int N = Eigen::Dynamic> class OdeFunction {
ee837ed20d93e6d9b7ddad95937ff657|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|31|1|V|cpp
	private:
	  OdeFunc<Params, N> p_func;
	  OdeJac<Params, N> *p_jac;
638d0c83a26faf81471c681f2e5409dc|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|29|1|V|cpp
	  OdeFunc<Params, N> p_func;
6195763ec57cbcf49772dbe1833956c6|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|22|17|v|cpp
	std::function<void(Matrix<double, N, N> &, Params &)>
4bf26395801dcda2362105efd320c5db|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|27|3|v|cpp
	size_t
a0d876e3cb486e417119dc70719e5503|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|28|3|v|cpp
	ze_t
9c5eaaf3f83209d4d52902507e50fea6|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|35|1|V|cpp
	template <class Params, int N = Eigen::Dynamic> class OdeFunction {
	private:
	  OdeFuncType<Params, N> p_func;
	  OdeJacType<Params, N> *p_jac;
	  OdeMassType<Params, N> *p_mass;
	
	public:
	  OdeFunction(OdeFuncType<Params, N> func)
	      : p_func(func), p_jac(nullptr), p_mass(nullptr) {}
	  OdeFunction(OdeFuncType<Params, N> func, OdeJacType<Params, N> jac)
	      : p_func(func), p_jac(jac), p_mass(nullptr) {}
	  OdeFunction(OdeFuncType<Params, N> func, OdeMassTyp<Params, N> mass)
	      : p_func(func), p_jac(nullptr), p_mass(mass) {}
	  OdeFunction(OdeFunc<Params, N> func, OdeJac<Params, N> jac,
	              OdeMass<Params, N> mass)
	      : p_func(func), p_jac(jac), p_mass(mass) {}
	
	  void operator()(double x, const Vector<double, N> &y, Vector<double, N> &dy,
	                  Params &params) {
	    p_func(x, y, dy, params);
	  }
	
	  void jacobian(double x, const Vector<double, N> &y, Matrix<double, N, N> &j,
	                Params &params) {
	    if (p_jac != nullptr) {
	      p_jac(x, y, j, params);
	    } else {
	      // Numerical jacobian
	    }
	  }
	};
47f24555b6f742df9e4bacf1597b22f6|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|24|1|V|cpp
	template <class Params, int N = Eigen::Dynamic> class OdeJacobian {
	private:
	  OdeJacType<Params, N> p_jac;
	  int p_ubw;
	  int p_lbw;
	
	public:
	  OdeJacobian(OdeJacType<Params, N> jac, int ubw = N, int lbw = N)
	      : p_jac(jac), p_ubw(ubw), p_lbw(lbw) {}
	};
3971f21b5b3816032e12e289330ee4b5|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|38|3|V|cpp
	  OdcType<Params, N> p_jac;
d30984a05f90925fbfad4bfbd9d3a546|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|43|17|v|cpp
	OdeJacType
972ee3c699a61f059fd1972ffb5c785f|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|43|17|v|cpp
	<Params, 
8aa73995cd4dc0cdc60e4114c3bac749|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|36|11|v|cpp
	class Params, 
f9e431a0eda26b8619fb6becc09b98e8|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|27|1|V|cpp
	  int p_ubw;
	  int p_lbw;
fb80d3310a0580a52ddd4232852f27cf|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|16|1|V|cpp
	template <class Params, int N = Eigen::Dynamic>
	using OdeFuncType = std::function<void(double, const Vector<double, N> &,
	                                       Vector<double, N> &, Params &)>;
d6ea5b02069dec3999bd1d55d2389af2|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|11|1|V|cpp
	template <class Params, int N = Eigen::Dynamic>
	using OdeJacType = std::function<void(double, const Vector<double, N> &,
	                                      Matrix<double, N, N> &, Params &)>;
a1eecd19d854711b9b6880925a0d61a0|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|15|10|v|cpp
	JacType 
fe777960e5260f00cfc7ecaeba787f83|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|14|1|V|cpp
	template <class Params, int N = Eigen::Dynamic>
	using OdeMassType = std::function<void(double, const Vector<double, N> &,
	                                       Matrix<double, N, N> &, Params &)>;
f53df0293e169f562bc1d9a20e1d2589|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|17|39|v|cpp
	Matrix
2a46e930fb7c9876137bc0d663621145|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|19|16|v|cpp
	, class Fcn, class Jac, class Mass, class SolOut
e554580e0336c688839ef4ab7546bacc|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|20|13|v|cpp
	Fcn 
7cb455041ca75f61ff338c42ef05113b|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|15|30|v|cpp
	 = Eigen::Dynamic
67e92c8765a9bc7fb2d335c459de9eb5|file:///Users/loganmorrison/Documents/git_hub/stiff/src/radau5.cpp|26|13|v|cpp
	work
ced58486447f9555f0692e75ab6714be|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|8|1|V|cpp
	template <int Ndim, int N>
	int dec(Matrix<double, Ndim, N> a, Vector<double, N> ip);
e5186a45e4c6d0a0ad4a86c165c16c29|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|8|1|V|cpp
	template <int Ndim, int N>
	int dec(Matrix<double, Ndim, N> &a, Vector<double, N> &ip);
	
	template <int Ndim, int N>
	int sol(const Matrix<double, Ndim, N> &a, Vector<double, N> &b,
	        const Vector<double, N> &ip);
bb3c0bd9e2c6ff2074ee386bf2f93850|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|8|1|V|cpp
	/**
	 * Perform an LU triangularization on the real matrix `a` using Gaussian
	 * elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param ip: Vector to store the pivots.
	 */
c1a7c962332d3afcdb4b85e47e03f9b9|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|18|1|V|cpp
	/**
	 * Solve the linear system Ax = b. The matrix `a` and the vector `ip` should be
	 * the output of `dec` (i.e., `a` should furnish the upper and lower triangular
	 * matrices of its decomposition and `ip` should hold the pivots.)
	 *
	 * @param a: Matrix holding the LU decompositions.
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
b62cc2f8836847ab02c492dc16d1724e|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|36|1|V|cpp
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
1bed897611bef88a1af6ada088a988f8|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|31|1|V|cpp
	/**
	 * Perform an LU triangularization on the real Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int dech(Matrix<double, Ndim, N> &a, int lb, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a real Hessenberg matrix. The matrix `a`
	 * and the vector `ip` should be the output of `dec` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix holding the LU decompositions.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solh(const Matrix<double, Ndim, N> &a, int lb, Vector<double, N> &b,
	          const Vector<double, N> &ip);
f22e728b362d4f6618331e5632226c97|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|67|10|v|cpp
	Matrix<double, Ndim, N> &a
3a215df82cffbe73af4099c214a5ea22|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|81|11|v|cpp
	const Matrix<double, Ndim, N> &a
4560985e6b9e5784357f4278989e12d3|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|81|79|v|cpp
	, int lb
95631adbe8520fffacd40459d4288bdb|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|82|11|v|cpp
	Vector<double, N> &b,
4bca24304861acde5770fdbe3cc2503b|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|70|41|v|cpp
	real
442e315bffc3c3cd2d5b17c1680596e5|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|70|49|v|cpp
	Hessenberg 
44ed9c4ce6e198d2ad866ac820082739|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|75|1|V|cpp
	 * @param a: Matrix holding the LU decompositions.
c425bed12f4f4d3a4e9d7bb0d89ded8e|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|77|1|V|cpp
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
742d80a63af975142cda2e3214d28f50|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|57|1|V|cpp
	/**
	 * Perform an LU triangularization on the real Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decc(Matrix<double, Ndim, N> &ar, Matrix<double, Ndim, N> &ai,
	         Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solc(const Matrix<double, Ndim, N> &ar, const Matrix<double, Ndim, N> &ai,
	          Vector<double, N> &br, Vector<double, N> &bi,
	          const Vector<double, N> &ip);
b8162345a23172bbabc5efc34dba339c|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|58|43|v|cpp
	real Hessenberg
b0a9b180f315d8fb32ebe4a52f442029|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|61|1|V|cpp
	 * @param ar: Real part of the matrix to triangularize.
7f80fcc452c2f1ed2bb51b39d0864df1|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|62|15|v|cpp
	Real
d7b903340e08268b32428611e4cbac81|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|61|1|V|cpp
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
f6516bf526693d2d49eed2ad08084b78|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|93|1|V|cpp
	 * @param a: Matrix to triangularize.
5dbed51e3550ae80b0fb601ef4e4cb2a|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|57|1|V|cpp
	/**
	 * Perform an LU triangularization on the complex matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decc(Matrix<double, Ndim, N> &ar, Matrix<double, Ndim, N> &ai,
	         Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solc(const Matrix<double, Ndim, N> &ar, const Matrix<double, Ndim, N> &ai,
	          Vector<double, N> &br, Vector<double, N> &bi,
	          const Vector<double, N> &ip);
4b8bafdec076f25030c303049f4e6586|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|124|50|v|cpp
	complex
1127866f26182578607433179dfc7f7d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|128|2|V|cpp
	 * @param ai: Imag part of the matrix to triangularize.
d85fe0b0bf326036f2a0db9f0d64960f|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|133|38|v|cpp
	Matrix<double, Ndim, N> &ai,
b75fcdd2d72d9e000beab48622402d93|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|128|15|v|cpp
	Lower
86f048f4508831587ab6efbeefc599ed|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|126|14|v|cpp
	Real part of the m
85b195aa3aab1e9e863a7e407c5807f0|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|126|1|V|cpp
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
196fa3603b63a41d4db4fe8429d76d8d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|140|1|V|cpp
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
7e23ad50232df4a5250b6272a539faa3|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|143|15|v|cpp
	Imag part of the 
bceef2c009328e0b0bcf23751dcca82f|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|147|45|v|cpp
	const Matrix<double, Ndim, N> &ai,
a08da6bc4d4f214d9f39395da393b138|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|148|31|v|cpp
	r, Vector<double, N> &bi,
5fecbd3840652b6025845410e274ace2|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|122|1|V|cpp
	/**
	 * Perform an LU triangularization on the banded real matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decb(Matrix<double, Ndim, N> &a, int ml, int mu, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param bi: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solb(const Matrix<double, Ndim, N> &a, int ml, int mu,
	          Vector<double, N> &b, const Vector<double, N> &ip);
aef660fb7728c52b3d2c0e8c9a6791ee|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|161|10|v|cpp
	Matrix<double, Ndim, N> &ar
518aef80c95c9b4fe1ca6aee2222a124|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|154|1|V|cpp
	 * @param ar: Matrix to triangularize (real part).
	 * @param ai: Matrix to triangularize (imag part).
d41aa7a5bdec878d9168a761aee8d449|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|174|1|V|cpp
	 * @param bi: RHS of the linear system Ax = b. On output, it holds the solution.
3b240dd2b43754a36bf554ee535bf370|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|179|11|v|cpp
	const Matrix<double, Ndim, N> &a,
2631c30d5025a4e984565b9b11d34509|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|174|22|v|cpp
	the linear system
8c863c8035bdc2b80aaa133b116647fc|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/decsol.hpp|8|1|V|cpp
	/**
	 * Perform an LU triangularization on the real matrix `a` using Gaussian
	 * elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int dec(Matrix<double, Ndim, N> &a, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b. The matrix `a` and the vector `ip` should be
	 * the output of `dec` (i.e., `a` should furnish the upper and lower triangular
	 * matrices of its decomposition and `ip` should hold the pivots.)
	 *
	 * @param a: Matrix holding the LU decompositions.
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void sol(const Matrix<double, Ndim, N> &a, Vector<double, N> &b,
	         const Vector<double, N> &ip);
	
	/**
	 * Perform an LU triangularization on the real Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int dech(Matrix<double, Ndim, N> &a, int lb, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a real Hessenberg matrix. The matrix `a`
	 * and the vector `ip` should be the output of `dech` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix holding the LU decompositions.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solh(const Matrix<double, Ndim, N> &a, int lb, Vector<double, N> &b,
	          const Vector<double, N> &ip);
	
	/**
	 * Perform an LU triangularization on the complex matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decc(Matrix<double, Ndim, N> &ar, Matrix<double, Ndim, N> &ai,
	         Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solc(const Matrix<double, Ndim, N> &ar, const Matrix<double, Ndim, N> &ai,
	          Vector<double, N> &br, Vector<double, N> &bi,
	          const Vector<double, N> &ip);
	
	/**
	 * Perform an LU triangularization on the complex Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int dechc(Matrix<double, Ndim, N> &ar, Matrix<double, Ndim, N> &ai, int lb,
	          Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex Hessenberg matrix. The matrix
	 * `a` and the vector `ip` should be the output of `decc` (i.e., `a` should
	 * furnish the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solhc(const Matrix<double, Ndim, N> &ar, const Matrix<double, Ndim, N> &ai,
	           int lb, Vector<double, N> &br, Vector<double, N> &bi,
	           const Vector<double, N> &ip);
	
	/**
	 * Perform an LU triangularization on the banded real matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decb(Matrix<double, Ndim, N> &a, int ml, int mu, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solb(const Matrix<double, Ndim, N> &a, int ml, int mu,
	          Vector<double, N> &b, const Vector<double, N> &ip);
	
	/**
	 * Perform an LU triangularization on the banded complex matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Matrix to triangularize (real part).
	 * @param ai: Matrix to triangularize (imag part).
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
	template <int Ndim, int N>
	int decbc(Matrix<double, Ndim, N> &ar, Matrix<double, Ndim, N> &ai, int ml,
	          int mu, Vector<double, N> &ip);
	
	/**
	 * Solve the linear system Ax = b for a complex banded matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decbc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix to triangularize (real part).
	 * @param ai: Matrix to triangularize (imag part).
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param br: RHS of Ax = b (real part). On output, it holds the solution.
	 * @param bi: RHS of Ax = b (imag part). On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
	template <int Ndim, int N>
	void solbc(const Matrix<double, Ndim, N> &ar, const Matrix<double, Ndim, N> &ai,
	           int ml, int mu, Vector<double, N> &br, Vector<double, N> &bi,
	           const Vector<double, N> &ip);
0b498ab7b2abbdc6790e1f7109032bc1|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|13|1|V|cpp
	/**
	 * Perform an LU triangularization on the real Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
8fcde1bb7681a63f253db858480de856|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|16|1|V|cpp
	/**
	 * Solve the linear system Ax = b for a real Hessenberg matrix. The matrix `a`
	 * and the vector `ip` should be the output of `dech` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix holding the LU decompositions.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
c1b2636c4cd6ab8a609c0b508e6e6287|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|20|1|V|cpp
	/**
	 * Perform an LU triangularization on the complex matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
b01c0be519438755e3436dbdf999b4a4|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|24|1|V|cpp
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
a47971338389cb81282f46586eb7b941|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|29|1|V|cpp
	/**
	 * Perform an LU triangularization on the complex Hessenberg matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Real part of the matrix to triangularize.
	 * @param ai: Imag part of the matrix to triangularize.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
594b0668a5e6a6d0eeb3b815a409f28c|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|33|1|V|cpp
	/**
	 * Solve the linear system Ax = b for a complex Hessenberg matrix. The matrix
	 * `a` and the vector `ip` should be the output of `decc` (i.e., `a` should
	 * furnish the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix holding the real part of the LU decompositions.
	 * @param ai: Matrix holding the imag part of the LU decompositions.
	 * @param lb: Lower bandwidth of `a` (diagonal not counted.)
	 * @param br: Real part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param bi: Imag part of the RHS of the linear system Ax = b. On output, it
	 * holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
1196822c53645a07cae8863259e443a8|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|38|1|V|cpp
	/**
	 * Perform an LU triangularization on the banded real matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
0b7d1bdf5cbda0ebf07f5946498dd006|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|41|1|V|cpp
	/**
	 * Solve the linear system Ax = b for a complex matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param a: Matrix to triangularize.
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param b: RHS of the linear system Ax = b. On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
36a984b6211ae2aac4fdeeaceac1c93d|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|45|1|V|cpp
	/**
	 * Perform an LU triangularization on the banded complex matrix `a` using
	 * Gaussian elimination.
	 *
	 * @param ar: Matrix to triangularize (real part).
	 * @param ai: Matrix to triangularize (imag part).
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param ip: Vector to store the pivots.
	 */
ef0120c83683a81bdab140c78f5e335f|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|49|1|V|cpp
	/**
	 * Solve the linear system Ax = b for a complex banded matrix. The matrix `a`
	 * and the vector `ip` should be the output of `decbc` (i.e., `a` should furnish
	 * the upper and lower triangular matrices of its decomposition and `ip`
	 * should hold the pivots.)
	 *
	 * @param ar: Matrix to triangularize (real part).
	 * @param ai: Matrix to triangularize (imag part).
	 * @param ml: Lower bandwidth of `a` (diagonal not counted.)
	 * @param mu: Upper bandwidth of `a` (diagonal not counted.)
	 * @param br: RHS of Ax = b (real part). On output, it holds the solution.
	 * @param bi: RHS of Ax = b (imag part). On output, it holds the solution.
	 * @param ip: Vector holding the pivots of the LU decomposition.
	 */
c8bb8e17c1c9c2751ed55e6bee89c06f|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|6|1|V|cpp
	// ========================================================================== 
75ec330c53b92eca5c71a5de76d3782c|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|6|1|V|cpp
	// ========================================================================== 
	// ---- Real Matrices -------------------------------------------------------
	// ========================================================================== 
f09582c8d8f4a5713d52c7b1e9a8b5eb|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|18|1|V|cpp
	// ========================================================================== 
	// ---- Real Hessenberg Matrices --------------------------------------------
	// ========================================================================== 
da009f2198c5a6e44656c91ddcecf341|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|31|17|v|cpp
	Hessenberg
6a477a4b184666443968cf4bd970894d|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|30|1|V|cpp
	// ========================================================================== 
	// ---- Complex Matrices ----------------------------------------------------
	// ========================================================================== 
67c06b5ce1d86ec2f976573aaffe4de6|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|44|1|V|cpp
	// ========================================================================== 
	// ---- Complex Hessenberg Matrices -----------------------------------------
	// ========================================================================== 
8f6a5be51e5bfba3f6b44223cc9ff4b0|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|58|1|V|cpp
	// ========================================================================== 
	// ---- Real Banded Matrices ------------------------------------------------
	// ========================================================================== 
9e721dca9dabcc72adb7d7931a3cd3a4|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|70|1|V|cpp
	// ========================================================================== 
	// ---- Complex Banded Matrices ---------------------------------------------
	// ========================================================================== 
aebcf5a11c18997069db612f15536c35|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|30|1|V|fortran
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	        end do
	        ip(k) = m
	        t = a(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        a(m, k) = a(k, k)
	        a(k, k) = t
	        20     continue
	        if (t == 0.d0) go to 80
	        t = 1.d0 / t
	        do i = kp1, n
	            a(i, k) = -a(i, k) * t
	        end do
	        do j = kp1, n
	            t = a(m, j)
	            a(m, j) = a(k, j)
	            a(k, j) = t
	            if (t == 0.d0) go to 45
	            do i = kp1, n
	                a(i, j) = a(i, j) + a(i, k) * t
	            end do
	            45       continue
	        end do
	    end do
e5a3f93b7364e6770a3caf5a80e89d70|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|20|1|V|cpp
	  for (k = 1; k <= nm1; k++){
	
	  }
468644c39f05189ee2e6d62b77fdef66|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|20|5|V|cpp
	    nm1 = n - 1
cf7d2f545caed62eb0dc73f1a88a7101|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|48|1|V|cpp
	    end do
6d1b72631ed0af16a10a41a5c2f45468|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|25|9|v|cpp
	end do
2ad2d20ad85e34812a99d4eb6d244fa8|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|38|1|V|cpp
	        end do
a1dce4e2e0f4dcc1ab2ed5f34d86d01e|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|47|1|V|cpp
	            end do
75a3aef3e2e8f995eafa88ef11116057|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|87|1|V|fortran
	    if (n == 1) go to 50
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = ip(k)
	        t = b(m)
	        b(m) = b(k)
	        b(k) = t
	        do i = kp1, n
	            b(i) = b(i) + a(i, k) * t
	        end do
	    end do
	    do kb = 1, nm1
	        km1 = n - kb
	        k = km1 + 1
	        b(k) = b(k) / a(k, k)
	        t = -b(k)
	        do i = 1, km1
	            b(i) = b(i) + a(i, k) * t
	        end do
	    end do
	    50   b(1) = b(1) / a(1, 1)
	    return
a1a1fea9795c2801158b1403a636f3a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|72|1|V|fortran
	    integer n, ndim, ip, nm1, k, kp1, m, i, kb, km1
f6e8e47ca5017f00ec94ee05c4ded8fd|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|73|5|v|cpp
	integer 
e6062f1a6e1904c5ad0719d0e075cb14|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|73|9|v|cpp
	n, ndim, ip, 
7d8e86bedc323d676242f6a0676cb7ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|143|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        na = min0(n, lb + k)
	        do i = kp1, na
	            if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	        end do
	        ip(k) = m
	        t = a(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        a(m, k) = a(k, k)
	        a(k, k) = t
	        20     continue
	        if (t == 0.d0) go to 80
	        t = 1.d0 / t
	        do i = kp1, na
	            a(i, k) = -a(i, k) * t
	        end do
	        do j = kp1, n
	            t = a(m, j)
	            a(m, j) = a(k, j)
	            a(k, j) = t
	            if (t == 0.d0) go to 45
	            do i = kp1, na
	                a(i, j) = a(i, j) + a(i, k) * t
	            end do
	            45       continue
	        end do
	    end do
	    70   k = n
	    if (a(n, n) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
7bedc22c5d06156e6ed69fa89912a5cd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|116|1|V|fortran
	    integer n, ndim, ip, ier, nm1, k, kp1, m, i, j, lb, na
	    double precision a, t
b00c73908a2c8b0a3cdd540cef69f665|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|112|12|v|cpp
	precision a, 
14b271641fdcfd87f65da78b2364a11d|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|11|1|V|cpp
	#define FDO(var, start, end) for (var = start; var <= end; var++)
640c51af97ace60e25f53847bab5d355|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|12|16|v|cpp
	var, start, end
861fb560b1ca3ae8e1d9a944cc557fdc|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|12|18|v|cpp
	for (var = start; var <= end; var++)
3691671f0ca6cc6b455266a436fb68d4|file:///Users/loganmorrison/Documents/git_hub/stiff/include/stiff/common.hpp|11|1|V|cpp
	#define FENDDO() }
e4dd95de075be1f3b9630fe8fb63fd02|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|114|1|V|cpp
	  ier = 0; ip(N) = 1;
	  if (N == 1)
	    goto _70;
	  nm1 = N - 1;
	  FDO(k, 1, nm1)
	  kp1 = k + 1;
	  m = k;
	  na = fmin(N, lb + k);
	  for(i=kp1; i<= na; i++)
	  if (fabs(a(i, k)) > dabs(a(m, k)))
	    m = i;
	  FENDDO()
	  ip(k) = m;
	  t = a(m, k);
	  if (m == k)
	    go to 20;
	  ip(n) = -ip(n);
	  a(m, k) = a(k, k);
	  a(k, k) = t;
	  20 continue;
	  if (t == 0.d0)
	    go to 80;
	  t = 1.d0 / t;
	  do
	    i = kp1, na a(i, k) = -a(i, k) * t;
	  end do do j = kp1, n t = a(m, j);
	  a(m, j) = a(k, j);
	  a(k, j) = t;
	  if (t == 0.d0)
	    go to 45;
	  do
	    i = kp1, na a(i, j) = a(i, j) + a(i, k) * t;
	  end do 45 continue;
	  end do end do 70 k = n;
	  if (a(n, n) == 0.d0)
	    go to 80;
	  return;
	  80 ier = k;
	  ip(n) = 0;
	  return;
dd9565cc483e16fe09ff175032ae3aed|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|205|1|V|fortran
	    if (n == 1) go to 50
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = ip(k)
	        t = b(m)
	        b(m) = b(k)
	        b(k) = t
	        na = min0(n, lb + k)
	        do i = kp1, na
	            b(i) = b(i) + a(i, k) * t
	        end do
	    end do
	    do kb = 1, nm1
	        km1 = n - kb
	        k = km1 + 1
	        b(k) = b(k) / a(k, k)
	        t = -b(k)
	        do i = 1, km1
	            b(i) = b(i) + a(i, k) * t
	        end do
	    end do
	    50   b(1) = b(1) / a(1, 1)
	    return
5f0a76f195cb3929e5fe73da6eef7670|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|189|1|V|fortran
	    integer n, ndim, ip, nm1, k, kp1, m, i, kb, km1, lb, na
06360937fd32496c340d1a78af22d467|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|170|5|v|cpp
	ndim
d916c18863878ce667ccfd6f0d76f78c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|235|1|V|fortran
	    integer n, ndim, ip, ier, nm1, k, kp1, m, i, j
	    dimension ar(ndim, n), ai(ndim, n), ip(n)
	    !-----------------------------------------------------------------------
	    !  matrix triangularization by gaussian elimination
	    !  ------ modification for complex matrices --------
	    !  input..
	    !     n = order of matrix.
	    !     ndim = declared dimension of arrays  ar and ai .
	    !     (ar, ai) = matrix to be triangularized.
	    !  output..
	    !     ar(i,j), i.le.j = upper triangular factor, u ; real part.
	    !     ai(i,j), i.le.j = upper triangular factor, u ; imaginary part.
	    !     ar(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	    !                                                    real part.
	    !     ai(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	    !                                                    imaginary part.
	    !     ip(k), k.lt.n = index of k-th pivot row.
	    !     ip(n) = (-1)**(number of interchanges) or o .
	    !     ier = 0 if matrix a is nonsingular, or k if found to be
	    !           singular at stage k.
	    !  use  sol  to obtain solution of linear system.
	    !  if ip(n)=o, a is singular, sol will divide by zero.
	    !
	    !  reference..
	    !     c. b. moler, algorithm 423, linear equation solver,
	    !     c.a.c.m. 15 (1972), p. 274.
	    !-----------------------------------------------------------------------
	    ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(ar(i, k)) + dabs(ai(i, k)) >&
	                    dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	        end do
	        ip(k) = m
	        tr = ar(m, k)
	        ti = ai(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        ar(m, k) = ar(k, k)
	        ai(m, k) = ai(k, k)
	        ar(k, k) = tr
	        ai(k, k) = ti
	        20     continue
	        if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	        den = tr * tr + ti * ti
	        tr = tr / den
	        ti = -ti / den
	        do i = kp1, n
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            ar(i, k) = -prodr
	            ai(i, k) = -prodi
	        end do
	        do j = kp1, n
	            tr = ar(m, j)
	            ti = ai(m, j)
	            ar(m, j) = ar(k, j)
	            ai(m, j) = ai(k, j)
	            ar(k, j) = tr
	            ai(k, j) = ti
	            if (dabs(tr) + dabs(ti) == 0.d0) go to 48
	            if (ti == 0.d0) then
	                do i = kp1, n
	                    prodr = ar(i, k) * tr
	                    prodi = ai(i, k) * tr
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            if (tr == 0.d0) then
	                do i = kp1, n
	                    prodr = -ai(i, k) * ti
	                    prodi = ar(i, k) * ti
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            do i = kp1, n
	                prodr = ar(i, k) * tr - ai(i, k) * ti
	                prodi = ai(i, k) * tr + ar(i, k) * ti
	                ar(i, j) = ar(i, j) + prodr
	                ai(i, j) = ai(i, j) + prodi
	            end do
	            48       continue
	        end do
	    end do
	    70   k = n
	    if (dabs(ar(n, n)) + dabs(ai(n, n)) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
212ddd4951fc7ef581ff066a84ecdf4e|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|209|5|v|cpp
	dimension 
769b3826a7cbcdf6bdecd0d4979ca220|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|209|1|V|cpp
	    ar(ndim, n), ai(ndim, n), ip(n)
083238a40af12bfe9b2dc535f6b44461|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|209|1|V|cpp
	    !-----------------------------------------------------------------------
	    !  matrix triangularization by gaussian elimination
	    !  ------ modification for complex matrices --------
	    !  input..
	    !     n = order of matrix.
	    !     ndim = declared dimension of arrays  ar and ai .
	    !     (ar, ai) = matrix to be triangularized.
	    !  output..
	    !     ar(i,j), i.le.j = upper triangular factor, u ; real part.
	    !     ai(i,j), i.le.j = upper triangular factor, u ; imaginary part.
	    !     ar(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	    !                                                    real part.
	    !     ai(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	    !                                                    imaginary part.
	    !     ip(k), k.lt.n = index of k-th pivot row.
	    !     ip(n) = (-1)**(number of interchanges) or o .
	    !     ier = 0 if matrix a is nonsingular, or k if found to be
	    !           singular at stage k.
	    !  use  sol  to obtain solution of linear system.
	    !  if ip(n)=o, a is singular, sol will divide by zero.
	    !
	    !  reference..
	    !     c. b. moler, algorithm 423, linear equation solver,
	    !     c.a.c.m. 15 (1972), p. 274.
	    !-----------------------------------------------------------------------
b7f7d44aff6c00519159f2e6e0f39b97|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|209|5|V|cpp
	    ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(ar(i, k)) + dabs(ai(i, k)) >&
	                    dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	        end do
	        ip(k) = m
	        tr = ar(m, k)
	        ti = ai(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        ar(m, k) = ar(k, k)
	        ai(m, k) = ai(k, k)
	        ar(k, k) = tr
	        ai(k, k) = ti
	        20     continue
	        if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	        den = tr * tr + ti * ti
	        tr = tr / den
	        ti = -ti / den
0e5243d9965540f62aac19a985f3f33e|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|249|28|v|cpp
	then
28683033cc7f22c25969fcf5eeaaaf00|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|257|1|V|cpp
	            end if
57d47609e1dd28ee1ff5c014bc3e928c|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|255|1|V|cpp
	                end do
6aac153de52acb58fb7a41009ed5a93f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|355|1|V|fortran
	    if (n == 1) go to 50
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = ip(k)
	        tr = br(m)
	        ti = bi(m)
	        br(m) = br(k)
	        bi(m) = bi(k)
	        br(k) = tr
	        bi(k) = ti
	        do i = kp1, n
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(i) = br(i) + prodr
	            bi(i) = bi(i) + prodi
	        end do
	    end do
	    do kb = 1, nm1
	        km1 = n - kb
	        k = km1 + 1
	        den = ar(k, k) * ar(k, k) + ai(k, k) * ai(k, k)
	        prodr = br(k) * ar(k, k) + bi(k) * ai(k, k)
	        prodi = bi(k) * ar(k, k) - br(k) * ai(k, k)
	        br(k) = prodr / den
	        bi(k) = prodi / den
	        tr = -br(k)
	        ti = -bi(k)
	        do i = 1, km1
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(i) = br(i) + prodr
	            bi(i) = bi(i) + prodi
	        end do
	    end do
	    50     continue
	    den = ar(1, 1) * ar(1, 1) + ai(1, 1) * ai(1, 1)
	    prodr = br(1) * ar(1, 1) + bi(1) * ai(1, 1)
	    prodi = bi(1) * ar(1, 1) - br(1) * ai(1, 1)
	    br(1) = prodr / den
	    bi(1) = prodi / den
	    return
03bc08e0278de43ee6fe95d1c5ab2d86|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|341|1|V|fortran
	    integer n, ndim, ip, nm1, k, kp1, m, i, kb, km1
	    dimension ar(ndim, n), ai(ndim, n), br(n), bi(n), ip(n)
e25b9faad36ecf18cae43676236acd4a|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|298|1|V|cpp
	    dimension ar(ndim, n), ai(ndim, n), br(n), bi(n), ip(n)
c8577bcafd3e3bde113847aba0758edc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|432|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    if (lb == 0) go to 70
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        na = min0(n, lb + k)
	        do i = kp1, na
	            if (dabs(ar(i, k)) + dabs(ai(i, k)) >&
	                    dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	        end do
	        ip(k) = m
	        tr = ar(m, k)
	        ti = ai(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        ar(m, k) = ar(k, k)
	        ai(m, k) = ai(k, k)
	        ar(k, k) = tr
	        ai(k, k) = ti
	        20     continue
	        if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	        den = tr * tr + ti * ti
	        tr = tr / den
	        ti = -ti / den
	        do i = kp1, na
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            ar(i, k) = -prodr
	            ai(i, k) = -prodi
	        end do
	        do j = kp1, n
	            tr = ar(m, j)
	            ti = ai(m, j)
	            ar(m, j) = ar(k, j)
	            ai(m, j) = ai(k, j)
	            ar(k, j) = tr
	            ai(k, j) = ti
	            if (dabs(tr) + dabs(ti) == 0.d0) go to 48
	            if (ti == 0.d0) then
	                do i = kp1, na
	                    prodr = ar(i, k) * tr
	                    prodi = ai(i, k) * tr
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            if (tr == 0.d0) then
	                do i = kp1, na
	                    prodr = -ai(i, k) * ti
	                    prodi = ar(i, k) * ti
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            do i = kp1, na
	                prodr = ar(i, k) * tr - ai(i, k) * ti
	                prodi = ai(i, k) * tr + ar(i, k) * ti
	                ar(i, j) = ar(i, j) + prodr
	                ai(i, j) = ai(i, j) + prodi
	            end do
	            48       continue
	        end do
	    end do
	    70   k = n
	    if (dabs(ar(n, n)) + dabs(ai(n, n)) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
a36bc16c73e43d187bfe4e0c7439f6f7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|528|1|V|fortran
	    if (n == 1) go to 50
	    nm1 = n - 1
	    if (lb == 0) go to 25
	    do k = 1, nm1
	        kp1 = k + 1
	        m = ip(k)
	        tr = br(m)
	        ti = bi(m)
	        br(m) = br(k)
	        bi(m) = bi(k)
	        br(k) = tr
	        bi(k) = ti
	        do i = kp1, min0(n, lb + k)
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(i) = br(i) + prodr
	            bi(i) = bi(i) + prodi
	        end do
	    end do
	    25     continue
	    do kb = 1, nm1
	        km1 = n - kb
	        k = km1 + 1
	        den = ar(k, k) * ar(k, k) + ai(k, k) * ai(k, k)
	        prodr = br(k) * ar(k, k) + bi(k) * ai(k, k)
	        prodi = bi(k) * ar(k, k) - br(k) * ai(k, k)
	        br(k) = prodr / den
	        bi(k) = prodi / den
	        tr = -br(k)
	        ti = -bi(k)
	        do i = 1, km1
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(i) = br(i) + prodr
	            bi(i) = bi(i) + prodi
	        end do
	    end do
	    50     continue
	    den = ar(1, 1) * ar(1, 1) + ai(1, 1) * ai(1, 1)
	    prodr = br(1) * ar(1, 1) + bi(1) * ai(1, 1)
	    prodi = bi(1) * ar(1, 1) - br(1) * ai(1, 1)
	    br(1) = prodr / den
	    bi(1) = prodi / den
	    return
5aa1957152699402b63188fd81ecf9e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|606|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    md = ml + mu + 1
	    md1 = md + 1
	    ju = 0
	    if (ml == 0) go to 70
	    if (n == 1) go to 70
	    if (n < mu + 2) go to 7
	    do j = mu + 2, n
	        do i = 1, ml
	            a(i, j) = 0.d0
	        end do
	    end do
	    7   nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = md
	        mdl = min(ml, n - k) + md
	        do i = md1, mdl
	            if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	        end do
	        ip(k) = m + k - md
	        t = a(m, k)
	        if (m == md) go to 20
	        ip(n) = -ip(n)
	        a(m, k) = a(md, k)
	        a(md, k) = t
	        20     continue
	        if (t == 0.d0) go to 80
	        t = 1.d0 / t
	        do i = md1, mdl
	            a(i, k) = -a(i, k) * t
	        end do
	        ju = min0(max0(ju, mu + ip(k)), n)
	        mm = md
	        if (ju < kp1) go to 55
	        do j = kp1, ju
	            m = m - 1
	            mm = mm - 1
	            t = a(m, j)
	            if (m == mm) go to 35
	            a(m, j) = a(mm, j)
	            a(mm, j) = t
	            35       continue
	            if (t == 0.d0) go to 45
	            jk = j - k
	            do i = md1, mdl
	                ijk = i - jk
	                a(ijk, j) = a(ijk, j) + a(i, k) * t
	            end do
	            45       continue
	        end do
	        55     continue
	    end do
	    70   k = n
	    if (a(md, n) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
c649d751ebf6623ddecf19214abffdc2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|687|1|V|fortran
	    md = ml + mu + 1
	    md1 = md + 1
	    mdm = md - 1
	    nm1 = n - 1
	    if (ml == 0) go to 25
	    if (n == 1) go to 50
	    do k = 1, nm1
	        m = ip(k)
	        t = b(m)
	        b(m) = b(k)
	        b(k) = t
	        mdl = min(ml, n - k) + md
	        do i = md1, mdl
	            imd = i + k - md
	            b(imd) = b(imd) + a(i, k) * t
	        end do
	    end do
	    25   continue
	    do kb = 1, nm1
	        k = n + 1 - kb
	        b(k) = b(k) / a(md, k)
	        t = -b(k)
	        kmd = md - k
	        lm = max0(1, kmd + 1)
	        do i = lm, mdm
	            imd = i - kmd
	            b(imd) = b(imd) + a(i, k) * t
	        end do
	    end do
	    50   b(1) = b(1) / a(md, 1)
	    return
40613e150b09f2adb5a3217836b89da6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|753|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    md = ml + mu + 1
	    md1 = md + 1
	    ju = 0
	    if (ml == 0) go to 70
	    if (n == 1) go to 70
	    if (n < mu + 2) go to 7
	    do j = mu + 2, n
	        do i = 1, ml
	            ar(i, j) = 0.d0
	            ai(i, j) = 0.d0
	        end do
	    end do
	    7   nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = md
	        mdl = min(ml, n - k) + md
	        do i = md1, mdl
	            if (dabs(ar(i, k)) + dabs(ai(i, k)) >&
	                    dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	        end do
	        ip(k) = m + k - md
	        tr = ar(m, k)
	        ti = ai(m, k)
	        if (m == md) go to 20
	        ip(n) = -ip(n)
	        ar(m, k) = ar(md, k)
	        ai(m, k) = ai(md, k)
	        ar(md, k) = tr
	        ai(md, k) = ti
	        20     if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	        den = tr * tr + ti * ti
	        tr = tr / den
	        ti = -ti / den
	        do i = md1, mdl
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            ar(i, k) = -prodr
	            ai(i, k) = -prodi
	        end do
	        ju = min0(max0(ju, mu + ip(k)), n)
	        mm = md
	        if (ju < kp1) go to 55
	        do j = kp1, ju
	            m = m - 1
	            mm = mm - 1
	            tr = ar(m, j)
	            ti = ai(m, j)
	            if (m == mm) go to 35
	            ar(m, j) = ar(mm, j)
	            ai(m, j) = ai(mm, j)
	            ar(mm, j) = tr
	            ai(mm, j) = ti
	            35       continue
	            if (dabs(tr) + dabs(ti) == 0.d0) go to 48
	            jk = j - k
	            if (ti == 0.d0) then
	                do i = md1, mdl
	                    ijk = i - jk
	                    prodr = ar(i, k) * tr
	                    prodi = ai(i, k) * tr
	                    ar(ijk, j) = ar(ijk, j) + prodr
	                    ai(ijk, j) = ai(ijk, j) + prodi
	                end do
	                go to 48
	            end if
	            if (tr == 0.d0) then
	                do i = md1, mdl
	                    ijk = i - jk
	                    prodr = -ai(i, k) * ti
	                    prodi = ar(i, k) * ti
	                    ar(ijk, j) = ar(ijk, j) + prodr
	                    ai(ijk, j) = ai(ijk, j) + prodi
	                end do
	                go to 48
	            end if
	            do i = md1, mdl
	                ijk = i - jk
	                prodr = ar(i, k) * tr - ai(i, k) * ti
	                prodi = ai(i, k) * tr + ar(i, k) * ti
	                ar(ijk, j) = ar(ijk, j) + prodr
	                ai(ijk, j) = ai(ijk, j) + prodi
	            end do
	            48       continue
	        end do
	        55     continue
	    end do
	    70   k = n
	    if (dabs(ar(md, n)) + dabs(ai(md, n)) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
01bf3c61a0acc0cd9c713c5e290bd5c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|870|1|V|fortran
	    md = ml + mu + 1
	    md1 = md + 1
	    mdm = md - 1
	    nm1 = n - 1
	    if (ml == 0) go to 25
	    if (n == 1) go to 50
	    do k = 1, nm1
	        m = ip(k)
	        tr = br(m)
	        ti = bi(m)
	        br(m) = br(k)
	        bi(m) = bi(k)
	        br(k) = tr
	        bi(k) = ti
	        mdl = min(ml, n - k) + md
	        do i = md1, mdl
	            imd = i + k - md
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(imd) = br(imd) + prodr
	            bi(imd) = bi(imd) + prodi
	        end do
	    end do
	    25     continue
	    do kb = 1, nm1
	        k = n + 1 - kb
	        den = ar(md, k) * ar(md, k) + ai(md, k) * ai(md, k)
	        prodr = br(k) * ar(md, k) + bi(k) * ai(md, k)
	        prodi = bi(k) * ar(md, k) - br(k) * ai(md, k)
	        br(k) = prodr / den
	        bi(k) = prodi / den
	        tr = -br(k)
	        ti = -bi(k)
	        kmd = md - k
	        lm = max0(1, kmd + 1)
	        do i = lm, mdm
	            imd = i - kmd
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            br(imd) = br(imd) + prodr
	            bi(imd) = bi(imd) + prodi
	        end do
	    end do
	    den = ar(md, 1) * ar(md, 1) + ai(md, 1) * ai(md, 1)
	    prodr = br(1) * ar(md, 1) + bi(1) * ai(md, 1)
	    prodi = bi(1) * ar(md, 1) - br(1) * ai(md, 1)
	    br(1) = prodr / den
	    bi(1) = prodi / den
	    50   continue
	    return
e1c95ab39fed7de7b7cacb7249b74177|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|15|1|V|cpp
	
	  int ier = 0;
	  ip[N - 1] = 1;
	  if (N == 1) {
	    goto _70;
	  }
	  nm1 = N - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= N; i++) {
	      if (fabs(FMAT(a, i, k)) > abs(FMAT(a, m, k))) {
	        m = i;
	      }
	    }
	    FVEC(ip, k) = m;
	    t = FMAT(a, m, k);
	    if (m == k) {
	      goto _20;
	    }
	    FVEC(ip, N) = -FVEC(ip, N);
	    FMAT(a, m, k) = FMAT(a, k, k);
	    FMAT(a, k, k) = t;
	  _20:
	    continue;
	    if (t == 0.0)
	      goto _80;
	    t = 1.0 / t;
	    for (i = kp1; i <= N; i++) {
	      FMAT(a, i, k) = -FMAT(a, i, k) * t;
	    }
	    for (j = kp1; j <= N; j++) {
	      t = FMAT(a, m, j);
	      FMAT(a, m, j) = FMAT(a, k, j);
	      FMAT(a, k, j) = t;
	      if (t == 0.0)
	        goto _45;
	      for (i = kp1; i <= N; i++) {
	        FMAT(a, i, j) = FMAT(a, i, j) + FMAT(a, i, k) * t;
	      }
	    _45:
	      continue;
	    }
	  }
	_70:
	  k = N;
	  if (FMAT(a, N, N) == 0.0)
	    goto _80;
	  return ier;
	_80:
	  ier = k;
	  FVEC(ip, N) = 0;
	  return ier;
43801444268d43f3d1b4b97b1e73b283|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|27|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	        end do
	        ip(k) = m
	        t = a(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        a(m, k) = a(k, k)
	        a(k, k) = t
	        20     continue
	        if (t == 0.d0) go to 80
	        t = 1.d0 / t
	        do i = kp1, n
	            a(i, k) = -a(i, k) * t
	        end do
	        do j = kp1, n
	            t = a(m, j)
	            a(m, j) = a(k, j)
	            a(k, j) = t
	            if (t == 0.d0) go to 45
	            do i = kp1, n
	                a(i, j) = a(i, j) + a(i, k) * t
	            end do
	            45       continue
	        end do
	    end do
	    70   k = n
	    if (a(n, n) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
7ae8e609da32ae987b266466d58bdbae|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|63|1|V|cpp
	
	  if (N == 1)
	    goto _50;
	  nm1 = N - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = FVEC(ip, k);
	    t = FVEC(b, m);
	    b(m) = b(k);
	    b(k) = t;
	    for (i = kp1; i <= N; i++) {
	      b(i) = b(i) + a(i, k) * t;
	    }
	  }
	  for (kb = 1; kb <= nm1; i++) {
	    km1 = N - kb;
	    k = km1 + 1;
	    b(k) = b(k) / a(k, k);
	    t = -b(k);
	    for (i = 1; i <= km1; i++) {
	      b(i) = b(i) + a(i, k) * t;
	    }
	  }
	_50:
	  b(1) = b(1) / a(1, 1);
	  return;
7427d06993b3ef63ab29fd839bc3885e|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|98|1|V|cpp
	  ier = 0;
	  ip(N) = 1;
	  if (N == 1)
	    goto _70;
	  nm1 = N - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    na = fmin(N, lb + k);
	    for (i = kp1; i <= na; i++) {
	      if (fabs(a(i, k)) > fabs(a(m, k)))
	        m = i;
	    }
	    ip(k) = m;
	    t = a(m, k);
	    if (m == k)
	      goto _20;
	    ip(N) = -ip(N);
	    a(m, k) = a(k, k);
	    a(k, k) = t;
	  _20:
	    continue;
	    if (t == 0.0)
	      goto _80;
	    t = 1.0 / t;
	    for (i = kp1; i <= na; i++) {
	      a(i, k) = -a(i, k) * t;
	    }
	    for (j = kp1; j <= N; j++) {
	      t = a(m, j);
	      a(m, j) = a(k, j);
	      a(k, j) = t;
	      if (t == 0.0)
	        goto _45;
	      for (i = kp1; i <= na; i++) {
	        a(i, j) = a(i, j) + a(i, k) * t;
	      }
	    _45:
	      continue;
	    }
	  }
	_70:
	  k = N;
	  if (a(N, N) == 0.0)
	    goto _80;
	  return ier;
	_80:
	  ier = k;
	  ip(N) = 0;
	  return ier;
4d71f67e68737ae253571b0425ee08b0|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|146|1|V|cpp
	  if (N == 1)
	    goto _50;
	  nm1 = N - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = ip(k);
	    t = b(m);
	    b(m) = b(k);
	    b(k) = t;
	    na = fmin(N, lb + k);
	    for (i = kp1; i <= na; i++) {
	      b(i) = b(i) + a(i, k) * t;
	    }
	  }
	  for (kb = 1; kb <= nm1; kb++) {
	    km1 = N - kb;
	    k = km1 + 1;
	    b(k) = b(k) / a(k, k);
	    t = -b(k);
	    for (i = 1; i <= km1; i++) {
	      b(i) = b(i) + a(i, k) * t;
	    }
	  }
	_50:
	  b(1) = b(1) / a(1, 1);
	  return;
abcf1b38dec7302f4575e9ace063b987|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|262|1|V|fortran
	    ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(ar(i, k)) + dabs(ai(i, k)) >&
	                    dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	        end do
	        ip(k) = m
	        tr = ar(m, k)
	        ti = ai(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        ar(m, k) = ar(k, k)
	        ai(m, k) = ai(k, k)
	        ar(k, k) = tr
	        ai(k, k) = ti
	        20     continue
	        if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	        den = tr * tr + ti * ti
	        tr = tr / den
	        ti = -ti / den
	        do i = kp1, n
	            prodr = ar(i, k) * tr - ai(i, k) * ti
	            prodi = ai(i, k) * tr + ar(i, k) * ti
	            ar(i, k) = -prodr
	            ai(i, k) = -prodi
	        end do
	        do j = kp1, n
	            tr = ar(m, j)
	            ti = ai(m, j)
	            ar(m, j) = ar(k, j)
	            ai(m, j) = ai(k, j)
	            ar(k, j) = tr
	            ai(k, j) = ti
	            if (dabs(tr) + dabs(ti) == 0.d0) go to 48
	            if (ti == 0.d0) then
	                do i = kp1, n
	                    prodr = ar(i, k) * tr
	                    prodi = ai(i, k) * tr
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            if (tr == 0.d0) then
	                do i = kp1, n
	                    prodr = -ai(i, k) * ti
	                    prodi = ar(i, k) * ti
	                    ar(i, j) = ar(i, j) + prodr
	                    ai(i, j) = ai(i, j) + prodi
	                end do
	                go to 48
	            end if
	            do i = kp1, n
	                prodr = ar(i, k) * tr - ai(i, k) * ti
	                prodi = ai(i, k) * tr + ar(i, k) * ti
	                ar(i, j) = ar(i, j) + prodr
	                ai(i, j) = ai(i, j) + prodi
	            end do
	            48       continue
	        end do
	    end do
	    70   k = n
	    if (dabs(ar(n, n)) + dabs(ai(n, n)) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
c4719181951d73d9cc62b32d6ea307fc|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|181|1|V|cpp
	  ier = 0;
	  ip(N) = 1;
	  if (N == 1)
	    goto _70;
	  nm1 = N - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= N; i++) {
	      if (fabs(ar(i, k)) + fabs(ai(i, k)) > fabs(ar(m, k)) + fabs(ai(m, k)))
	        m = i;
	    }
	    ip(k) = m;
	    tr = ar(m, k);
	    ti = ai(m, k);
	    if (m == k)
	      goto _20;
	    ip(N) = -ip(N);
	    ar(m, k) = ar(k, k);
	    ai(m, k) = ai(k, k);
	    ar(k, k) = tr;
	    ai(k, k) = ti;
	  _20:
	    continue;
	    if (fabs(tr) + fabs(ti) == 0.0)
	      goto _80;
	    den = tr * tr + ti * ti;
	    tr = tr / den;
	    ti = -ti / den;
	    for (i = kp1; i <= N; i++) {
	      prodr = ar(i, k) * tr - ai(i, k) * ti;
	      prodi = ai(i, k) * tr + ar(i, k) * ti;
	      ar(i, k) = -prodr;
	      ai(i, k) = -prodi;
	    }
	    for (j = kp1; j <= N; j++) {
	      tr = ar(m, j);
	      ti = ai(m, j);
	      ar(m, j) = ar(k, j);
	      ai(m, j) = ai(k, j);
	      ar(k, j) = tr;
	      ai(k, j) = ti;
	      if (fabs(tr) + fabs(ti) == 0.0)
	        goto _48;
	      if (ti == 0.0) {
	        for (i = kp1; i <= N; i++) {
	          prodr = ar(i, k) * tr;
	          prodi = ai(i, k) * tr;
	          ar(i, j) = ar(i, j) + prodr;
	          ai(i, j) = ai(i, j) + prodi;
	        }
	        goto _48;
	      }
	      if (tr == 0.0) {
	        for (i = kp1; i <= N; i++) {
	          prodr = -ai(i, k) * ti;
	          prodi = ar(i, k) * ti;
	          ar(i, j) = ar(i, j) + prodr;
	          ai(i, j) = ai(i, j) + prodi;
	        }
	        goto _48;
	      }
	      for (i = kp1; i <= N; i++) {
	        prodr = ar(i, k) * tr - ai(i, k) * ti;
	        prodi = ai(i, k) * tr + ar(i, k) * ti;
	        ar(i, j) = ar(i, j) + prodr;
	        ai(i, j) = ai(i, j) + prodi;
	      }
	    _48:
	      continue;
	    }
	  }
	_70:
	  k = N;
	  if (fabs(ar(N, N)) + fabs(ai(N, N)) == 0.0)
	    goto _80;
	  return ier;
	_80:
	  ier = k;
	  ip(N) = 0;
	  return ier;
a26628b44c8900bd7dcc3b7c0d98fe22|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|299|5|V|cpp
	    continue;
056afd87918aad8f97e235806b5fa61b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|404|1|V|fortran
	    integer n, ndim, ip, ier, nm1, k, kp1, m, i, j
157db7df530023575515d366c9b672e8|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|400|5|v|cpp
	integer
2a23ab786c379c3fe7e86cc64764d6c7|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|540|7|v|cpp
	 continue;
8fb84873211361dc1667e8c1db2ab4ac|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|692|5|v|cpp
	     continue;
680358579f5ade013e616602ee11e25c|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|717|5|v|cpp
	   continue;
6614b7aa271c9f4fe41b692e7bb623ae|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|44|1|V|cmake
	add_executable(test_van_der_pol test_van_der_pol.cpp)
	target_link_libraries(test_van_der_pol PUBLIC
		stiff 
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	set_target_properties(test_van_der_pol PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
0c5b1ee4ffc4230a6aded121cdaceba4|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|40|1|V|cmake
	# -------------------------------------------------
	# test_decsol.cpp: The the decomposition algorithms
	# -------------------------------------------------
faa77afc312b26c9e4d12ffdf446a010|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|55|3|v|cmake
	test_decsol
bc39ce8e8201bd13104a6826c96eb916|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|55|25|v|cmake
	The the decomposition algorithms
2b6ff9d7a0c30ce6e55f76cffe11be74|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|46|1|V|cmake
		stiff 
4b3897fa2db9585fb3aa32f6e4980c64|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|26|1|V|cmake
	        ${PROJECT_BINARY_DIR}/include
d32b8e2d8eb2574ee4faea1bf2e85ecd|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|23|1|V|cmake
	message("include = ${PROJECT_SOURCE_DIR}/include")
4815076686bc9d0c0d78841d979f3fb5|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|31|10|v|cmake
	include = ${PROJECT_SOURCE_DIR}/include
cc4e83422a12f4d746191286d2742acb|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|31|1|V|cmake
	message("=============================================================")
	message(" SOURCES = ${STIFF_SOURCES}")
	message("=============================================================")
cd0c6092d6a6874f379fe4827ed1db8b|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|32|29|v|cmake
	PUBLIC
9ff5b73b41467f789183936f9079611f|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|49|2|V|cmake
		stiff
0e5562a3a5b64f3768b0309b0fe6a1bf|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|35|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(Eigen3 REQUIRED)
03169f5ba6de8fcf1abca235ef45b2b3|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|1|1|V|cmake
	set(CMAKE_CXX_STANDARD 17)
6b27ac1f7b5b73a33e196c0ca5a3b0fc|file:///Users/loganmorrison/Documents/git_hub/stiff/src/decsol.cpp|13|1|V|cpp
	int dec(Matrix<double, Ndim, N> &a, Vector<int, N> &ip) {
fe6f99ef1ec99efbdc19a9786cf1facc|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|34|19|v|cmake
	STATIC
6b1b681ebffaf9e0d38a97461be4a2c3|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|9|1|V|cmake
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
ee77997a927ed8328e5c9ff3656033be|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|10|1|V|cmake
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
085f73d3263483fa5ed6f2879f9293cd|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|50|9|V|cmake
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
31ef9d4a09ff79805255a34a38e61296|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|49|1|V|cmake
	set_target_properties(test_decsol PROPERTIES
7cc13e4a2de5373d5f2adebb205d95fb|file:///Users/loganmorrison/Documents/git_hub/stiff/test/CMakeLists.txt|60|1|V|cmake
	set_target_properties(test_van_der_pol PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
9c4944ce9372dd263223a888f9bd2c60|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|394|4|V|fortran
	    use iso_c_binding
a3b8a158c74441481d405aa3c9efd163|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|683|33|v|fortran
	rpar, ipar
8d3a0d5d09d896a0777ada676b467683|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|719|31|v|fortran
	, rpar(*), ipar(*)
0c6e252817e75e879070500a8a34aacc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|1444|45|v|fortran
	 rpar, ipar
08fd04da1b9c3e4c1c9ab1fe42494a35|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|6|37|v|fortran
	userdata
46efa8cf67b3cb00f3ccad2e49ba513a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|394|5|V|fortran
	    type(c_ptr), value :: userdata
6b435113530b223ee99d19e1bca55241|file:///Users/loganmorrison/Documents/git_hub/stiff/conanfile.py|7|16|v|python
	<Put the package license here>
6dd122093eb5016c8677cf74f91355af|file:///Users/loganmorrison/Documents/git_hub/stiff/conanfile.py|8|15|v|python
	<Put your name here>
3caa922782f7be60e91ade8e539ed878|file:///Users/loganmorrison/Documents/git_hub/stiff/conanfile.py|8|33|v|python
	<And your email here>
bb66c42fbb876e4018573b2b8c06b465|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|23|1|V|cmake
	file(GLOB_RECURSE STIFF_SOURCES "src/*.cpp")
c970f2efd9ed093c5c5d7cd9734ac6ac|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|23|26|v|cmake
	${STIFF_SOURCES}
e5d18b4e2c1dc1975775ee385ab41c85|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|6|25|v|cmake
	0.1.0
2fa060d6d64f2aac600e327e2023b9bd|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|6|25|v|cmake
	${STIFF_VERSION}
5ac8111daf754da04e3377af2875c168|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|33|1|V|cmake
		include/stiff/radau.hpp
dfa44e7970a37a2c85280bcaef6d5bf8|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|32|1|v|cmake
	set_target_properties(stiff PROPERTIES PUBLIC_HEADER
		include/stiff/radau.hpp
		include/stiff/radau5.hpp
		include/stiff/common.hpp
		include/stiff/decsol.hpp
		include/stiff/radaup.hpp
	)
0032f5a392d2bb530cd635362ad873c4|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|32|28|v|cmake
	mylib
af75eae740de9ca4d23f0e59e3810920|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/CMakeLists.txt|2|1|V|cmake
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
e36f7ec4e1e8bb54d83ee43753c80ee4|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|14|75|v|cmake
	cmake-build-debug
b0da275520918e23dd615e2a747528f1|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|15|72|v|cmake
	build
78aa41bda69827c8b661a76e207bdcad|file:///Users/loganmorrison/Documents/git_hub/stiff/test/test_decsol.cpp|17|4|v|cpp
	/ dec(mat, ip);
bbb2d909b7731cd8fb4d779e9b84e1e2|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|19|1|V|cmake
	install(TARGETS ${PROJECT_NAME} EXPORT MyLibConfig
		ARCHIVE DESTINATION ${CMA
2f43ab3b3596fe00ac2f7d04dc48bb18|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|25|16|v|cmake
	MyLib
0eb168cb3782b6c475a9513f6ce49d23|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|2|9|v|cmake
	StiffOdeSolvers
ea198fa5cba53afaa0f6be05cf287604|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|2|9|v|cmake
	StiffOdeSolvers 
fd91ee67f2b4976f7af20d48127f38ea|file:///Users/loganmorrison/Documents/git_hub/stiff/CMakeLists.txt|14|2|V|cmake
		Boost
9a961183ceebb2574a01d309659804c3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|6|1|V|cpp
	void dec(n, ndim, a, ip, ier);
	void sol(n, ndim, a, b, ip);
	void dech(n, ndim, a, lb, ip, ier);
	void solh(n, ndim, a, lb, b, ip);
	void decc(n, ndim, ar, ai, ip, ier);
	void solc(n, ndim, ar, ai, br, bi, ip);
	void dechc(n, ndim, ar, ai, lb, ip, ier);
	void solhc(n, ndim, ar, ai, lb, br, bi, ip);
	void decb(n, ndim, a, ml, mu, ip, ier);
	void solb(n, ndim, a, ml, mu, b, ip);
	void decbc(n, ndim, ar, ai, ml, mu, ip, ier);
	void solbc(n, ndim, ar, ai, ml, mu, br, bi, ip);
	void elmhes(nm, n, low, igh, a, int);
7872cac381aecfcca6e2bf5163458ea4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|7|1|V|cpp
	// --------------------------------------------
d2136d19ef0879b45aa1f2fcc1a2bec4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|10|10|v|cpp
	n, ndim, 
2bf975e1e74defa05769aa339dc0840b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/lanre.hpp|14|1|V|cpp
	template <class Type, int n = Eigen::Dynamic>
	using Vector = Eigen::Matrix<Type, n, 1>;
	
	template <class Type, int n = Eigen::Dynamic>
	using RowVector = Eigen::Matrix<Type, 1, n>;
	
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Matrix = Eigen::Matrix<Type, n, m>;
97008de886bb355282e9c43e360d5f64|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/lanre.hpp|23|1|V|cpp
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Array = Eigen::Array<Type, n, m>;
29bfc4572f5c2051043013cda1f277bc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/vector_matrix.hpp|9|1|V|cpp
	template <class Type, int n = Eigen::Dynamic>
	using RowVector = Eigen::Matrix<Type, 1, n>;
536bbadd6a915c15da9703392cca6e18|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|9|82|v|cpp
	, ier
482631144b92b851e363980287f4e721|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|15|1|V|cpp
	  // c  matrix triangularization by gaussian elimination.
	  // c  input..
	  // c     n = order of matrix.
	  // c     ndim = declared dimension of array  a .
	  // c     a = matrix to be triangularized.
	  // c  output..
	  // c     a(i,j), i.le.j = upper triangular factor, u .
	  // c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  sol  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
c245041bad9bb6dd903f0bff11397771|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|28|3|v|cpp
	//          
c7f4da574caf0eaf115c36496027a6c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|32|3|V|cpp
	  // c version real double precision
2c15cb9684a4a2daa17f076802de8bbd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|34|1|V|cpp
	  // dimension a(ndim, n), ip(n)
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination.
	  // c  input..
	  // c     n = order of matrix.
	  // c     ndim = declared dimension of array  a .
	  // c     a = matrix to be triangularized.
	  // c  output..
	  // c     a(i,j), i.le.j = upper triangular factor, u .
	  // c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  sol  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
929fb7500b72f7a67a7cc1ba020c1fa6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|67|9|v|cpp
	goto g45;
a1fd5622debcf9e922270b6a78eb4641|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|71|5|V|cpp
	    g45:
3dd517fa5fe91214e45afe1ff6dff350|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|85|1|V|cpp
	// c
	// c
	// --------------------------------------------
21520777e8306da89fb1f3f0b9e9a59d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|82|1|V|cpp
	  // c----------------------- end of subroutine dec -------------------------
4e112f5b1d0d47842fa8e6cb5b2ff545|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|30|1|V|cpp
	template <int n, int ndim>
37e7be736cc0f53dcfc9ee854dce2d61|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|824|1|V|cpp
	// c
	// --------------------------------------------
3cd7e3b51ae30be40a4e2fe0e00acb3d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|31|9|v|cpp
	Matrix<double, ndim, n> &
1cfb16f4f53fd3f85f9fd530f788f164|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|31|37|v|cpp
	Vector<int, n> &
12eba97694ad9f9f18515d4d64674f08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|84|65|v|cpp
	Vector<double, n> &
9bbda723d2ea5bbf4393d81768c05b59|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|262|1|V|cpp
	  // c version complex double precision
	  // implicit double(a - h, o - z)
01c3ed2568f9d375bf0c41c25d2684f2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|263|3|V|cpp
	  // dimension ar(ndim, n), ai(ndim, n), ip(n)
7b4056a7ef3c87966bd6c151ba1476ad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|263|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination
	  // c  ------ modification for complex matrices --------
	  // c  input..
	  // c     n = order of matrix.
	  // c     ndim = declared dimension of arrays  ar and ai .
	  // c     (ar, ai) = matrix to be triangularized.
	  // c  output..
	  // c     ar(i,j), i.le.j = upper triangular factor, u ; real part.
	  // c     ai(i,j), i.le.j = upper triangular factor, u ; imaginary part.
	  // c     ar(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c                                                    real part.
	  // c     ai(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c                                                    imaginary part.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  sol  to obtain solution of linear system.
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
f1e9023beb8fcdeecedd120c10e041dd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|89|1|V|cpp
	  // dimension a(ndim, n), b(n), ip(n)
03381cd909d0664f98f2ddc85e7a8e6b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|89|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n = order of matrix.
	  // c    ndim = declared dimension of array  a .
	  // c    a = triangularized matrix obtained from dec.
	  // c    b = right hand side vector.
	  // c    ip = pivot vector obtained from dec.
	  // c  do not use if dec has set ier .ne. 0.
	  // c  output..
	  // c    b = solution vector, x .
	  // c-----------------------------------------------------------------------
3e29aa0caf2538ec209fd20aaae8d497|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|125|3|V|cpp
	  // c----------------------- end of subroutine sol -------------------------
809b1ab39dd13afa16b8df9c8f67286c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|132|3|V|cpp
	  // dimension a(ndim, n), ip(n)
01083ea68cf75192b0ccea41d8552024|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|131|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination of a hessenberg
	  // c  matrix with lower bandwidth lb
	  // c  input..
	  // c     n = order of matrix a.
	  // c     ndim = declared dimension of array  a .
	  // c     a = matrix to be triangularized.
	  // c     lb = lower bandwidth of a (diagonal is not counted, lb.ge.1).
	  // c  output..
	  // c     a(i,j), i.le.j = upper triangular factor, u .
	  // c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  solh  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     this is a slight modification of
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
e61ae182c798ac7283da6c0df0ec9258|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|203|3|V|cpp
	  // c----------------------- end of subroutine dech ------------------------
79573be2e23887f86313123782b87424|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|210|10|v|cpp
	a, b, 
6d475ba25def3a4dd7122b509e7db16a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|211|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n = order of matrix a.
	  // c    ndim = declared dimension of array  a .
	  // c    a = triangularized matrix obtained from dech.
	  // c    lb = lower bandwidth of a.
	  // c    b = right hand side vector.
	  // c    ip = pivot vector obtained from dec.
	  // c  do not use if dech has set ier .ne. 0.
	  // c  output..
	  // c    b = solution vector, x .
	  // c-----------------------------------------------------------------------
3b82eb1a9fc827322a9924721eb3f422|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|249|3|V|cpp
	  // c----------------------- end of subroutine solh ------------------------
863858dddd52c43eb8e207d667dbb541|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|342|9|V|cpp
	        goto g48
5ae2af49b9da398cd2d9ec943312795c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|333|9|V|cpp
	        goto g48;
78c9f36eb9d7c8d8e7697eddabc49a9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|350|5|V|cpp
	    g48:
7357fd860368172c33865e3a4fc42805|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|361|3|V|cpp
	  // c----------------------- end of subroutine decc ------------------------
ab21a42ade41c52cea82679145daab87|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|366|3|V|cpp
	  // c version complex double precision
455b78a7f181fb5bd1c11419d79de253|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|366|3|V|cpp
	  // implicit double(a - h, o - z)
a3b4c6d53c2fb305c1a9e080cee9dda8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|367|3|V|cpp
	  // dimension ar(ndim, n), ai(ndim, n), br(n), bi(n), ip(n)
ce52491e43f0f9d0ffea114f82fecc70|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|367|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n = order of matrix.
	  // c    ndim = declared dimension of arrays  ar and ai.
	  // c    (ar,ai) = triangularized matrix obtained from dec.
	  // c    (br,bi) = right hand side vector.
	  // c    ip = pivot vector obtained from dec.
	  // c  do not use if dec has set ier .ne. 0.
	  // c  output..
	  // c    (br,bi) = solution vector, x .
	  // c-----------------------------------------------------------------------
7cb8974111a2c46909b89e01f219591e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|426|3|V|cpp
	  // c----------------------- end of subroutine solc ------------------------
f2c5540fc92afa06783290af98518e74|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|432|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination
	  // c  ------ modification for complex matrices --------
	  // c  input..
	  // c     n = order of matrix.
	  // c     ndim = declared dimension of arrays  ar and ai .
	  // c     (ar, ai) = matrix to be triangularized.
	  // c  output..
	  // c     ar(i,j), i.le.j = upper triangular factor, u ; real part.
	  // c     ai(i,j), i.le.j = upper triangular factor, u ; imaginary part.
	  // c     ar(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c                                                    real part.
	  // c     ai(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c                                                    imaginary part.
	  // c     lb = lower bandwidth of a (diagonal not counted), lb.ge.1.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  sol  to obtain solution of linear system.
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
ed8b877c5bff5051888d16fe08708dd2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|544|3|V|cpp
	  // c----------------------- end of subroutine dechc -----------------------
e052bcaf630c94342d43546a19162e52|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|550|7|v|cpp
	ip, 
396eab269e40bde65aeeccae84273168|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|552|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n = order of matrix.
	  // c    ndim = declared dimension of arrays  ar and ai.
	  // c    (ar,ai) = triangularized matrix obtained from dec.
	  // c    (br,bi) = right hand side vector.
	  // c    lb = lower bandwidth of a.
	  // c    ip = pivot vector obtained from dec.
	  // c  do not use if dec has set ier .ne. 0.
	  // c  output..
	  // c    (br,bi) = solution vector, x .
	  // c-----------------------------------------------------------------------
d12ac106ba98069b989dc9957ad13f28|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|579|7|V|cpp
	      {
d5a98fdc75ecfb12279b2c8afc6ff8e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|614|3|V|cpp
	  // c----------------------- end of subroutine solhc -----------------------
c561cd0078c48569fadac2ebffabe325|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|618|29|v|cpp
	, int ier
835822dfbd72c73d0bbc4559994f3752|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|620|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination of a banded
	  // c  matrix with lower bandwidth ml and upper bandwidth mu
	  // c  input..
	  // c     n       order of the original matrix a.
	  // c     ndim    declared dimension of array  a.
	  // c     a       contains the matrix in band storage.   the columns
	  // c                of the matrix are stored in the columns of  a  and
	  // c                the diagonals of the matrix are stored in rows
	  // c                ml+1 through 2*ml+mu+1 of  a.
	  // c     ml      lower bandwidth of a (diagonal is not counted).
	  // c     mu      upper bandwidth of a (diagonal is not counted).
	  // c  output..
	  // c     a       an upper triangular matrix in band storage and
	  // c                the multipliers which were used to obtain it.
	  // c     ip      index vector of pivot indices.
	  // c     ip(n)   (-1)**(number of interchanges) or o .
	  // c     ier     = 0 if matrix a is nonsingular, or  = k if found to be
	  // c                singular at stage k.
	  // c  use  solb  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(md,1)*a(md,2)*...*a(md,n)  with md=ml+mu+1.
	  // c  if ip(n)=o, a is singular, solb will divide by zero.
	  // c
	  // c  reference..
	  // c     this is a modification of
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
fcd51d59f5ad7e6a8f77a14bab2a0435|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|646|55|v|cpp
	fewqf ;
cdc64689ce4295d577635521bd905de6|file:///Users/loganmorrison/.config/nvim/init.vim|353|3|V|vim
	  inoremap jk <Esc>
ea877acff1831dc9df46bcbf7c23d788|file:///Users/loganmorrison/.config/nvim/init.vim|353|3|V|vim
	  inoremap kj <Esc>
16eda88e0eec572f7622301832e9cca6|file:///Users/loganmorrison/.config/nvim/init.vim|352|1|V|vim
	  " I hate escape more than anything else
1ec5da47034dd76960fd1a2a2cbb7094|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|725|3|V|cpp
	  // c----------------------- end of subroutine decb ------------------------
f7944092adca945e05a8ef14c7a09c34|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|732|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n      order of matrix a.
	  // c    ndim   declared dimension of array  a .
	  // c    a      triangularized matrix obtained from decb.
	  // c    ml     lower bandwidth of a (diagonal is not counted).
	  // c    mu     upper bandwidth of a (diagonal is not counted).
	  // c    b      right hand side vector.
	  // c    ip     pivot vector obtained from decb.
	  // c  do not use if decb has set ier .ne. 0.
	  // c  output..
	  // c    b      solution vector, x .
	  // c-----------------------------------------------------------------------
813c7c773ef57dbd8f995bef9aa96b7d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|782|3|V|cpp
	  // c----------------------- end of subroutine solb ------------------------
7015bbdaea7fb14c3e2c30fdb7f31de5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|781|1|V|cpp
	  return;
d3b866b8d96e3aed02e6338dbe9b0bf2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|786|1|V|cpp
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination of a banded complex
	  // c  matrix with lower bandwidth ml and upper bandwidth mu
	  // c  input..
	  // c     n       order of the original matrix a.
	  // c     ndim    declared dimension of array  a.
	  // c     ar, ai     contains the matrix in band storage.   the columns
	  // c                of the matrix are stored in the columns of  ar (real
	  // c                part) and ai (imaginary part)  and
	  // c                the diagonals of the matrix are stored in rows
	  // c                ml+1 through 2*ml+mu+1 of  ar and ai.
	  // c     ml      lower bandwidth of a (diagonal is not counted).
	  // c     mu      upper bandwidth of a (diagonal is not counted).
	  // c  output..
	  // c     ar, ai  an upper triangular matrix in band storage and
	  // c                the multipliers which were used to obtain it.
	  // c     ip      index vector of pivot indices.
	  // c     ip(n)   (-1)**(number of interchanges) or o .
	  // c     ier     = 0 if matrix a is nonsingular, or  = k if found to be
	  // c                singular at stage k.
	  // c  use  solbc  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(md,1)*a(md,2)*...*a(md,n)  with md=ml+mu+1.
	  // c  if ip(n)=o, a is singular, solbc will divide by zero.
	  // c
	  // c  reference..
	  // c     this is a modification of
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
0fd9144ae995e7ced8d6c89e752392f3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|11|3|v|cpp
	model.set_xi_inf(
ff74605565c664875932c6fce8a0b748|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|10|3|v|cpp
	double r = 
884fb8f89efbb551de7f067ea7528985|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|11|3|V|cpp
	  1e-2);
4ab288090507e4f314949094a130afd0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|10|46|v|cpp
	model.dark_heff_inf()
c8b9afa0f5e711d5e036d4f701d74dc9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|88|1|V|cpp
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
7c79cccb07b261fac0e8bb0ad0417aaf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|745|1|V|cpp
	  int i, imd, j, k, kb, kbm, kmd, m, md, md1, mdm, mdl, nm1, lm;
e8b1bce65981b07983da309f17463126|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|815|1|V|cpp
	  int ier, i, j, k, m, md, md1, ju, nm1, ;
555c6d2c82ef39aff40d69680a5f8878|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|46|1|V|cmake
	#add_executable(test_model test_model.cpp)
	#set_property(TARGET test_model PROPERTY CXX_STANDARD 17)
6fc7288232bcff2a7a37c93f04ad6fbf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|4|1|V|cpp
	TEST(TestDarkSunModel, TestConstruction) {
	  auto model = darksun::DarkSun(10, 1.0);
	
	}
2a0d30cb1153031c3dfc239c6e0407ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|9|28|v|cpp
	Construction
631b8590067f4f3ecc5f2e7611c5aa42|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|15|5|V|cpp
	    double lam = model.get_lam()
309648217f27f7432f9daef363c96b08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|17|44|v|cpp
	model.get_lam() * model.get_n());
b194edb19d8c9b7a0c0cd24f9c8f22e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|21|1|V|cpp
	    auto tcs1 = model.thermal_cross_section_2eta_4eta(x);
2ce3de2a300fc925a51dc6da683e5c0b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|22|17|v|cpp
	model.thermal_cross_section_2eta_4eta(x);
918b81db5e91d031548b963c93845e5b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_model.cpp|25|19|v|cpp
	mine
5971efde1ff59ed956a3b5383340a4c5|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/phase_space/rambo.hpp|8|1|V|cpp
	#include "lanre/phase_space/base.hpp"
	#include <utility>
	#include <vector>
	#include <array>
	#include <algorithm>
	#include <thread>
	#include <mutex>
	#include <functional>
	
	namespace lanre {
	namespace phase_space {
	
	
	class Rambo : public PhaseSpaceGenerator {
	private:
	    double compute_scale_factor(std::vector<FourVector> &);
	
	    void initialize_four_momenta(std::vector<FourVector> &);
	
	    void boost_four_momenta(std::vector<FourVector> &);
	
	    double correct_masses(std::vector<FourVector> &);
	
	    PhaseSpaceEvent internal_generate_event();
	
	    void internal_generate_events(std::size_t);
	
	public:
	    Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses, double cme)
	            : PhaseSpaceGenerator(isp_masses, fsp_masses, cme) {}
	
	    Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses, double cme,
	          std::function<double(const std::vector<FourVector> &)> t_mat_squared)
	            : PhaseSpaceGenerator(isp_masses, fsp_masses, cme, std::move(t_mat_squared)) {}
	
	    PhaseSpaceEvent generate_event();
	
	    std::vector<PhaseSpaceEvent> generate_events(std::size_t) override;
	};
	
	/* Function for finding the scaling parameter to turn mass-less four-vectors
	 * into four-vectors with the correct masses.
	 * @param momenta 4-momenta of final-state particles
	 */
	double Rambo::compute_scale_factor(std::vector<FourVector> &momenta) {
	    static thread_local const int MAX_ITER = 50;
	    static thread_local const double TOL = 1e-4;
	
	    double mass_sum = std::accumulate(fsp_masses.begin(), fsp_masses.end(), 0.0);
	
	    double xi = sqrt(1.0 - (mass_sum / cme) * (mass_sum / cme));
	
	    int iter_count = 0;
	    bool converged = false;
	    do { // Perform newton iterations to solve for xi
	        double f = -cme;
	        double df = 0.0;
	
	        for (size_t i = 0; i < fsp_masses.size(); i++) {
	            // Compute residual and derivative of residual
	            double m2 = fsp_masses[i] * fsp_masses[i];
	            double xi2 = xi * xi;
	            double e2 = momenta[i].t * momenta[i].t;
	            double del_f = sqrt(m2 + xi2 * e2);
	            f += del_f;
	            df += xi * e2 / del_f;
	        }
	
	        // Newton correction
	        double delta_xi = -(f / df);
	        xi += delta_xi;
	
	        iter_count++;
	        if (fabs(delta_xi) < TOL || iter_count >= MAX_ITER) {
	            converged = true;
	        }
	    } while (!converged);
	    return xi;
	}
	
	/**
	 * Initialize the four-momenta with isotropic, random four-momenta with energies,
	 * q, distributed according to q * exp(-q).
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::initialize_four_momenta(std::vector<FourVector> &momenta) {
	
	    std::uniform_real_distribution<double> distribution(0.0, 1.0);
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double rho1 = phase_space_uniform_rand();
	        double rho2 = phase_space_uniform_rand();
	        double rho3 = phase_space_uniform_rand();
	        double rho4 = phase_space_uniform_rand();
	
	        double c = 2.0 * rho1 - 1.0;
	        double phi = 2.0 * M_PI * rho2;
	
	        momenta[i].t = -log(rho3 * rho4);
	        momenta[i].x = momenta[i].t * sqrt(1.0 - c * c) * cos(phi);
	        momenta[i].y = momenta[i].t * sqrt(1.0 - c * c) * sin(phi);
	        momenta[i].z = momenta[i].t * c;
	    }
	}
	
	/**
	 * Boost the four-momenta into the center-of-mass frame and compute the
	 * initial weight of the event.
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::boost_four_momenta(std::vector<FourVector> &momenta) {
	    // Total momentum and its mass
	    FourVector Q = std::accumulate(momenta.begin(), momenta.end(), FourVector{});
	    double massQ = mass(Q);
	
	    // Boost three-vector
	    double bx = -Q.x / massQ;
	    double by = -Q.y / massQ;
	    double bz = -Q.z / massQ;
	    // Boost factors
	    double x = cme / massQ;
	    double gamma = Q.t / massQ;
	    double a = 1.0 / (1.0 + gamma);
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double qe = momenta[i].t;
	        double qx = momenta[i].x;
	        double qy = momenta[i].y;
	        double qz = momenta[i].z;
	
	        double b_dot_q = bx * qx + by * qy + bz * qz;
	
	        momenta[i].t = x * (gamma * qe + b_dot_q);
	        momenta[i].x = x * (qx + bx * qe + a * b_dot_q * bx);
	        momenta[i].y = x * (qy + by * qe + a * b_dot_q * by);
	        momenta[i].z = x * (qz + bz * qe + a * b_dot_q * bz);
	    }
	}
	
	/**
	 * Correct the masses of the four-momenta and correct the weight of the
	 * event.
	 * @param momenta 4-momenta of final-state particles
	 * @return new event weight factor
	 */
	double Rambo::correct_masses(std::vector<FourVector> &momenta) {
	    double xi = compute_scale_factor(momenta);
	
	    double term1 = 0.0;
	    double term2 = 0.0;
	    double term3 = 1.0;
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double m = fsp_masses[i];
	        double eng = momenta[i].t;
	        momenta[i].t = sqrt(m * m + (xi * eng) * (xi * eng));
	        momenta[i].x *= xi;
	        momenta[i].y *= xi;
	        momenta[i].z *= xi;
	
	        double mod = sqrt(momenta[i].x * momenta[i].x +
	                                  momenta[i].y * momenta[i].y +
	                                  momenta[i].z * momenta[i].z);
	        eng = momenta[i].t;
	
	        term1 += mod / cme;
	        term2 += mod * mod / eng;
	        term3 *= mod / eng;
	    }
	
	    term1 = pow(term1, 2.0 * fsp_masses.size() - 3.0);
	    term2 = 1.0 / term2;
	
	    // re-weight
	    return term1 * term2 * term3 * cme;
	}
	
	/**
	 * generate single phase space event
	 * @return event
	 */
	PhaseSpaceEvent Rambo::internal_generate_event() {
	    std::vector<FourVector> momenta(fsp_masses.size(), FourVector{});
	    double weight;
	
	    initialize_four_momenta(momenta);
	    boost_four_momenta(momenta);
	    weight = correct_masses(momenta) * mat_squared(momenta) * m_base_weight;
	
	    return PhaseSpaceEvent{momenta, weight};
	}
	
	/**
	 * Generate many phase space events.
	 * @param num_points
	 * @return vector of events
	 */
	void Rambo::internal_generate_events(size_t num_points) {
	    std::vector<PhaseSpaceEvent> local_events;
	    local_events.reserve(num_points);
	
	    for (size_t n = 0; n < num_points; n++)
	        local_events.emplace_back(internal_generate_event());
	
	    {
	        // Add events to class level event array. Avoid data races by lock guard.
	        std::lock_guard<std::mutex> lck(m_mtx);
	        for (auto &event:local_events)
	            m_events.emplace_back(event);
	    }
	}
	
	/**
	 * Generate a set of Rambo event.
	 * @return RamboEvent.
	 */
	PhaseSpaceEvent Rambo::generate_event() {
	    auto num_fsp_d = (double) fsp_masses.size();
	    m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) * pow(cme, 2.0 * num_fsp_d - 4.0) /
	            tgamma(num_fsp_d) / tgamma(num_fsp_d - 1.0) * pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	    return internal_generate_event();
	}
	
	/**
	 * Generate a set of Rambo events.
	 * @param num_events number of events to generate.
	 * @return nothing; events stored in 'events'.
	 */
	std::vector<PhaseSpaceEvent> Rambo::generate_events(size_t num_events) {
	    auto num_fsp_d = (double) fsp_masses.size();
	    m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) * pow(cme, 2.0 * num_fsp_d - 4.0) /
	            tgamma(num_fsp_d) / tgamma(num_fsp_d - 1.0) * pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	
	    m_events.clear();
	    size_t num_threads = std::thread::hardware_concurrency();
	
	    std::vector<std::thread> threads;
	
	    for (size_t n = 0; n < num_threads - 1; n++) {
	        threads.emplace_back([this](size_t num_points) {
	            this->internal_generate_events(num_points);
	        }, num_events / num_threads);
	    }
	    // add the remainder of points into last thread
	    threads.emplace_back([this](size_t num_points) {
	        this->internal_generate_events(num_points);
	    }, num_events / num_threads + (num_events % num_threads));
	    for (auto &thread: threads) {
	        thread.join();
	    }
	    return m_events;
	}
768918571d7a86cd3e3a367a5f74bca2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/phase_space/rambo.hpp|9|1|V|cpp
	#include <utility>
	#include <vector>
	#include <array>
	#include <algorithm>
	#include <thread>
	#include <mutex>
	#include <functional>
40573a541da8cb1c054fe26a551563e3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/phase_space/rambo.hpp|21|1|V|cpp
	class Rambo : public PhaseSpaceGenerator {
	private:
	    double compute_scale_factor(std::vector<FourVector> &);
	
	    void initialize_four_momenta(std::vector<FourVector> &);
	
	    void boost_four_momenta(std::vector<FourVector> &);
	
	    double correct_masses(std::vector<FourVector> &);
	
	    PhaseSpaceEvent internal_generate_event();
	
	    void internal_generate_events(std::size_t);
	
	public:
	    Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses, double cme)
	            : PhaseSpaceGenerator(isp_masses, fsp_masses, cme) {}
	
	    Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses, double cme,
	          std::function<double(const std::vector<FourVector> &)> t_mat_squared)
	            : PhaseSpaceGenerator(isp_masses, fsp_masses, cme, std::move(t_mat_squared)) {}
	
	    PhaseSpaceEvent generate_event();
	
	    std::vector<PhaseSpaceEvent> generate_events(std::size_t) override;
	};
	
	/* Function for finding the scaling parameter to turn mass-less four-vectors
	 * into four-vectors with the correct masses.
	 * @param momenta 4-momenta of final-state particles
	 */
	double Rambo::compute_scale_factor(std::vector<FourVector> &momenta) {
	    static thread_local const int MAX_ITER = 50;
	    static thread_local const double TOL = 1e-4;
	
	    double mass_sum = std::accumulate(fsp_masses.begin(), fsp_masses.end(), 0.0);
	
	    double xi = sqrt(1.0 - (mass_sum / cme) * (mass_sum / cme));
	
	    int iter_count = 0;
	    bool converged = false;
	    do { // Perform newton iterations to solve for xi
	        double f = -cme;
	        double df = 0.0;
	
	        for (size_t i = 0; i < fsp_masses.size(); i++) {
	            // Compute residual and derivative of residual
	            double m2 = fsp_masses[i] * fsp_masses[i];
	            double xi2 = xi * xi;
	            double e2 = momenta[i].t * momenta[i].t;
	            double del_f = sqrt(m2 + xi2 * e2);
	            f += del_f;
	            df += xi * e2 / del_f;
	        }
	
	        // Newton correction
	        double delta_xi = -(f / df);
	        xi += delta_xi;
	
	        iter_count++;
	        if (fabs(delta_xi) < TOL || iter_count >= MAX_ITER) {
	            converged = true;
	        }
	    } while (!converged);
	    return xi;
	}
	
	/**
	 * Initialize the four-momenta with isotropic, random four-momenta with energies,
	 * q, distributed according to q * exp(-q).
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::initialize_four_momenta(std::vector<FourVector> &momenta) {
	
	    std::uniform_real_distribution<double> distribution(0.0, 1.0);
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double rho1 = phase_space_uniform_rand();
	        double rho2 = phase_space_uniform_rand();
	        double rho3 = phase_space_uniform_rand();
	        double rho4 = phase_space_uniform_rand();
	
	        double c = 2.0 * rho1 - 1.0;
	        double phi = 2.0 * M_PI * rho2;
	
	        momenta[i].t = -log(rho3 * rho4);
	        momenta[i].x = momenta[i].t * sqrt(1.0 - c * c) * cos(phi);
	        momenta[i].y = momenta[i].t * sqrt(1.0 - c * c) * sin(phi);
	        momenta[i].z = momenta[i].t * c;
	    }
	}
	
	/**
	 * Boost the four-momenta into the center-of-mass frame and compute the
	 * initial weight of the event.
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::boost_four_momenta(std::vector<FourVector> &momenta) {
	    // Total momentum and its mass
	    FourVector Q = std::accumulate(momenta.begin(), momenta.end(), FourVector{});
	    double massQ = mass(Q);
	
	    // Boost three-vector
	    double bx = -Q.x / massQ;
	    double by = -Q.y / massQ;
	    double bz = -Q.z / massQ;
	    // Boost factors
	    double x = cme / massQ;
	    double gamma = Q.t / massQ;
	    double a = 1.0 / (1.0 + gamma);
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double qe = momenta[i].t;
	        double qx = momenta[i].x;
	        double qy = momenta[i].y;
	        double qz = momenta[i].z;
	
	        double b_dot_q = bx * qx + by * qy + bz * qz;
	
	        momenta[i].t = x * (gamma * qe + b_dot_q);
	        momenta[i].x = x * (qx + bx * qe + a * b_dot_q * bx);
	        momenta[i].y = x * (qy + by * qe + a * b_dot_q * by);
	        momenta[i].z = x * (qz + bz * qe + a * b_dot_q * bz);
	    }
	}
	
	/**
	 * Correct the masses of the four-momenta and correct the weight of the
	 * event.
	 * @param momenta 4-momenta of final-state particles
	 * @return new event weight factor
	 */
	double Rambo::correct_masses(std::vector<FourVector> &momenta) {
	    double xi = compute_scale_factor(momenta);
	
	    double term1 = 0.0;
	    double term2 = 0.0;
	    double term3 = 1.0;
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	        double m = fsp_masses[i];
	        double eng = momenta[i].t;
	        momenta[i].t = sqrt(m * m + (xi * eng) * (xi * eng));
	        momenta[i].x *= xi;
	        momenta[i].y *= xi;
	        momenta[i].z *= xi;
	
	        double mod = sqrt(momenta[i].x * momenta[i].x +
	                                  momenta[i].y * momenta[i].y +
	                                  momenta[i].z * momenta[i].z);
	        eng = momenta[i].t;
	
	        term1 += mod / cme;
	        term2 += mod * mod / eng;
	        term3 *= mod / eng;
	    }
	
	    term1 = pow(term1, 2.0 * fsp_masses.size() - 3.0);
	    term2 = 1.0 / term2;
	
	    // re-weight
	    return term1 * term2 * term3 * cme;
	}
	
	/**
	 * generate single phase space event
	 * @return event
	 */
	PhaseSpaceEvent Rambo::internal_generate_event() {
	    std::vector<FourVector> momenta(fsp_masses.size(), FourVector{});
	    double weight;
	
	    initialize_four_momenta(momenta);
	    boost_four_momenta(momenta);
	    weight = correct_masses(momenta) * mat_squared(momenta) * m_base_weight;
	
	    return PhaseSpaceEvent{momenta, weight};
	}
	
	/**
	 * Generate many phase space events.
	 * @param num_points
	 * @return vector of events
	 */
	void Rambo::internal_generate_events(size_t num_points) {
	    std::vector<PhaseSpaceEvent> local_events;
	    local_events.reserve(num_points);
	
	    for (size_t n = 0; n < num_points; n++)
	        local_events.emplace_back(internal_generate_event());
	
	    {
	        // Add events to class level event array. Avoid data races by lock guard.
	        std::lock_guard<std::mutex> lck(m_mtx);
	        for (auto &event:local_events)
	            m_events.emplace_back(event);
	    }
	}
	
	/**
	 * Generate a set of Rambo event.
	 * @return RamboEvent.
	 */
	PhaseSpaceEvent Rambo::generate_event() {
	    auto num_fsp_d = (double) fsp_masses.size();
	    m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) * pow(cme, 2.0 * num_fsp_d - 4.0) /
	            tgamma(num_fsp_d) / tgamma(num_fsp_d - 1.0) * pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	    return internal_generate_event();
	}
	
	/**
	 * Generate a set of Rambo events.
	 * @param num_events number of events to generate.
	 * @return nothing; events stored in 'events'.
	 */
	std::vector<PhaseSpaceEvent> Rambo::generate_events(size_t num_events) {
	    auto num_fsp_d = (double) fsp_masses.size();
	    m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) * pow(cme, 2.0 * num_fsp_d - 4.0) /
	            tgamma(num_fsp_d) / tgamma(num_fsp_d - 1.0) * pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	
	    m_events.clear();
	    size_t num_threads = std::thread::hardware_concurrency();
	
	    std::vector<std::thread> threads;
	
	    for (size_t n = 0; n < num_threads - 1; n++) {
	        threads.emplace_back([this](size_t num_points) {
	            this->internal_generate_events(num_points);
	        }, num_events / num_threads);
	    }
	    // add the remainder of points into last thread
	    threads.emplace_back([this](size_t num_points) {
	        this->internal_generate_events(num_points);
	    }, num_events / num_threads + (num_events % num_threads));
	    for (auto &thread: threads) {
	        thread.join();
	    }
	    return m_events;
	}
87a295542b75090a17da0e14a9e419d9|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/phase_space/base.hpp|15|1|V|cpp
	struct FourVector {
	    double t;
	    double x;
	    double y;
	    double z;
	};
	
	FourVector operator+(const FourVector &fv1, const FourVector &fv2) {
	    return FourVector{
	            fv1.t + fv2.t,
	            fv1.x + fv2.x,
	            fv1.y + fv2.y,
	            fv1.z + fv2.z
	    };
	}
	
	FourVector operator-(const FourVector &fv1, const FourVector &fv2) {
	    return FourVector{
	            fv1.t - fv2.t,
	            fv1.x - fv2.x,
	            fv1.y - fv2.y,
	            fv1.z - fv2.z
	    };
	}
	
	std::ostream &operator<<(std::ostream &os, const FourVector &fv) {
	    os << "FourVector(" << fv.t << ", " << fv.x << ", " << fv.y << ", " << fv.z << ")";
	    return os;
	}
	
	double mass(FourVector &fv) {
	    double m = fv.t * fv.t - fv.x * fv.x - fv.y * fv.y - fv.z * fv.z;
	    return m >= 0 ? std::sqrt(m) : -std::sqrt(-m);
	}
	
	
	double scalar_product(const FourVector &fv1, const FourVector &fv2) {
	    return fv1.t * fv2.t - fv1.x * fv2.x - fv1.y * fv2.y - fv1.z * fv2.z;
	}
	
	
	struct PhaseSpaceEvent {
	    std::vector<FourVector> momenta;
	    double weight;
	};
	
	class PhaseSpaceGenerator {
	protected:
	    const size_t phase_space_dim;
	    /* mutex lock for locking access to m_events */
	    std::mutex m_mtx;
	
	    /* common weight factor to all events */
	    double m_base_weight{};
	
	    /* private storage container for the events produced by generate_events */
	    std::vector<PhaseSpaceEvent> m_events;
	
	    /**
	     * Uniform random number generator that is thread-safe.
	     * @return random number between (0,1)
	     */
	    static double phase_space_uniform_rand() {
	        static thread_local std::random_device rd{};
	        static thread_local std::mt19937 generator{rd()};
	        std::uniform_real_distribution<double> distribution(0.0, 1.0);
	        return distribution(generator);
	    }
	
	public:
	    std::vector<double> isp_masses{};
	    std::vector<double> fsp_masses{};
	    double cme{};
	    std::function<double(const std::vector<FourVector> &)> mat_squared;
	
	    // Full constructor
	    PhaseSpaceGenerator(std::vector<double> isp_masses, std::vector<double> fsp_masses, double cme,
	                        std::function<double(const std::vector<FourVector> &mat_squared)> mat_squared)
	            : phase_space_dim(3 * fsp_masses.size() - 4), isp_masses(std::move(isp_masses)),
	              fsp_masses(std::move(fsp_masses)), cme(cme), mat_squared(std::move(mat_squared)) {}
	
	    // Constructor assuming constant matrix element
	    PhaseSpaceGenerator(std::vector<double> isp_masses, std::vector<double> fsp_masses, double cme)
	            : phase_space_dim(3 * fsp_masses.size() - 4),
	              isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	              cme(cme), mat_squared([](const std::vector<FourVector> &) { return 1.0; }) {}
	
	    virtual ~PhaseSpaceGenerator() = default;
	
	    /**
	     * Generate several events.
	     * @return Vector of PhaseSpaceEvent's containing four-momenta and weight.
	     */
	    virtual std::vector<PhaseSpaceEvent> generate_events(size_t num_events) = 0;
	
	    std::pair<double, double> compute_width_cross_section(size_t num_events);
	};
	
	/**
	 * Compute the decay width or scattering cross-section.
	 * @param num_events number of events to generate.
	 * @return average and standard-deviation.
	 */
	std::pair<double, double> PhaseSpaceGenerator::compute_width_cross_section(size_t num_events) {
	    generate_events(num_events);
	    auto num_events_d = (double) m_events.size();
	
	    // Compute average: <w_i> and average of squares: <w_i^2>
	    double avg = 0.0, avg2 = 0.0;
	    for (auto &event: m_events) {
	        double weight = event.weight;
	        avg += weight;
	        avg2 += weight * weight;
	    }
	    avg /= num_events_d;
	    avg2 /= num_events_d;
	
	    /* Compute the pre-factor of width or cross-section based on the number
	     * of initial state particles.
	     */
	    double pre_factor;
	    if (isp_masses.size() == 2) {
	        double m1 = isp_masses[0];
	        double m2 = isp_masses[1];
	        double eng1 = (cme * cme + m1 * m1 - m2 * m2) / (2.0 * cme);
	        double eng2 = (cme * cme - m1 * m1 + m2 * m2) / (2.0 * cme);
	        double p = sqrt((m1 - m2 - cme) * (m1 + m2 - cme) * (m1 - m2 + cme) *
	                                (m1 + m2 + cme)) / (2.0 * cme);
	
	        double v1 = p / eng1, v2 = p / eng2;
	        double v_rel = v1 + v2;
	
	        pre_factor = 1.0 / (2.0 * eng1 * 2.0 * eng2 * v_rel);
	
	    } else {
	        pre_factor = 1.0 / (2.0 * cme);
	    }
	
	    /* Compute standard deviation:
	     *  var = <x^2> - <x>^2
	     *  sig = sqrt(var / N)
	     */
	    double var = avg2 - avg * avg;
	    double sig = sqrt(var / num_events_d);
	    if (isnan(sig)) sig = avg * 1e-12;
	    return std::make_pair(pre_factor * avg, pre_factor * sig);
	}
c2ba35d37228408a61903894bf898420|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/phase_space/base.hpp|8|1|V|cpp
	#include <array>
	#include <random>
	#include <iostream>
19571498b726029aa1a5f5e08805faf6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|8|1|V|cpp
	#include <array>
cade08f855fbbce89cca28faaa73d51c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|42|1|V|cmake
	# --------------------------------------------------------------------------
	# test_model.cpp: Make sure everything compiles
	# --------------------------------------------------------------------------
	
	add_executable(test_model test_model.cpp)
	set_property(TARGET test_model PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_model PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_model PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
a543436fe37a12870a86694656f9b460|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|116|25|v|cmake
	Make sure everything compiles
b48696fd5c92756a58e30ecbac6dc155|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|124|3|V|cmake
	 	GSL::gslcblas
3e601717a29af396972d60b81f3b592b|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_phase_space_rambo.cpp|13|1|V|cpp
	double mat_squared_mu_to_e_nu_nu(const std::vector<FourVector> &momenta) {
	    double s = scalar_product(momenta[1] + momenta[2], momenta[1] + momenta[2]);
	    double t = scalar_product(momenta[0] + momenta[2], momenta[0] + momenta[2]);
	    return -16 * kG_FERMI * kG_FERMI * (s + t) * (s + t - kMUON_MASS * kMUON_MASS);
	}
	
	double mat_squared_ttbar_higgs_ttbar(const std::vector<FourVector> &momenta) {
	    double Q = momenta[0].t + momenta[1].t;
	    FourVector p1{Q / 2, 0.0, 0.0, sqrt(Q * Q / 4.0 - kTOP_QUARK_MASS * kTOP_QUARK_MASS)};
	
	    double s = Q * Q;
	    double t = scalar_product(p1 - momenta[0], p1 - momenta[0]);
	
	    return (9 * pow(kALPHA_EM, 2) * pow(M_PI, 2) * pow(kTOP_QUARK_MASS, 4) * pow(s - 4 * pow(kTOP_QUARK_MASS, 2), 2)) /
	            (pow(s - pow(kHIGGS_MASS, 2), 2) * pow(kW_BOSON_MASS, 4) * pow(kSIN_THETA_WEAK, 4)) +
	            (9 * pow(kALPHA_EM, 2) * pow(M_PI, 2) * pow(kTOP_QUARK_MASS, 4) * pow(t - 4 * pow(kTOP_QUARK_MASS, 2), 2)) /
	                    (pow(t - pow(kHIGGS_MASS, 2), 2) * pow(kW_BOSON_MASS, 4) * pow(kSIN_THETA_WEAK, 4)) -
	            (3 * pow(kALPHA_EM, 2) * pow(M_PI, 2) * pow(kTOP_QUARK_MASS, 4) *
	                    (s * t + 4 * (s + t) * pow(kTOP_QUARK_MASS, 2) - 16 * pow(kTOP_QUARK_MASS, 4))) /
	                    ((s - pow(kHIGGS_MASS, 2)) * (-t + pow(kHIGGS_MASS, 2)) * pow(kW_BOSON_MASS, 4) *
	                            pow(kSIN_THETA_WEAK, 4));
	}
96e06ec992758ebacf64909dd4f08b09|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/test_phase_space_rambo.cpp|39|1|V|cpp
	TEST(TestRambo, TestMomentumConservationAndMasses) {
	    std::vector<double> isp_masses = {1.0, 2.0};
	    std::vector<double> fsp_masses = {3.0, 4.0};
	    double cme = 10.0;
	
	    Rambo rambo{isp_masses, fsp_masses, cme};
	    auto events = rambo.generate_events(100);
	
	    for (auto &event:events) {
	        FourVector sum = event.momenta[0] + event.momenta[1];
	        ASSERT_NEAR(sum.t, cme, 1e-3);
	        ASSERT_NEAR(sum.x, 0.0, 1e-3);
	        ASSERT_NEAR(sum.y, 0.0, 1e-3);
	        ASSERT_NEAR(sum.z, 0.0, 1e-3);
	
	        ASSERT_NEAR(mass(event.momenta[0]), fsp_masses[0], 1e-3);
	        ASSERT_NEAR(mass(event.momenta[1]), fsp_masses[1], 1e-3);
	    }
	}
	
	/**
	 * Check the 2->2 proccess with top quark annihilation into t tbar through the
	 * SM Higgs boson.
	 */
	TEST(TestRambo, TestTopQuarkAnnihilationHiggs) {
	
	    double Q = 10.0 * kTOP_QUARK_MASS;
	    std::vector<double> isp_masses = {kTOP_QUARK_MASS, kTOP_QUARK_MASS};
	    std::vector<double> fsp_masses = {kTOP_QUARK_MASS, kTOP_QUARK_MASS};
	    Rambo rambo{isp_masses, fsp_masses, Q, mat_squared_ttbar_higgs_ttbar};
	
	    double s = Q * Q;
	    double cs = (
	            (3 * pow(kALPHA_EM, 2) * M_PI * pow(kTOP_QUARK_MASS, 4) *
	                    ((log(pow(kHIGGS_MASS, 2) / (s + pow(kHIGGS_MASS, 2) - 4 * pow(kTOP_QUARK_MASS, 2))) *
	                            (s - pow(kHIGGS_MASS, 2)) *
	                            (-6 * pow(kHIGGS_MASS, 4) + 7 * pow(kHIGGS_MASS, 2) * (s + 4 * pow(kTOP_QUARK_MASS, 2)) -
	                                    4 * (5 * s * pow(kTOP_QUARK_MASS, 2) + 4 * pow(kTOP_QUARK_MASS, 4)))) /
	                            (s - 4 * pow(kTOP_QUARK_MASS, 2)) +
	                            (6 * pow(kHIGGS_MASS, 8) + 48 * pow(s, 2) * pow(kTOP_QUARK_MASS, 4) -
	                                    10 * pow(kHIGGS_MASS, 6) * (s + 4 * pow(kTOP_QUARK_MASS, 2)) + pow(kHIGGS_MASS, 4) *
	                                    (3 * pow(s, 2) + 52 * s * pow(kTOP_QUARK_MASS, 2) + 112 * pow(kTOP_QUARK_MASS, 4)) +
	                                    pow(kHIGGS_MASS, 2) * (7 * pow(s, 3) - 72 * pow(s, 2) * pow(kTOP_QUARK_MASS, 2) +
	                                            32 * s * pow(kTOP_QUARK_MASS, 4) - 192 * pow(kTOP_QUARK_MASS, 6))) /
	                                    (pow(kHIGGS_MASS, 2) * (s + pow(kHIGGS_MASS, 2) - 4 * pow(kTOP_QUARK_MASS, 2))))) /
	                    (16. * s * pow(s - pow(kHIGGS_MASS, 2), 2) * pow(kW_BOSON_MASS, 4) * pow(kSIN_THETA_WEAK, 4))
	    );
	
	    auto res = rambo.compute_width_cross_section(1000000);
	    std::cout << "avg = " << std::get<0>(res) << " +- " << std::get<1>(res) << std::endl;
	    std::cout << "actual = " << cs << std::endl;
	
	    ASSERT_NEAR(std::get<0>(res), cs, 3.0 * std::get<1>(res));
	}
	
	/**
	 * Check 1->3 proccess with of muon decay into an electron and two neutrinos.
	 */
	TEST(TestRambo, TestMuonDecay) {
	
	    std::vector<double> isp_masses = {kMUON_MASS};
	    std::vector<double> fsp_masses = {kELECTRON_MASS, 0.0, 0.0};
	    Rambo rambo{isp_masses, fsp_masses, kMUON_MASS, mat_squared_mu_to_e_nu_nu};
	
	    double width = (pow(kG_FERMI, 2) * pow(kMUON_MASS, 5)) / (192.0 * pow(M_PI, 3));
	
	    auto res = rambo.compute_width_cross_section(100000);
	    std::cout << "avg = " << std::get<0>(res) << " +- " << std::get<1>(res) << std::endl;
	    std::cout << "actual = " << width << std::endl;
	
	    ASSERT_NEAR(std::get<0>(res), width, 3.0 * std::get<1>(res));
	}
5513f78bb92055f8e92c75063f0eb8ec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_phase_space.cpp|30|1|V|cpp
	TEST(TestPhaseSpace, 
629422a87b9ec52cfaadce7bf49541d2|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|10|1|V|cpp
	static constexpr double kG_FERMI = 1.1663787e-5;
77e73d15189c42ebd8a864a21691982f|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|24|1|V|cpp
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
67a767acbe1928f2215f6b6519a370ce|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|32|1|V|cpp
	static constexpr double kTOP_QUARK_MASS = 172.9;
b3b22dbfe5eedf16959b740499671a63|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|35|1|V|cpp
	static constexpr double kHIGGS_MASS = 125.10;
900c98300e8aea0531ed9f31e8959c31|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|12|1|V|cpp
	static constexpr double kALPHA_EM = 1.0 / 137.0; //at p^2 = 0
2f5c37df6d33e546df0e0c9baadcaca1|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|14|1|V|cpp
	static constexpr double kSIN_THETA_WEAK_SQRD = 0.23122;
2372203a27820b9514e33e73e85305ef|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|13|1|V|cpp
	static constexpr double kSIN_THETA_WEAK = 0.480853;
b511977a953e9900fcbefd57a166c0b4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|33|1|V|cpp
	static constexpr double kW_BOSON_MASS = 80.379;
d546d3b0d39c546783c18eb3ffc73259|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/apps/CMakeLists.txt|9|1|V|cmake
	add_executable(${INITIAL_DATA_GENERATOR_APP} initial_data_generator.cpp)
	include_directories(${Boost_INCLUDE_DIRS})
	target_link_libraries(${INITIAL_DATA_GENERATOR_APP}
	        thdm
	        ${ARMADILLO_LIBRARIES}
	        ${Boost_LIBRARIES}
	        ${Boost_THREAD_LIBRARY}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${INITIAL_DATA_GENERATOR_APP} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
cb07215fcfaa941b8265e16fbe3143df|file:///Users/loganmorrison/CLionProjects/thdm_one_loop_extrema/thdm/apps/CMakeLists.txt|6|1|V|cmake
	set(INITIAL_DATA_GENERATOR_APP initial_data_generator)
f2331a45dadc979f39d7bfddf744baba|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|13|9|V|cmake
	        ${ARMADILLO_LIBRARIES}
d7fa2cb361fadc0c219c08ba99c9ed4b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|14|9|V|cmake
	        ${Boost_THREAD_LIBRARY}
ab8ec65f394a3926a28e173153780f31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|20|1|V|cmake
	# Applications
	add_subdirectory(apps)
0431096d6243c7c69fedff224bfade08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|6|1|V|cpp
	    FourVector &p1,
b358bad94556257125ff364bacb442de|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|48|1|V|rust
	    (p1.dot(&q) * p2.dot(&p3) + p2.dot(&q) * p3.dot(&p1) + p3.dot(&q) * p1.dot(&p2))
	        * (p4.dot(&q) * p5.dot(&p6) + p5.dot(&q) * p6.dot(&p4) + p6.dot(&q) * p4.dot(&p5))
	        / (q.dot(&q) - 1.0)
4dd8fc8b454426dd6db2a23172f7db9a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|13|3|V|cpp
	  scalar_product
ee53f550164e5d95b2db97b9c7f02343|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|14|23|v|cpp
	.dot(
61235c9828a88791a7e55e5afd87325a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|14|145|v|cpp
	.dot(&
d5228ae3636735c45bfd2e5dd0aaca16|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|5|33|v|cpp
	FourVector &p1, FourVector &p2, FourVector &p3,
	                                FourVector &p4, FourVector &p5, FourVector &p6
14f6f8daa89146d9adbfe13e37e8aded|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|63|1|V|rust
	    p1.dot(&p4) * p2.dot(&p6) * p3.dot(&p5)
	        + p1.dot(&p4) * p2.dot(&p5) * p3.dot(&p6)
	        + p1.dot(&p3) * p2.dot(&p6) * p4.dot(&p5)
	        + p1.dot(&p2) * p3.dot(&p6) * p4.dot(&p5)
	        + p1.dot(&p6)
	            * (p2.dot(&p5) * p3.dot(&p4) + p2.dot(&p4) * p3.dot(&p5) + p2.dot(&p3) * p4.dot(&p5))
	        + p1.dot(&p3) * p2.dot(&p5) * p4.dot(&p6)
	        + p1.dot(&p2) * p3.dot(&p5) * p4.dot(&p6)
	        + p1.dot(&p5)
	            * (p2.dot(&p6) * p3.dot(&p4) + p2.dot(&p4) * p3.dot(&p6) + p2.dot(&p3) * p4.dot(&p6))
	        + p1.dot(&p4) * p2.dot(&p3) * p5.dot(&p6)
	        + p1.dot(&p3) * p2.dot(&p4) * p5.dot(&p6)
	        + p1.dot(&p2) * p3.dot(&p4) * p5.dot(&p6)
354238efb2f075f77d73142995575ab1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|7|33|v|cpp
	FourVector &p1, FourVector &p2, FourVector &p3,
	                                FourVector &p4, FourVector &p5, FourVector &p6,
	                                FourVector &q
17f588132cfaa5f330b52cc2f1454e6c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|5|33|v|cpp
	FourVector&
4c5704b55953a7d76f520fca669e4c25|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|9|1|V|cpp
	double mat_elem_2_to_4_diag_4pt(FourVector &p1, FourVector &p2, FourVector &p3,
	                                FourVector &p4, FourVector &p5, FourVector &p6,
	                                FourVector &q) {
	  return (scalar_product(p1, q) * scalar_product(p2, p3) +
	          scalar_product(p2, q) * scalar_product(p3, p1) +
	          scalar_product(p3, q) * scalar_product(p1, p2)) *
	         (scalar_product(p4, q) * scalar_product(p5, p6) +
	          scalar_product(p5, q) * scalar_product(p6, p4) +
	          scalar_product(p6, q) * scalar_product(p4, p5)) /
	         (scalar_product(q, q) - 1.0);
	}
2136569b9edda1d9c4b672cc59c582c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|10|1|V|cpp
	double mat_elem_2_to_4_diag_6pt(FourVector &p1, FourVector &p2, FourVector &p3,
	                                FourVector &p4, FourVector &p5,
	                                FourVector &p6) {
f036e678f39c4457df4fe0938611111d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|14|1|V|cpp
	double mat_elem_2_to_4_diag_6pt(FourVector &p1, FourVector &p2, FourVector &p3,
	                                FourVector &p4, FourVector &p5,
	                                FourVector &p6) {
	  return scalar_product(p1, p4) * scalar_product(p2, p6) *
	             scalar_product(p3, p5) +
	         scalar_product(p1, p4) * scalar_product(p2, p5) *
	             scalar_product(p3, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p2) * scalar_product(p3, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p6) *
	             (scalar_product(p2, p5) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p5) +
	              scalar_product(p2, p3) * scalar_product(p4, p5)) +
	         scalar_product(p1, p3) * scalar_product(p2, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p5) *
	             (scalar_product(p2, p6) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p6) +
	              scalar_product(p2, p3) * scalar_product(p4, p6)) +
	         scalar_product(p1, p4) * scalar_product(p2, p3) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p4) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p4) *
	             scalar_product(p5, p6);
	}
a0b129455bc30f3e046b9fdfcbb98742|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|13|1|V|cpp
	std::tuple<double, double, double> scaled_cross_section_2_4(double z);
e1c237982910b27f83196d083e642e02|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|85|1|V|rust
	    let nevents = 500000;
c9077732a294f90a75acea3ce5f2a4e8|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|85|19|v|rust
	500000
9a998fda1c01bc86621060bbe324e633|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|69|1|V|cpp
	  FourVector p1{z / 2.0, 0.0, 0.0, p};
f6fe675780c40e70d1c562f945ba6d96|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|72|1|V|cpp
	  auto msqrd44 = [](std::vector<FourVector>&fm){
	  };
4ac3986f2badc1480056dffb47b37079|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|77|3|V|cpp
	  };
246b3afc471af781f869c3631714b10a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|73|1|V|cpp
	    auto p3 = fm[0];
6db5b640e5b536393fc6f3b3d415d8c5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|78|5|V|cpp
	    auto q = p4 + p5 + p6;
d31a4a3fd025a78cc554269b32dea74e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|89|59|v|cpp
	-p2 + 
890c406d9d1f4207774d186b3aae35f1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|117|1|V|rust
	        (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 + diag8 + diag9 + diag10).powi(2)
2a1b3b4dd334c2b13880dc52cc258e08|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|3|1|V|cpp
	#include <boost/math/special_functions/pow.hpp>
52a10408e3bc7d52696c2080d1bbdc3b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|75|1|V|cpp
	    const FourVector p3 = fm[0];
	    const FourVector p4 = fm[1];
	    const FourVector p5 = fm[2];
	    const FourVector p6 = fm[3];
f6e1db2bfcae1c9566bf7419327380ef|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|125|1|V|rust
	        mat_elem_2_to_4_diag_6pt(&p1, &p2, &p3, &p4, &p5, &p6).powi(2)
b4d14cb0e80afd650f48a04644f1d7f4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|80|1|V|cpp
	    const double diag1 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p3, p4, p5, p6, (p4 + p5 + p6));
	    const double diag2 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p4, p3, p5, p6, (p3 + p5 + p6));
	    const double diag3 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p5, p4, p3, p6, (p3 + p4 + p6));
	    const double diag4 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p6, p4, p5, p3, (p3 + p4 + p5));
	    const double diag5 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p4, p2, p5, p6, (p5 + p6 - p2));
	    const double diag6 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p5, p4, p2, p6, (p4 + p6 - p2));
	    const double diag7 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p6, p4, p5, p2, (p4 + p5 - p2));
	    const double diag8 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p5, p2, p3, p6, (p3 + p6 - p2));
	    const double diag9 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p6, p2, p5, p3, (p3 + p5 - p2));
	    const double diag10 =
	        mat_elem_2_to_4_diag_4pt(p1, p5, p6, p4, p2, p3, (p3 + p4 - p2));
	    double sum = (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 +
	                  diag8 + diag9 + diag10);
dcea72e49c79055e9a490afb8f64dc96|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|110|1|V|cpp
	    const double diag = mat_elem_2_to_4_diag_6pt(p1, p2, p3, p4, p5, p6);
1bb04c241dae74f4111c6b44c1c05414|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|66|1|V|cpp
	  const std::vector<double> fsp_masses = {1.0, 1.0, 1.0, 1.0};
d26f09d0e3a9cf2d8940120ba46fabfe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|66|51|v|cpp
	, 1.0, 1.0
946d6f42382b5042829f0f1b342677ae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|66|1|V|cpp
	  const std::vector<double> isp_masses = {1.0, 1.0};
	  const std::vector<double> fsp_masses = {1.0, 1.0, 1.0, 1.0};
	  const double nevents = 500000;
b2a9629f9d17f470e3be9ea91390efbc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|145|15|v|cpp
	= Rambo
6ff78d6ac2e48b669d4b043a5fd2d9f5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|145|1|V|cpp
	  Rambo rambo{isp_masses, fsp_masses, z};
c007751f3d5bc4defed16a106af1b744|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|146|48|v|cpp
	, msqrd44
96a9b06c832efa002160804601c9cc2b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|146|1|V|cpp
	  Rambo ram44 = Rambo(isp_masses, fsp_masses, z, msqrd44);
979ea33f4992d6794347d17f40170857|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|149|3|V|cpp
	  Rambo ram66{isp_masses, fsp_masses, z, msqrd66};
3d9cb7b9c49faa1db117632905354997|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|149|3|V|cpp
	  Rambo ram46{isp_masses, fsp_masses, z, msqrd46};
2cb5cacf99ae9a156d3221eb8a74c36b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|148|3|v|cpp
	Rambo 
2cb5cacf99ae9a156d3221eb8a74c36b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|148|3|v|cpp
	Rambo 
2cb5cacf99ae9a156d3221eb8a74c36b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|148|3|v|cpp
	Rambo 
1a71bc883c5288d18f9aff81e40627b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|150|3|V|cpp
	  ram44.compute_width_cross_section(nevents)
1c60db8c74bcee3ccbc86b398a3237c1|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|37|1|V|rust
	/// Template matrix element squared for the various diagrams that contribute
	/// to 2eta <-> 4eta using only 4pt interactions.
891495dda3db39a68b79565edc44ea60|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|24|1|V|cpp
	/**
	 */
f3a888a5994a0ef843b8056753b7997b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|19|1|V|cpp
	/**
	 * Template matrix element squared for the various diagrams that contribute
	 * to 2eta <-> 4eta using only 4pt interactions.
	 */
1d403416b151a7c9f87daf320f851348|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/generate_cs_data.rs|77|1|V|rust
	/// Compute the integrated squared matrix element for 2eta -> 4eta in the
	/// center of mass frame with scaled center-of-mass energy z = cme / meta.
a38aeb3be401edcd5c805560d2dbbb99|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|20|1|V|cpp
	  std::cout << ca
	  return 0; 
	}
1096ab4795fd8f547278a7dd92159f06|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|21|1|V|cpp
	  auto res1 = scaled_cross_section_2_4(zs[0]);
2c2f36265d27ea314aa2ddb24615423b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|25|3|V|cpp
	  std::cout << ca
227cec51d05b5f8cd6ce557d3214255f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|20|3|V|cpp
	  const std::vector<double> zs = {4.1, 10, 100};
29c4a7ca099fecb96d51a511f67970e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|20|1|V|cpp
	  const double z1 = 4.1;
1b148ecd1d14bfb5d80be56acbea646c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|21|21|v|cpp
	4.1;
ebc1a969e79325fe9b8be70d2b940980|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|1|V|cpp
	      std::get<0>(res1)
3bd249239cc0b976d679ec515c9d8ca5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|25|1|V|cpp
	  fmt::print("logz, cs44, cs66, cs46 = ({}, {}, {}, {}", log(z1),
	             std::get<0>(res1), std::get<1>(res1), std::get<2>(res1));
92ae79d7086d3c7d3ebbff0087bf9529|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|33|1|V|cpp
	auto res1 = scaled_cross_section_2_4(zs[0]);
805a50a56f0ca14692411c51d98f625e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|38|1|V|cmake
	find_package(fmt REQUIRED)
4df50e110031e763572042f8fa70db43|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|30|1|V|cpp
	    ("zmin", "minimum value of z. Must be larger than 4")
e383234c8c5c6cf7eb44a3208e26d50f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|31|15|v|cpp
	minimum
dc45c17965b890221389a2cf677b9228|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|31|35|v|cpp
	Must be larger than 4
0f420a87413a8b6ff6476be8c63db4a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|43|1|V|cpp
	  const double z1 = 4.0 + 1e-5;
209e74805126c52ba0b61350a6b8938c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|37|1|V|cpp
	  double zmin = 4.0 + 1e-5;
150b9cfc4d86823491d0c200eaa670b9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|38|1|V|cpp
	  double zmax = 4.0 + 1e-5;
9f95db6331c27734e1d9e27f8dba7dfb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|39|19|v|cpp
	4.0 + 1e-5;
0c40c45948a58ad8c34a13c2c1e568ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|40|3|V|cpp
	  char* ofile = "
e218687b43275788476fc9a93a817282|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|47|1|V|cpp
	  if (vm.count("zmin")){
	    zmin = vm["zmin"].as<double>();
	    std::cout << "Using zmin = " << zmin << std::endl;
	  }
0242d984114f31743e16fa0e79dd9e2c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|51|1|V|cpp
	  if (vm.count("zmax")){
	    zmax = vm["zmax"].as<double>();
	    std::cout << "Using zmax = " << zmax << std::endl;
	  }
91b641c464c0dc87660499321a356d93|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|55|17|v|cpp
	zmax
4554000d17a8f12491dc6be88b02d699|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|44|1|V|cpp
	  if (vm.count("help")){
	    std::cout << desc << std::endl;
	  }
657f8b8da628ef83cf69101b6817150a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|44|18|v|cpp
	help
197bf51f3d6d81eabb308af3aced0dd4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|28|1|V|cpp
	  po::option_description desc("Allowed options");
	  desc.add_options()("help", "produce help message")(
	      "zmin", po::value<double>(),
	      "Minimum value of z = cme / meta. Must be larger than 4")(
	      "zmax", po::value<double>(), "Maximum value of z = cme / meta.")(
	      "num_zs", po::value<int>(), "Number of zs")(
	      "file", po::value<const char *>(), "Name of the output file");
	  po::variables_map vm;
	  po::notify(vm);
	
	  double zmin = 4.0 + 1e-5;
	  double zmax = 100;
	  double num_zs = 500;
	  std::string ofile = "";
	
	
	  if (!vm.count("file")){
	    std::cout << desc << std::endl;
	  }
	
	
	  if (vm.count("help")){
	    std::cout << desc << std::endl;
	  }
	  if (vm.count("zmin")){
	    zmin = vm["zmin"].as<double>();
	    std::cout << "Using zmin = " << zmin << std::endl;
	  }
	  if (vm.count("zmax")){
	    zmax = vm["zmax"].as<double>();
	    std::cout << "Using zmax = " << zmax << std::endl;
	  }
	  if (vm.count("num_zs")){
	    num_zs = vm["num_zs"].as<int>();
	    std::cout << "Using num_zs = " << num_zs << std::endl;
	  }
99ee9646af64ffcef443175526261584|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|6|1|v|cpp
	#include <boost/program_options.hpp>
06a97025f5f30e00a1fcbca1f358aa9b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|14|1|V|cpp
	namespace po = boost::program_options;
e1b4eae2f621abd46c9e2fcafe061aec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|3|V|cpp
	  boost::ProgressBar progress
875458c97e9824297badeebd5577d938|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|34|10|v|cpp
	ProgressBar 
6422062c1e6a93b7c95157a7dc0305ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|34|3|v|cpp
	boost::progress_display
557ea47efb6e86d5f3a1add814f5972a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|3|V|cpp
	  const double z = 10.0;
5a51c02302024b0093f27fdeea7c8c11|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|31|1|V|cpp
	  const double logz_step = (logz_max - logz_min) / double(num_zs - 1);
f6a122c24e4c2f34d9f7bad187fb2c26|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|32|21|v|cpp
	_step
dafa19f84bdec42a150edb18a8f69045|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|32|3|V|cpp
	  const double logcss = (logz_max - logz_min) / double(num_zs - 1);
c826611bc0c5d775b9fa60ed909d65cf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|36|5|V|cpp
	    logzs[i] = log(
4b2223e54df2e6ad5fab9104d9d4339c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|28|27|v|cpp
	log10(
2ca17e8eaa59ec19f99799e0a4ceefda|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|31|29|v|cpp
	logz_max 
9a3aa228d6feffaaeccf078dfcc2fd7a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|31|42|v|cpp
	logz_min
26c8c43b5c98c04761036ee498d1762f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|38|5|V|cpp
	    log_css[i] = 
b912fe5737597b09d2d5ec171b38bd92|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|37|16|v|cpp
	scaled_cross_section_2_4(pow(10.0, logz))
32aa5a73e673db130924e302db890d3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|34|55|v|cpp
	(num_zs);
993efa9906ce90442a64aea28f809b6f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|45|3|V|cpp
	  boost::progress_display progress(num_zs);
165ac2743f7c983d1d28dfc36456fec8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|51|1|V|cpp
	  auto res1 = scaled_cross_section_2_4(z1);
	  auto res2 = scaled_cross_section_2_4(z2);
	  auto res3 = scaled_cross_section_2_4(z3);
	  fmt::print("logz, cs44, cs66, cs46 = ({:e}, {:e}, {:e}, {:e})\n", log10(z1),
	             log10(std::get<0>(res1)), log10(std::get<1>(res1)),
	             log10(std::get<2>(res1)));
	  fmt::print("logz, cs44, cs66, cs46 = ({:e}, {:e}, {:e}, {:e})\n", log10(z2),
	             log10(std::get<0>(res2)), log10(std::get<1>(res2)),
	             log10(std::get<2>(res2)));
	  fmt::print("logz, cs44, cs66, cs46 = ({:e}, {:e}, {:e}, {:e})\n", log10(z3),
	             log10(std::get<0>(res3)), log10(std::get<1>(res3)),
	             log10(std::get<2>(res3)));
5075140835d0bc504791c76b04c33d2b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|6|17|v|cpp
	process
04a78e1c5e85edb352ceaa498f092475|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|40|5|V|cpp
	    auto res = ;
2d5a0e88c5da727e430503c6592a2ed6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|43|1|V|cpp
	        std::get<0>(log_css.back())
8e64cae706a1db3536621febca6321e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|392|3|V|cpp
	  std::cout << "# threads = " << num_threads << std::endl;
c8ce869aa4bf32ab83130bca915abae3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|352|1|V|cpp
	  std::cout << "Here" << std::endl;
1c75c5f8783e204546d7ec69521c6fe7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|46|5|v|cpp
	//++
d497525994157e9fdd88828935d5e487|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|55|v|cpp
	rundata
eefe0cb10c72d848e8bc16023b663f2d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|21|v|cpp
	(
	      "~/Documents/research/SUN_DM/cpp/darksun/apps/cs_data.dat");
0acbb07ff2dd2e7203a5317ac3d75d4a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|47|v|cpp
	 << std::endl;
d6fe1d0be6347b8ef2427fa629c04485|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|15|v|cpp
	path
e4059ce1670f4107c02cd99e496c9f89|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|30|3|V|cpp
	  std::string
430b1a3b5913cc87f8ddb263b714d6af|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|30|46|v|cpp
	std::filesystem::path(
517b089ef84136b1194e4e75b46a18ee|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|32|14|v|cpp
	~/Documents/research/SUN_DM/cpp/darksun/apps/cs_data.dat");
1a2dd2c4b83d856d73a06cca76d01034|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|40|1|V|cpp
	  std::vector<double> log_zs;
	  std::vector<std::tuple<double, double, double>> log_css;
	  log_zs.reserve(num_zs);
	  log_css.reserve(num_zs);
6a63c9d63897b2921d57c7b86e6c2aba|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|42|20|V|cpp
	    log_zs.push_back(logz);
a138e143761d2673ce55a7aa4d66f8a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|42|5|v|cpp
	log_css.emplace_back(
b5c57a3d4ceb3c9d522ede912edcbffb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|389|3|V|cpp
	  //  m_events.clear();
c72bed5a318767d2e2ce40d32ff0253f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|391|51|v|cpp
	internal_generate_event
ffc92c458b8c2fae185c283126663580|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|6|11|v|cpp
	execution
c7efb18ffc1308b04e0b8fd904fcdc96|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/CMakeLists.txt|20|38|V|cmake
		/usr/local/opt/gcc/include/c++/10.1.0
3c703d650d4223eb77502f67abbd3308|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|6|20|V|cpp
	#include <execution>
e1f6c04c398f13b8f4fbc86b5739a283|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|390|51|V|cpp
	  auto gen = [this]() { return internal_generate_event(); };
	  std::generate(std::execution::par_unseq, m_events.begin(), m_events.end(),
	                gen);
f914824deb1ef5aaae7b13d52219e05b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/bin/cs_data.dat|1|3735|V|csv
	0.6020615.76349e-21,5.88602e-22,1.83712e-210.6161822.20326e-06,2.26121e-07,7.05934e-070.6303023.78195e-05,3.9032e-06,1.21286e-050.6444230.000235256,2.43421e-05,7.56667e-050.6585430.000963861,0.000100312,0.0003114820.6726640.00314859,0.000328824,0.001016060.6867850.00885233,0.000929568,0.00286710.7009050.0224784,0.00237574,0.007298210.7150260.0529847,0.00562093,0.01724220.7291460.117744,0.0125712,0.03846890.7432670.250579,0.0268614,0.08205930.7573880.514065,0.0552583,0.1683940.7715081.0201,0.110284,0.3349920.7856291.977,0.214486,0.652050.7997493.75018,0.408832,1.238220.813876.97621,0.763637,2.30980.82799112.7765,1.40292,4.233840.84211123.0701,2.54179,7.66370.85623241.1208,4.55277,13.69310.87035272.5748,8.05309,24.18280.884473126.681,14.1264,42.27360.898594219.249,24.5335,73.43810.912714377.008,42.2509,126.180.926835644.364,72.2536,215.720.9409551091.28,122.975,366.5320.9550761836.64,207.906,617.4270.9691973080.19,349.572,1037.040.9833175144.13,584.888,1734.220.9974388540.18,974.863,2882.651.0115614110.7,1618.79,4772.191.0256823302.6,2666.8,7882.681.039838339.9,4400.43,12947.81.0539262733.6,7218.54,21233.11.06804102414,11834,34787.51.08216166968,19273.5,56788.71.09628271334,31412.1,92186.11.1104439079,51053.3,1495231.12452713192,82754.5,2424921.138641.15151e+06,133692,3926741.152761.85636e+06,216611,6325421.166882.98495e+06,349251,1.01967e+061.181014.79665e+06,562230,1.64111e+061.195137.69972e+06,904390,2.64191e+061.209251.23615e+07,1.45201e+06,4.23535e+061.223371.98575e+07,2.3275e+06,6.77897e+061.237493.17191e+07,3.72859e+06,1.08567e+071.251615.06482e+07,5.96756e+06,1.73909e+071.265738.10666e+07,9.53196e+06,2.77573e+071.279851.29111e+08,1.52377e+07,4.42629e+071.293972.06247e+08,2.43004e+07,7.07186e+071.308093.28607e+08,3.87164e+07,1.12552e+081.322215.21928e+08,6.17193e+07,1.79302e+081.336338.30919e+08,9.80026e+07,2.86228e+081.350451.32043e+09,1.56717e+08,4.54263e+081.364572.09591e+09,2.48342e+08,7.22194e+081.378693.32975e+09,3.95175e+08,1.14732e+091.392815.29464e+09,6.27659e+08,1.8206e+091.406948.40086e+09,9.9654e+08,2.88786e+091.421061.32815e+10,1.57963e+09,4.5797e+091.435182.1146e+10,2.51239e+09,7.27193e+091.44933.34705e+10,3.97578e+09,1.15067e+101.463425.30138e+10,6.30266e+09,1.82426e+101.477548.38673e+10,9.98622e+09,2.88959e+101.491661.32972e+11,1.58329e+10,4.57977e+101.505782.10736e+11,2.50512e+10,7.2552e+101.51993.32423e+11,3.95923e+10,1.14762e+111.534025.26419e+11,6.2666e+10,1.81649e+111.548148.32281e+11,9.92505e+10,2.86838e+111.562261.31873e+12,1.57369e+11,4.53931e+111.576382.08263e+12,2.48352e+11,7.16411e+111.59053.29372e+12,3.91681e+11,1.13473e+121.604625.20194e+12,6.21291e+11,1.79319e+121.618748.20705e+12,9.80377e+11,2.83147e+121.632861.29724e+13,1.5515e+12,4.47265e+121.646992.05144e+13,2.4515e+12,7.07562e+121.661113.24222e+13,3.87424e+12,1.11887e+131.675235.12723e+13,6.12133e+12,1.76753e+131.689358.08172e+13,9.65367e+12,2.78684e+131.703471.27606e+14,1.5249e+13,4.40383e+131.717592.0168e+14,2.4116e+13,6.9436e+131.731713.18513e+14,3.80445e+13,1.09802e+141.745835.02454e+14,5.99438e+13,1.73452e+141.759957.92482e+14,9.47664e+13,2.73944e+141.774071.25252e+15,1.49801e+14,4.31867e+141.788191.9711e+15,2.36767e+14,6.81168e+141.802313.1167e+15,3.72523e+14,1.07523e+151.816434.91534e+15,5.88281e+14,1.69894e+151.830557.75658e+15,9.28279e+14,2.6798e+151.844671.22406e+16,1.46198e+15,4.22431e+151.858791.93028e+16,2.3057e+15,6.65966e+151.872913.04712e+16,3.64443e+15,1.0506e+161.887044.80994e+16,5.74686e+15,1.65885e+161.901167.57929e+16,9.08476e+15,2.6153e+161.915281.19361e+17,1.43205e+16,4.12945e+161.92941.88605e+17,2.25777e+16,6.51557e+161.943522.97241e+17,3.56283e+16,1.0275e+171.957644.69477e+17,5.60329e+16,1.62036e+171.971767.40439e+17,8.85592e+16,2.5542e+171.985881.16476e+18,1.39755e+17,4.03469e+1721.84325e+18,2.2047e+17,6.35415e+17
7bc19defccc84c893799aa3cd560b655|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|197|32|V|cpp
	  const double nevents = 500000;
4e6d25845933049b3cb6e446c32899cc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|197|6|V|cpp
	  const double nevents = ;
7c8318d8050a15783aa7b72d0e15568a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|65|10|v|cpp
	(scalar_product(p1, q) * scalar_product(p2, p3) +
	          scalar_product(p2, q) * scalar_product(p3, p1) +
	          scalar_product(p3, q) * scalar_product(p1, p2)) *
	         (scalar_product(p4, q) * scalar_product(p5, p6) +
	          scalar_product(p5, q) * scalar_product(p6, p4) +
	          scalar_product(p6, q) * scalar_product(p4, p5)) /
	         (scalar_product(q, q) - 1.0)
c067cfaae33e706d0bebc7699e16cd9c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|67|5|v|cpp
	-1 + 
6789d809efdbd79cc6323ac1bbe5e7fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|130|1|V|cpp
	    const double diag1 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p3, p4, p5, p6, (p4 + p5 + p6));
	    const double diag2 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p4, p3, p5, p6, (p3 + p5 + p6));
	    const double diag3 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p5, p4, p3, p6, (p3 + p4 + p6));
	    const double diag4 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p6, p4, p5, p3, (p3 + p4 + p5));
	    const double diag5 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p4, p2, p5, p6, (p5 + p6 - p2));
	    const double diag6 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p5, p4, p2, p6, (p4 + p6 - p2));
	    const double diag7 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p6, p4, p5, p2, (p4 + p5 - p2));
	    const double diag8 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p5, p2, p3, p6, (p3 + p6 - p2));
	    const double diag9 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p6, p2, p5, p3, (p3 + p5 - p2));
	    const double diag10 =
	        mat_elem_2_to_4_diag_4pt(p1, p5, p6, p4, p2, p3, (p3 + p4 - p2));
60b92cb7102679a9d46094b008c7ce0a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|150|1|V|cpp
	    double sum = (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 +
	                  diag8 + diag9 + diag10);
94d90d0fff252ddfc90767c907804faf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|65|10|v|cpp
	((scalar_product(p1, q) * scalar_product(p2, p3) +
	           scalar_product(p1, p3) * scalar_product(p2, q) +
	           scalar_product(p1, p2) * scalar_product(p3, q)) *
	          (scalar_product(p4, q) * scalar_product(p5, p6) +
	           scalar_product(p4, p6) * scalar_product(p5, q) +
	           scalar_product(p4, p5) * scalar_product(p6, q))) /
	         (scalar_product(q, q) - 1.0);
a856ea8b32df558e77ed82ad85f4e2a7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|61|8|v|cpp
	mat_elem
245532328d1bd49d4eec40f4bfd58a65|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|61|11|v|cpp
	_2_to_4_diag
ff1d4b2cc263c7944178564992192630|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|63|16|v|cpp
	const FourVector &q
862567ee20167b5d4a67313e523fe56b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|21|33|v|cpp
	const FourVector &
eb111897079bcd62286538874329f29d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|250|10|v|cpp
	scalar_product(p1, p4) * scalar_product(p2, p6) *
	             scalar_product(p3, p5) +
	         scalar_product(p1, p4) * scalar_product(p2, p5) *
	             scalar_product(p3, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p2) * scalar_product(p3, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p6) *
	             (scalar_product(p2, p5) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p5) +
	              scalar_product(p2, p3) * scalar_product(p4, p5)) +
	         scalar_product(p1, p3) * scalar_product(p2, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p5) *
	             (scalar_product(p2, p6) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p6) +
	              scalar_product(p2, p3) * scalar_product(p4, p6)) +
	         scalar_product(p1, p4) * scalar_product(p2, p3) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p4) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p4) *
	             scalar_product(p5, p6);
776e6c3d14fd9df9fc13e130d598c448|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|308|18|v|cpp
	diag
726a67bacf7f6c1a8394bc5d240c975c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|299|1|V|cpp
	    double amp = amp_4pt(p1, p2, p3, p4, p5, p6);
6b182b239cd2e525858285782999e6cc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|317|1|V|cpp
	    const double diag1 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p3, p4, p5, p6, (p4 + p5 + p6));
	    const double diag2 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p4, p3, p5, p6, (p3 + p5 + p6));
	    const double diag3 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p5, p4, p3, p6, (p3 + p4 + p6));
	    const double diag4 =
	        mat_elem_2_to_4_diag_4pt(p1, p2, p6, p4, p5, p3, (p3 + p4 + p5));
	    const double diag5 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p4, p2, p5, p6, (p5 + p6 - p2));
	    const double diag6 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p5, p4, p2, p6, (p4 + p6 - p2));
	    const double diag7 =
	        mat_elem_2_to_4_diag_4pt(p1, p3, p6, p4, p5, p2, (p4 + p5 - p2));
	    const double diag8 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p5, p2, p3, p6, (p3 + p6 - p2));
	    const double diag9 =
	        mat_elem_2_to_4_diag_4pt(p1, p4, p6, p2, p5, p3, (p3 + p5 - p2));
	    const double diag10 =
	        mat_elem_2_to_4_diag_4pt(p1, p5, p6, p4, p2, p3, (p3 + p4 - p2));
	    double sum = (diag1 + diag2 + diag3 + diag4 + diag5 + diag6 + diag7 +
	                  diag8 + diag9 + diag10);
	    const double diag11 = mat_elem_2_to_4_diag_6pt(p1, p2, p3, p4, p5, p6);
620c7365a3a115049d09b1670416fb8d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|308|1|V|cpp
	    const double amp = amp_6pt(p1, p2, p3, p4, p5, p6);
b210a44f73cdc1872d1cc872e40b3eb3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|321|19|v|cpp
	diag11
473179be15dd7c37a3c4d91a300e8839|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|54|1|V|cpp
	/**
	 * Compute the ampltude for 2eta -> 4eta using only the 4pt eta interaction
	 * with all prefactors removed. Note, the removed prefactor is:
	 *    pf = 256 pi^4 lec1^2 meta^8 / (9 lam^8 N^2)
	 */
b8521b7157063fddd03476d606d620a7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|245|1|v|cpp
	/**
	 * Template matrix element squared for the various diagrams that contribute
	 * to 2eta <-> 4eta using only 6pt interactions.
	 */
6074c6aa3488f3c2dddff2a7ca821aab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|247|43|v|cpp
	5555
a16f000066d3c1afd988ae708c4aa21c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/bin/cs_data_44.dat|1|1|V|csv
	-20.23950740177372
	-8.26182692745449
	-7.1721708251976795
	-6.519343539322965
	-6.045844840790325
	-5.670891068339153
	-5.356521661416255
	-5.0861109470341574
	-4.84804208977013
	-4.633048739124271
	-4.437703566014508
	-4.257164934640316
	-4.0898047662639545
	-3.9328361173971564
	-3.7847432389214237
	-3.644789928119485
	-3.511514150506523
	-3.3850016009239887
	-3.2630619634769085
	-3.145595569755695
	-3.0333088216331547
	-2.9247633597938796
	-2.8191547215679567
	-2.717214802447883
	-2.6181740169354146
	-2.5222379101289856
	-2.4277919583448275
	-2.3362613934267005
	-2.2469135614950035
	-2.1591953288814576
	-2.0739803067343736
	-1.989577067218535
	-1.9075214770705697
	-1.8272482433617436
	-1.7479264867783117
	-1.6700004244508064
	-1.593100610764566
	-1.518265073599124
	-1.4439678110160645
	-1.3707963828014156
	-1.299160478923495
	-1.228186979713259
	-1.1575573967027117
	-1.0885227828938977
	-1.0203478440471807
	-0.9529705880860944
	-0.8858261986972856
	-0.820617708669486
	-0.7544453853128407
	-0.6906978061395729
	-0.6270953580156969
	-0.5634827444025002
	-0.500421504576037
	-0.43832153144538755
	-0.3773467222508631
	-0.31645318007103074
	-0.25545512089202715
	-0.19648757678377918
	-0.13660813418409695
	-0.0775553416234558
	-0.019186549776841328
	0.03908480309995165
	0.0966945495056654
	0.15396417502320436
	0.21080525618465054
	0.2670919047844852
	0.3228867678213647
	0.3784505945712887
	0.4339633437806058
	0.4889368976337791
	0.5438570500705913
	0.5981654169517324
	0.6516297663697814
	0.7052640062265113
	0.7587408647319371
	0.8120224739033912
	0.8646659043596711
	0.9172875198951975
	0.96953472130831
	1.021433262671651
	1.0735900587673903
	1.12522419139717
	1.1760594096258483
	1.227230913327773
	1.2780513049663411
	1.3283286269163594
	1.3793091444116974
	1.4291916946205927
	1.4790438128429315
	1.528896141472382
	1.5788752003597954
	1.627400680697409
	1.6774600341507493
	1.7259059178563754
	1.7749736471225777
	1.8240086171898284
	1.8724959971324573
	1.9202798946329485
	1.9683736607087958
	2.0166615243274677
	2.0644505013264727
	2.1119376325367294
	2.159741597821957
	2.207165625741656
	2.2546519860058556
	2.301425023931899
	2.348744777178231
	2.395621647883181
	2.4419997417389148
	2.4889538028296516
	2.5353308372660446
	2.5819542071264734
	2.627768211971893
	2.6739364779064316
	2.720018651943208
	2.766090725094074
	2.8113222641018867
	2.856972244548282
	2.9027315461671943
	2.948626148125628
	2.9933405428985673
	3.0395806659430904
	3.0834632018756225
	3.1287933155449688
	3.174571467548145
	3.219055087314749
	3.2637946103835334
	3.308502519519666
	3.3532447569204025
	3.3974098459390505
	3.4415993132678926
	3.4860633342451717
	3.5301856058231134
	3.574641167783488
	3.619273901124588
	3.662351670887225
	3.7068525718855154
	3.750720476243363
	3.7945187180595563
	3.8383786650652403
	3.8814782397160474
	3.925719889215124
	3.968721511492647
	4.01262635095405
	4.056062112448185
	4.099497632702221
	4.142680358495144
	4.185740417574961
	4.228787765451861
	4.27208539329047
	4.315029404515987
	4.357942466135056
	4.400486181791203
	4.443826031377536
	4.4868213804553365
	4.529713887917377
	4.572333626499389
	4.615298647432903
	4.6572662529537485
	4.70009077386584
	4.742883741551868
	4.784427559351184
	4.8270434299859675
	4.869733216262761
	4.911619367241782
	4.953932602162159
	4.99569923734437
	5.038834673483903
	5.080449703191668
	5.12267778742849
	5.164766131228934
	5.206550645749979
	5.248706286104546
	5.290786736810575
	5.3322505616611116
	5.374168900317869
	5.416595577998939
	5.45752614408629
	5.499748923948431
	5.541305851903171
	5.583097842635704
	5.624770788913776
	5.665779801726022
	5.707453497005982
	5.749016273870339
	5.791598728829303
	5.83169448605643
	5.873954429942057
	5.914927817840694
	5.955669473970686
	5.99773097436055
	6.039358589391083
	6.0801681438229025
	6.121750196116055
	6.162394120147866
	6.203196124935032
	6.245053454814325
	6.285975650324549
	6.32699090552036
	6.368130622375794
	6.409041651832982
	6.450007252925498
	6.4907350172881335
	6.531773881632743
	6.572751980562958
	6.6140319822010385
	6.654763549941894
	6.696164977359848
	6.736791570351865
	6.777981118391875
	6.818334783593388
	6.858695367445906
	6.899430337338585
	6.940137806348829
	6.981052141888169
	7.021408459072693
	7.062138062629021
	7.103047321846789
	7.1438513388222145
	7.183497610559352
	7.224867006860835
	7.266266984623656
	7.3053771683525195
	7.347167978611605
	7.387268776581958
	7.427559134539206
	7.468149341545365
	7.508307464933965
	7.548759056086051
	7.589379844241917
	7.6300982150160905
	7.670276475323358
	7.71115149772437
	7.751029543974956
	7.7917102935604605
	7.831325125678854
	7.871479528839012
	7.9122348140776735
	7.95279195888052
	7.99323160093681
	8.033278966526815
	8.073568062119588
	8.113472054195492
	8.153610621727326
	8.194097885578952
	8.233977876849826
	8.274603465436023
	8.314787539155361
	8.354500280353221
	8.395127113670029
	8.434840253297574
	8.474644517884027
	8.51469382103857
	8.555443921038687
	8.59503081449093
	8.635410352888679
	8.675619804417384
	8.71597828746114
	8.755485339854209
	8.79554843724842
	8.835947901896425
	8.875692558047636
	8.915007051212015
	8.954896354019404
	8.996157788152232
	9.035065338365529
	9.074929751863117
	9.114310676868424
	9.154898485615991
	9.194825035717566
	9.234815821607878
	9.27527448978514
	9.31454764395139
	9.354594346439928
	9.395156836575309
	9.434884929860134
	9.473993230118909
	9.514449460829718
	9.554485525725166
	9.594025510413065
	9.633829880552668
	9.673243068916424
	9.71302155432737
	9.752923840568341
	9.793077613011507
	9.8321415230496
	9.872097974274226
	9.911942359511983
	9.951298654016089
	9.991564073407076
	10.031880881209773
	10.07032606857333
	10.110225962631329
	10.150145235400895
	10.190656596996861
	10.230178041535886
	10.269692695589724
	10.309583329220843
	10.349120103624175
	10.388836249866063
	10.428069969119063
	10.468307444393515
	10.507565795608066
	10.547478102796267
	10.587242751998474
	10.62607231573411
	10.666103143579662
	10.70550621263606
	10.745600937634908
	10.784953045738472
	10.82438880521467
	10.863808046939456
	10.904322176537129
	10.943772909338827
	10.982705310518886
	11.0226798839395
	11.06245035989562
	11.102519458368336
	11.141292960081593
	11.18063903760307
	11.220607501059579
	11.260009341484233
	11.299653273815366
	11.339262576558127
	11.37901891577903
	11.418279741822273
	11.45841573558019
	11.497468723709966
	11.53716527320239
	11.576416222110453
	11.616046784447665
	11.655906418180216
	11.695210157580508
	11.735447189468635
	11.774544701297192
	11.813865088326471
	11.853576543619642
	11.89265437031377
	11.932309858613895
	11.97073960956241
	12.011096563128872
	12.050089614073691
	12.089848614173558
	12.129783313456093
	12.1691863867008
	12.208425231344094
	12.248027243112483
	12.28776591035151
	12.326534525694026
	12.366682522365776
	12.405628056408847
	12.445443842733411
	12.48477516718838
	12.52448699634374
	12.562955104564482
	12.602329170469828
	12.642869936279077
	12.682029489904922
	12.720921338295414
	12.760381766406894
	12.799915780860395
	12.839042906469173
	12.878986861919273
	12.918956158857757
	12.957604414099224
	12.99768775183471
	13.036768581598269
	13.076877002378335
	13.115067720507671
	13.155056541307458
	13.194813943335676
	13.234000682241797
	13.272998955820324
	13.31267866442537
	13.352464235583389
	13.39166714106929
	13.430578106879937
	13.469658572726772
	13.509339646306952
	13.549269400527185
	13.58775472892437
	13.627303371052047
	13.667478169256823
	13.706359277466857
	13.745245039138323
	13.784395453416444
	13.824228698087751
	13.863879946408696
	13.902711442997402
	13.942621092120143
	13.981921847392723
	14.021404325001805
	14.0608677484319
	14.100518731442143
	14.13917357188699
	14.178844625506922
	14.218065246401412
	14.257810522759359
	14.29665641654701
	14.33537163501966
	14.376085817197714
	14.414744447874453
	14.453595038155154
	14.493589086381851
	14.532345363784474
	14.571798475840671
	14.610674000683805
	14.650530928146397
	14.689812135851318
	14.729729167697904
	14.768405724835915
	14.807624313082876
	14.84736780150428
	14.886099684143899
	14.926104651618193
	14.964654606641789
	15.004566401533477
	15.044171159237141
	15.083663837854232
	15.122602474069781
	15.161879868444915
	15.201470866179095
	15.240733908970528
	15.280100110054924
	15.318920637435676
	15.358193822618642
	15.397249800864618
	15.436703190083218
	15.476331568895535
	15.515542700362122
	15.555159769298117
	15.594498624622007
	15.63367646311495
	15.6725051644665
	15.711453746609088
	15.751542372952075
	15.790574362750133
	15.82945301580674
	15.86915835297991
	15.909058873395562
	15.94763660667444
	15.986656653368927
	16.02580951859101
	16.065908205378843
	16.10483181522299
	16.144515052361275
	16.18376508409018
	16.223054413179106
	16.262104465133056
	16.30181319058285
	16.34046791114608
	16.38033065627538
	16.42018191903228
	16.458711861604282
	16.498081627165554
	16.536756607335796
	16.576235355594957
	16.61518805376585
	16.654575986086435
	16.694145217428627
	16.73264300548965
	16.77321724873098
	16.8123945661063
	16.851477275817473
	16.890785851742233
	16.930071409849482
	16.96876024809485
	17.008753425124176
	17.04736054932258
	17.087472618346354
	17.12619636792053
	17.165555908930905
	17.204659800787937
	17.243293586816083
	17.283436924527777
	17.32232475344577
	17.361826013237366
	17.40080383782921
	17.440189382518128
	17.47971923543957
	17.518566578443117
	17.55829807628348
	17.59850051566538
	17.636339428522955
	17.675812240975144
	17.71520919537866
	17.754580712831313
	17.79334538896684
	17.83254531527684
	17.872699820720612
	17.911635336259923
	17.9504865566277
	17.990146088285996
	18.028998017852636
	18.068886848341606
	18.108402640301552
	18.147398039347653
	18.18593009858452
	18.22566071122322
	18.26522596239455
5221712a538ef5bcdf921d17c4cb2561|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/bin/cs_data_66.dat|1|1|V|csv
	-21.230568759758295
	-9.252801118520273
	-8.162302370629703
	-7.509549879643981
	-7.035231868757337
	-6.659488465679137
	-6.345515420529976
	-6.075042916508595
	-5.835676891431706
	-5.6206020118499795
	-5.424697821310542
	-5.243470386819696
	-5.075413714230881
	-4.918465474569413
	-4.769586845522422
	-4.629135472099636
	-4.4956678076455105
	-4.368683087854066
	-4.24652112300161
	-4.128782701074565
	-4.016084730368427
	-3.90630171532527
	-3.8006535369623626
	-3.698425306487682
	-3.5985942890768268
	-3.501867336568739
	-3.407340344678831
	-3.316310105294472
	-3.2266283068236734
	-3.138018979417365
	-3.052069525518032
	-2.9675383871025653
	-2.884852316718583
	-2.804426882729951
	-2.724760073766454
	-2.646818788647696
	-2.5698539660092767
	-2.4938414590099742
	-2.4194308127467585
	-2.3455712361345085
	-2.273518933758805
	-2.202068710809034
	-2.1313014985395644
	-2.061562338215723
	-1.992960981596935
	-1.925329811075993
	-1.8585815847339124
	-1.7917226099270573
	-1.7267324423066097
	-1.6611392827371856
	-1.5970202611162845
	-1.533169437070027
	-1.4706928672204214
	-1.408298894384993
	-1.3463167731714756
	-1.2847464612392765
	-1.2236417389813712
	-1.1633347868996164
	-1.103633641115358
	-1.044784314444477
	-0.9853366799535288
	-0.9272612906488872
	-0.8694218085907336
	-0.8120254811946291
	-0.7546600973046758
	-0.6978098176557146
	-0.6417985627887528
	-0.585459491770991
	-0.5301485413261948
	-0.47422463735458503
	-0.4195083950783458
	-0.3649205764798042
	-0.31103942658195954
	-0.2568392221026467
	-0.20267635776421788
	-0.14939970813011733
	-0.09628291045426296
	-0.043616397253304934
	0.008672548144370431
	0.06180670682034146
	0.11351552862303035
	0.1656093006877331
	0.21702571929008865
	0.26904804708126767
	0.32002782600705915
	0.3704631252801323
	0.42161379708680413
	0.4715997161416706
	0.5223216225625228
	0.5723731549541632
	0.6219797102392567
	0.6719453660828917
	0.7214816794834362
	0.770861580737171
	0.8191449910650253
	0.868721417468099
	0.9176866466169784
	0.9665153000353851
	1.0148102517682114
	1.0630893047267806
	1.1111280363451241
	1.1589050211875438
	1.207006569680732
	1.2551880507429405
	1.3019843940704392
	1.3498173880536133
	1.397077512540581
	1.444086973549812
	1.4916333931162302
	1.5382242475479597
	1.5847076759101015
	1.631389986226223
	1.6779899847740474
	1.724388116120535
	1.7710205440839057
	1.816243952163727
	1.8629085955363476
	1.9087707013882949
	1.95456521508013
	1.9998010475637018
	2.045307328253064
	2.0918005661129366
	2.1367776239970926
	2.182266247889239
	2.2271279541968942
	2.2719321718778436
	2.317281737179793
	2.3625785970061655
	2.4068142955227514
	2.452258838222522
	2.4969683732431163
	2.541802573618903
	2.586035647986175
	2.630229498521153
	2.6744110041656257
	2.7187183668513106
	2.7628210549461514
	2.8066289651659906
	2.851124981486924
	2.8952772043571713
	2.9395661738554466
	2.9832495548287272
	3.0270232545887037
	3.0701265645075604
	3.1140068214777115
	3.1580457035256546
	3.201099298333666
	3.244519565135515
	3.287642758012378
	3.3307586366782567
	3.3744385487593798
	3.417224166165742
	3.4610045248366736
	3.503499240402074
	3.5468078475952267
	3.589413380063756
	3.6325160040200286
	3.6754547909021147
	3.717760347739038
	3.7608339634072787
	3.8035172025519435
	3.8461161967925257
	3.888962540220508
	3.9314014189084046
	3.973486229649883
	4.0162266402067655
	4.0587523819205575
	4.100649644726378
	4.142877303978689
	4.185360806841445
	4.227313263061791
	4.269711366791274
	4.311679706886967
	4.353635454057692
	4.396239460797677
	4.437492128276394
	4.480396482791054
	4.521950970567874
	4.563292375486906
	4.605937168666971
	4.647220568393497
	4.688726745482613
	4.730871869932524
	4.7728547107449
	4.8141443386039455
	4.855611213917548
	4.8979117632140525
	4.9384391630831335
	4.9804760632131915
	5.0213753854036725
	5.0638622979259935
	5.105264866848612
	5.145948076398738
	5.1878815429420895
	5.229236314872972
	5.270730063571576
	5.3121032745521735
	5.352996298632683
	5.394108312386723
	5.435830037850957
	5.476901156419219
	5.517662942310334
	5.558422946003502
	5.600085986405523
	5.640752662085261
	5.681788284697414
	5.722367341847019
	5.764101376476227
	5.8048887446223905
	5.845474472185478
	5.886701053248753
	5.9271865446816605
	5.9682101446351
	6.009085288668008
	6.050341081834084
	6.090589556608069
	6.131599418967825
	6.17235477543979
	6.213089892407061
	6.254069291823112
	6.294336138790013
	6.334988247719099
	6.37580439398349
	6.416489060253622
	6.456750046881982
	6.497385832537447
	6.538089658061993
	6.578165696988588
	6.619525322232681
	6.659973215296316
	6.700076912039588
	6.741067253983981
	6.78137906239368
	6.8222792549891
	6.861961923685119
	6.902222704097922
	6.943139713676668
	6.983495031887948
	7.023556976466458
	7.064820997513947
	7.104309533243186
	7.145028500346318
	7.185244590963389
	7.22514380468751
	7.265906913096373
	7.305697377177627
	7.3456422630712295
	7.386711156183228
	7.4270915593792255
	7.467519313989927
	7.507091812786419
	7.547332804385882
	7.5872551094258185
	7.627726253377093
	7.667200708661177
	7.707279697763807
	7.747814838773309
	7.78799433555427
	7.827816262859679
	7.868341090322328
	7.908640479198835
	7.948366012485739
	7.988263678957582
	8.028095219851796
	8.068438198892634
	8.108673245632698
	8.148278663810057
	8.189091489282445
	8.22814103932
	8.269347133492806
	8.308863088365301
	8.34885176854287
	8.388360563529679
	8.428677323121082
	8.467973439909244
	8.50804060986463
	8.547505186954798
	8.588099075503731
	8.627707831250003
	8.668096912204907
	8.70768852650579
	8.74734188006852
	8.78758514802261
	8.827020146123575
	8.867621260984652
	8.906762659773028
	8.946646278593981
	8.986323328862214
	9.026398420281078
	9.066169327447929
	9.10528872328422
	9.146028757021524
	9.185295616397996
	9.22556512988341
	9.264713957562066
	9.304397885637583
	9.344508201082062
	9.38411854842467
	9.423637381872679
	9.463652642727334
	9.502558207966684
	9.542995875867588
	9.581893932280279
	9.622353928245431
	9.662372460429447
	9.701976185385321
	9.741732109129066
	9.781026872076078
	9.82036305792312
	9.861150724147963
	9.89961917066734
	9.939782245607475
	9.97967764229086
	10.019182780205982
	10.05847157743314
	10.099055331846191
	10.137518681593061
	10.177594209647827
	10.217017814619085
	10.257061486490818
	10.29556490099751
	10.3360572746584
	10.375059753585813
	10.415086917830674
	10.45450033548455
	10.494495492715362
	10.533676752181512
	10.573232590056193
	10.613362882946852
	10.652676553337413
	10.691489943677183
	10.731118763863831
	10.771655081528948
	10.811085478582296
	10.849889082344024
	10.889907610776332
	10.929906594434273
	10.968538049089421
	11.008719373494715
	11.048134814359242
	11.087983615712119
	11.126955686604104
	11.166533716391982
	11.20609964671074
	11.244976872084814
	11.284850161237584
	11.324173353407351
	11.363767997068217
	11.403266405884153
	11.44293734016577
	11.48282215095364
	11.522004499728402
	11.56100711719925
	11.600707230854672
	11.640755641640315
	11.67951147662839
	11.719358636729217
	11.758948964734827
	11.797664942737669
	11.837838969025825
	11.87685841432022
	11.916658150546162
	11.956146330857594
	11.995344690441373
	12.03477279645335
	12.07387591385086
	12.113067198699351
	12.153037009614923
	12.192383438518037
	12.231632675104736
	12.270865088739779
	12.311060555293635
	12.349959038828965
	12.389348626941478
	12.429143195024592
	12.467790071618197
	12.50801094917718
	12.546987833843028
	12.587244998829599
	12.626320859619767
	12.665578177005713
	12.704747475862046
	12.744070692670789
	12.783650643383604
	12.823076922356712
	12.862215485896314
	12.901898931232145
	12.941106266577663
	12.980019287843781
	13.019722632472812
	13.059173248517066
	13.098671409045133
	13.138207932668163
	13.17704565746214
	13.215893888049935
	13.256089657134034
	13.295248133745986
	13.334522106939666
	13.373641960822955
	13.41320417524013
	13.452715414590463
	13.491871340459655
	13.531736862440603
	13.571552783775392
	13.610174503691036
	13.649815627201274
	13.688665378136834
	13.727881890052204
	13.76729466965598
	13.806624897843294
	13.846082152224643
	13.885474302829158
	13.924982893272862
	13.964066724773202
	14.003710351909811
	14.042504633577078
	14.08174684774132
	14.121385828924815
	14.160804551625267
	14.199612582425651
	14.239462152641385
	14.278380862094341
	14.31795474776832
	14.357477454138898
	14.396873810909106
	14.435927141501171
	14.475081076687495
	14.51468319954017
	14.553919418511436
	14.593323733785914
	14.632091683071272
	14.671979565883124
	14.710871011760744
	14.750306242740796
	14.790259119661027
	14.829288330974922
	14.868465747345569
	14.907972141436218
	14.947651794716963
	14.986644561387594
	15.025424665429405
	15.064884586286276
	15.104599767437843
	15.14357059135425
	15.182614347736349
	15.222232496347283
	15.26180034731504
	15.300636781201465
	15.339977840866407
	15.380113514458449
	15.418763519148397
	15.458024116236944
	15.496879853494654
	15.536249023803023
	15.57602444155125
	15.615415530123407
	15.654564441049045
	15.693324116665428
	15.732672744612861
	15.77290746235513
	15.811072059106909
	15.85085628734985
	15.889911527949598
	15.929840242399631
	15.968289107225916
	16.007722180322105
	16.04752407700657
	16.08659827119328
	16.125390168165737
	16.165517344135033
	16.20397881400816
	16.243229096230955
	16.28276481531666
	16.321697828413228
	16.361446397551358
	16.4009315253186
	16.43947322457793
	16.47957818914776
	16.51854683972881
	16.557556523408945
	16.596620184086444
	16.636644334546737
	16.67548046378947
	16.714644886171087
	16.754352923304555
	16.79323634088177
	16.833268263810975
	16.871472522526066
	16.911499048428098
	16.95021438325052
	16.989945680327036
	17.028298716538945
	17.06779222002612
	17.107501663273037
	17.1470483845182
	17.186125355161515
	17.225030002638167
	17.264588813918984
	17.303774731032956
	17.342602283669873
4bded5aa63f86302b129bedeaca8167a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/bin/cs_data_46.dat|1|1|V|csv
	-20.734451100879674
	-8.757575359947017
	-7.666836974058505
	-7.014391223378398
	-6.540628624291228
	-6.165436886340575
	-5.851440530030877
	-5.580859111226253
	-5.341730012641716
	-5.126999277625956
	-4.930761230729006
	-4.750346789202402
	-4.582662850973971
	-4.425605235188984
	-4.277053629464064
	-4.136399993769419
	-4.003679249234956
	-3.87632145824325
	-3.7546600973046758
	-3.637410095891803
	-3.5237482039929664
	-3.4152697247719974
	-3.3099457535723236
	-3.207424124646887
	-3.108336565025557
	-3.0124079110416027
	-2.9177066301167214
	-2.8256755656268604
	-2.736416002536664
	-2.648959729537279
	-2.5629601056505824
	-2.4789482605286737
	-2.3966953687142074
	-2.315766131753396
	-2.236178324756301
	-2.1587675823928674
	-2.081495240668012
	-2.006661662133325
	-1.9317176390907032
	-1.8585188707291964
	-1.786086644164769
	-1.715172378321687
	-1.6446461927554807
	-1.5753633353498027
	-1.5069255243881254
	-1.43959834613742
	-1.3721898334866707
	-1.3059593119380006
	-1.2409451317368665
	-1.176169873471725
	-1.1118570265580734
	-1.0482871293227554
	-0.9853240838579349
	-0.9233304344573275
	-0.8622061191382822
	-0.8007523444261404
	-0.7401768512225431
	-0.6801072995206259
	-0.6203845120736016
	-0.5614086079760636
	-0.5026376561713882
	-0.4437698876789014
	-0.38616134816821496
	-0.329226447224933
	-0.2720912933948026
	-0.21572728447900624
	-0.15938522549218817
	-0.10369649819966212
	-0.04837838815737441
	0.006876609403363761
	0.06132805399157764
	0.11586336051185649
	0.17020595779452025
	0.2243750615165119
	0.2781360067154778
	0.33096339646308015
	0.38380818749991635
	0.43710656894185107
	0.4889538028296514
	0.5412658897924626
	0.5935330571548317
	0.6454301298115658
	0.6966568829440579
	0.7481484733861832
	0.7987721480479469
	0.8494710100762191
	0.9002502084927645
	0.9505157600940135
	1.0008157071013302
	1.0508860734457648
	1.100370545117563
	1.1497762537244463
	1.1994370168023378
	1.2484588157797814
	1.2970203768265722
	1.3463568869959146
	1.3945444838437504
	1.4429561341483574
	1.491413525888971
	1.5401041338998749
	1.5874404286541692
	1.6354113583687235
	1.6833586813569557
	1.7307685523897334
	1.7784095787553045
	1.8255812416018744
	1.8725123065402134
	1.9199808000293557
	1.9668866714687667
	2.0136460297473247
	2.0603540452005986
	2.1060514381183606
	2.152587965365356
	2.1990829264957132
	2.2447964787476224
	2.291666271390471
	2.3369937677091697
	2.3832227420787353
	2.4283858992001304
	2.4738648972455475
	2.5197322022539725
	2.5646944640525575
	2.6103971650002418
	2.6552297039278634
	2.700545369774794
	2.74575772138095
	2.7905201966265203
	2.8353455349077055
	2.8801576553791466
	2.924638464475725
	2.969538913971766
	3.0138984727308737
	3.058304526489531
	3.1021351542721747
	3.146664368265019
	3.191031608848618
	3.234818350715004
	3.2782092489627654
	3.3223785068568445
	3.3656826250011935
	3.410297980175922
	3.453877669079202
	3.497381687563492
	3.541268387532114
	3.584801455393751
	3.62823153364921
	3.671488494327553
	3.71473284607444
	3.758732538657395
	3.8014153733776306
	3.844748602624074
	3.887831019635978
	3.9305430587087815
	3.9734788434380746
	4.01678689078579
	4.059165668942177
	4.1017951735195926
	4.144947633670373
	4.187289411537507
	4.230224051910522
	4.272799712658736
	4.314953704624502
	4.357380196065705
	4.400106070428544
	4.442783825524572
	4.484460712093363
	4.526784975980321
	4.5696957067602755
	4.611121887669944
	4.654079272132999
	4.695780151357523
	4.737434380400301
	4.779719836458638
	4.822195548933356
	4.86382706283288
	4.906175519748821
	4.94764640547235
	4.9896544574189745
	5.031254919062388
	5.07319394854708
	5.114777731971562
	5.156158292180021
	5.198555373172088
	5.240107241112675
	5.281387934193896
	5.322529394341455
	5.365102190037342
	5.405715089200449
	5.447182847460731
	5.488430845962476
	5.530276557681541
	5.571638966487158
	5.613206293880048
	5.654762588282579
	5.695563099072425
	5.737042283974334
	5.777565281527705
	5.818930225673249
	5.8596581782872965
	5.901364041470292
	5.942750433965836
	5.983182746612613
	6.024493877347127
	6.065650659880603
	6.106816211825169
	6.147583582421641
	6.188605102128683
	6.229638333914494
	6.270366683987736
	6.310655084251761
	6.3515296207683365
	6.392491186082689
	6.433419377675667
	6.474778442576163
	6.5148424947468655
	6.55557565599115
	6.5973397086343155
	6.637198434391746
	6.678250618154213
	6.718764013175521
	6.759367889111627
	6.799751900305726
	6.840773340763993
	6.880833592224041
	6.9217291226680455
	6.96242758500374
	7.002908696607174
	7.043711930975164
	7.084229418760225
	7.124145425061654
	7.164914695337107
	7.20517187187372
	7.246153765786101
	7.286004874172612
	7.325952611366391
	7.366747856052543
	7.406768337984377
	7.447970022888738
	7.487530054083552
	7.527810282478543
	7.568522044810652
	7.608971865741853
	7.64885843156105
	7.689114315574242
	7.729893403963238
	7.7700297546828745
	7.809812138055279
	7.850212949723851
	7.890163272117975
	7.930426851197049
	7.970529111477733
	8.011168524708546
	8.051140941106778
	8.090399149255463
	8.130584621733924
	8.171410488210482
	8.2111499205798
	8.25147274340986
	8.291164533009484
	8.331328075725335
	8.371638538206994
	8.41186203526287
	8.451996626150171
	8.491568984947175
	8.531464866111133
	8.571525993772624
	8.611070845493808
	8.65086290934457
	8.691302563383482
	8.731641940847304
	8.771489000239923
	8.810935156767659
	8.851134159443529
	8.890712127680812
	8.93134292508908
	8.970799069567363
	9.010838249849227
	9.051083029770714
	9.090229828164821
	9.130040923133416
	9.170223566231188
	9.210171321769055
	9.24996350928816
	9.28978955560691
	9.32908450473359
	9.36867543714651
	9.408750300658044
	9.44850844674306
	9.488714251161111
	9.528502766913657
	9.567963383597816
	9.607881601803694
	9.647776982039865
	9.68698910186589
	9.727115700258322
	9.76657493363761
	9.80676655380917
	9.845970714975826
	9.886164599883463
	9.926135541444413
	9.965472638836962
	10.005068920534539
	10.045487275347286
	10.084626317213989
	10.12413237220995
	10.163662195115435
	10.203603951504492
	10.24293132321536
	10.282531483812228
	10.322349563539147
	10.362035509618082
	10.401431560708124
	10.441211094929894
	10.480828735953757
	10.520085082978731
	10.559621787608972
	10.599383018287245
	10.640074778806415
	10.678490153533952
	10.718348039359492
	10.757652581558295
	10.797532746580057
	10.837619367991097
	10.876203979908272
	10.916612371335226
	10.956082427809706
	10.994980627754439
	11.034724688507367
	11.07448730498569
	11.114046902491259
	11.15402510340831
	11.193027149557768
	11.23227168239782
	11.272938729155147
	11.311798347480245
	11.351291784153506
	11.390521801114614
	11.429966952461704
	11.469399293310875
	11.509838036348228
	11.548987313065524
	11.588605564951033
	11.627812212972655
	11.667493111598175
	11.70630206002395
	11.746180988730453
	11.786368762230959
	11.825341717515444
	11.864577525404272
	11.9037512395448
	11.943903885357912
	11.982963290562964
	12.023305971296708
	12.062089128251525
	12.101241706536966
	12.14104507957396
	12.18032949260369
	12.219516416793416
	12.259187582942806
	12.298481912513482
	12.337253546684796
	12.377723221290116
	12.41696818450607
	12.455785573742586
	12.495619257288455
	12.535472612576552
	12.57476258261283
	12.614201999531852
	12.653143986350893
	12.692852204776287
	12.732490258986104
	12.771573518566875
	12.810968715255221
	12.850203139108476
	12.89029020771413
	12.929166450606699
	12.968677636951199
	13.00834462925269
	13.0480492850545
	13.087064097919042
	13.125543071004113
	13.165552942529724
	13.20470046341544
	13.24419050072909
	13.283251462942948
	13.32308908020132
	13.361846778651671
	13.401889708178885
	13.441333727689482
	13.48129640574675
	13.520433746507704
	13.558858508211818
	13.598259621146708
	13.637647807947308
	13.677107592042091
	13.717002740519767
	13.755301513436518
	13.794946497646736
	13.834848428835897
	13.874253303617902
	13.913590821982742
	13.95263796748106
	13.992249449454437
	14.031424623745659
	14.071171096656961
	14.110458392116087
	14.149923884016093
	14.188981888859999
	14.228176993826347
	14.267601115471908
	14.307288468294134
	14.345865586986301
	14.385379237313284
	14.424687303521937
	14.464013858257577
	14.503226687170267
	14.542850314182012
	14.581961030166877
	14.621349757120132
	14.660527772862247
	14.700599889320824
	14.739152877688717
	14.779186531602376
	14.81794529363109
	14.857632779611953
	14.897033516540445
	14.936031931201187
	14.975836960983948
	15.015007481915326
	15.054126402816513
	15.092857436424772
	15.13237177172509
	15.171495353361369
	15.210946895592711
	15.250780951055042
	15.290157087406476
	15.328935877984717
	15.368123179900504
	15.407672976778084
	15.447269692710291
	15.48601369629484
	15.52629403602495
	15.56481277656845
	15.603947237294877
	15.643578998325909
	15.683086681568858
	15.721353830213307
	15.761489565996914
	15.800742503006243
	15.839892660337366
	15.879652016855944
	15.917840947297858
	15.957740858755965
	15.99722207291069
	16.036173605592047
	16.075010148344404
	16.114894417307184
	16.153482540046202
	16.193769992409806
	16.232609899177813
	16.27185786324492
	16.311253604766467
	16.350437980618775
	16.389408866874607
	16.429199777360047
	16.46853932294295
	16.50740650866999
	16.546369898359305
	16.58646239892022
	16.62536596262467
	16.664287439065003
	16.703690229841765
	16.743609311801
	16.781885284644133
	16.821656304626945
	16.860808586651274
	16.900004245599945
	16.939549702083788
	16.9788772948829
	17.01837590450592
	17.056165159231288
	17.096273740020997
	17.135409366278648
	17.174832879019117
	17.21457365403259
	17.25408380822595
	17.293247611700203
	17.33231724454098
	17.372022260678193
	17.410632163226502
	17.449996466426892
	17.48895662029832
	17.528091013334237
	17.567797759757784
	17.60691852594829
	17.646337057393346
	17.68564501895876
	17.724748419808424
	17.763748354751538
	17.80334443029235
1c8627bd39ef703cf2d878dbcc8a01fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|20|39|v|cpp
	-11.11639799
f98432e67ade84fc295ca7eef3a016ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|21|39|v|cpp
	-12.03846184
36a1f0b62603df37680e341f8adef8ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|22|39|v|cpp
	-11.57806204
3a10c7435300c8666e25beef0caf0f62|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|20|39|v|cpp
	-9.7449
a1870421848e7b8d1130c1983dd1d9f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|21|39|v|cpp
	-10.6678
378b68702fb60f96d25bf7d9d55c7ecc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|22|39|v|cpp
	-10.2069
cc2e1658c8b9b83197a19814f2af67d4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|11|1|V|cpp
	#include <gsl/gsl_matrix.h>
	#include <gsl/gsl_multifit_nlinear.h>
	#include <gsl/gsl_vector.h>
ed5448bf0070ea3feebdf666a365bc05|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|22|v|cpp
	DarkSun &model
78a4812071807be56c99d07c513f823b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|93|1|V|cpp
	  void set_diffeq_params(double *y, double &log_xstart, double &log_xfinal) {
	    double meta = get_m_eta();           // Mass of the eta
	    double td = get_lam() / 2.0;         // Start Td at confinement
	    double xi = compute_xi_const_td(td); // Starting value of xi
	    double tsm = td / xi;                // Initial SM temperature
	    double s = sm_entropy_density(tsm);  // Initial SM entropy density
	    log_xstart = log(meta / tsm);        // Log of initial x
	    log_xfinal = log(meta / T_CMB);      // Log of final x (end at CMB)
	
	    y[0] = log(neq_eta(td) / s); // y[0] is log(Y_eta)
	    y[1] = neq_del(td) / s;      // y[1] is Y_delta
	  }
3742fbec9c1ab356de61305da1166419|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|113|35|v|cpp
	rpar, 
5ad8179f714607646e9b7e60b5774f4e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|5|37|V|cpp
	#include "darksun/standard_model.hpp"
8a78c1a17c3f8d4168945bc0d8e639de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|110|1|V|cpp
	void set_diffeq_params(const double *rpar, const int *ipar, double *y, double &log_xstart, double &log_xfinal) {
	  double meta = get_m_eta(rpar);           // Mass of the eta
	  double td = get_lam(rpar) / 2.0;         // Start Td at confinement
	  double xi = compute_xi_const_td(td, rpar); // Starting value of xi
	  double tsm = td / xi;                // Initial SM temperature
	  double s = sm_entropy_density(tsm);  // Initial SM entropy density
	  log_xstart = log(meta / tsm);        // Log of initial x
	  log_xfinal = log(meta / T_CMB);      // Log of final x (end at CMB)
	
	  y[0] = log(neq_eta(td) / s); // y[0] is log(Y_eta)
	  y[1] = neq_del(td) / s;      // y[1] is Y_delta
	}
bcc502042631854a10b7bef502b3b67e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|42|v|cpp
	, const int *ipar
475ce4efae7a56b6883c0f65d9d78fec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|73|1|V|cpp
	  void clear() {
	    m_rpar[IDX_XI_FO] = -1.0;           // xi_fo
	    m_rpar[IDX_TSM_FO] = -1.0;          // tsfo
	    m_rpar[IDX_XI_BBN] = -1.0;          // xi_bbn
	    m_rpar[IDX_XI_CMB] = -1.0;          // xi_cmb
	    m_rpar[IDX_RD_ETA] = -1.0;          // rd_eta
	    m_rpar[IDX_RD_DEL] = -1.0;          // rd_del
	    m_rpar[IDX_DNEFF_CMB] = -1.0;       // dneff_cmb
	    m_rpar[IDX_DNEFF_BBN] = -1.0;       // dneff_bbn
	    m_rpar[IDX_ETA_SI_PER_MASS] = -1.0; // eta_si_per_mass
	    m_rpar[IDX_DEL_SI_PER_MASS] = -1.0; // del_si_per_mass
	
	    m_ipar = 0; // Number of recorded solutions -> 0
	
	    // Zero out the solution vector
	    for (size_t i = NUM_PARS; i < m_rpar.size(); i++) {
	      m_rpar[i] = 0;
	    }
	  }
44443aeacccdd0f5e8fb71fc9b24bd19|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|126|35|v|cpp
	m_rpar.size()
c0d9addca653c897728d878de57bd1fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|125|33|v|cpp
	NUM_PARS + 3 * SOL_SIZE
23b94cbbd1160d3057d3f93129af8bf6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|9|1|V|cpp
	static constexpr size_t RPAR_SIZE = NUM_PARS + 3 * SOL_SIZE;
dbec59fa3b938ff46486361c3c49ef11|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|164|1|V|cpp
	  double *rpar = model.get_rpar_mut();
	  int *ipar = model.get_ipar_mut();
01ce2509493bc36b029498e97d5c3285|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|74|1|V|cpp
	    m_rpar[IDX_XI_FO] = -1.0;           // xi_fo
	    m_rpar[IDX_TSM_FO] = -1.0;          // tsfo
	    m_rpar[IDX_XI_BBN] = -1.0;          // xi_bbn
	    m_rpar[IDX_XI_CMB] = -1.0;          // xi_cmb
	    m_rpar[IDX_RD_ETA] = -1.0;          // rd_eta
	    m_rpar[IDX_RD_DEL] = -1.0;          // rd_del
	    m_rpar[IDX_DNEFF_CMB] = -1.0;       // dneff_cmb
	    m_rpar[IDX_DNEFF_BBN] = -1.0;       // dneff_bbn
	    m_rpar[IDX_ETA_SI_PER_MASS] = -1.0; // eta_si_per_mass
	    m_rpar[IDX_DEL_SI_PER_MASS] = -1.0; // del_si_per_mass
	
	    m_ipar = 0; // Number of recorded solutions -> 0
	
	    // Zero out the solution vector
	    for (size_t i = NUM_PARS; i < m_rpar.size(); i++) {
	      m_rpar[i] = 0;
	    }
f68dae82694bffecf181d4564fec9a07|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|279|1|V|cpp
	  std::array<double, 3> get_ith_solution(size_t i) {
	    std::array<double, 3> sol;
	    if (i < SOL_SIZE) {
	      sol[0] = m_rpar[NUM_PARS + 3 * i + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * i + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * i + 2];
	    } else {
	      sol[0] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 2];
	    }
	    return sol;
	  }
86ddfbce80c75dd9d86e596b23105474|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|296|1|V|cpp
	  std::array<std::array<double, 3>, SOL_SIZE> get_solution() {
	    std::array<std::array<double, 3>, SOL_SIZE> sol;
	    for (auto i = 0; i < SOL_SIZE; i++) {
	      sol[i] = get_ith_solution(i);
	    }
	    return sol;
	  }
7e5a3db85d3ee6929fcf1af2a8e16c43|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|297|1|V|cpp
	    std::array<std::array<double, 3>, SOL_SIZE> sol;
	    for (auto i = 0; i < SOL_SIZE; i++) {
	      sol[i] = get_ith_solution(i);
	    }
	    return sol;
ff032b03918ed5b024b4588015f5724b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|280|31|V|cpp
	    std::array<double, 3> sol;
	    if (i < SOL_SIZE) {
	      sol[0] = m_rpar[NUM_PARS + 3 * i + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * i + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * i + 2];
	    } else {
	      sol[0] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 0];
	      sol[1] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 1];
	      sol[2] = m_rpar[NUM_PARS + 3 * (SOL_SIZE - 1) + 2];
	    }
	    return sol;
1ace7f2cf521d2dbd89b69e9bde8768b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|276|1|V|cpp
	  /**
	   * Return the ith piece of the solution.
	   */
f162bbdae38bc1eaa3548159793632ce|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|280|1|V|cpp
	  /**
	   * Return the entire solution.
	   */
b8a41e6aa0b1131b0cbbf8bc2fb37f20|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|124|1|V|cpp
	void solve_boltzmann(double *rpar, int *ipar) {
8ab58d41af17bcecd35210ca970049e0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|75|22|v|cpp
	double *rpar, int *ipar
130aee46880e700338a12bf7fdf2a4be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|76|13|v|cpp
	_sum_g
9c5bda6c28e511cec4e4fb3e83bbab32|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|6|27|V|cpp
	#include "darksun/model.hpp"
d311e6bf1772c6477073b27ca8b8a4b5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|174|14|V|cpp
	    if (get_xi_fo(rpar) == -1.0) {
8915634894cd08ecadb61e0672529abc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|174|14|V|cpp
	      set_xi_cmb(rpar, NAN);
cacbf8bd572c0a99d08b90e355ae31b0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|174|12|V|cpp
	    } else {
f4ee78ccd9bdbc06a18415392d9b77d8|file:///Users/loganmorrison/Documents/git_hub/Haliax/setup.py|1|1|V|python
	import os
	import re
	import sys
	import platform
	import subprocess
	
	from distutils.version import LooseVersion
	from setuptools import setup, find_packages, Extension
	from setuptools.command.build_ext import build_ext
	
	
	class CMakeExtension(Extension):
	    def __init__(self, name, sourcedir=''):
	        Extension.__init__(self, name, sources=[])
	        self.sourcedir = os.path.abspath(sourcedir)
	
	
	class CMakeBuild(build_ext):
	    def run(self):
	        try:
	            out = subprocess.check_output(['cmake', '--version'])
	        except OSError:
	            raise RuntimeError(
	                "CMake must be installed to build the following extensions: " +
	                ", ".join(e.name for e in self.extensions))
	
	        if platform.system() == "Windows":
	            cmake_version = LooseVersion(re.search(r'version\s*([\d.]+)',
	                                                   out.decode()).group(1))
	            if cmake_version < '3.1.0':
	                raise RuntimeError("CMake >= 3.1.0 is required on Windows")
	
	        for ext in self.extensions:
	            self.build_extension(ext)
	
	    def build_extension(self, ext):
	        extdir = os.path.abspath(
	            os.path.dirname(self.get_ext_fullpath(ext.name)))
	        cmake_args = ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=' + extdir,
	                      '-DPYTHON_EXECUTABLE=' + sys.executable]
	
	        cfg = 'Release'  # 'Debug' if self.debug else 'Release'
	        build_args = ['--config', cfg]
	
	        if platform.system() == "Windows":
	            cmake_args += ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(
	                cfg.upper(),
	                extdir)]
	            if sys.maxsize > 2**32:
	                cmake_args += ['-A', 'x64']
	            build_args += ['--', '/m']
	        else:
	            cmake_args += ['-DCMAKE_BUILD_TYPE=' + cfg]
	            build_args += ['--', '-j2']
	
	        env = os.environ.copy()
	        env['CXXFLAGS'] = '{} -DVERSION_INFO=\\"{}\\"'.format(
	            env.get('CXXFLAGS', ''),
	            self.distribution.get_version())
	        if not os.path.exists(self.build_temp):
	            os.makedirs(self.build_temp)
	        subprocess.check_call(['cmake', ext.sourcedir] + cmake_args,
	                              cwd=self.build_temp, env=env)
	        subprocess.check_call(['cmake', '--build', '.'] + build_args,
	                              cwd=self.build_temp)
	        print()  # Add an empty line for cleaner output
	
	
	setup(
	    name='Haliax',
	    version='0.1',
	    author='Logan Morrison',
	    author_email='loganmorr@ucsc.edu',
	    description='Python wrapper around the Lanre c++ library.',
	    long_description='',
	    packages=find_packages('haliax'),
	    package_dir={'': 'haliax'},
	    ext_modules=[CMakeExtension('haliax/cosmology'),
	                 CMakeExtension('haliax/dm_models'),
	                 CMakeExtension('haliax/diffeq')],
	    cmdclass=dict(build_ext=CMakeBuild),
	    zip_safe=False,
	)
4735e5c19d81d940a4c2480e30e6b4e1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|79|48|V|python
	                 CMakeExtension('haliax/dm_models'),
df24d5b5fc978a2b2a3b41f4c270873a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|79|48|V|python
	                 CMakeExtension('haliax/diffeq')],
e05ea1210babab6d985b747d1aece745|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|83|18|v|python
	Python wrapper around the Lanre c++ library.
8603c05d8f38811f8cc1d431c778e634|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|60|1|V|python
	            cmake_args += ["-DCMAKE_BUILD_TYPE=" + cfg]
1e85a7900faff6f0305fe9585e9f3abf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|60|30|v|python
	DCMAKE_BUILD_TYPE
8bfb32cc06385cd788415d5ba65664f1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|61|37|v|python
	BUILD_TYPE
881f4f27fe275ef41a7bd9d6e8059f5d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|61|61|V|python
	            cmake_args += ["-DCMAKE_Fortran_COMPILER=gfortran"]
5b90412a21ff4ca5b1f9f81ed44d029c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|45|1|V|python
	            "-DCMAKE_Fortran_COMPILER=gfortran",
843e353f7a5a6842b926bf213dfefe86|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/setup.py|46|22|v|python
	Fortran
9589b80a609378ac306b214e41b2a96d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|23|24|v|cmake
	/Users/loganmorrison/.pyenv/shims/python
217b5d6dc40ef30dcdd36f990c01e9db|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|4|1|V|rust
	
	/// Perform a triangular decomposition on a real dense matrix `a`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn dec(n: usize, mut a: ArrayViewMut2<f64>, mut ip: ArrayViewMut1<i32>) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            for i in kp1..n {
	                if a[[i, k]].abs() > a[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut t = a[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                a[[m, k]] = a[[k, k]];
	                a[[k, k]] = t;
	            }
	            if t == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            t = t.recip();
	            for i in kp1..n {
	                a[[i, k]] *= -t;
	            }
	            for j in kp1..n {
	                t = a[[m, j]];
	                a[[m, j]] = a[[k, j]];
	                a[[k, j]] = t;
	                if t != 0.0 {
	                    for i in kp1..n {
	                        a[[i, j]] += a[[i, k]] * t;
	                    }
	                }
	            }
	        }
	    }
	    if a[[n - 1, n - 1]] == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
	
	/// Perform a triangular decomposition on a complex matrix with real and
	/// imaginary components `ar` and `ai`. The upper and
	/// lower triangular matricies are stored in `a` upon completion and the pivots
	/// are stored in `ip`. Returns an error code which will be equal to zero if
	/// decomposition is successful and a non-zero number which stage matrix was
	/// found to be singular otherwise.
	pub(crate) fn decc(
	    n: usize,
	    mut ar: ArrayViewMut2<f64>,
	    mut ai: ArrayViewMut2<f64>,
	    mut ip: ArrayViewMut1<i32>,
	) -> usize {
	    let mut ier = 0;
	    ip[n - 1] = 1;
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let mut m = k;
	            for i in kp1..n {
	                if ar[[i, k]].abs() + ai[[i, k]].abs() > ar[[m, k]].abs() + ai[[m, k]].abs() {
	                    m = i;
	                }
	            }
	            ip[k] = m as i32;
	            let mut tr = ar[[m, k]];
	            let mut ti = ai[[m, k]];
	            if m != k {
	                ip[n - 1] = -ip[n - 1];
	                ar[[m, k]] = ar[[k, k]];
	                ai[[m, k]] = ai[[k, k]];
	                ar[[k, k]] = tr;
	                ai[[k, k]] = ti;
	            }
	            if tr.abs() + ti.abs() == 0.0 {
	                ier = k;
	                ip[n - 1] = 0;
	                return ier;
	            }
	            let den = tr * tr + ti * ti;
	            tr = tr / den;
	            ti = -ti / den;
	            for i in kp1..n {
	                let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                ar[[i, k]] = -prodr;
	                ai[[i, k]] = -prodi;
	            }
	            for j in kp1..n {
	                tr = ar[[m, j]];
	                ti = ai[[m, j]];
	                ar[[m, j]] = ar[[k, j]];
	                ai[[m, j]] = ai[[k, j]];
	                ar[[k, j]] = tr;
	                ai[[k, j]] = ti;
	                if tr.abs() + ti.abs() == 0.0 {
	                } else if ti == 0.0 {
	                    for i in kp1..n {
	                        let prodr = ar[[i, k]] * tr;
	                        let prodi = ai[[i, k]] * tr;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                } else if tr == 0.0 {
	                    for i in kp1..n {
	                        let prodr = -ai[[i, k]] * ti;
	                        let prodi = ar[[i, k]] * ti;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                } else {
	                    for i in kp1..n {
	                        let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                        let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                        ar[[i, j]] += prodr;
	                        ai[[i, j]] += prodi;
	                    }
	                }
	            }
	        }
	    }
	    if ar[[n - 1, n - 1]].abs() + ai[[n - 1, n - 1]].abs() == 0.0 {
	        ier = n;
	        ip[n - 1] = 0;
	    }
	
	    return ier;
	}
	
	pub(crate) fn sol(n: usize, a: ArrayView2<f64>, mut b: ArrayViewMut1<f64>, ip: ArrayView1<i32>) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k];
	            let t = b[m as usize];
	            b[m as usize] = b[k];
	            b[k] = t;
	            for i in kp1..n {
	                b[i] += a[[i, k]] * t;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            b[kb] = b[kb] / a[[kb, kb]];
	            let t = -b[kb];
	            for i in 0..(km1 + 1) {
	                b[i] += a[[i, kb]] * t;
	            }
	        }
	    }
	    b[0] = b[0] / a[[0, 0]];
	}
	
	pub(crate) fn solc(
	    n: usize,
	    ar: ArrayView2<f64>,
	    ai: ArrayView2<f64>,
	    mut br: ArrayViewMut1<f64>,
	    mut bi: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    if n != 1 {
	        let nm1 = n - 1;
	        for k in 0..nm1 {
	            let kp1 = k + 1;
	            let m = ip[k] as usize;
	            let tr = br[m];
	            let ti = bi[m];
	            br[m] = br[k];
	            bi[m] = bi[k];
	            br[k] = tr;
	            bi[k] = ti;
	            for i in kp1..n {
	                let prodr = ar[[i, k]] * tr - ai[[i, k]] * ti;
	                let prodi = ai[[i, k]] * tr + ar[[i, k]] * ti;
	                br[i] += prodr;
	                bi[i] += prodi;
	            }
	        }
	        for k in 0..nm1 {
	            let km1 = n - k - 2;
	            let kb = km1 + 1;
	            let den = ar[[kb, kb]] * ar[[kb, kb]] + ai[[kb, kb]] * ai[[kb, kb]];
	            let mut prodr = br[kb] * ar[[kb, kb]] + bi[kb] * ai[[kb, kb]];
	            let mut prodi = bi[kb] * ar[[kb, kb]] - br[kb] * ai[[kb, kb]];
	            br[kb] = prodr / den;
	            bi[kb] = prodi / den;
	            let tr = -br[kb];
	            let ti = -bi[kb];
	            for i in 0..(km1 + 1) {
	                prodr = ar[[i, kb]] * tr - ai[[i, kb]] * ti;
	                prodi = ai[[i, kb]] * tr + ar[[i, kb]] * ti;
	                br[i] += prodr;
	                bi[i] += prodi;
	            }
	        }
	    }
	    let den = ar[[0, 0]] * ar[[0, 0]] + ai[[0, 0]] * ai[[0, 0]];
	    let prodr = br[0] * ar[[0, 0]] + bi[0] * ai[[0, 0]];
	    let prodi = bi[0] * ar[[0, 0]] - br[0] * ai[[0, 0]];
	    br[0] = prodr / den;
	    bi[0] = prodi / den;
	}
166770f64e4a375a4b954740d02d196a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|7|5|V|rust
	    return ier;
633387428c5469751371cdca52420a2c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|5|1|V|rust
	pub fn dec(mut a: ArrayViewMut2<f64>, mut ip: ArrayViewMut1<i32>) -> i32 {
	    let mut ier = 0;
	    unimplemented!()
	}
	
	pub fn sol(a: ArrayView2<f64>, mut b: ArrayViewMut1<f64>, ip: ArrayView1<i32>) {
	    unimplemented!()
	}
d0daaa6d406c3df53801a56ed56fc3a9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|26|1|V|rust
	    mut a: ArrayViewMut2<f64>, 
3adbdf5693fa16ea8d6e72b623c03211|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|34|1|V|rust
	    a: ArrayView2<f64>, 
318e8c88b147e64e37ef95f11384473d|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|36|1|V|rust
	    mut b: ArrayViewMut1<f64>, 
0dda5053eb1e2893ebf1789951e3c2d9|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|23|1|V|rust
	pub fn decc(
	    mut ar: ArrayViewMut2<f64>,
	    mut ai: ArrayViewMut2<f64>,
	    mut ip: ArrayViewMut1<i32>,
	) -> i32 {
	    let mut ier = 0;
	    unimplemented!()
	}
	
	pub fn solc(
	    ar: ArrayView2<f64>,
	    ai: ArrayView2<f64>,
	    mut br: ArrayViewMut1<f64>,
	    mut bi: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    unimplemented!()
	}
d0ad193ea50e7a6aaf324e5f1e6fd829|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|66|1|V|rust
	    ml: usize,
	    mu: usize,
6e2f29c29fcafdd8d76eed747792cf33|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|63|1|V|rust
	pub fn decb(mut a: ArrayViewMut2<f64>, ml: usize, mu: usize, mut ip: ArrayViewMut1<i32>) -> i32 {
	    let mut ier = 0;
	    unimplemented!()
	}
	
	pub fn solb(
	    a: ArrayView2<f64>,
	    ml: usize,
	    mu: usize,
	    mut b: ArrayViewMut1<f64>,
	    ip: ArrayView1<i32>,
	) {
	    unimplemented!()
	}
c443506a7ab02ca2eeed97432d2f2b7a|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|87|1|V|rust
	    a: ArrayView2<f64>,
5fc3c4fa4b881fe4d344e64dd5e0f1ae|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|91|1|V|rust
	    mut b: ArrayViewMut1<f64>,
1202c6f0d3a9d5131a96f8462bf5da02|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|3|1|V|fortran
	    integer n, ndim, ip, ier, nm1, k, kp1, m, i, j
	    double precision a, t
da6e9dfc74d1132386a87561f541635c|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|8|5|v|rust
	ip, ier, 
0a25ee08ad1678a7c98c7dce18fa7894|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|8|5|V|rust
	    let mut nm1;, k, kp1, m, i, j;
9e171e7ef05ff73a5875bb02e8484984|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|8|5|V|rust
	    double precision a, t;
3dfd0a8620c69f42e9c0bf2cefe0c591|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|10|15|v|rust
	go to 70;
a2e2a21d17fe1b9b50d3f150db867dec|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|7|9|v|rust
	(n, ndim)
60b83e1a00313f9f12b3bb8e16967366|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|43|1|V|rust
	    end do;
8a520dd2493420d426b1e83f02fb2302|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|20|1|V|rust
	        end do;
66680c7ec6e6b7094dfe204b4d21af21|file:///Users/loganmorrison/Documents/coding/rust/projects/darksun/src/ode/linalg.rs|41|13|V|rust
	            45       continue;
f518295b359628e071d16f926b78cb4f|file:///Users/loganmorrison/.config/fish/config.fish|2|1|V|fish
	set -g CXX "/usr/local/bin/g++"
9b25473aa95d3a84896f2a9583ef3cde|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|1|V|rust
	extern "C" {
	    pub fn radau5_(
	        n: *mut c_int,
	        fcn: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ),
	        x: *mut c_double,
	        y: *mut c_double,
	        xend: *mut c_double,
	        h: *mut c_double,
	        rtol: *mut c_double,
	        atol: *mut c_double,
	        itol: *mut c_int,
	        jac: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	            *mut c_double,
	            *mut c_int,
	        ),
	        ijac: *mut c_int,
	        mljac: *mut c_int,
	        mujac: *mut c_int,
	        mas: extern "C" fn(*mut c_int, *mut c_double, *mut c_int, *mut c_double, *mut c_int),
	        imas: *mut c_int,
	        mlmas: *mut c_int,
	        mumas: *mut c_int,
	        solout: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            &mut c_int,
	            &mut c_int,
	            *mut c_double,
	            *mut c_int,
	            *mut c_int,
	        ),
	        iout: *mut c_int,
	        work: *mut c_double,
	        lwork: *mut c_int,
	        iwork: *mut c_int,
	        liwork: *mut c_int,
	        rpar: *mut c_double,
	        ipar: *mut c_int,
	        idid: *mut c_int,
	    );
	}
1a56df3607ac232ee87f25e03e859d6a|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|1|V|rust
	use libc::{c_double, c_int};
01e35f4e94e810aded82913dbf91e182|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|3|1|V|rust
	extern "C" {
	    pub fn radau5_(
	        n: *mut c_int,
	        fcn: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ),
	        x: *mut c_double,
	        y: *mut c_double,
	        xend: *mut c_double,
	        h: *mut c_double,
	        rtol: *mut c_double,
	        atol: *mut c_double,
	        itol: *mut c_int,
	        jac: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	            *mut c_double,
	            *mut c_int,
	        ),
	        ijac: *mut c_int,
	        mljac: *mut c_int,
	        mujac: *mut c_int,
	        mas: extern "C" fn(*mut c_int, *mut c_double, *mut c_int, *mut c_double, *mut c_int),
	        imas: *mut c_int,
	        mlmas: *mut c_int,
	        mumas: *mut c_int,
	        solout: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            &mut c_int,
	            &mut c_int,
	            *mut c_double,
	            *mut c_int,
	            *mut c_int,
	        ),
	        iout: *mut c_int,
	        work: *mut c_double,
	        lwork: *mut c_int,
	        iwork: *mut c_int,
	        liwork: *mut c_int,
	        rpar: *mut c_double,
	        ipar: *mut c_int,
	        idid: *mut c_int,
	    );
	}
	
	#[cfg(test)]
	mod test {
	    use super::*;
	
	    #[test]
	    fn test_vdpol() {}
	}
b187c46cb789f34c930b77bf308327c4|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/lib.rs|1|1|V|rust
	pub mod radau
8925316f22efc33f12018f06ac7ca593|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/fortran/radau.f90|1|18|v|fortran
	n, fcn, x, y, xend, h, &
	        rtol, atol, itol, &
	        jac, ijac, mljac, mujac, &
	        mas, imas, mlmas, mumas, &
	        solout, iout, &
	        work, lwork, iwork, liwork, rpar, ipar, idid
aebcb8657a9246f5c49843007488b958|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|5|1|V|rust
	        n: *mut c_int,
	        fcn: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	        ),
	        x: *mut c_double,
	        y: *mut c_double,
	        xend: *mut c_double,
	        h: *mut c_double,
	        rtol: *mut c_double,
	        atol: *mut c_double,
	        itol: *mut c_int,
	        jac: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_int,
	            *mut c_double,
	            *mut c_int,
	        ),
	        ijac: *mut c_int,
	        mljac: *mut c_int,
	        mujac: *mut c_int,
	        mas: extern "C" fn(*mut c_int, *mut c_double, *mut c_int, *mut c_double, *mut c_int),
	        imas: *mut c_int,
	        mlmas: *mut c_int,
	        mumas: *mut c_int,
	        solout: extern "C" fn(
	            *mut c_int,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            *mut c_double,
	            &mut c_int,
	            &mut c_int,
	            *mut c_double,
	            *mut c_int,
	            *mut c_int,
	        ),
	        iout: *mut c_int,
	        work: *mut c_double,
	        lwork: *mut c_int,
	        iwork: *mut c_int,
	        liwork: *mut c_int,
	        rpar: *mut c_double,
	        ipar: *mut c_int,
	        idid: *mut c_int,
d44a46dd68179b94af7deb6a7c165bb9|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|9|9|V|rust
	        dd
6a5a5768c5b2e246049ecff5b87f86f5|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|6|14|v|rust
	fn(*mut c_int, *mut c_double, *mut c_double, *mut c_double, *mut c_double, *mut c_int)
58dd95c0d806a18b9410de5bea2a8a1b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|24|5|V|rust
	    let mut work = vec![
29fbd434c85748a54bba0d0a73be7b8a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|110|1|V|cpp
	  int LWORK = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
349d3074b143e5eb758f4d3973083473|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|24|1|V|rust
	    let lwork = 
a70b6a6183b4d4d68be477914bd90daf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|66|1|V|cpp
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int nsmax = iwork[11];
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  if (nsmax == 0)
	    nsmax = 7;
	
	  /* allocation of workspace */
	
	  int LWORK = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
	  int LIWORK = (2 + (nsmax - 1) / 2) * n + 20;
	
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  radau_(&N, fcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC, &MLJAC,
	         &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT, WORK.data(), &LWORK,
	         IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
0b065d0e1cb4286c60ec2d5e729344d8|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|24|1|V|rust
	  let lwork = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
365b7c05a5fc9100a0fccbf73cb99c61|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|63|17|v|rust
	 /* no mass */
e99a2a08f6c992e55895b17ad2c8d05f|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|82|1|V|rust
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
74926a4ebcc3be0030ee093a245db982|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|82|1|V|rust
	  let mut WORK = vec![0.0; LWORK];
26ae6a7233b097f974a49b34806d07bf|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|86|14|v|rust
	; le < 
9bc82b8b24fac4b4dd84dc8e47c0ec01|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|86|18|v|rust
	; ++le) {
0ee03e01ce200ab07fad6c8de6c07218|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|96|18|v|rust
	; ++le)
3564d9a064d00185ebcfedfe3497a46e|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|95|9|v|rust
	extern 
056c512dfcb161c82a6f1242d91fc764|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|115|14|v|rust
	.data(),
1907fbea2da4e437ad852d313b689b2a|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|75|8|v|rust
	nsmax == 0
810bfe097a77c36b484aa857f49c2c62|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|67|15|v|rust
	mlmas = n
48355ce976e0878d2437e3ff4085180c|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|65|8|v|rust
	imas == 0
90c3f1590675b6ac72bdffe23c49650b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|55|8|v|rust
	mljac == n
e542ef87f8b4877d1460376f88b757fc|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|103|12|v|rust
	.as_ptr()
251e4895dd6690511c712c00370fc890|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|5|13|v|rust
	i32, f64, Vec<f64>, Vec<f64>, Vec<f64>, Vec<i32>
f2313fe6a5ab4b0c15e315208bfc9e0b|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|93|5|V|rust
	    extern "C" {
ddec9c772c957242af5d8b0087c3ceef|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|94|1|V|rust
	        let fnc_f = |n: i32, x: f64, y: &Vec<f64>, dy: mut Vec<f64>, rpar:&mut Vec<f64>, ipar: &mut Vec<i32>|{
	        fcn(n, x, y, dy, rpar, ipar);
	        }
c37bee831610cd437f807775870dd3a8|file:///Users/loganmorrison/Documents/coding/rust/projects/fortran-stiff/src/radau.rs|3|1|v|rust
	pub fn radau(
	    n: i32,
	    fcn: fn(i32, f64, Vec<f64>, Vec<f64>, Vec<f64>, Vec<i32>),
	    x: f64,
	    y: Vec<f64>,
	    xend: f64,
	    h: f64,
	    rtol: f64,
	    atol: f64,
	    itol: i32,
	    jac: fn(i32, f64, Vec<f64>, Vec<f64>, i32, Vec<f64>, Vec<i32>),
	    ijac: i32,
	    mljac: i32,
	    mujac: i32,
	    mas: fn(i32, Vec<f64>, i32, Vec<f64>, Vec<i32>),
	    imas: i32,
	    mlmas: i32,
	    mumas: i32,
	    solout: fn(i32, f64, f64, Vec<f64>, Vec<f64>, i32, i32, Vec<f64>, Vec<i32>, i32),
	    iout: i32,
	    work: &mut Vec<f64>,
	    iwork: &mut Vec<i32>,
	    rpar: &mut Vec<f64>,
	    ipar: &mut Vec<i32>,
	    idid: &mut i32,
	) {
	    let mut N = n;
	    let mut X = x;
	    let mut XEND = xend;
	    let mut H = h;
	    /* we have scalar tolerances */
	    let mut ITOL = 0;
	    let mut RTOL = rtol;
	    let mut ATOL = atol;
	
	    let mut IJAC = ijac;
	    let mut MLJAC = mljac;
	    let mut MUJAC = mujac;
	
	    let mut IMAS = imas;
	    let mut MLMAS = mlmas;
	    let mut MUMAS = mumas;
	
	    let mut IOUT = iout;
	
	    let mut nsmax = iwork[11];
	    let mut ljac;
	    let mut lmas;
	    let mut le;
	
	    /* computing the size of the working arrays */
	
	    if mljac == n {
	        /* full jacobian */
	        ljac = n;
	        le = n;
	    } else {
	        /* banded case */
	        ljac = mljac + mujac + 1;
	        le = 2 * mljac + mujac + 1;
	    }
	
	    if imas == 0 {
	        lmas = 0;
	    } else if mlmas == n {
	        lmas = n;
	    } else
	    /*banded mass */
	    {
	        lmas = mlmas + mumas + 1;
	    }
	
	    if nsmax == 0 {
	        nsmax = 7;
	    }
	
	    /* allocation of workspace */
	
	    let LWORK = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
	    let LIWORK = (2 + (nsmax - 1) / 2) * n + 20;
	
	    let mut WORK = vec![0.0; LWORK as usize];
	    let mut IWORK = vec![0i32; LIWORK as usize];
	
	    /* copy parameters */
	    for le in 0..20 {
	        WORK[le] = work[le];
	        IWORK[le] = iwork[le];
	    }
	
	    unsafe {
	        let fcn_f = || {};
	        radau_(
	            &mut N,
	            fcn_f,
	            &mut X,
	            y.as_mut_ptr(),
	            &mut XEND,
	            &mut H,
	            &mut RTOL,
	            &mut ATOL,
	            &mut ITOL,
	            jac,
	            &mut IJAC,
	            &mut MLJAC,
	            &mut MUJAC,
	            mas,
	            &mut IMAS,
	            &mut MLMAS,
	            &mut MUMAS,
	            solout,
	            &mut IOUT,
	            WORK.as_mut_ptr(),
	            &mut LWORK,
	            IWORK.as_mut_ptr(),
	            &mut LIWORK,
	            rpar.as_mut_ptr(),
	            ipar.as_mut_ptr(),
	            idid,
	        );
	    }
	
	    /* copy results */
	    for le in 0..20 {
	        work[le] = WORK[le];
	        iwork[le] = IWORK[le];
	    }
	}
eab5429c64bc791809fa876a930d9e4a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|6|1|V|cpp
	void vdpol(int *n, double *x, double *y, double *fy, double *rpar, int *ipar) {
	  fy[0] = y[1];
	  fy[1] = ((1 - y[0] * y[0]) * y[1] - y[0]) / rpar[0];
	}
589bb4ef341453c5d82354605fec6857|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|10|1|V|cpp
	void jvpol(int *n, double *x, double *y, double *dfy, int *ldfy, double *rpar,
	           double *ipar) {
	  /* make comfortable 2D acces */
	  /* dfy is a (ldfy,n) matrix in colum major storage*/
	  double *J[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i)
	    J[i] = &dfy[i * *ldfy];
	
	  J[0][0] = 0.0;
	  J[1][0] = 1.0;
	  J[0][1] = (-2.0 * y[0] * y[1] - 1.0) / rpar[0];
	  J[1][1] = (1.0 - y[0] * y[0]) / rpar[0];
	}
199e2cf2a4d31ebff8e15518d9ae440c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|19|1|V|cmake
	
	
	# Use PyBind11 to link Lanre to Haliax
	set(PYBIND11_CPP_STANDARD -std=c++17)
	set(PYTHON_EXECUTABLE "./venv/bin/python")
	add_subdirectory("pybind11")
	
	include_directories(
		"${CMAKE_SOURCE_DIR}/darksun/include"
		${Boost_INCLUDE_DIRS})
	
	set(SOURCE_DIR darksun)
	
	pybind11_add_module(pydarksun ${SOURCES} "${SOURCE_DIR}/model.cpp")
	target_link_libraries(
		pydarksun PRIVATE
		darksun	
		GSL::gsl
		GSL::gslcblas
		Eigen3::Eigen
		${Boost_LIBRARIES})
aae3fc40b0aa760918c012bdb8165087|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|15|v|cpp
	cur_path
3a8a39b6317bac5c6e39d47d74022b19|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|1|V|cpp
	  std::string fname_zs = std::filesystem::current_path().append("../rundata/cs_data.dat");
5a9e61a5afce2051b61705328ccc6697|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|85|v|cpp
	cs_data
898d0fac700ea126c65fa9a2b59563bb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|32|1|V|cpp
	  std::ofstream file_zs;
8c7dd922ad47494fc02c388e12c00eac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|36|3|v|cpp
	file
3ea81a1380b7713abcfb50a1000dd5bd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|36|1|V|cpp
	  file_zs.open(fname_zs);
7ab77faeede7f62e0c4685a1c289cdd5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|60|1|V|cpp
	  file_zs.close();
0c5fae2d5f6800069db3a9cf6668a4bf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|54|1|V|cpp
	    // fmt::print("{:e}, {:e}, {:e}, {:e}\n", pow(10.0, logz),
	    //           std::get<0>(log_css.back()), std::get<1>(log_css.back()),
	    //           std::get<2>(log_css.back()));
cb5ac24995d0a24a1188245d2925f66a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|54|43|v|cpp
	pow(10.0, logz)
b65ed89945f35cf48a206428c6154fca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|29|7|v|cpp
	std::filesystem::current_path()
35eae25e0f1ea6220960abcd35da62b9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|7|1|V|cmake
	set(GEN_CS_DATA generate_cs_data)
	
	add_executable(${GEN_CS_DATA} "${GEN_CS_DATA}.cpp")
	include_directories(${Boost_INCLUDE_DIRS})
	target_link_libraries(${GEN_CS_DATA}
		darksun
		stiff
		fmt::fmt
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${GEN_CS_DATA} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
11554d4c34373158411a8110ccf971d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|24|1|V|cmake
	# ===========================================================================
f4e3222f67470737cb67cc3a87e36678|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|26|1|V|cmake
	# ---------------------------------------------------------------------------
28a04bb23e43dc14eedd893c7f33498a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|9|1|V|cmake
	add_executable(${GEN_CS_DATA} "${GEN_CS_DATA}.cpp")
	include_directories(${Boost_INCLUDE_DIRS})
	target_link_libraries(${GEN_CS_DATA}
		darksun
		stiff
		fmt::fmt
	        ${Boost_LIBRARIES}
	        GSL::gsl
	        GSL::gslcblas
	        Eigen3::Eigen)
	
	set_target_properties(${GEN_CS_DATA} PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin
	        )
608698ac21ea5f27ca2e4b8c74bafab1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|25|1|V|cmake
	# ---- Scanners -------------------------------------------------------------
95cf76320c226e8a642a3ee5ec96dfff|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|29|8|v|cmake
	Scanners
8ae124938e7b6b5b87624bb7d4fb671b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|28|1|V|cmake
	set(CSCAN c_scan)
f50e34fa3a505767bca2aecd9020b60a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|32|1|V|cmake
	set(MU_ETA_SCAN c_scan)
4c3a6c1d5b369941b8042fe2e0da97ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|28|5|v|cmake
	C_SCAN
be9589e6be2ac09152bb3cb87144758a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|29|15|v|cmake
	adel_scan
c5386f13381f0086c805c53d6885b2e0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|33|1|V|cmake
		mu_eta_scan)
3084c3b58fbee01a1449028dd10bc545|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|33|2|v|cmake
	mu_eta_scan
82cfd99a51a1894234dd1bfe9652e681|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|36|1|V|cmake
	set(ADEL_SCAN )
	set(LEC1_SCAN lec1_scan)
	set(LEC2_SCAN lec2_scan)
	set(MU_ETA_SCAN mu_eta_scan)
	set(MU_DEL_SCAN mu_del_scan)
	set(XI_INF_SCAN xi_inf_scan)
35f325d6c33dd9b11fbecac9b4ad1950|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|37|1|V|cmake
	# ---- c-scan ---------------------------------------------------------------
c4d460651b52eb714fdd553b3d2335dc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|38|19|v|cmake
	GEN_CS_DATA
9c7030a612cf16a7c65844a4ecc4ff05|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/CMakeLists.txt|39|2|V|cmake
		include_directories(${Boost_INCLUDE_DIRS})
1ea1f4efbdd7db2380d7f4fa7b11048d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|1|1|V|cpp
	int main() { return 0; }
d376f63bdc94d3e01bebf59df16aa034|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|6|1|V|cpp
	  std::vector<double> lams;
b15aaf4d9f1188f6b4c1754cd5fe16b3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|6|23|v|cpp
	lams
17f1405a099d7965c5d1fbd1ec4a1cf7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|5|1|V|cpp
	constexpr size_t NUM_LAMS = 100;
eb16f3e10c52fd10112533f97b242726|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|7|1|V|cpp
	constexpr double 
10a3dd866fdfcec54dc85f7d17741145|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|9|27|V|cpp
	constexpr size_t NUM_NS = 100;
53c1d20147b221922a588996ea173875|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|18|15|V|cpp
	  const double 
f446feaa2144d49a2f8a849543aa4583|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|8|1|V|cpp
	#include <filesystem>
	#include <fmt/core.h>
	#include <fstream>
	#include <iomanip>
	#include <iostream>
	#include <string>
f2e82d1a796cbb63da64a4a9a2e70eb7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|5|1|V|cpp
	#include <iomanip>
175605e8c5116e0ec265f3cb600f69d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|17|1|V|cpp
	  std::string fname_rd_eta;
a6a326205ea88350a7037d171588aca1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|18|1|V|cpp
	  std::string fname_rd_del;
4e15eb8f9578289c1699ee83905dbbdf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|19|1|V|cpp
	  std::string fname_xi_fo;
edbe663e90751bdc3b8ff97735a78639|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|19|1|V|cpp
	  std::string fname_xi_fo;
	  std::string fname_tsm_fo;
ea8570c1d84af704893b6965035eaad8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|21|1|V|cpp
	  std::string fname_si_eta;
	  std::string fname_si_del;
8455faeb47693d9057a1d10195000363|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|23|21|v|cpp
	si_eta;
b7e450675c5ddb5cc279489541c097be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|24|21|v|cpp
	si_del;
5f4ae71c193548aa8c34201edcb9269b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|13|1|V|cpp
	constexpr size_t N_MIN = 1;
	constexpr size_t N_MAX = 100;
fa449eb7fb64430d52c754d63da76189|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|16|19|v|cpp
	S[2] = {0.5, 1.5};
12ec6027d61c016f9dbba2173ddb4292|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|16|1|V|cpp
	constexpr double C1 = 0.5;
c6bdc947ad2bd78429f0a0258d983f0f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|22|1|V|cpp
	  std::string fname_xi_fo;
	  std::string fname_tsm_fo;
	  std::string fname_si_eta;
	  std::string fname_si_del;
	  std::string fname_dneff_bbn;
	  std::string fname_dneff_cmb;
e85352d578acf671d845fea26cd57aff|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|21|26|v|cpp
	std::fil;
dd8a2f7690de7e5dd0b5fea8177e714c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|21|23|v|cpp
	 = fs::current_path().append("../rundata/c_scan/c=0.5.dat");
f8a56be3a98fcb5436a04f6e7ba283d9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|26|1|V|cpp
	  std::ofstream file_c1;
9043bb4eb9b6ee548e94b79b71f87f35|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|27|24|V|cpp
	  std::ofstream file_c2;
3e25b64f079bd5525aa1fb75b7bc55a5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|27|1|V|cpp
	  file_c1.open(fname_c1);
636b4fedadb471b0c3eb98f3c93e1606|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|45|15|v|cpp
	<< model.get_n() << ","
ddfc7da9bd1a065567bc7345c5bf00b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|55|9|V|cpp
	model.get
82708377b0e3a282d6c26517bf5c177f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|41|1|V|cpp
	  for (auto &n : ns) {
	    for (auto &lam : lams) {
	      DarkSun model(n, lam);
	      model.set_c(C1);
	      model.solve_boltzmann();
	      file_c1 << model.get_n() << "," << model.get_lam() << ","
	              << model.get_rd_eta() << "," << model.get_rd_del() << ","
	              << model.get_eta_si_per_mass() << ","
	              << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	              << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	              << model.get_tsm_fo() << "\n";
	    }
	  }
ddfe7fdefb693e53f09b7a3110aae340|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|43|1|V|cpp
	      DarkSun model1(n, lam);
ccf0506e5e0ddc2dd611b6b36ec5950c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|45|1|V|cpp
	      model1.set_c(C1);
c18e9261e93c917ea749654acb6b997d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|47|1|V|cpp
	      model1.solve_boltzmann();
f89f951aca4f200d0b1720d89e774a12|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|58|1|V|cpp
	  for (auto &n : ns) {
	    for (auto &lam : lams) {
	      DarkSun model(n, lam);
	      model.set_c(C2);
	      model.solve_boltzmann();
	      file_c2 << model.get_n() << "," << model.get_lam() << ","
	              << model.get_rd_eta() << "," << model.get_rd_del() << ","
	              << model.get_eta_si_per_mass() << ","
	              << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	              << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	              << model.get_tsm_fo() << "\n";
	    }
	  }
789e56f55ff96d2387bbaf1db444b118|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|52|1|V|cpp
	      file_c1 << model1.get_n() << "," << model1.get_lam() << ","
	              << model1.get_rd_eta() << "," << model1.get_rd_del() << ","
	              << model1.get_eta_si_per_mass() << ","
	              << model1.get_del_si_per_mass() << "," << model1.get_dneff_cmb()
	              << "," << model1.get_dneff_bbn() << "," << model1.get_xi_fo()
	              << "," << model1.get_tsm_fo() << "\n";
7f6e8c5ef073c485098a1b0aa72383f1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|44|1|V|cpp
	  for (auto &n : ns) {
	    for (auto &lam : lams) {
	      DarkSun model1(n, lam);
	      DarkSun model2(n, lam);
	
	      model1.set_c(C1);
	      model2.set_c(C2);
	
	      model1.solve_boltzmann();
	      model2.solve_boltzmann();
	
	      file_c1 << model1.get_n() << "," << model1.get_lam() << ","
	              << model1.get_rd_eta() << "," << model1.get_rd_del() << ","
	              << model1.get_eta_si_per_mass() << ","
	              << model1.get_del_si_per_mass() << "," << model1.get_dneff_cmb()
	              << "," << model1.get_dneff_bbn() << "," << model1.get_xi_fo()
	              << "," << model1.get_tsm_fo() << "\n";
	      file_c2 << model2.get_n() << "," << model2.get_lam() << ","
	              << model2.get_rd_eta() << "," << model2.get_rd_del() << ","
	              << model2.get_eta_si_per_mass() << ","
	              << model2.get_del_si_per_mass() << "," << model2.get_dneff_cmb()
	              << "," << model2.get_dneff_bbn() << "," << model2.get_xi_fo()
	              << "," << model2.get_tsm_fo() << "\n";
	    }
	  }
1bd1ec06b063c9c2e6e0ef3a2a27f449|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|54|7|v|cpp
	file_c1
f564545b0a694bb67158cd6012e65cc3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|52|10|V|cpp
	      model2.solve_boltzmann();
254af2fe47929bfe569cf962c2239232|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|49|12|V|cpp
	      model2.set_c(C2);
aabaa0bba232cb2bf5179f12cbd4bbcb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|46|15|V|cpp
	      DarkSun model2(n, lam);
f9b4a51edf664561f9fe60e0fa4ed836|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|55|1|V|cpp
	      file_c2 << model2.get_n() << "," << model2.get_lam() << ","
	              << model2.get_rd_eta() << "," << model2.get_rd_del() << ","
	              << model2.get_eta_si_per_mass() << ","
	              << model2.get_del_si_per_mass() << "," << model2.get_dneff_cmb()
	              << "," << model2.get_dneff_bbn() << "," << model2.get_xi_fo()
	              << "," << model2.get_tsm_fo() << "\n";
41cf1a1e7c3c975b215051c73541eb37|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|24|18|v|cpp
	gaurd
dce7c4174ce9323904a934a486c41288|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|24|18|v|cpp
	lock
578ef7307ccb85a73632b03d552fc56e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|62|29|V|cpp
	       progress_mutex.lock();
3b19f4f540ef4a53a5e4f8006ccb0289|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|1|V|cpp
	  std::thread thread_c1(scan, C1, file_c1);
9a9b2b3e237802b1dff3e86895018131|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|32|1|V|cpp
	  std::ofstream file_c1, file_c2;
9be130ddf87b408dde8348e2b74352d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|50|21|v|cpp
	_c1, file_c2;
25a8631a05f376bfd83612b3d2487ae2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|49|58|v|cpp
	ofstream
a7158de41d88b8b6709f2084bbc58231|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|32|17|V|cpp
	  std::ofstream file_c1, file_c2;
	  file_c1.open(fname_c1);
	  file_c2.open(fname_c2);
fd19e5fd8f5cfb1fe265d30f64ba134d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|35|v|cpp
	file_c2
3a4b8c911d14ce7e67ff7328680714cf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|72|1|V|cpp
	  file_c1.close();
	  file_c2.close();
d4f47c603f188b440eac92c40c6d8d4a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|43|1|V|cpp
	  boost::progress_display progress(ns.size() * lams.size());
89f4c87e05a071aac2b2365ed3fa49c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|25|34|v|cpp
	ns.size() * lams.size());
7186ab0a494c466a4da9a5e86f13a0ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|46|24|v|cpp
	, &progress
ecf7d92a74f172ebbdf5cd184fd1c8d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|62|1|V|cpp
	        std::cout << "*";
85d1e970140f304f306c7ebcf2dc0525|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|47|21|V|cpp
	    std::cout << "*";
da3644768e283d55bbe7ba449c4a337b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|45|5|V|cpp
	  std::cout << "*";
11ca3338777893713067566fbe225457|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|79|32|V|cpp
	// # N, LAM, RD_ETA, RD_DEL, SI_ETA, SI_DEL, DNEFF_CMB, DNEFF_BBN, XI_FO, TSM_FO
6da61e0f7daaca26ed2f08a8ee8c20e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|10|28|V|cpp
	  model.set_xi_inf(cbrt(1e-0 * SM_HEFF_INF / 1.0));
889a83a8afcb9ac0bccf0068981c78e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_solve_boltzmann.cpp|10|22|V|cpp
	  model.set_lec2(0.0);
38a3a34e897be75017b37a986ede3008|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|37|26|v|cpp
	N_MAX - N_MIN + 1
24fbe8ce496b40ec98f742ae445c4555|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|39|18|V|cpp
	    std::cout << n << std::endl;
67c1e3403e94f2916859eb92eab32a26|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|38|19|v|cpp
	N_MIN
2fa0713033e802a9e1b99fbb2f4495d9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|38|27|v|cpp
	N_MAX
580ae97cea1cb5f66579ab67218d75de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|34|1|V|cpp
	    std::cout << "FROZEN" << std::endl;
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
9d749bc2dea1e1396d167fd421010388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|68|9|v|cpp
	//             
6bd4574c12dc26e20cb587be35d90a57|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|48|1|V|cpp
	    std::ofstream file;
	    file.open(fname);
bfbc5e9e383c382f0472e94037588f58|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|70|9|V|cpp
	  file_c1.open(fname);
61f67d2721f1d8228531b3f747ef72f1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|73|12|V|cpp
	  file.open(
047d9a057dfbf2e25f89f42ea675f05d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|69|1|V|cpp
	  std::string header =
	      "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO";
dea97fbd9150c09b063a249c52804ad7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|73|19|V|cpp
	  std::ofstream file;
ad16a50f9ad121c45a32fcb90d2dea7c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 10;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 15;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double C1 = 0.5;
	constexpr double C2 = 1.5;
	constexpr size_t NUM_CS = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_CS);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname_c1 =
	      fs::current_path().append("../rundata/c_scan/c=0.5.dat");
	  std::string fname_c2 =
	      fs::current_path().append("../rundata/c_scan/c=1.5.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MAX + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double c, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_c(c);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, C1, fname_c1);
	  std::thread thread_c2(scan, C2, fname_c2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
a7fe2ab2da6f608bf8caac9e320ec70b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|22|1|V|cpp
	constexpr double C1 = 0.5;
	constexpr double C2 = 1.5;
	constexpr size_t NUM_CS = 2;
0fc4ff0673abb12addbaf6edbb5bd3ec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|23|51|v|cpp
	*NUM_CS
6050e5a43597be44588f76f476f97131|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|32|1|V|cpp
	  std::string fname_c2 =
	      fs::current_path().append("../rundata/c_scan/c=1.5.dat");
f48d6d0596ef0cf109bdaf427bb3464c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|31|52|v|cpp
	c=0.5
c4189503f81e0a9609f056732082a6ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|44|53|V|cpp
	  auto scan = [ns, lams](const double c, const std::string fname) {
258990eac2f3121edafca25ccc807279|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|65|1|V|cpp
	  std::thread thread_c1(scan, C1, fname_c1);
	  std::thread thread_c2(scan, C2, fname_c2);
	  thread_c1.join();
	  thread_c2.join();
	
1ea55dffe217accca2b34d2b9da6461e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|49|1|V|cpp
	      model.set_c(c);
20b91dbe0e9d134a72dd2a8b6eb75195|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|30|61|v|cpp
	c_scan/
002adebb8687f83db2e6b95ea205c40d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/lec1_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 10;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 15;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double LEC11 = 0.01;
	constexpr double LEC12 = 1.0;
	constexpr size_t NUM_LEC1S = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_LEC1S);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname1 =
	      fs::current_path().append("../rundata/lec1_scan/lec1=0.01.dat");
	  std::string fname2 =
	      fs::current_path().append("../rundata/lec1_scan/c=1.0.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MAX + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double lec1, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_lec1(lec1);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, LEC11, fname1);
	  std::thread thread_c2(scan, LEC12, fname2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
931ca224bc5127455031c1f1159a0e21|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/lec1_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 10;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 15;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double LEC11 = 0.01;
	constexpr double LEC12 = 1.0;
	constexpr size_t NUM_LEC1S = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_LEC1S);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname1 =
	      fs::current_path().append("../rundata/lec1_scan/lec1=0.01.dat");
	  std::string fname2 =
	      fs::current_path().append("../rundata/lec1_scan/lec1=1.0.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MAX + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double lec1, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_lec1(lec1);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, LEC11, fname1);
	  std::thread thread_c2(scan, LEC12, fname2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
81182607309578329d157ce991b6cf15|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|22|18|v|cpp
	LEC1
7ae4f0e1a5caec38c694010467a5a140|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|22|18|v|cpp
	MU_ETA_1 
14f2772a95e7f4c176b1ebd4548d740e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|23|18|v|cpp
	LEC12
834488ea77e0aa5d78aadb9d2591d59a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|24|22|v|cpp
	LEC1S
84eca42939a3bc1da40fca2bdeac7852|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|27|52|v|cpp
	NUM_LEC1S
8a1c7bfc979e445fe9a30a6a847d5db0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|73|31|v|cpp
	LEC11
d5eb155b2bf8a4f3806becf0b83de529|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 10;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 15;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double MU_ETA_1 = 0.01;
	constexpr double MU_ETA_2 = 1.0;
	constexpr size_t NUM_MU_ETAS = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_MU_ETAS);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname1 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=0.01.dat");
	  std::string fname2 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=1.0.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MAX + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double mu_eta, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_mu_eta(mu_eta);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, MU_ETA_1, fname1);
	  std::thread thread_c2(scan, MU_ETA_2, fname2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
9f145438f6e855980099a7c95e5d1dc7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/mu_del_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 10;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 15;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double MU_DEL_1 = 0.01;
	constexpr double MU_DEL_2 = 1.0;
	constexpr size_t NUM_MU_DELS = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_MU_DELS);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname1 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=0.01.dat");
	  std::string fname2 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=1.0.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MAX + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double mu_del, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_mu_del(mu_del);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, MU_DEL_1, fname1);
	  std::thread thread_c2(scan, MU_DEL_2, fname2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
fc6a1d18fe8dfaad353197617e97900c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|22|18|v|cpp
	MU_DEL_1
b017da4eddd404037a4d11d33bbc11ba|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|23|18|v|cpp
	MU_DEL_2
251bf2cbddd469ab57923a3ad0575e90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|24|22|v|cpp
	MU_DEL
df01939ea2f8e06f09b7c4f218683208|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|22|27|v|cpp
	0.01;
8034e2dca56e45baf71201f3fdd85387|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|22|1|V|cpp
	constexpr double XI_INF_1 = 0.1;
ce6d9e9ff43be4a4b98893f748643c86|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|22|1|V|cpp
	constexpr double XI_INF_1 = 1.0;
89d796378417564d1f972decc8ed8fec|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|24|1|V|cpp
	constexpr double XI_INF_3 = 1e-3;
26086a1d798d3b86447ed380da6b9143|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|29|56|v|cpp
	MU_DELS
a3e573c7b4c451c1896e4831cb65186c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|36|1|V|cpp
	  std::string fname1 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=0.01.dat");
	  std::string fname2 =
	      fs::current_path().append("../rundata/mu_eta_scan/mu_eta=1.0.dat");
bddb4c6892d82bb79b4b73800051dfd3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|39|57|v|cpp
	u_eta
a2134821cb487692feabfba4bc60f003|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|79|1|V|cpp
	  std::thread thread_c1(scan, XI_INF_1, fname1);
	  std::thread thread_c2(scan, XI_INF_2, fname2);
67d2f1882396dda1782c97304a3ec3e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|83|1|V|cpp
	  thread_c1.join();
	  thread_c2.join();
cbf32fb410c4c44b2f956f0d9d918960|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|54|1|V|cpp
	// void fcn(int *, double *, double *, double *, double *, int *),
	
	// void boltzmann(const int *n, const double *x, const double *y, double *dy,
	//               const double *rpar, const int *) {
	//  for (size_t i = 0; i <
	//}
8a64af80d1e3b140dca345c33c3a79d8|file:///Users/loganmorrison/Documents/research/full_boltzmann/code/boltzmann/include/boltzmann/toy_model.hpp|55|65|v|cpp
	, double pre
01a7fafff77508c6d254f3edcdd0b2a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <filesystem>
	#include <fstream>
	#include <iostream>
	#include <mutex>
	#include <string>
	#include <thread>
	#include <vector>
	
	using namespace darksun;
	namespace fs = std::filesystem;
	
	constexpr size_t NUM_LAMS = 100;
	constexpr double LOG_LAM_MIN = -7.0;
	constexpr double LOG_LAM_MAX = 1.0;
	
	constexpr size_t N_MIN = 5;
	constexpr size_t N_MAX = 100;
	constexpr size_t NUM_NS = N_MAX - N_MIN + 1;
	
	constexpr double C1 = 0.5;
	constexpr double C2 = 1.5;
	constexpr size_t NUM_CS = 2;
	
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_CS);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
	
	int main() {
	
	  std::string fname_c1 =
	      fs::current_path().append("../rundata/c_scan/c=0.5.dat");
	  std::string fname_c2 =
	      fs::current_path().append("../rundata/c_scan/c=1.5.dat");
	
	  std::vector<size_t> ns(NUM_NS);
	  for (size_t i = 0; i < NUM_NS; i++) {
	    ns[i] = N_MIN + i;
	  }
	  std::vector<double> lams(NUM_LAMS);
	  const double log_lam_step =
	      (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAMS - 1);
	  for (size_t i = 0; i < NUM_LAMS; i++) {
	    lams[i] = pow(10.0, LOG_LAM_MIN + log_lam_step * i);
	  }
	
	  auto scan = [ns, lams](const double c, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_c(c);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, C1, fname_c1);
	  std::thread thread_c2(scan, C2, fname_c2);
	  thread_c1.join();
	  thread_c2.join();
	
	  return 0;
	}
07e5e88417879a5ae5f71bf45f00c791|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|22|26|v|cpp
	0.5;
7ca27c378b3df59bc2bf2f5684c56e7e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|23|1|V|cpp
	constexpr double C2 = 1.5;
c4881e87c5783742e025a1678706e336|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|23|1|V|cpp
	constexpr size_t NUM_NS = 5;
77a7898dbf3de6cc983f8c6e8524fc24|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|20|27|v|cpp
	C_MAX - N_MIN + 1;
c8ff66b3f7c28adb688dbaaf95c92edc|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|34|5|V|cpp
	    k
ef96b45d622ad4d91aa00011f4a82926|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|34|7|v|cpp
	fs::current_path().append("../rundata/c_scan/c=0.5.dat")
c8563596038228303b12bc9720e5c379|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|33|44|v|cpp
	{fs::current_path().append(
	      "../rundata/c_scan/N=" + std::to_string(NS[0]) + ".dat")};
9c46bceb0308735054d83be8a0bd6cc8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|63|1|V|cpp
	             << model.get_c() << ","
436ecc308634dbaea008825649dce7be|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|64|1|V|cpp
	             << model.get_lec1() << ","
ac8abf77cc33364675b3a140348d7219|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|66|1|V|cpp
	             << model.get_lec2() << ","
cf6df31ba1b168b691d43fe52b8cdf8d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|67|1|V|cpp
	             << model.get_mu_eta() << ","
53c59a33d731762a17a70770803988ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|68|1|V|cpp
	             << model.get_mu_del() << ","
edbc4fc242b83feffe46d8158b895cca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|86|21|v|cpp
	theards
d719fa050aeef63a08cad95c8862ac6a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|86|1|V|cpp
	  for(auto& thread: threads){
	    thead = std::thread(scan, 
	  }
8fce93693a4ba7b520a27fe5da8c5619|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|86|1|V|cpp
	  for (size_t i = 0; i < NUM_NS; i++){
	    threads[i] = std::thread(scan, NS[i], fnames[i]);
	  }
9d5ec51697d6a2d24acb8995bf8940f1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|90|22|v|cpp
	 = std::thread(scan, NS[i], fnames[i]);
ae7aa5217994d77c0287ff07d77e2b43|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|93|1|V|cpp
	  std::thread thread_c1(scan, C1, fname_c1);
	  std::thread thread_c2(scan, C2, fname_c2);
	  thread_c1.join();
	  thread_c2.join();
a34e8f30f69bfed0e6f1077f3ca54eb3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|61|1|V|cpp
	        file << model.get_n() << "," << model.get_lam() << "," << model.get_c()
	             << "," << model.get_adel() << "," << model.get_lec1() << ","
	             << model.get_lec2() << "," << model.get_mu_eta() << ","
	             << model.get_mu_del() << "," << model.get_xi_inf() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
365c255ef41e393355d1292d6636f783|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|28|1|V|cpp
	std::string header =
	    "N,LAM,RD_ETA,RD_DEL,SI_ETA,SI_DEL,DNEFF_CMB,DNEFF_BBN,XI_FO,TSM_FO\n";
a841c2618d0dd4b6546af7f2daa1d70e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|25|1|V|cpp
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
f4899356774e2d6712e28c759b9c734c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/benchmark.cpp|51|1|V|cpp
	      file << model.get_n() << "," << model.get_lam() << ","
	           << model.get_rd_eta() << "," << model.get_rd_del() << ","
	           << model.get_eta_si_per_mass() << "," << model.get_del_si_per_mass()
	           << "," << model.get_dneff_cmb() << "," << model.get_dneff_bbn()
	           << "," << model.get_xi_fo() << "," << model.get_tsm_fo() << "\n";
893cb3b073240549ea7c637434d51886|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_scan.cpp|60|1|V|cpp
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
3f9169260c0fa709065dd62d61055737|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/xi_inf_scan.cpp|31|1|V|cpp
	std::string header = "N,LAM,C,ADEL,LEC1,LEC2,MU_ETA,MU_DEL,XI_INF,RD_ETA,RD_"
	                     "DEL,SI_ETA,SI_DEL,DNEFF_CMB,DNEFF_BBN,XI_FO,TSM_FO\n";
2853c09852b45a0633970214a8445fbd|file:///Users/loganmorrison/.config/nvim/init.vim|180|30|v|vim
	meals
8c6c00cf8706e37c85c842391d64700b|file:///Users/loganmorrison/Library/Mathematica/Applications/HazmaTools/Models/Info.fr|1|1|V|
	M$ModelName = "Hazma";
	
	M$Information = {
	  Authors -> {"Adam Coogan", "Logan Morrison"},
	  Date -> "11/20/2019",
	  Institutions -> {
	    "University of Amsterdam, GRAPPA",
	    "University of California, Santa Cruz",
	    "Santa Cruz Institute for Particle Physics"
	  },
	  Emails -> {
	    "a.m.coogan@uva.nl",
	    "loanmorr@ucsc.edu"
	  },
	  URLs -> {
	    "https://github.com/LoganAMorrison/HazmaTools",
	    "https://github.com/LoganAMorrison/Hazma"
	  },
	  References -> {
	    "https://arxiv.org/pdf/1907.11846.pdf"
	  },
	  Version -> 1
	};
c390869ec35b73207361d0edebe2605e|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Info.fr|15|1|V|
	  URLs -> {
	    "https://github.com/LoganAMorrison/HazmaTools",
	    "https://github.com/LoganAMorrison/Hazma"
	  },
	  References -> {
	    "https://arxiv.org/pdf/1907.11846.pdf"
	  },
191301d863125f70c133e8c97e6d4afc|file:///Users/loganmorrison/Library/Mathematica/Applications/HazmaTools/Models/Parameters.fr|1|1|V|
	M$Parameters = {
	  (* ChiPT Parameters *)
	
	  fpi == {
	    ParameterType -> External,
	    Value -> 0.093,
	    TeX -> ComposedChar["f", "\\pi"],
	    Description -> "pion decay constant"
	  },
	
	  b0 == {
	    ParameterType -> External,
	    Description -> "mass term coefficient",
	    TeX -> ComposedChar["B", "0"],
	    Value -> 2.617 (* ((mpi0 + mpi)/2)^2 / (mu + md) *)
	  },
	
	  fv == {
	    ParameterType -> External,
	    Description -> "vector coupling F_V",
	    TeX -> ComposedChar["F", "V"],
	    Value -> 0.165 (* MeV *)
	  },
	
	  gv == {
	    ParameterType -> External,
	    Description -> "vector coupling G_V",
	    TeX -> ComposedChar["G", "V"],
	    Value -> 0.055 (* MeV *)
	  },
	
	  mrho == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "\\rho"],
	    Description -> "rho0 mass"
	  },
	
	  rhowidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "\\rho"],
	    Description -> "rho0 width"
	  },
	
	  momega == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "\\omega"],
	    Description -> "omega mass"
	  },
	
	  omegawidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "\\omega"],
	    Description -> "omega width"
	  },
	
	  (* Standard Model Parameters *)
	
	  muq == {
	    ParameterType -> External,
	    Value -> 0.0024,
	    TeX -> ComposedChar["m", "u"],
	    Description -> "mass of the up quark"
	  },
	
	  mdq == {
	    ParameterType -> External,
	    Value -> 0.0048,
	    TeX -> ComposedChar["m", "d"],
	    Description -> "mass of the down quark"
	  },
	
	  msq == {
	    ParameterType -> External,
	    Value -> 0.095,
	    TeX -> ComposedChar["m", "s"],
	    Description -> "mass of the strange quark"
	  },
	
	  ml == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "l"],
	    Description -> "SM fermion mass"
	  },
	
	  me == {
	    ParameterType -> External,
	    Value -> 0.000511,
	    TeX -> ComposedChar["m", "e"],
	    Description -> "electron mass"
	  },
	
	  mmu == {
	    ParameterType -> External,
	    Value -> 0.10566,
	    TeX -> ComposedChar["m", "\\mu"],
	    Description -> "muon mass"
	  },
	
	  alphaEM == {
	    ParameterType -> External,
	    Value -> 1 / 137.0,
	    TeX -> ComposedChar["\\alpha", "EM"],
	    Description -> "fine structure constant for EM"
	  },
	
	  Vud == {
	    ParameterType -> External,
	    Value -> 0.974267,
	    TeX -> ComposedChar["V", "ud"],
	    Description -> "ud element of CKM matrix"
	  },
	
	  Vus == {
	    ParameterType -> External,
	    Value -> 0.225369,
	    TeX -> ComposedChar["V", "us"],
	    Description -> "us element of CKM matrix"
	  },
	
	  GF == {
	    ParameterType -> External,
	    Value -> 1.166 * 10^(-5), (* GeV^-2 *)
	    TeX -> ComposedChar["G", "F"],
	    Description -> "Fermi constant"
	  },
	
	  qe == {
	    ParameterType -> Internal,
	    Value -> Sqrt[4 Pi alphaEM],
	    TeX -> "e",
	    Description -> "electric coupling constant"
	  },
	
	  vh == {
	    ParameterType -> External,
	    TeX -> ComposedChar["v", "H"],
	    Description -> "Higgs vev",
	    Value -> 246.0
	  },
	
	  (* Dark Matter Parameters *)
	
	  mx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "\\chi"],
	    Description -> "dark matter mass"
	  },
	
	  (* Scalar Mediator Parameters *)
	
	  gsuu == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Suu"],
	    Description -> "Scalar mediator-up quark coupling"
	  },
	
	  gsdd == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Sff"],
	    Description -> "Scalar mediator-down quark coupling"
	  },
	
	  gsss == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Sff"],
	    Description -> "Scalar mediator-strange quark coupling"
	  },
	
	  gsee == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Sff"],
	    Description -> "Scalar mediator-electron coupling"
	  },
	
	  gsll == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Sff"],
	    Description -> "Scalar mediator-lepton coupling"
	  },
	
	  gsGG == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "SGG"],
	    Description -> "effective SGG coupling"
	  },
	
	  gsFF == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "SFF"],
	    Description -> "effective SFF coupling"
	  },
	
	  vs == {
	    ParameterType -> External,
	    TeX -> ComposedChar["v", "S"],
	    Description -> "vev of S"
	  },
	
	  ms == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "S"],
	    Description -> "mass of S"
	  },
	
	  swidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "S"],
	    Description -> "width of S"
	  },
	
	  gsxx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "S\\chi\\chi"],
	    Description -> "S\[Chi]\[Chi]C coupling"
	  },
	
	  Lam == {
	    ParameterType -> External,
	    TeX -> "\\Lambda",
	    Description -> "UV cutoff scale."
	  },
	
	  (* Vector Mediator Parameters *)
	
	  gvll == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Vll"],
	    Description -> "Sll coupling"
	  },
	
	  gvuu == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Vuu"],
	    Description -> "Suu coupling"
	  },
	
	  gvdd == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Vdd"],
	    Description -> "Sdd coupling"
	  },
	
	  gvss == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Vss"],
	    Description -> "Sss coupling"
	  },
	
	  mv == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "V"],
	    Description -> "mass of V"
	  },
	
	  vwidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "V"],
	    Description -> "width of V"
	  },
	
	  gvxx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "V\\chi\\chi"],
	    Description -> "V\[Chi]\[Chi]C coupling"
	  },
	
	  (* Pseudo-Scalar Mediator Parameters *)
	
	  gpuu == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Puu"],
	    Description -> "Puu coupling"
	  },
	
	  gpdd == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Pdd"],
	    Description -> "Pdd coupling"
	  },
	
	  gpss == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Pss"],
	    Description -> "Pss coupling"
	  },
	
	  gpll == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Pll"],
	    Description -> "Pll coupling"
	  },
	
	  gpGG == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "PGG"],
	    Description -> "effective PGGdual coupling"
	  },
	
	  gpFF == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "PFF"],
	    Description -> "effective PFFdual coupling"
	  },
	
	  mp == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "P"],
	    Description -> "mass of P"
	  },
	
	  pwidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "P"],
	    Description -> "width of P"
	  },
	
	  gpxx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "P\\chi\\chi"],
	    Description -> "P\[Chi]\[Chi] coupling"
	  },
	
	  sinbeta == {
	    ParameterType -> Internal,
	    TeX -> ComposedChar["Sin", "\\beta"]
	  },
	
	  cosbeta == {
	    ParameterType -> Internal,
	    TeX -> ComposedChar["Cos", "\\beta"]
	  },
	
	  (* Axial-Vector Mediator *)
	
	  gall == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "All"],
	    Description -> "All coupling"
	  },
	
	  gauu == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Auu"],
	    Description -> "Auu coupling"
	  },
	
	  gadd == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Add"],
	    Description -> "Add coupling"
	  },
	
	  gass == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "Ass"],
	    Description -> "Ass coupling"
	  },
	
	  ma == {
	    ParameterType -> External,
	    TeX -> ComposedChar["m", "A"],
	    Description -> "mass of A"
	  },
	
	  awidth == {
	    ParameterType -> External,
	    TeX -> ComposedChar["\\Gamma", "A"],
	    Description -> "width of A"
	  },
	
	  gaxx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "A\\chi\\chi"],
	    Description -> "A\[Chi]\[Chi] coupling"
	  }
	};
074607e4bc4b560d77505c0a7eba354f|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|371|1|V|
	  gaxx == {
	    ParameterType -> External,
	    TeX -> ComposedChar["g", "A\\chi\\chi"],
	    Description -> "A\[Chi]\[Chi] coupling"
	  }
b206a1b4ea1097761f78e8876f6da779|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|378|22|v|
	External
14785411cd0ed527d91f63eee1a9e6d7|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|377|3|v|
	gaxx
e001ba374e866e6dd27d7f4560604dd6|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|377|1|V|
	  CmixN == {
	    ParameterType -> Internal,
	    Va
	    TeX -> ComposedChar["g", "A\\chi\\chi"],
	    Description -> "A\[Chi]\[Chi] coupling"
	  }
afbf0897a5a83fdd873dfb032ec695d3|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|378|22|v|
	Internal
001c0028e13f259bd8ba6aef110189aa|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|380|51|v|
	A\\chi\\chi
855519396700127a550f26afb8f26327|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|381|23|v|
	A\[Chi]\[Chi] coupling
b6623bb9f52208ad17293ef93a378d3c|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|377|1|V|
	  SmixN == {
	    ParameterType -> Internal,
	    Value         -> -Sqrt[mnu / (mnu + mn)[
	    TeX           -> ComposedChar["Sin[\Theta]", ""],
	    Description   -> "Mixing angle between RH and active neutrino."
	  }
315553cb20112f4f8124fb291afc676c|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Parameters.fr|386|5|V|
	    Value         -> Sqrt[mnu / (mnu + mn)[
3cc69c69f6449d87cdd85b6f941e4ffd|file:///Users/loganmorrison/Library/Mathematica/Applications/HazmaTools/Models/Particles.fr|1|1|V|
	(*
	  This file contains all definitions of particles in Hazma. The available particles are:
	
	  ======================================================
	  | Particle               | name                      |
	  |====================================================|
	  | Neutral pion           | pi0                       |
	  | Charged pion           | pim, pip (pipbar, pimbar) |
	  | Neutral kaon           | k0, k0bar                 |
	  | Charged kaon           | km, kp (kpbar, kmbar)     |
	  | Eta                    | eta                       |
	  | Photon                 | A                         |
	  | Rho                    | rho                       |
	  | Omega                  | omega                     |
	  | Lepton                 | l                         |
	  | Neutrino               | vl                        |
	  | Dark Matter            | x                         |
	  |----------------------------------------------------|
	  | Scalar Mediator        | sm                        |
	  | Vector Mediator        | vm                        |
	  | Pseudo-Scalar Mediator | psm                       |
	  | Axial-Vector Mediator  | avm                       |
	  ======================================================
	
	*)
	
	FeynmanGauge = True;
	
	M$GaugeGroups = {
	  U1EM == {
	    Abelian -> True,
	    CouplingConstant -> qe,
	    GaugeBoson -> A,
	    Charge -> Q
	  }
	};
	
	M$ClassesDescription = {
	  (* Goldstones *)
	  S[1] == {
	    ClassName -> pi0,
	    SelfConjugate -> True,
	    Mass -> {mpi0, 0.13498},
	    Width -> 0,
	    ParticleName -> "pi0",
	    TeXParticleName -> ComposedChar["\\pi", Null, "0"],
	    PropagatorLabel -> ComposedChar["\\pi", Null, "0"]
	  },
	
	  S[2] == {
	    ClassName -> pim,
	    SelfConjugate -> False,
	    Mass -> {mpi, 0.13957},
	    QuantumNumbers -> {Q -> -1},
	    Width -> 0,
	    ParticleName -> "pim",
	    AntiParticleName -> "pip",
	    TeXParticleName -> ComposedChar["\\pi", Null, "-"],
	    TeXAntiParticleName -> ComposedChar["\\pi", Null, "+"],
	    PropagatorLabel -> ComposedChar["\\pi", Null, "-"],
	    PropagatorArrow -> Forward
	  },
	
	  S[3] == {
	    ClassName -> k0,
	    SelfConjugate -> False,
	    Mass -> {mk0, 0.49765},
	    Width -> 0,
	    ParticleName -> "k0",
	    AntiParticleName -> "k0~",
	    TeXParticleName -> ComposedChar["K", Null, "0"],
	    TeXAntiParticleName -> ComposedChar["K", Null, "0", "\\bar"],
	    PropagatorLabel -> ComposedChar["K", Null, "0"],
	    PropagatorArrow -> Forward
	  },
	
	  S[4] == {
	    ClassName -> km,
	    SelfConjugate -> False,
	    Mass -> {mk, 0.49367},
	    QuantumNumbers -> {Q -> -1},
	    Width -> 0,
	    ParticleName -> "km",
	    AntiParticleName -> "kp",
	    TeXParticleName -> ComposedChar["K", Null, "-"],
	    TeXAntiParticleName -> ComposedChar["K", Null, "+"],
	    PropagatorLabel -> ComposedChar["K", Null, "-"],
	    PropagatorArrow -> Forward
	  },
	
	  S[5] == {
	    ClassName -> eta,
	    SelfConjugate -> True,
	    Mass -> {meta, 0.547862},
	    Width -> 0,
	    ParticleName -> "eta",
	    TeXParticleName -> "\\eta",
	    PropagatorLabel -> "\\eta"
	  },
	
	  (* Scalar Mediator *)
	  S[7] == {
	    ClassName -> sm,
	    SelfConjugate -> True,
	    Width -> swidth,
	    Mass -> ms,
	    ParticleName -> "S",
	    TeXParticleName -> "S",
	    PropagatorLabel -> "S"
	  },
	
	  (* Pseudo-Scalar Mediator *)
	  S[8] == {
	    ClassName -> psm,
	    SelfConjugate -> True,
	    Width -> pwidth,
	    Mass -> mp,
	    ParticleName -> "P",
	    TeXParticleName -> "P",
	    PropagatorLabel -> "P"
	  },
	
	  (* Photon *)
	  V[1] == {
	    ClassName -> A,
	    SelfConjugate -> True,
	    Mass -> 0,
	    Width -> 0,
	    ParticleName -> "A",
	    TeXParticleName -> "\\gamma",
	    PropagatorLabel -> "\\gamma"
	  },
	
	  V[2] == {
	    ClassName -> rho,
	    SelfConjugate -> True,
	    Mass -> mrho,
	    Width -> rhowidth,
	    ParticleName -> "rho",
	    PropagatorLabel -> "\\rho",
	    TeXParticleName -> "\\rho"
	  },
	
	  V[3] == {
	    ClassName -> omega,
	    SelfConjugate -> True,
	    Mass -> momega,
	    Width -> omegawidth,
	    ParticleName -> "omega",
	    TeXParticleName -> "\\omega",
	    PropagatorLabel -> "\\omega"
	  },
	
	  (* Vector Mediator *)
	  V[4] == {
	    ClassName -> vm,
	    SelfConjugate -> True,
	    Mass -> mv,
	    Width -> vwidth,
	    ParticleName -> "V",
	    TeXParticleName -> "V",
	    PropagatorLabel -> "V"
	  },
	
	  (* Axial-Vector Mediator*)
	  V[5] == {
	    ClassName -> avm,
	    SelfConjugate -> True,
	    Mass -> ma,
	    Width -> awidth,
	    ParticleName -> "A",
	    TeXParticleName -> "A",
	    PropagatorLabel -> "A"
	  },
	
	  (* SM leptons *)
	  F[1] == {
	    ClassName -> vl,
	    SelfConjugate -> False,
	    Mass -> 0,
	    Width -> 0,
	    QuantumNumbers -> {LeptonNumber -> 1},
	    ParticleName -> "vl",
	    ParticleName -> "vl~",
	    TeXParticleName -> ComposedChar["\\nu", "\\ell", Null],
	    PropagatorLabel -> ComposedChar["\\nu", "\\ell", Null],
	    PropagatorType -> S,
	    PropagatorArrow -> Forward
	  },
	
	  F[2] == {
	    ClassName -> l,
	    SelfConjugate -> False,
	    Mass -> ml,
	    QuantumNumbers -> {Q -> -1, LeptonNumber -> 1},
	    ParticleName -> "l",
	    ParticleName -> "l~",
	    TeXParticleName -> "\\ell",
	    PropagatorLabel -> "\\ell",
	    PropagatorType -> Straight,
	    PropagatorArrow -> Forward
	  },
	
	  (* Dark matter *)
	  F[3] == {
	    ClassName -> x,
	    SelfConjugate -> False,
	    Mass -> mx,
	    Width -> 0,
	    ParticleName -> "x",
	    AntiParticleName -> "x~",
	    TeXParticleName -> "\\chi",
	    TeXAntiParticleName -> ComposedChar["\\chi", Null, Null, "\\bar"],
	    PropagatorLabel -> "\\chi",
	    PropagatorArrow -> Forward
	  }
	};
	
	(* Need both of these terms to use the pip and kp field names *)
	(* Note that FeynRules automatically creates the k0bar conjugate field *)
	pip = anti[pim];
	pipbar = pim;
	kp = anti[km];
	kpbar = km;
	
	GaugeXi[V[1]] = GaugeXi[A];
2a2911971853c6f1f76195dda164c015|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|16|1|V|
	  | Neutrino               | vl                        |
4ab0a76ec9a3413394d1676130e1a08d|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|102|1|V|
	  (* Scalar Mediator *)
	  S[7] == {
	    ClassName -> sm,
	    SelfConjugate -> True,
	    Width -> swidth,
	    Mass -> ms,
	    ParticleName -> "S",
	    TeXParticleName -> "S",
	    PropagatorLabel -> "S"
	  },
	
	  (* Pseudo-Scalar Mediator *)
	  S[8] == {
	    ClassName -> psm,
	    SelfConjugate -> True,
	    Width -> pwidth,
	    Mass -> mp,
	    ParticleName -> "P",
	    TeXParticleName -> "P",
	    PropagatorLabel -> "P"
	  },
a3289c8c60b58b42346796ec7f389d4c|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|134|1|V|
	  (* Vector Mediator *)
	  V[4] == {
	    ClassName -> vm,
	    SelfConjugate -> True,
	    Mass -> mv,
	    Width -> vwidth,
	    ParticleName -> "V",
	    TeXParticleName -> "V",
	    PropagatorLabel -> "V"
	  },
	
	  (* Axial-Vector Mediator*)
	  V[5] == {
	    ClassName -> avm,
	    SelfConjugate -> True,
	    Mass -> ma,
	    Width -> awidth,
	    ParticleName -> "A",
	    TeXParticleName -> "A",
	    PropagatorLabel -> "A"
	  },
3342605f4dee854b3fa4d4ac01883c29|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|163|6|v|
	Dark matter
f8320b26d30ab433c5a54546d21f414c|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|166|22|v|
	False
300a649f1737415e8fc45d1c7c967fc3|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|144|1|V|
	    TeXParticleName -> ComposedChar["\\nu", "\\ell", Null],
	    PropagatorLabel -> ComposedChar["\\nu", "\\ell", Null],
	    PropagatorType -> S,
	    PropagatorArrow -> Forward
2cf090b68d107cd6288bb04b1f13bfa7|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|171|1|V|
	    TeXParticleName -> "\\chi",
	    TeXAntiParticleName -> ComposedChar["\\chi", Null, Null, "\\bar"],
	    PropagatorLabel -> "\\chi",
	    PropagatorArrow -> Forward
72177632cb8c6560fd99871b6ea6de84|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|171|46|v|
	\\ell
664258a8fb9f063fadfb051bc64b81d7|file:///Users/loganmorrison/Library/Mathematica/Applications/HazmaTools/Models/Tools.fr|1|1|V|
	(*
	  This file contains various convenience definitions for constructing Lagrangians.
	*)
	
	(* Flags specifying which models should be included *)
	$IncludeScalarMediator = False;
	$IncludeVectorMediator = False;
	$IncludePseudoScalarMediator = False;
	$IncludeAxialVectorMediator = False;
	
	(*
	  Taylor expand in fpi around fpi = Infinity to order n.
	*)
	FpiExpand[expr_, n_Integer /; n >= 0] := Normal[Series[expr, {fpi, Infinity, n}]];
	
	(*
	  Quark mass and charge matrices
	*)
	QuarkMassMatrix = DiagonalMatrix[{muq, mdq, msq}];
	QuarkChargeMatrix = DiagonalMatrix[{2 / 3, -1 / 3, -1 / 3}];
	VecCouplingMatrix = DiagonalMatrix[{gvuu, gvdd, gvss}];
	AxCouplingMatrix = DiagonalMatrix[{gauu, gadd, gass}];
	PCouplingMatrix = DiagonalMatrix[{gpuu, gpdd, gpss}];
	
	
	(*
	  Goldstone Matrices
	  ------------------
	  - Phi: Scherer Eqn.(4.28)
	  - Sigma: Above Scherer Eqn.(4.28)
	  - SqrtSigma: needed for resonance Lagrangians
	*)
	
	Phi = {
	  {pi0 + eta / Sqrt[3], Sqrt[2] * pip, Sqrt[2] * kp},
	  {Sqrt[2] * pim, -pi0 + eta / Sqrt[3], Sqrt[2] * k0},
	  {Sqrt[2] * km, Sqrt[2] * k0bar, -2 * eta / Sqrt[3]}
	};
	
	Sigma[order_Integer /; order >= 0] := Sum[
	  (1 / Factorial[n]) * (I / fpi)^n * MatrixPower[Phi, n],
	  {n, 0, order}
	];
	
	SqrtSigma[order_Integer /; order >= 0] := Sum[
	  (1 / Factorial[n]) * (I / fpi)^n * MatrixPower[Phi / 2, n],
	  {n, 0, order}
	];
	
	(*
	  Explicit expressions for Golstone matrices. Should speed up calculations.
	*)
	Sigma3 = Sigma[3];
	Sigma4 = Sigma[4];
	SigmaDag3 = HC[Sigma3];
	SigmaDag4 = HC[Sigma4];
	
	SqrtSigma2 = SqrtSigma[2];
	SqrtSigma3 = SqrtSigma[3];
	SqrtSigma4 = SqrtSigma[4];
	SqrtSigmaDag2 = HC[SqrtSigma2];
	SqrtSigmaDag3 = HC[SqrtSigma3];
	SqrtSigmaDag4 = HC[SqrtSigma4];
	
	(*
	  Currents
	  --------
	    - EMCurrentL(R): Left(Right) electromagnetic/quark current
	    - VecCurrentL(R): Left(Right) vector-mediator/quark current
	    - AxCurrentL(R): Left(Right) axial-vector-mediator/quark current
	    - WeakCurrentL: Left-Handed Weak current with W integrated out (leaving lepton current)
	    - l(r)hNoWeak: Left(Right)-handed currents with no weak interactions
	
	    - FSLeft(Right): Left(Right)-handed field strength currents
	    - FSOctetLeft(Right): Left(Right)-handed Octet field strength current
	    - FSOctetPlus(Minus): Vector(Axial-Vector) field-strength currents
	
	    - SqrtSigmaMu
	
	    - lh: Total left-handed current
	    - rh: Total right-handed current
	    - vmu: Total vector current
	    - amu: Total axial-vector current
	*)
	
	EMCurrentL[mu_] := qe * QuarkChargeMatrix * A[mu];
	EMCurrentR[mu_] := qe * QuarkChargeMatrix * A[mu];
	
	VecCurrentL[m_] := vm[m] * VecCouplingMatrix;
	VecCurrentR[m_] := vm[m] * VecCouplingMatrix;
	
	AxCurrentL[m_] := -avm[m] * AxCouplingMatrix;
	AxCurrentR[m_] := avm[m] * AxCouplingMatrix;
	
	CKM = {{0, Vud, Vus}, {0, 0, 0}, {0, 0, 0}};
	WeakCurrentL[m_] := 2 * Sqrt[2] * GF * CKM * lbar.Ga[m].ProjM.vl;
	
	lhNoWeak[m_] := Module[{current},
	  current = EMCurrentL[m];
	  If[$IncludeVectorMediator, current = current + VecCurrentL[m]];
	  If[$IncludeAxialVectorMediator, current = current + AxCurrentL[m]];
	  current
	];
	rhNoWeak[m_] := Module[{current},
	  current = EMCurrentR[m];
	  If[$IncludeVectorMediator, current = current + VecCurrentL[m]];
	  If[$IncludeAxialVectorMediator, current = current + AxCurrentR[m]];
	  current
	];
	
	FSRight[m_, n_] := FS[rhNoWeak, m, n];
	FSLeft[m_, n_] := FS[lhNoWeak, m, n];
	
	FSOctetLeft[m_, n_] := SqrtSigma4.FSLeft[m, n].SqrtSigmaDag4;
	FSOctetRight[m_, n_] := SqrtSigmaDag4.FSRight[m, n].SqrtSigma4;
	
	FSOctetPlus[m_, n_] := FSOctetLeft[m, n] + FSOctetRight[m, n];
	FSOctetMinus[m_, n_] := FSOctetLeft[m, n] - FSOctetRight[m, n];
	
	SqrtSigmaMu[m_] := I * SqrtSigmaDag2.DCS[Sigma4, m].SqrtSigmaDag2;
	
	lh[m_] := lhNoWeak[m] + WeakCurrentL[m] + HC[WeakCurrentL[m]];
	rh[m_] := rhNoWeak[m];
	
	vmu[mu_] := 1 / 2 * (rh[mu] + lh[mu]);
	amu[mu_] := 1 / 2 * (rh[mu] - lh[mu]);
	
	(*
	  Covariant derivatives
	  ---------------------
	  From Scherer's review, Eqn.(4.58):
	    D_{\mu}A = \pd_{\mu}A - I r_{\mu} A + I l_{\mu} A
	*)
	
	DCS[FF_, mu_] := del[FF, mu] - I * rh[mu].FF + I * FF.lh[mu];
	
	HCDCS[FF_, mu_] := HC[DCS[FF, mu]];
	
	(* WZW Lagrangian, ignoring terms from the weak LH current *)
	scSigmaL[m_] := SigmaDag3.del[Sigma4, m];
	scSigmaR[m_] := Sigma3.HC[del[Sigma4, m]];
	
	z1[m_, n_, r_, s_] := 1 / 2 Sigma4 . lhNoWeak[m] . SigmaDag4 . rhNoWeak[n] . Sigma4 . lhNoWeak[r] . SigmaDag4 . rhNoWeak[s];
	z2[m_, n_, r_, s_] := Sigma4 . lhNoWeak[m] . lhNoWeak[n] . lhNoWeak[r] . SigmaDag4 . rhNoWeak[s] - SigmaDag4 . rhNoWeak[m] . rhNoWeak[n] . rhNoWeak[r] . Sigma4 . lhNoWeak[s];
	z3[m_, n_, r_, s_] := I Sigma4 . del[lhNoWeak[n], m] . lhNoWeak[r] . SigmaDag4 . rhNoWeak[s] - I SigmaDag4 . del[rhNoWeak[n], m] . rhNoWeak[r] . Sigma4 . lhNoWeak[s];
	z4[m_, n_, r_, s_] := I del[rhNoWeak[n], m] . Sigma4 . lhNoWeak[r] . SigmaDag4 . rhNoWeak[s] - I del[lhNoWeak[n], m] . SigmaDag4 . rhNoWeak[r] . Sigma4 . lhNoWeak[s];
	z5[m_, n_, r_, s_] := -I scSigmaL[m] . lhNoWeak[n] . SigmaDag3 . rhNoWeak[r] . Sigma3 . lhNoWeak[s] + I scSigmaR[m] . rhNoWeak[n] . Sigma3 . lhNoWeak[r] . SigmaDag3 . rhNoWeak[s];
	z6[m_, n_, r_, s_] := -I scSigmaL[m] . lhNoWeak[n] . lhNoWeak[r] . lhNoWeak[s] + I scSigmaR[m] . rhNoWeak[n] . rhNoWeak[r] . rhNoWeak[s];
	z7[m_, n_, r_, s_] := 1 / 2 scSigmaL[m] . SigmaDag3 . del[rhNoWeak[r], n] . Sigma3 . lhNoWeak[s] - 1 / 2 scSigmaR[m] . Sigma3 . del[lhNoWeak[r], n] . SigmaDag3 . rhNoWeak[s];
	z8[m_, n_, r_, s_] := 1 / 2 scSigmaL[m] . SigmaDag3 . rhNoWeak[n] . Sigma3 . del[lhNoWeak[s], r] - 1 / 2 scSigmaR[m] . Sigma3 . lhNoWeak[n] . SigmaDag3 . del[rhNoWeak[s], r];
	z9[m_, n_, r_, s_] := -scSigmaL[m] . scSigmaL[n] . SigmaDag3 . rhNoWeak[r] . Sigma3 . lhNoWeak[s] + scSigmaR[m] . scSigmaR[n] . Sigma3 . lhNoWeak[r] . SigmaDag3 . rhNoWeak[s];
	z10[m_, n_, r_, s_] := scSigmaL[m] . lhNoWeak[n] . del[lhNoWeak[s], r] - scSigmaR[m] . rhNoWeak[n] . del[rhNoWeak[s], r];
	z11[m_, n_, r_, s_] := scSigmaL[m] . del[lhNoWeak[r], n] . lhNoWeak[s] - scSigmaR[m] . del[rhNoWeak[r], n] . rhNoWeak[s];
	z12[m_, n_, r_, s_] := 1 / 2 scSigmaL[m] . lhNoWeak[n] . scSigmaL[r] . lhNoWeak[s] - 1 / 2 scSigmaR[m] . rhNoWeak[n] . scSigmaR[r] . rhNoWeak[s];
	z13[m_, n_, r_, s_] := -I scSigmaL[m] . scSigmaL[n] . scSigmaL[r] . lhNoWeak[s] + I scSigmaR[m] . scSigmaR[n] . scSigmaR[r] . rhNoWeak[s];
	
	z[m_, n_, r_, s_] := Total[{
	  z1[m, n, r, s],
	  z2[m, n, r, s],
	  z3[m, n, r, s],
	  z4[m, n, r, s],
	  z5[m, n, r, s],
	  z6[m, n, r, s],
	  z7[m, n, r, s],
	  z8[m, n, r, s],
	  z9[m, n, r, s],
	  z10[m, n, r, s],
	  z11[m, n, r, s],
	  z12[m, n, r, s],
	  z13[m, n, r, s]}];
	
	(*
	  Tools for including Resonances
	  ------------------------------
	    - ResonanceMatrix: Similar to Goldstone matrix but with vector resonances
	    - ResConnection: Connection used to define vector resonance covariant derivative
	    - ResonanceFS: Field-strength tensor for vector resonances
	    - ResonanceJ2: J2 resonance interaction term
	*)
	
	ResonanceMatrix[m_] := {
	  {rho[m] / Sqrt[2] + omega[m] / Sqrt[6], 0, 0},
	  {0, -rho[m] / Sqrt[2] + omega[m] / Sqrt[6], 0},
	  {0, 0, -2 omega[m] / Sqrt[6]}
	};
	
	ResConnection[m_] := Block[{derTerm1, derTerm2, curTerm1, curTerm2, tot},
	  derTerm1 = 1 / 2 * SqrtSigmaDag3 . del[SqrtSigma4, m];
	  curTerm1 = -I / 2 * SqrtSigmaDag4 . rhNoWeak[m] . SqrtSigma4;
	
	  derTerm2 = 1 / 2 * SqrtSigma3 . del[SqrtSigmaDag4, m];
	  curTerm2 = -I / 2 * SqrtSigma4 . lhNoWeak[m] . SqrtSigmaDag4;
	
	  tot = derTerm1 + derTerm2 + curTerm1 + curTerm2;
	
	  FpiExpand[tot, 3]
	];
	
	ResonanceFS[m_, n_] := Block[{derivTerm, connectTerm1, connectTerm2, tot},
	  derivTerm = del[ResonanceMatrix[n], m] - del[ResonanceMatrix[m], n];
	
	  (* These are already expanded to O(f^-3) *)
	  connectTerm1 = commutator[ResConnection[m], ResonanceMatrix[n]];
	  connectTerm2 = commutator[ResConnection[n], ResonanceMatrix[m]];
	
	  tot = derivTerm + connectTerm1 + connectTerm2
	];
	
	ResonanceJ2[m_, n_] := -fv / 2 / Sqrt[2] * FSOctetPlus[m, n] - I * gv / Sqrt[2] * SqrtSigmaMu[m].SqrtSigmaMu[n];
d7d5793ca42d08e0eca91ff9ae5c7745|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|24|1|V|
	GAMatrix = 1/4 * DiagonalMatrix[{1, -1, -1}];
e29fb048f406aca89a588c5347b6af27|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|97|1|V|
	CKM = {{0, Vud, Vus}, {0, 0, 0}, {0, 0, 0}};
6a6c40567c50a180d701bc3bc5ed8933|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|98|33|v|
	VudD
45d4d0287e1ea52bfc9a08b2909021d4|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|105|1|V|
		t1 = CKM * (CmixN * vlbar.ga[mu].left[l]-SmixN*vrbar.ga[mu].left[l]);	
eb50ae4471ef328606165d9e8408b7f3|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|103|1|V|
	LHCurrent[mu_] := Module[{coeff,t1,t2,t3},
		coeff = -4 * GF / Sqrt[2];
		t1 = CKM * (CmixN * vlbar.ga[mu].left[l]-SmixN*vrbar.ga[mu].left[l]);	
		t2 = CKMD * (CmixN * lbar.ga[mu].left[vl]-SmixN*lbar.ga[mu].left[vr]);	
		t3 = 2 / cw^2 * (GVMatrix-GAMatrix) * (
			lbar.ga[mu].(gvl + gal*ga[5]).l +
			CmixN^2 * vlbar.ga[mu].left[vl] +
			SmixN^2 * vrbar.ga[mu].left[vr] -
			SmixN * CmixN * (vlbar.ga[mu].left[vr] + vrbar.ga[mu].left[vl])
		);
	);
c1afce827785040b58db1f56bf3fbf54|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|118|1|V|
		t1 = CKM * (CmixN * vlbar.ga[mu].left[l]-SmixN*vrbar.ga[mu].left[l]);	
		t2 = CKMD * (CmixN * lbar.ga[mu].left[vl]-SmixN*lbar.ga[mu].left[vr]);	
a3eccdd03161e35147b76b85bd0f4277|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|116|33|v|
	t1,t2,
560f05ddf3dffd90377f79fe31941234|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|104|1|V|
		gvl = -1/4;
		gal = -1/4 + sw^2;
b33729306f6b93b84c522b3b0280a568|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|21|1|V|
	VecCouplingMatrix = DiagonalMatrix[{gvuu, gvdd, gvss}];
2a2f9efb7dd05d3a1cc44e5f5b80799b|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|21|1|V|
	AxCouplingMatrix = DiagonalMatrix[{gauu, gadd, gass}];
339660fce23327a68d2c1cd29ae6962a|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|21|1|V|
	PCouplingMatrix = DiagonalMatrix[{gpuu, gpdd, gpss}];
00b4755c74327f2b0fb4773779d908c7|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|125|12|v|
	 + EMCurrentR[mu]
7bca46025cf0cd32a3da1a52978a2a37|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|112|24|v|
	 + EMCurrentL[mu]
4fe0c357f75b0fa156183e7f80525678|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|96|1|V|
	WeakCurrentL[m_] := 2 * Sqrt[2] * GF * CKM * lbar.Ga[m].ProjM.vl;
8d1b69dd9bdc9df4a8073c7a8193c7af|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|125|1|V|
	
	
	
	
	
	
	
	
	
1c12112b57ada0c16be2f3f116367836|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|127|1|V|
	  If[$IncludeVectorMediator, current = current + VecCurrentL[m]];
ef064aa6122e8578170bf77214ff6f10|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|127|3|V|
	  If[$IncludeAxialVectorMediator, current = current + AxCurrentL[m]];
ed75a32b04a79e1638c18fb1fff46bab|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|126|3|v|
	current = 
2cab102a59d656a7fb73812e9808ac79|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|127|3|V|
	  current
2f3914fd29fb50e11b012ab3f3727bfb|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|130|3|v|
	current 
d6d21f6e6722e42f01a29bd55b95462f|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|131|1|V|
	  If[$IncludeVectorMediator, current = current + VecCurrentL[m]];
	  If[$IncludeAxialVectorMediator, current = current + AxCurrentR[m]];
	  current
b20d961b8a5557b970a011d51b97a7ef|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|140|41|v|
	+ HC[WeakCurrentL[m]];
808072b88369cc5469485cbfa0fdf96b|file:///Users/loganmorrison/Library/Mathematica/Applications/HazmaTools/Models/Lagrangians.fr|1|1|V|
	(* Total Lagrangian *)
	
	Lagrangian := Module[{lag},
	  lag = LPhoton + LNeutrino + LLepton;
	  lag += LDarkMatter;
	  lag += LChiPT;
	  If[$IncludeScalarMediator, lag += LScalar];
	  If[$IncludeVectorMediator, lag += LVector];
	  If[$IncludeAxialVectorMediator, lag += LAxialVector];
	  Normal[Series[lag, {GF, 0, 1}]]
	];
	
	(*
	  Plain Standard Model
	  --------------------
	    - LPhoton: Photon kinetic term
	    - LNeutrino: Neutrino kinetic term
	    - LLepton: Lepton kinetic term
	*)
	
	LPhoton := Block[{mu, nu},
	  -1 / 4 * FS[A, mu, nu] FS[A, mu, nu]
	];
	
	LNeutrino := Block[{m},
	  I * left[nubar].Ga[m].del[left[nu], m]
	];
	
	LLepton := Block[{m},
	  I * lbar.Ga[m].DC[l, m] - ml lbar.l
	];
	
	(*
	  Dark Matter
	  -----------
	    - LDarkMatter: DM kinetic and mass terms
	*)
	
	LDarkMatter := Block[{mu}, I * (xbar . Ga[mu] . del[x, mu]) - mx * xbar . x];
	
	(*
	  Chiral Lagrangian
	  -----------------
	    - LChiPTKinetic: Meson kinetic term Scherer Eqn.(4.70)
	    - LChiPTMass: Meson mass term Scherer Eqn.(4.70) with chi = 2 * B0 * QuarkMassMatrix
	    - LChiPTWessZuminoWitten: Wess-Zumino-Witten term
	    - LChiPTKineticRho: Kinetic term for the rho vector meson
	    - LChiPTRhoMes: Interaction term between rho vector meson and pions
	    - LChiPTContactRho: pi-pi-gamma contact interactions required to correct the rho propagator
	    - LChiPT: Chiral Lagrangian
	*)
	
	LChiPTKinetic := Block[{mu, kinetic},
	  kinetic = fpi^2 / 4 * Tr[DCS[Sigma4, mu].HCDCS[Sigma4, mu]];
	  FpiExpand[kinetic, 4]
	];
	
	LChiPTMass := b0 * fpi^2 / 2 * Tr[QuarkMassMatrix.(Sigma4 + SigmaDag4)];
	
	LChiPTWessZuminoWitten := Block[{m, n, r, s, coeff},
	  (*
	    This is positive since I'm using P&S and Schwartz' sign convention for Eps! Shouldn't affect
	    anything since none of the amplitudes coming from L_WZW interfere with amplitudes coming from
	    the rest of the Lagrangian.
	   *)
	  coeff = I / (48 Pi^2);
	
	  3 coeff Eps[m, n, r, s] Tr[FpiExpand[z[m, n, r, s], 3]]
	];
	
	LChiPTKineticRho := Block[{m, n, kinetic, mass},
	  kinetic = -1 / 4 * Tr[ResonanceFS[m, n] . ResonanceFS[m, n]];
	  mass = mVectorRes^2 / 2 * Tr[ResonanceMatrix[m] . ResonanceMatrix[m]];
	
	  kinetic + mass;
	
	  FpiExpand[kinetic + mass, 3]
	];
	
	LChiPTRhoMes := Block[{m, n},
	  1 / mVectorRes Tr[ResonanceFS[m, n] . ResonanceJ2[m, n]] // FpiExpand[#, 2]&
	];
	
	LChiPTContactRho := Block[{m, n},
	  -rhoContactCoeff / mVectorRes^2 Tr[ResonanceJ2[m, n] . ResonanceJ2[m, n]] // FpiExpand[#, 4]&
	];
	
	(* NOTE: Not including rho *)
	LChiPT := LChiPTKinetic + LChiPTMass + LChiPTWessZuminoWitten;
	
	
	(*
	  Scalar Mediator Theory
	  ----------------------
	    - fpiT: unphysical value of fpi
	    - b0T: unphysical value of b0
	    - LScalarKineticS: Scalar-Mediator kinetic term
	    - LScalarSLL: ScalarMediator-Lepton interactions
	    - LScalarSXX: ScalarMediator-DarkMatter interactions
	    - LScalarSFF: Effective interaction between ScalarMediator and photons
	    - LScalarMesSKin: Interactions between ScalarMediator and mesons through meson kinetic term
	    - LScalarMesSMass: Interactions between ScalarMediator and mesons through meson mass term
	    - LScalar: Full scalar piece of Lagrangian
	*)
	
	fpiT = (3 * fpi) / Sqrt[9 + (4 * gsGG * vs) / Lam];
	
	b0T = (b0 * (9 * Lam + 4 * gsGG * vs) * (-2 * gsGG * vh * vs + 3 * Lam * (vh - gsff * vs))) / (27 * Lam^2 * vh);
	
	LScalarKineticS := Block[{mu}, 1 / 2 * (del[sm, mu] * del[sm, mu] - ms^2 * sm^2)];
	
	LScalarSLL := -gsll * sm * lbar.l;
	
	LScalarSXX := -gsxx * sm * xbar.x;
	
	LScalarSFF := Block[{m, n},
	  (alphaEM * gsFF) / (4 * Lam * Pi) * sm * FS[A, m, n] * FS[A, m, n]
	];
	
	LScalarMesSKin := Module[{mu, coeff, kinetic, interaction},
	  coeff = (fpiT^2 * gsGG) / (9 * Lam);
	
	  kinetic = Tr[DCS[Sigma4, mu].HCDCS[Sigma4, mu]];
	
	  interaction = coeff * sm * kinetic;
	
	  FpiExpand[interaction, 4]
	];
	
	LScalarMesSMass := Module[{coeff1, coeff2, interaction},
	  coeff1 = (b0T * fpiT^2 * (2 * gsGG * vh * (9 * Lam - 4 * gsGG * vs) + 9 * gsff * Lam * (3 * Lam + 4 * gsGG * vs))) / (54 * Lam^2 * vh);
	
	  coeff2 = (b0T * fpiT^2 * gsGG * (9 * gsff * Lam - 2 * gsGG * vh)) / (27 * Lam^2 * vh);
	
	  interaction = (sm * coeff1 + sm^2 * coeff2) * Tr[QuarkMassMatrix.(Sigma4 + SigmaDag4)];
	
	  FpiExpand[interaction, 4]
	];
	
	LScalar := LScalarKineticS + LScalarSLL + LScalarSXX + LScalarSFF + LScalarMesSKin + LScalarMesSMass;
	
	
	(*
	  Vector Mediator Theory
	  ----------------------
	    - LVectorKineticV: Vector-Mediator Kinetic Term
	    - LVectorVLL: Lepton-AntiLepton-VectorMediator interaction
	    - LVectorVXX: DarkMatter-AntiDarkMatter-VectorMediator interaction
	    - LVector: Vector part of Lagrangian
	*)
	
	LVectorKineticV := Block[{m, n, kinetic, mass},
	  kinetic = -1 / 4 * FS[vm, m, n] * FS[vm, m, n];
	  mass = mv^2 / 2 * vm[m] * vm[m];
	
	  kinetic + mass
	];
	
	LVectorVLL := Block[{m}, gvll * vm[m] * lbar.Ga[m].l];
	
	LVectorVXX := Block[{m}, gvxx * vm[m] * xbar.Ga[m].x];
	
	LVector := LVectorKineticV + LVectorVLL + LVectorVXX;
	
	
	(*
	  Axial-Vector Mediator Theory
	  ----------------------
	    - LAxialVectorKineticA: AxialVectorMediator Kinetic Term
	    - LAxialVectorALL: Lepton-AntiLepton-AxialVectorMediator interaction
	    - LAxialVectorAXX: DarkMatter-AntiDarkMatter-AxialVectorMediator interaction
	    - LAxialVector: Axial-vector part of Lagrangian
	*)
	
	LAxialVectorKineticA := Block[{m, n, kinetic, mass},
	  kinetic = -1 / 4 * FS[avm, m, n] * FS[avm, m, n];
	  mass = ma^2 / 2 * avm[m] * avm[m];
	
	  kinetic + mass
	];
	
	LAxialVectorALL := Block[{m}, gall * avm[m] * lbar.Ga[m].(ProjP - ProjM).l];
	
	LAxialVectorAXX := Block[{m}, gaxx * avm[m] * xbar.Ga[m].(ProjP - ProjM).x];
	
	LAxialVector := LAxialVectorKineticA + LAxialVectorALL + LAxialVectorAXX;
a370eade75350bc2d9b7de00ad4e2aef|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Lagrangians.fr|25|1|V|
	LNeutrinoL := Block[{m}, I * left[nubar].Ga[m].del[left[nu], m] ];
6bacfa775996134797103b9515a17898|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|164|1|V|
	  F[3] == {
	    ClassName -> vr,
	    SelfConjugate -> True,
	    Mass -> mvr,
	    Width -> 0,
	    ParticleName -> "vr",
	    AntiParticleName -> "vr~",
	    TeXParticleName -> ComposedChar["\\nu", "R", Null],
	    PropagatorLabel -> ComposedChar["\\nu", "R", Null],
	    PropagatorType -> S,
	    PropagatorArrow -> Forward
	  },
6558fd69a605b3a7e9a433f91328626a|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|181|22|v|
	True,
7b295afed8d4ddf9ef263a05e24a4cf7|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|182|5|V|
	    Mass -> mvr,
0dcafd52c0037db0227319d406d0057a|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|182|1|V|
	    Width -> 0,
	    ParticleName -> "vr",
	    AntiParticleName -> "vr~",
	    TeXParticleName -> ComposedChar["\\nu", "R", Null],
	    PropagatorLabel -> ComposedChar["\\nu", "R", Null],
	    PropagatorType -> S,
	    PropagatorArrow -> Forward
56f80bf6edf5b35f973f61ffe0d91339|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|177|1|V|
	  (* Left handed Weyl neutrino *)
	  W[1] == {
	    ClassName -> nuL,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
945d5e233cf7d6240f6b783b36a374ff|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|183|6|v|
	Left
2d2ecace2c119f371ccbadbf38cea0f2|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|183|18|v|
	Weyl neutrino *)
f47f890928e03eb606b30665d089f246|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|183|1|V|
	  (* Left handed lepton *)
	  W[2] == {
	    ClassName -> ellL,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
2e6aab1d96d805fe1ba29c68949a1329|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|154|5|V|
	    WeylComponents
66343ec3cbb1a89d7deea29547c11555|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|184|3|v|
	(* Left handed lepton *)
	  W[21] == {
	    ClassName -> ellL,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
	  (* Left handed lepton *)
	  W[22] == {
	    ClassName -> ellR,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
	
ce4a5cb794a3f042ace7f6c561cb2489|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|180|1|V|
	  W[1] == {
	    ClassName -> nuL,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
f1698fc52b49e08fa8635034f3ba7de4|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|185|1|V|
	  W[21] == {
	    ClassName -> nuL,
	    Chirality -> Left,
	    SelfConjugate -> False
	  },
03fb10e969a327e6ab27881eed00e22e|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|155|28|v|
	ellbbar
2fd3f020a9458558334ac1d5d717fff8|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Particles.fr|142|1|V|
	    QuantumNumbers -> {LeptonNumber -> 1},
0382eb63d5943300c1456a14f9e111e2|file:///Users/loganmorrison/Documents/research/Gecco/RH-Neutrino/FeynRules/Tools.fr|101|38|v|
	left[l]
1011aba4e12e1ae2f1e1885f35857f96|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|2|1|v|cpp
	#define DARK_SUN_CROSS_SECTIONS_HPP
85224681b29e23ce1c27faa765c74e56|file:///Users/loganmorrison/Documents/git_hub/YAC/haliax/constrain/__init__.py|100|1|V|python
	    new_contours = []
	
	    for contour in contours:
	        _p2s, _p1s = contour.T
	
	        new_p2s = np.interp(_p2s, np.arange(len(p2s)), p2s)
	        new_p1s = np.interp(_p1s, np.arange(len(p1s)), p1s)
	
	        new_contours.append([new_p1s, new_p2s])
	
	    return new_contours
205ecce1933a873754314860b12e0612|file:///Users/loganmorrison/Documents/git_hub/YAC/haliax/constrain/__init__.py|81|1|V|python
	    """
	    Fix the contours produced by skimage's marching squares algorithm. Note
	    that their algorithm determines the contours based on the indices
	    and not actually coordinates.
	
	    Parameters
	    ----------
	    contours : array-like
	        Contours produced by skimage.
	    p1s: array-like
	        Array of the horizontal-axis parameters.
	    p2s: array-like
	        Array of the vertical-axis parameters.
	
	    Returns
	    -------
	    new_contours: array-like
	        New contours with coordinates instead of indices.
	    """
f797915fd59cf9aec56cabffd88c8f67|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|43|1|V|cpp
	    std::cout << cs[i] << std::endl;
2b2cb89f1a6ecfb6c374d8182082693f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|7|1|V|cpp
	void scan(
242352410f917bc8feb6653e7125741d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|24|2|V|cpp
	 std 
1e847903a574cdd099485ab12094070a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|6|1|V|cpp
	#include <vector>
7ad4905b4543ab4a1637dd23c50e36ce|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|35|13|v|cpp
	HEADER
9eb81e6f2e999536a471f2320a2c6a5e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|29|1|V|cpp
	  std::string header = "N,LAM,C,ADEL,LEC1,LEC2,MU_ETA,MU_DEL,XI_INF,RD_ETA,RD_"
	                       "DEL,SI_ETA,SI_DEL,DNEFF_CMB,DNEFF_BBN,XI_FO,TSM_FO\n";
099fb995346f31c749f6e40db0f395e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|23|13|v|cpp
	header
00d925351e275978e9e77d70cc4a51ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|57|1|v|cpp
	        DarkSun model(n, lam);
56c4968b98b554e3cff6621555de9da1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|57|1|V|cpp
	        DarkSun model(n, lam);
	        model.set_c(c);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << "," << model.get_c()
	             << "," << model.get_adel() << "," << model.get_lec1() << ","
	             << model.get_lec2() << "," << model.get_mu_eta() << ","
	             << model.get_mu_del() << "," << model.get_xi_inf() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
fc19bebcd731422f6e84248329fcfe32|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|44|1|V|cpp
	          n = static_cast<size_t>(x);
9b77956b3637ef78ce4ce9fb664bf5b8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|24|1|V|cpp
	std::string HEADER = "N,LAM,C,ADEL,LEC1,LEC2,MU_ETA,MU_DEL,XI_INF,RD_ETA,RD_"
	                     "DEL,SI_ETA,SI_DEL,DNEFF_CMB,DNEFF_BBN,XI_FO,TSM_FO\n";
adc3262b5de27e0b626558207f16320d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|31|1|V|cpp
	template <DarkSunPar ScanX, typename TX, size_t NumX, DarkSunPar ScanY,
	          typename TY, size_t NumY, DarkSunPar Sense, typename TSense,
	          size_t NumSense>
b976578a11f26df08008db987ea510fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|28|40|v|cpp
	, size_t NumX
1e64e0c6b3522543714921f27120de25|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|29|22|v|cpp
	, size_t NumY
d51e9c279c81a2f7d2612e91351a96f0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|29|57|v|cpp
	,
	          size_t NumSense
e4ba965739a625fd3ac570cbc22cb577|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|28|11|v|cpp
	DarkSunPar ScanX, 
fff6918511da4764e82abb0b71ae4f11|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|28|22|v|cpp
	, DarkSunPar ScanY
639b4baaff31c5b3f1e04aea4bd32b34|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|28|35|v|cpp
	, DarkSunPar Sense
c55281b4eda732350919c4fec8cbb143|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|30|1|V|cpp
	    DarkSunPar ScanX, 
77f4f7331ebc6a37f1ebec0d9de7d04c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|45|34|v|cpp
	Need different scan variables
ff79e553b83071dfea48dce584fab616|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|28|1|V|cpp
	template <typename TX, typename TY, typename TSense>
	void set_pars(DarkSun &model, 
	    DarkSunPar ScanX, 
	    TX x, 
	    DarkSunPar ScanY, 
	    TY y, 
	    DarkSunPar Sense, 
	    TSense sense){
	}
b573170f69f1d6420bdc67bcfbcff607|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|27|21|v|cpp
	X, typename TY, typename TSense>
687ee3f0271b92f9222708fe22797c9d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|29|16|v|cpp
	ScanX, 
bd232b76752fb108c66719ec9ea43e92|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|31|1|V|cpp
	    DarkSunPar ScanY, 
	    TY y, 
	    DarkSunPar Sense, 
	    TSense sense){
fd30fc7ebe6b398906d1be9c1543ab45|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|31|1|V|cpp
	  if (Par == DarkSunPar::N){
	  }e
e96d095f94ab3fb6e55d67357d7cc41c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|32|1|V|cpp
	    case DarkSunPar::N:
523eee4de998cdec6b1fb2331f3984ef|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|39|1|V|cpp
	    case DarkSunPar::MuDel:
cee223ebb71846324958777e9288d543|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|40|22|v|cpp
	MuDel
0689207c46115b36ca624d3905fe6910|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|33|1|V|cpp
	      model.set_n(static_cast<size_t>(p));
2ac8285c15f23ded4d04af200c664a70|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|47|6|V|cpp
	  default: {
	  }
b01b02fad5abbaf91a8c0a84be23c956|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|48|5|V|cpp
	    std::assert 
9299482cd687359e052af28c116d5ba1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|47|1|V|cpp
	    break;
974022b3f46f56e428625e5abbe292cd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|72|1|V|cpp
	  static_assert(ScanX != ScanY, "Scan variables must be different");
970a70c932251bf004021f59396c91d9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|73|26|v|cpp
	ScanY
7ab841a5393ab78f7db691b6d6782aae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|64|1|V|cpp
	  set_par(model, ScanX, x);
26b6e91e283c8d5e7699ae15e41dd390|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|66|18|v|cpp
	ScanX
c6d59065615bb2e781c4ee18ef8fe990|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|76|1|V|cpp
	  static_assert(ScanY != Sense, "Scan variables must be different");
60abc4b12539d01c141a36f6c736fd74|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|78|17|v|cpp
	ScanY != Sense, "Scan variables must be different");
be7257afe36dd3974fccdb17ffa4a249|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|78|1|V|cpp
	  static_assert((ScanX != DarkSunPar::N && ScanY != DarkSunPar::N && Sense != DarkSunPar::N),
	                "One of the scan variables must be N");
4ebf76f83a88d4c3b14552f064ad5927|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|95|1|V|cpp
	        if (ScanX == DarkSunPar::N) {
	          n = static_cast<size_t>(x);
	        }
e274c96c2db33aed3abbf5599a04daf9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|96|9|V|cpp
	        model.set_c(c);
3f0788e5afbde3251bcb8112143e6acb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|92|9|V|cpp
	        size_t n;
8dbbe77b7d646fc2cf9ab4e895dac1ae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|92|9|V|cpp
	        double lam;
f7f0c81a66095a7a1d6890bdd3bc0fb1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|110|7|v|cpp
	(auto &thread: threads){
fe27d04747f379350a66796bb6620530|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|110|1|V|cpp
	  for (size_t i = 0; i < NumSense; i++){
	    threads[i] = std::thread(scanner, senses[i], "");
	  }
d971d83de3c7d904e810796c0c126801|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|114|22|v|cpp
	 = std::thread(scanner, senses[i], "");
2a6804590a27fd9ece0821610c71bf91|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|57|23|v|cpp
	_error("Can't get here..");
a237250889567e56c427edd04f6f738f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|57|5|V|cpp
	    throw std::runtime
121f48309360742785a52cddf9345dfb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|56|3|V|cpp
	  default:
7fa50b0f778a979f1913ef338fd880c7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
a586444fa3f9767f2d2687cd61ae1fd7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/c_vs_lam.cpp|26|1|V|cpp
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_CS);
f3228b67706500dba0ae315829bbc2b6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|86|36|v|cpp
	NUM_LAMS *NUM_NS *NUM_CS);
bfaff935901c8687378c2f4c30775390|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|26|1|V|cpp
	std::mutex progress_mutex;
	boost::progress_display progress(NUM_LAMS *NUM_NS *NUM_CS);
	
	std::string header =
	    "# N LAM RD_ETA RD_DEL SI_ETA SI_DEL DNEFF_CMB DNEFF_BBN XI_FO TSM_FO\n";
49b12feb4a8d0823fbea119892069683|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|45|1|V|cpp
	  auto scan = [ns, lams](const double c, const std::string fname) {
	    std::ofstream file;
	    file.open(fname);
	    file << header;
	    for (auto n : ns) {
	      for (auto lam : lams) {
	        DarkSun model(n, lam);
	        model.set_c(c);
	        model.solve_boltzmann();
	
	        file << model.get_n() << "," << model.get_lam() << ","
	             << model.get_rd_eta() << "," << model.get_rd_del() << ","
	             << model.get_eta_si_per_mass() << ","
	             << model.get_del_si_per_mass() << "," << model.get_dneff_cmb()
	             << "," << model.get_dneff_bbn() << "," << model.get_xi_fo() << ","
	             << model.get_tsm_fo() << "\n";
	        std::lock_guard<std::mutex> gaurd(progress_mutex);
	        ++progress;
	      }
	    }
	    file.close();
	  };
	
	  std::thread thread_c1(scan, C1, fname_c1);
	  std::thread thread_c2(scan, C2, fname_c2);
	  thread_c1.join();
	  thread_c2.join();
4f38e44b9276746a94409a3c22adfcd9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|31|1|V|cpp
	      fs::current_path().append("../rundata/adel_scan/adel=0.0.dat");
a804b45d2d3bbe8a8be47cc269c4b4e6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|28|3|V|cpp
	  std::string fname_bas = 
4b8ef019857e7721be9fa6010d8daa3f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|72|11|v|cpp
	DarkSunPar S
bd8774d693f3f2a9e9b8189379ce2fa0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|69|11|v|cpp
	DarkSunPar ScanX
1c759a1498483c39be6ae34b1a9d24e3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|70|35|v|cpp
	, DarkSunPar ScanY,
35d85741c3369e5d69a23c1ef664a044|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|29|3|v|cpp
	std::string fname_c1 =
117469c9f82cccf9e9579c176d6c4754|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|31|3|v|cpp
	std::string fname_c2 =
71619e9ef29d4ffa6411528ba97b9008|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|28|43|v|cpp
	(NUM_ADEL);
5af34bb45b63a44693a975bab19df5d6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|32|32|v|cpp
	(NUM_NS);
fdc1f210c64d6f780c65cbb361a6c94e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|36|36|v|cpp
	(NUM_LAMS);
98028bcd5f1b00394a16f0ac3ae84c93|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|69|11|v|cpp
	DarkSunPar ScanX, DarkSunPar ScanY, DarkSunPar Sense, 
c7e91102fd0a7cbf04926d791b853b3d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|77|11|v|cpp
	DarkSunPar ScanX,
f0955db89689dcb53c089fe059dff444|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|79|1|V|cpp
	    const std::array<TX, NumX> &xs, const std::array<TY, NumX> &ys,
	    DarkSunPar ScanY,
	          const std::array<TSense, NumSense> &senses,
15cdcb0b2a2eee06a1ac9fa7235a9c70|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|32|1|V|cpp
	  ScanVar<size_t, NUM_NS, DarkSunPar::N> ns;
dee6c46f9004ab02471d1bc17f58fe87|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|36|3|V|cpp
	  std::array<size_t, NUM_NS> ns;
b584d3d8ba6503733d9c88748461f9d1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|39|3|V|cpp
	  std::array<double, NUM_LAMS> lams;
69335ff763dd3de815178e56c472b930|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/adel_scan.cpp|45|7|v|cpp
	<DarkSunPar::N, DarkSunPar::Lam, DarkSunPar::Adel>
64890f19fc4b2a308e4c3a9dc8fd8f0e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|95|59|v|cpp
	std::array<TX,NumX> &xs,
23147b15ed0e4407d78ede1f9b883d92|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|95|1|V|cpp
	                                                    const ScanVar<TX, NumX,ScanX> &x,
71b94e73a6b27722b3b6043f5f6ea1a1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|96|85|v|cpp
	,
	                                                    const std::array<TY,NumY> &ys
4db31f4009addfe8eb32912c2e3e09c1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|71|26|V|cpp
	  static constexpr DarkSunPar type = Par;
599dcce2998a6b40b1e38e8c6006cb0a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|105|28|v|cpp
	type
564107d495a544e1c3948d68c1a86eb9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|105|65|v|cpp
	Sense
7077436200a011b3ba264ca7272be5fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|29|52|v|cpp
	DarkSunPar Par, T p
56c5cacb1903240e423e8f8833f0fae9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|69|1|V|cpp
	template <typename T, size_t N, DarkSunPar Par> class ScanVar {
	public:
	  static constexpr DarkSunPar par_type() { return Par; }
	  std::array<T, N> vals;
	};
6f1b3ebd29b4b4a2b04e6864c2b9e88f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|69|15|v|cpp
	DarkSun &model, DarkSunPar ScanX, TX x, DarkSunPar ScanY, TY y,
	              DarkSunPar Sense, TSense sense
700d93434e5eebf0c3f5a4412f804a8b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|70|1|V|cpp
	    ScanVar<TX, SizeX,PX>&x,
bfd8dd788df3b13b2761d14ce8671859|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|68|1|V|cpp
	template <typename TX, sizetypename TY, typename TSense>
e4b2c2ffa182275e4a4d6ec0e1eae982|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|74|18|v|cpp
	ScanY, 
9d117160d32e8d3aacd6a88c47a2c74a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|75|18|v|cpp
	Sense, 
914da18bbc481130a4a545d9fc0f67a9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|108|25|v|cpp
	x.par_type(), valx, y.par_type(), valy,
c673e12d25037ea9366f1375d2ed2cad|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|109|24|v|cpp
	par_type(), sense);
e2f236c76602b9d0052a3a6b5463d140|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|97|19|v|cpp
	&progress, &progress_mutex
e954dd340381b58e8aa1089557c4337b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/scan_tools.hpp|17|1|V|cpp
	enum DarkSunPar {
	  N,
	  Lam,
	  C,
	  Adel,
	  Lec1,
	  Lec2,
	  MuEta,
	  MuDel,
	  XiInf,
	};
6600d6fe20b991864f7e2c38e47471d5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|13|3|v|cpp
	Adel
b6a4fa33fdb6ecf4e285b814e25972bf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|14|3|v|cpp
	Lec1
7b54f005d3277e4de05e06baf59147ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|15|3|v|cpp
	Lec2
003286ea52f46efd877ac17964bb12fe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|16|3|v|cpp
	MuEta
13e06c09a0e8e51a72b46876918a53de|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|18|3|v|cpp
	XiInf
a9ba900aee733cda087f34ba758c70e0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|37|1|V|cpp
	static constexpr size_t IDX_N = 0;
	static constexpr size_t IDX_LAM = 1;
	static constexpr size_t IDX_C = 2;
	static constexpr size_t IDX_LEC1 = 3;
	static constexpr size_t IDX_LEC2 = 4;
	static constexpr size_t IDX_ADEL = 5;
	static constexpr size_t IDX_MU_ETA = 6;
	static constexpr size_t IDX_MU_DEL = 7;
	static constexpr size_t IDX_XI_INF = 8;
	static constexpr size_t IDX_XI_FO = 9;
	static constexpr size_t IDX_TSM_FO = 10;
	static constexpr size_t IDX_XI_BBN = 11;
	static constexpr size_t IDX_XI_CMB = 12;
	static constexpr size_t IDX_RD_ETA = 13;
	static constexpr size_t IDX_RD_DEL = 14;
	static constexpr size_t IDX_DNEFF_CMB = 15;
	static constexpr size_t IDX_DNEFF_BBN = 16;
	static constexpr size_t IDX_ETA_SI_PER_MASS = 17;
	static constexpr size_t IDX_DEL_SI_PER_MASS = 18;
	static constexpr size_t IDX_XOUT = 19;
	static constexpr size_t IDX_DXOUT = 20;
bd5c0c4790c44bbe8834e02e7d8afc66|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|44|1|V|cpp
	  if constexpr (P == DarkSunParameters::n){
	    return rpar[DarkSunParameters::n];
	  }
1de1542b7afff7143ecc362e5034bd99|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|48|4|v|cpp
	else if constexpr (P == DarkSunParameters::lec1){
	    return rpar[DarkSunParameters::lec1];
	  }
	
1cb3307e788fcaf57d232d77d2f9da0b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|51|17|v|cpp
	DarkSunParameters::lec2
dfe5d7d735c31faf41b205913f207921|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|42|1|V|cpp
	  if constexpr (P == DarkSunParameters::n) {
	    return rpar[DarkSunParameters::n];
	  } else if constexpr (P == DarkSunParameters::lam) {
	    return rpar[DarkSunParameters::lam];
	  } else if constexpr (P == DarkSunParameters::c) {
	    return rpar[DarkSunParameters::c];
	  } else if constexpr (P == DarkSunParameters::lec1) {
	    return rpar[DarkSunParameters::lec1];
	  } else if constexpr (P == DarkSunParameters::lec2) {
	    return rpar[P];
	  }
137b48b9c33afea8309d62d33b5f7372|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|45|1|V|cpp
	double get_n(const double *rpar) { return rpar[IDX_N]; }
	double get_lam(const double *rpar) { return rpar[IDX_LAM]; }
	double get_c(const double *rpar) { return rpar[IDX_C]; }
	double get_lec1(const double *rpar) { return rpar[IDX_LEC1]; }
	double get_lec2(const double *rpar) { return rpar[IDX_LEC2]; }
	double get_adel(const double *rpar) { return rpar[IDX_ADEL]; }
	double get_mu_eta(const double *rpar) { return rpar[IDX_MU_ETA]; }
	double get_mu_del(const double *rpar) { return rpar[IDX_MU_DEL]; }
	double get_xi_inf(const double *rpar) { return rpar[IDX_XI_INF]; }
	double get_xi_fo(const double *rpar) { return rpar[IDX_XI_FO]; };
	double get_tsm_fo(const double *rpar) { return rpar[IDX_TSM_FO]; };
	double get_xi_bbn(const double *rpar) { return rpar[IDX_XI_BBN]; };
	double get_xi_cmb(const double *rpar) { return rpar[IDX_XI_CMB]; };
	double get_rd_eta(const double *rpar) { return rpar[IDX_RD_ETA]; };
	double get_rd_del(const double *rpar) { return rpar[IDX_RD_DEL]; };
	double get_dneff_cmb(const double *rpar) { return rpar[IDX_DNEFF_CMB]; };
	double get_dneff_bbn(const double *rpar) { return rpar[IDX_DNEFF_BBN]; };
	double get_eta_si_per_mass(const double *rpar) {
	  return rpar[IDX_ETA_SI_PER_MASS];
	};
	double get_del_si_per_mass(const double *rpar) {
	  return rpar[IDX_DEL_SI_PER_MASS];
	};
	double get_xout(const double *rpar) { return rpar[IDX_XOUT]; }
	double get_dxout(const double *rpar) { return rpar[IDX_DXOUT]; }
89f70a418feec6eab581d97d096d90e7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|80|1|V|cpp
	void set_n(double *rpar, size_t n) { rpar[IDX_N] = n; }
	void set_lam(double *rpar, double lam) { rpar[IDX_LAM] = lam; }
	void set_c(double *rpar, double c) { rpar[IDX_C] = c; }
	void set_lec1(double *rpar, double lec1) { rpar[IDX_LEC1] = lec1; }
	void set_lec2(double *rpar, double lec2) { rpar[IDX_LEC2] = lec2; }
	void set_adel(double *rpar, double adel) { rpar[IDX_ADEL] = adel; }
	void set_mu_eta(double *rpar, double mu_eta) { rpar[IDX_MU_ETA] = mu_eta; }
	void set_mu_del(double *rpar, double mu_del) { rpar[IDX_MU_DEL] = mu_del; }
	void set_xi_inf(double *rpar, double xi_inf) { rpar[IDX_XI_INF] = xi_inf; }
	void set_xi_fo(double *rpar, double xi) { rpar[IDX_XI_FO] = xi; };
	void set_tsm_fo(double *rpar, double tsm) { rpar[IDX_TSM_FO] = tsm; };
	void set_xi_bbn(double *rpar, double xi) { rpar[IDX_XI_BBN] = xi; };
	void set_xi_cmb(double *rpar, double xi) { rpar[IDX_XI_CMB] = xi; };
	void set_rd_eta(double *rpar, double rd) { rpar[IDX_RD_ETA] = rd; };
	void set_rd_del(double *rpar, double rd) { rpar[IDX_RD_DEL] = rd; };
	void set_dneff_cmb(double *rpar, double dneff) { rpar[IDX_DNEFF_CMB] = dneff; };
	void set_dneff_bbn(double *rpar, double dneff) { rpar[IDX_DNEFF_BBN] = dneff; };
	void set_eta_si_per_mass(double *rpar, double si) {
	  rpar[IDX_ETA_SI_PER_MASS] = si;
	};
	void set_del_si_per_mass(double *rpar, double si) {
	  rpar[IDX_DEL_SI_PER_MASS] = si;
	};
03300edf4ebf23435548c0c489d95c97|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|81|1|V|cpp
	void set_xout(double *rpar, double val) { rpar[IDX_XOUT] = val; };
	void set_dxout(double *rpar, double val) { rpar[IDX_DXOUT] = val; };
b8fce0f86ec1ea6b5616adfaa2b00b97|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|91|8|v|cpp
	IDX_XI_FO
f8ca99ec31e798cae4df799b8a813339|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|92|8|v|cpp
	IDX_TSM_FO
c5345f260342228b2c3c404c3049d01e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|93|15|v|cpp
	XI_BBN
3a9ebec64741cb7d4a37f6a03bc13cb9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|94|15|v|cpp
	XI_CMB
520c6372e4035c4e835dadcb384af05e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|95|15|v|cpp
	RD_ETA
2fa16e8407a09da9ab7cdc1d12aef70b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|96|15|v|cpp
	RD_DEL
c9b5b2a9c2ffbbd6805d6f990c6859db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|97|15|v|cpp
	DNEFF_CMB
31a40f105b7e4a28ee9d0f451363d039|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|98|15|v|cpp
	DNEFF_BBN
bd1ea23a5766b5b50e602434332628ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|99|15|v|cpp
	ETA_SI_PER_MASS
c4b1d9052d16b5c47b50b39ec4054914|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|100|15|v|cpp
	DEL_SI_PER_MASS
66ce074d04b1c7be2545389fd6ba0f1b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f|391|1|V|fortran
	C USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR
723ebe42856a6af0737958958eea1c1a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f|391|1|V|fortran
	C TYPE(C_PTR), INTENT(IN), VALUE ::ptr
8f2b91532a5704986374d4c3afb170f7|file:///Users/loganmorrison/.config/fish/config.fish|11|1|V|fish
	set PATH ~/.local/bin $PATH
14e9a5395f9f19efea9b36945454f76b|file:///Users/loganmorrison/.config/nvim/init.vim|188|27|v|vim
	/home/rudra
25c8c63e19830246ac26f61d972a2c2a|file:///Users/loganmorrison/.config/nvim/init.vim|182|1|V|vim
	augroup coc
	  autocmd!
	  autocmd VimEnter * :silent CocStart
	augroup end
1c0f8fa2bde24b53ac4c5579cfe10271|file:///Users/loganmorrison/.config/nvim/init.vim|181|1|V|vim
	let g:coc_start_at_startup = 0
74d69dade96cff32d7ae85ebd3df78e6|file:///Users/loganmorrison/.config/nvim/init.vim|182|1|V|vim
	let g:coc_user_config = {
	      \   'languageserver': {
	      \     'fortran': {
	      \       'command': '~/.local/bin/fortls',
	      \       'args': ['--lowercase_intrinsics'],
	      \       'filetypes': ['fortran'],
	      \       'rootPatterns': ['.fortls', '.git/'],
	      \     }
	      }
	}
a98a5032f6b06066f87b18ab34a7b25a|file:///Users/loganmorrison/.config/nvim/coc-settings.json|16|7|V|json
	      \     'fortran': {
ef928e7303072e53b59b66902a0a23e6|file:///Users/loganmorrison/.config/nvim/coc-settings.json|14|1|V|json
	let g:coc_user_config = {
515c818f1c89b1a396f6434745a9ffba|file:///Users/loganmorrison/.config/nvim/coc-settings.json|16|19|v|json
	~/.local/bin/
b068931cc450442b63f5b3d276ea4297|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|7|12|v|fortran
	name
793a66efe11e9cba8499363393cb92d3|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|3|1|V|fortran
	   character*20 :: name
	   character(len=20) :: f_name, l_name
	   print *, "What's your name"
	
	   read *, f_name, l_name
	   print *, "Hello ", trim(f_name), " ", trim(l_name)
0009b12a43e94e878cbfa1c9eec0e509|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|11|1|V|fortran
	   print *, "Biggest real ", huge(r_num1)
918df7f0b35a53205cea290a426355b1|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|11|1|V|fortran
	   print *, "Biggest real ", huge(r_num1)
	   print *, "Biggest Int ", huge(i_num1)
	
67b02a660ddd129bec3e91972a4181c7|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|15|14|v|fortran
	Biggest
67b02a660ddd129bec3e91972a4181c7|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|15|14|v|fortran
	Biggest
b7cf27ffe6ea83cdcf8af2ef29de9285|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|14|31|v|fortran
	huge
3496064effd612e2aa77252d1db194e6|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/fortrantut.f90|15|1|V|fortran
	   print *, "Smallest Int ", tiny(i_num1)
1a1233623929795a7d36f4b7556fbe36|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/decsol.f90|2|1|V|fortran
	   ! version real double precision
1a978a4c62e422925c9a877df2529fea|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|12|1|V|make
	SRCDIR     = src
	OBJDIR     = obj
	BINDIR     = bin
	RUNDATADIR = rundata
13b1ea23c8a35d08189d136bdc9082a5|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|17|1|V|make
	SOURCES  := $(wildcard $(SRCDIR)/*.cpp)
6f32029d41f019f6d928480d19565110|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|19|1|V|make
	OBJECTS  := $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)
9774e8c8a57bbca2a4c5b69e229bd5f8|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|23|1|V|make
	$(BINDIR)/$(TARGET): $(OBJECTS)
		@$(LINKER) $(OBJECTS) $(LFLAGS) -o $@
		@echo "Linking complete!"
aa6830deb60d7afe440cf6e93d4d6423|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|27|1|V|make
	$(OBJECTS): $(OBJDIR)/%.o : $(SRCDIR)/%.cpp
		@$(CC) $(CFLAGS) -c $< -o $@
		@echo "Compiled "$<" successfully!"
78c0327e60b64fd47ee107248c530fb0|file:///Users/loganmorrison/Documents/coding/cpp/charged_pi_spectrum/Makefile|31|1|V|make
	run:
		./$(BINDIR)/$(TARGET)
	
	.PHONY: clean
	clean:
		@$(rm) $(OBJECTS)
		@echo "Cleanup complete!"
	
	.PHONY: remove
	remove: clean
		@$(rm) $(BINDIR)/$(TARGET)
		@$(rm) $(wildcard $(RUNDATADIR)/*.csv)
		@$(rm) $(wildcard $(SRCDIR)/*.h.gch)
		@echo "Executable removed!"
4a350ea81a596b1f5e0730d865238080|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/Makefile|32|1|V|make
		@$(rm) $(wildcard $(SRCDIR)/*.h.gch)
527761651331aca93472fce216aea9f8|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/Makefile|3|1|V|make
	FF = gfortran
c4999838a05455c68f2ac7b89dee8b35|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/Makefile|1|1|V|make
	SFLAG = -shared -o
354a57bc0f7dcbfe7dd3122be7eefab7|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/Makefile|15|24|v|make
	$(LFLAGS)
33b06f835c2b35fe87ad7abb1c5f1718|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/decsol.f90|2|3|V|fortran
	  public :: decsol 
9b8c0df3cc2037a7f4aac974144ad40a|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/lapackc.f90|72|7|V|fortran
	      external xerbla, zgetrf, zgetrs
5c6e74b292fb0c525b121f621060301e|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|6|1|V|fortran
	subroutine decomr(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, fac1, e1, lde1, ip1, ier, ijob, calhes, iphes)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), e1(lde1, nm1), &
	            ip1(nm1), iphes(n)
	    logical calhes
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 14, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do j = 1, n
	        do  i = 1, n
	            e1(i, j) = -fjac(i, j)
	        end do
	        e1(j, j) = e1(j, j) + fac1
	    end do
	    call dec (n, lde1, e1, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e1(i, j) = -fjac(i, jm1)
	        end do
	        e1(j, j) = e1(j, j) + fac1
	    end do
	    45   mm = m1 / m2
	    do j = 1, m2
	        do i = 1, nm1
	            sum = 0.d0
	            do k = 0, mm - 1
	                sum = (sum + fjac(i, j + k * m2)) / fac1
	            end do
	            e1(i, j) = e1(i, j) - sum
	        end do
	    end do
	    call dec (nm1, lde1, e1, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            e1(i + mle, j) = -fjac(i, j)
	        end do
	        e1(mdiag, j) = e1(mdiag, j) + fac1
	    end do
	    call decb (n, lde1, e1, mle, mue, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e1(i + mle, j) = -fjac(i, jm1)
	        end do
	        e1(mdiag, j) = e1(mdiag, j) + fac1
	    end do
	    46  mm = m1 / m2
	    do j = 1, m2
	        do i = 1, mbjac
	            sum = 0.d0
	            do k = 0, mm - 1
	                sum = (sum + fjac(i, j + k * m2)) / fac1
	            end do
	            e1(i + mle, j) = e1(i + mle, j) - sum
	        end do
	    end do
	    call decb (nm1, lde1, e1, mle, mue, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            e1(i, j) = -fjac(i, j)
	        end do
	        do i = max(1, j - mumas), min(n, j + mlmas)
	            e1(i, j) = e1(i, j) + fac1 * fmas(i - j + mbdiag, j)
	        end do
	    end do
	    call dec (n, lde1, e1, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e1(i, j) = -fjac(i, jm1)
	        end do
	        do i = max(1, j - mumas), min(nm1, j + mlmas)
	            e1(i, j) = e1(i, j) + fac1 * fmas(i - j + mbdiag, j)
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            e1(i + mle, j) = -fjac(i, j)
	        end do
	        do i = 1, mbb
	            ib = i + mdiff
	            e1(ib, j) = e1(ib, j) + fac1 * fmas(i, j)
	        end do
	    end do
	    call decb (n, lde1, e1, mle, mue, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    14  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e1(i + mle, j) = -fjac(i, jm1)
	        end do
	        do i = 1, mbb
	            ib = i + mdiff
	            e1(ib, j) = e1(ib, j) + fac1 * fmas(i, j)
	        end do
	    end do
	    goto 46
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            e1(i, j) = fmas(i, j) * fac1 - fjac(i, j)
	        end do
	    end do
	    call dec (n, lde1, e1, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e1(i, j) = fmas(i, j) * fac1 - fjac(i, jm1)
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    if (calhes) call elmhes (ldjac, n, 1, n, fjac, iphes)
	    calhes = .false.
	    do j = 1, n - 1
	        j1 = j + 1
	        e1(j1, j) = -fjac(j1, j)
	    end do
	    do j = 1, n
	        do i = 1, j
	            e1(i, j) = -fjac(i, j)
	        end do
	        e1(j, j) = e1(j, j) + fac1
	    end do
	    call dech(n, lde1, e1, 1, ip1, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
e202ceded7d8f78613f6130609141461|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|6|1|v|fortran
	subroutine decomr(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, &
ecd110ab9bc188f9138ba47062f1e41a|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|212|1|V|fortran
	subroutine decomc(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, alphn, betan, e2r, e2i, lde1, ip2, ier, ijob)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), &
	            e2r(lde1, nm1), e2i(lde1, nm1), ip2(nm1)
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 14, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            e2r(i, j) = -fjac(i, j)
	            e2i(i, j) = 0.d0
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    call decc (n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = -fjac(i, jm1)
	            e2i(i, j) = 0.d0
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    45  mm = m1 / m2
	    abno = alphn**2 + betan**2
	    alp = alphn / abno
	    bet = betan / abno
	    do j = 1, m2
	        do i = 1, nm1
	            sumr = 0.d0
	            sumi = 0.d0
	            do k = 0, mm - 1
	                sums = sumr + fjac(i, j + k * m2)
	                sumr = sums * alp + sumi * bet
	                sumi = sumi * alp - sums * bet
	            end do
	            e2r(i, j) = e2r(i, j) - sumr
	            e2i(i, j) = e2i(i, j) - sumi
	        end do
	    end do
	    call decc (nm1, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            imle = i + mle
	            e2r(imle, j) = -fjac(i, j)
	            e2i(imle, j) = 0.d0
	        end do
	        e2r(mdiag, j) = e2r(mdiag, j) + alphn
	        e2i(mdiag, j) = betan
	    end do
	    call decbc (n, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e2r(i + mle, j) = -fjac(i, jm1)
	            e2i(i + mle, j) = 0.d0
	        end do
	        e2r(mdiag, j) = e2r(mdiag, j) + alphn
	        e2i(mdiag, j) = e2i(mdiag, j) + betan
	    end do
	    46  mm = m1 / m2
	    abno = alphn**2 + betan**2
	    alp = alphn / abno
	    bet = betan / abno
	    do j = 1, m2
	        do i = 1, mbjac
	            sumr = 0.d0
	            sumi = 0.d0
	            do k = 0, mm - 1
	                sums = sumr + fjac(i, j + k * m2)
	                sumr = sums * alp + sumi * bet
	                sumi = sumi * alp - sums * bet
	            end do
	            imle = i + mle
	            e2r(imle, j) = e2r(imle, j) - sumr
	            e2i(imle, j) = e2i(imle, j) - sumi
	        end do
	    end do
	    call decbc (nm1, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do  j = 1, n
	        do  i = 1, n
	            e2r(i, j) = -fjac(i, j)
	            e2i(i, j) = 0.d0
	        end do
	    end do
	    do j = 1, n
	        do i = max(1, j - mumas), min(n, j + mlmas)
	            bb = fmas(i - j + mbdiag, j)
	            e2r(i, j) = e2r(i, j) + alphn * bb
	            e2i(i, j) = betan * bb
	        end do
	    end do
	    call decc(n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = -fjac(i, jm1)
	            e2i(i, j) = 0.d0
	        end do
	        do i = max(1, j - mumas), min(nm1, j + mlmas)
	            ffma = fmas(i - j + mbdiag, j)
	            e2r(i, j) = e2r(i, j) + alphn * ffma
	            e2i(i, j) = e2i(i, j) + betan * ffma
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            imle = i + mle
	            e2r(imle, j) = -fjac(i, j)
	            e2i(imle, j) = 0.d0
	        end do
	        do i = max(1, mumas + 2 - j), min(mbb, mumas + 1 - j + n)
	            ib = i + mdiff
	            bb = fmas(i, j)
	            e2r(ib, j) = e2r(ib, j) + alphn * bb
	            e2i(ib, j) = betan * bb
	        end do
	    end do
	    call decbc (n, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    14  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e2r(i + mle, j) = -fjac(i, jm1)
	            e2i(i + mle, j) = 0.d0
	        end do
	        do i = 1, mbb
	            ib = i + mdiff
	            ffma = fmas(i, j)
	            e2r(ib, j) = e2r(ib, j) + alphn * ffma
	            e2i(ib, j) = e2i(ib, j) + betan * ffma
	        end do
	    end do
	    goto 46
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            bb = fmas(i, j)
	            e2r(i, j) = bb * alphn - fjac(i, j)
	            e2i(i, j) = bb * betan
	        end do
	    end do
	    call decc(n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = alphn * fmas(i, j) - fjac(i, jm1)
	            e2i(i, j) = betan * fmas(i, j)
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    do j = 1, n - 1
	        j1 = j + 1
	        e2r(j1, j) = -fjac(j1, j)
	        e2i(j1, j) = 0.d0
	    end do
	    do j = 1, n
	        do i = 1, j
	            e2i(i, j) = 0.d0
	            e2r(i, j) = -fjac(i, j)
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    call dechc(n, lde1, e2r, e2i, 1, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
99286f6509993c17d3af32391fb87029|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/radau.f90|14|1|V|fortran
	      !
	      ! -----------------------------------------------------------
	      !
33f75880f7d0169cee8e0afc3879c730|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/radau.f90|16|7|V|fortran
	      ! ---  b=identity, jacobian a full matrix
712979efb6bfb44f691267e4a8f3aa1c|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|212|1|v|fortran
	subroutine decomc(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, alphn, betan, e2r, e2i, lde1, ip2, ier, ijob)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), &
	            e2r(lde1, nm1), e2i(lde1, nm1), ip2(nm1)
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 14, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            e2r(i, j) = -fjac(i, j)
	            e2i(i, j) = 0.d0
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    call decc (n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = -fjac(i, jm1)
	            e2i(i, j) = 0.d0
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    45  mm = m1 / m2
	    abno = alphn**2 + betan**2
	    alp = alphn / abno
	    bet = betan / abno
	    do j = 1, m2
	        do i = 1, nm1
	            sumr = 0.d0
	            sumi = 0.d0
	            do k = 0, mm - 1
	                sums = sumr + fjac(i, j + k * m2)
	                sumr = sums * alp + sumi * bet
	                sumi = sumi * alp - sums * bet
	            end do
	            e2r(i, j) = e2r(i, j) - sumr
	            e2i(i, j) = e2i(i, j) - sumi
	        end do
	    end do
	    call decc (nm1, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            imle = i + mle
	            e2r(imle, j) = -fjac(i, j)
	            e2i(imle, j) = 0.d0
	        end do
	        e2r(mdiag, j) = e2r(mdiag, j) + alphn
	        e2i(mdiag, j) = betan
	    end do
	    call decbc (n, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e2r(i + mle, j) = -fjac(i, jm1)
	            e2i(i + mle, j) = 0.d0
	        end do
	        e2r(mdiag, j) = e2r(mdiag, j) + alphn
	        e2i(mdiag, j) = e2i(mdiag, j) + betan
	    end do
	    46  mm = m1 / m2
	    abno = alphn**2 + betan**2
	    alp = alphn / abno
	    bet = betan / abno
	    do j = 1, m2
	        do i = 1, mbjac
	            sumr = 0.d0
	            sumi = 0.d0
	            do k = 0, mm - 1
	                sums = sumr + fjac(i, j + k * m2)
	                sumr = sums * alp + sumi * bet
	                sumi = sumi * alp - sums * bet
	            end do
	            imle = i + mle
	            e2r(imle, j) = e2r(imle, j) - sumr
	            e2i(imle, j) = e2i(imle, j) - sumi
	        end do
	    end do
	    call decbc (nm1, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do  j = 1, n
	        do  i = 1, n
	            e2r(i, j) = -fjac(i, j)
	            e2i(i, j) = 0.d0
	        end do
	    end do
	    do j = 1, n
	        do i = max(1, j - mumas), min(n, j + mlmas)
	            bb = fmas(i - j + mbdiag, j)
	            e2r(i, j) = e2r(i, j) + alphn * bb
	            e2i(i, j) = betan * bb
	        end do
	    end do
	    call decc(n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = -fjac(i, jm1)
	            e2i(i, j) = 0.d0
	        end do
	        do i = max(1, j - mumas), min(nm1, j + mlmas)
	            ffma = fmas(i - j + mbdiag, j)
	            e2r(i, j) = e2r(i, j) + alphn * ffma
	            e2i(i, j) = e2i(i, j) + betan * ffma
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do j = 1, n
	        do i = 1, mbjac
	            imle = i + mle
	            e2r(imle, j) = -fjac(i, j)
	            e2i(imle, j) = 0.d0
	        end do
	        do i = max(1, mumas + 2 - j), min(mbb, mumas + 1 - j + n)
	            ib = i + mdiff
	            bb = fmas(i, j)
	            e2r(ib, j) = e2r(ib, j) + alphn * bb
	            e2i(ib, j) = betan * bb
	        end do
	    end do
	    call decbc (n, lde1, e2r, e2i, mle, mue, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    14  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, mbjac
	            e2r(i + mle, j) = -fjac(i, jm1)
	            e2i(i + mle, j) = 0.d0
	        end do
	        do i = 1, mbb
	            ib = i + mdiff
	            ffma = fmas(i, j)
	            e2r(ib, j) = e2r(ib, j) + alphn * ffma
	            e2i(ib, j) = e2i(ib, j) + betan * ffma
	        end do
	    end do
	    goto 46
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do j = 1, n
	        do i = 1, n
	            bb = fmas(i, j)
	            e2r(i, j) = bb * alphn - fjac(i, j)
	            e2i(i, j) = bb * betan
	        end do
	    end do
	    call decc(n, lde1, e2r, e2i, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do j = 1, nm1
	        jm1 = j + m1
	        do i = 1, nm1
	            e2r(i, j) = alphn * fmas(i, j) - fjac(i, jm1)
	            e2i(i, j) = betan * fmas(i, j)
	        end do
	    end do
	    goto 45
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    do j = 1, n - 1
	        j1 = j + 1
	        e2r(j1, j) = -fjac(j1, j)
	        e2i(j1, j) = 0.d0
	    end do
	    do j = 1, n
	        do i = 1, j
	            e2i(i, j) = 0.d0
	            e2r(i, j) = -fjac(i, j)
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    call dechc(n, lde1, e2r, e2i, 1, ip2, ier)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
	
5717e301be570e45db82ade1f18b33a7|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|460|1|V|fortran
	subroutine slvrar(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, fac1, e1, lde1, z1, f1, ip1, iphes, ier, ijob)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), e1(lde1, nm1), &
	            ip1(nm1), iphes(n), z1(n), f1(n)
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 13, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do i = 1, n
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do i = 1, n
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    48   continue
	    mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sum1 = (z1(jkm) + sum1) / fac1
	            do i = 1, nm1
	                im1 = i + m1
	                z1(im1) = z1(im1) + fjac(i, jkm) * sum1
	            end do
	        end do
	    end do
	    call sol (nm1, lde1, e1, z1(m1 + 1), ip1)
	    49   continue
	    do i = m1, 1, -1
	        z1(i) = (z1(i) + z1(m2 + i)) / fac1
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do i = 1, n
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    call solb (n, lde1, e1, mle, mue, z1, ip1)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do i = 1, n
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    45  continue
	    mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sum1 = (z1(jkm) + sum1) / fac1
	            do i = max(1, j - mujac), min(nm1, j + mljac)
	                im1 = i + m1
	                z1(im1) = z1(im1) + fjac(i + mujac + 1 - j, jkm) * sum1
	            end do
	        end do
	    end do
	    call solb (nm1, lde1, e1, mle, mue, z1(m1 + 1), ip1)
	    goto 49
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do i = 1, n
	        s1 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            s1 = s1 - fmas(i - j + mbdiag, j) * f1(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s1 = 0.0d0
	        do j = max(1, i - mlmas), min(nm1, i + mumas)
	            s1 = s1 - fmas(i - j + mbdiag, j) * f1(j + m1)
	        end do
	        z1(im1) = z1(im1) + s1 * fac1
	    end do
	    if (ijob==14) goto 45
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do i = 1, n
	        s1 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            s1 = s1 - fmas(i - j + mbdiag, j) * f1(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	    end do
	    call solb (n, lde1, e1, mle, mue, z1, ip1)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do i = 1, n
	        s1 = 0.0d0
	        do j = 1, n
	            s1 = s1 - fmas(i, j) * f1(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s1 = 0.0d0
	        do j = 1, nm1
	            s1 = s1 - fmas(i, j) * f1(j + m1)
	        end do
	        z1(im1) = z1(im1) + s1 * fac1
	    end do
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    do i = 1, n
	        z1(i) = z1(i) - f1(i) * fac1
	    end do
	    do mm = n - 2, 1, -1
	        mp = n - mm
	        mp1 = mp - 1
	        i = iphes(mp)
	        if (i==mp) goto 746
	        zsafe = z1(mp)
	        z1(mp) = z1(i)
	        z1(i) = zsafe
	        746      continue
	        do i = mp + 1, n
	            z1(i) = z1(i) - fjac(i, mp1) * z1(mp)
	        end do
	    end do
	    call solh(n, lde1, e1, 1, z1, ip1)
	    do mm = 1, n - 2
	        mp = n - mm
	        mp1 = mp - 1
	        do i = mp + 1, n
	            z1(i) = z1(i) + fjac(i, mp1) * z1(mp)
	        end do
	        i = iphes(mp)
	        if (i==mp) goto 750
	        zsafe = z1(mp)
	        z1(mp) = z1(i)
	        z1(i) = zsafe
	        750      continue
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
fbf4b6adbc463b153c769c0a8360a09d|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|669|1|V|fortran
	subroutine slvrai(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, alphn, betan, e2r, e2i, lde1, z2, z3, &
	        f2, f3, cont, ip2, iphes, ier, ijob)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), &
	            ip2(nm1), iphes(n), z2(n), z3(n), f2(n), f3(n)
	    dimension e2r(lde1, nm1), e2i(lde1, nm1)
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 13, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solc (n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    48   abno = alphn**2 + betan**2
	    mm = m1 / m2
	    do j = 1, m2
	        sum2 = 0.d0
	        sum3 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sumh = (z2(jkm) + sum2) / abno
	            sum3 = (z3(jkm) + sum3) / abno
	            sum2 = sumh * alphn + sum3 * betan
	            sum3 = sum3 * alphn - sumh * betan
	            do i = 1, nm1
	                im1 = i + m1
	                z2(im1) = z2(im1) + fjac(i, jkm) * sum2
	                z3(im1) = z3(im1) + fjac(i, jkm) * sum3
	            end do
	        end do
	    end do
	    call solc (nm1, lde1, e2r, e2i, z2(m1 + 1), z3(m1 + 1), ip2)
	    49   continue
	    do i = m1, 1, -1
	        mpi = m2 + i
	        z2i = z2(i) + z2(mpi)
	        z3i = z3(i) + z3(mpi)
	        z3(i) = (z3i * alphn - z2i * betan) / abno
	        z2(i) = (z2i * alphn + z3i * betan) / abno
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solbc (n, lde1, e2r, e2i, mle, mue, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    45  abno = alphn**2 + betan**2
	    mm = m1 / m2
	    do j = 1, m2
	        sum2 = 0.d0
	        sum3 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sumh = (z2(jkm) + sum2) / abno
	            sum3 = (z3(jkm) + sum3) / abno
	            sum2 = sumh * alphn + sum3 * betan
	            sum3 = sum3 * alphn - sumh * betan
	            do i = max(1, j - mujac), min(nm1, j + mljac)
	                im1 = i + m1
	                iimu = i + mujac + 1 - j
	                z2(im1) = z2(im1) + fjac(iimu, jkm) * sum2
	                z3(im1) = z3(im1) + fjac(iimu, jkm) * sum3
	            end do
	        end do
	    end do
	    call solbc (nm1, lde1, e2r, e2i, mle, mue, z2(m1 + 1), z3(m1 + 1), ip2)
	    goto 49
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do i = 1, n
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            bb = fmas(i - j + mbdiag, j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solc(n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = max(1, i - mlmas), min(nm1, i + mumas)
	            jm1 = j + m1
	            bb = fmas(i - j + mbdiag, j)
	            s2 = s2 - bb * f2(jm1)
	            s3 = s3 - bb * f3(jm1)
	        end do
	        z2(im1) = z2(im1) + s2 * alphn - s3 * betan
	        z3(im1) = z3(im1) + s3 * alphn + s2 * betan
	    end do
	    if (ijob==14) goto 45
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do i = 1, n
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            bb = fmas(i - j + mbdiag, j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solbc(n, lde1, e2r, e2i, mle, mue, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do i = 1, n
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = 1, n
	            bb = fmas(i, j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solc(n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = 1, nm1
	            jm1 = j + m1
	            bb = fmas(i, j)
	            s2 = s2 - bb * f2(jm1)
	            s3 = s3 - bb * f3(jm1)
	        end do
	        z2(im1) = z2(im1) + s2 * alphn - s3 * betan
	        z3(im1) = z3(im1) + s3 * alphn + s2 * betan
	    end do
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do mm = n - 2, 1, -1
	        mp = n - mm
	        mp1 = mp - 1
	        i = iphes(mp)
	        if (i==mp) goto 746
	        zsafe = z2(mp)
	        z2(mp) = z2(i)
	        z2(i) = zsafe
	        zsafe = z3(mp)
	        z3(mp) = z3(i)
	        z3(i) = zsafe
	        746      continue
	        do i = mp + 1, n
	            e1imp = fjac(i, mp1)
	            z2(i) = z2(i) - e1imp * z2(mp)
	            z3(i) = z3(i) - e1imp * z3(mp)
	        end do
	    end do
	    call solhc(n, lde1, e2r, e2i, 1, z2, z3, ip2)
	    do mm = 1, n - 2
	        mp = n - mm
	        mp1 = mp - 1
	        do i = mp + 1, n
	            e1imp = fjac(i, mp1)
	            z2(i) = z2(i) + e1imp * z2(mp)
	            z3(i) = z3(i) + e1imp * z3(mp)
	        end do
	        i = iphes(mp)
	        if (i==mp) goto 750
	        zsafe = z2(mp)
	        z2(mp) = z2(i)
	        z2(i) = zsafe
	        zsafe = z3(mp)
	        z3(mp) = z3(i)
	        z3(i) = zsafe
	        750      continue
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
2eb29160f9eded66ec68e864075ba120|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|948|1|V|fortran
	subroutine slvrad(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, &
	        m1, m2, nm1, fac1, alphn, betan, e1, e2r, e2i, lde1, z1, z2, z3, &
	        f1, f2, f3, cont, ip1, ip2, iphes, ier, ijob)
	    implicit real(kind=8) (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), e1(lde1, nm1), &
	            e2r(lde1, nm1), e2i(lde1, nm1), ip1(nm1), ip2(nm1), &
	            iphes(n), z1(n), z2(n), z3(n), f1(n), f2(n), f3(n)
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    !
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 13, 15), ijob
	    !
	    ! -----------------------------------------------------------
	    !
	    1  continue
	    ! ---  b=identity, jacobian a full matrix
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    call solc (n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    11  continue
	    ! ---  b=identity, jacobian a full matrix, second order
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    48   abno = alphn**2 + betan**2
	    mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        sum2 = 0.d0
	        sum3 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sum1 = (z1(jkm) + sum1) / fac1
	            sumh = (z2(jkm) + sum2) / abno
	            sum3 = (z3(jkm) + sum3) / abno
	            sum2 = sumh * alphn + sum3 * betan
	            sum3 = sum3 * alphn - sumh * betan
	            do i = 1, nm1
	                im1 = i + m1
	                z1(im1) = z1(im1) + fjac(i, jkm) * sum1
	                z2(im1) = z2(im1) + fjac(i, jkm) * sum2
	                z3(im1) = z3(im1) + fjac(i, jkm) * sum3
	            end do
	        end do
	    end do
	    call sol (nm1, lde1, e1, z1(m1 + 1), ip1)
	    call solc (nm1, lde1, e2r, e2i, z2(m1 + 1), z3(m1 + 1), ip2)
	    49   continue
	    do i = m1, 1, -1
	        mpi = m2 + i
	        z1(i) = (z1(i) + z1(mpi)) / fac1
	        z2i = z2(i) + z2(mpi)
	        z3i = z3(i) + z3(mpi)
	        z3(i) = (z3i * alphn - z2i * betan) / abno
	        z2(i) = (z2i * alphn + z3i * betan) / abno
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    2  continue
	    ! ---  b=identity, jacobian a banded matrix
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solb (n, lde1, e1, mle, mue, z1, ip1)
	    call solbc (n, lde1, e2r, e2i, mle, mue, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    12  continue
	    ! ---  b=identity, jacobian a banded matrix, second order
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    45  abno = alphn**2 + betan**2
	    mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        sum2 = 0.d0
	        sum3 = 0.d0
	        do k = mm - 1, 0, -1
	            jkm = j + k * m2
	            sum1 = (z1(jkm) + sum1) / fac1
	            sumh = (z2(jkm) + sum2) / abno
	            sum3 = (z3(jkm) + sum3) / abno
	            sum2 = sumh * alphn + sum3 * betan
	            sum3 = sum3 * alphn - sumh * betan
	            do i = max(1, j - mujac), min(nm1, j + mljac)
	                im1 = i + m1
	                ffja = fjac(i + mujac + 1 - j, jkm)
	                z1(im1) = z1(im1) + ffja * sum1
	                z2(im1) = z2(im1) + ffja * sum2
	                z3(im1) = z3(im1) + ffja * sum3
	            end do
	        end do
	    end do
	    call solb (nm1, lde1, e1, mle, mue, z1(m1 + 1), ip1)
	    call solbc (nm1, lde1, e2r, e2i, mle, mue, z2(m1 + 1), z3(m1 + 1), ip2)
	    goto 49
	    !
	    ! -----------------------------------------------------------
	    !
	    3  continue
	    ! ---  b is a banded matrix, jacobian a full matrix
	    do i = 1, n
	        s1 = 0.0d0
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            bb = fmas(i - j + mbdiag, j)
	            s1 = s1 - bb * f1(j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    call solc(n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    13  continue
	    ! ---  b is a banded matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s1 = 0.0d0
	        s2 = 0.0d0
	        s3 = 0.0d0
	        j1b = max(1, i - mlmas)
	        j2b = min(nm1, i + mumas)
	        do j = j1b, j2b
	            jm1 = j + m1
	            bb = fmas(i - j + mbdiag, j)
	            s1 = s1 - bb * f1(jm1)
	            s2 = s2 - bb * f2(jm1)
	            s3 = s3 - bb * f3(jm1)
	        end do
	        z1(im1) = z1(im1) + s1 * fac1
	        z2(im1) = z2(im1) + s2 * alphn - s3 * betan
	        z3(im1) = z3(im1) + s3 * alphn + s2 * betan
	    end do
	    if (ijob==14) goto 45
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    4  continue
	    ! ---  b is a banded matrix, jacobian a banded matrix
	    do i = 1, n
	        s1 = 0.0d0
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            bb = fmas(i - j + mbdiag, j)
	            s1 = s1 - bb * f1(j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call solb (n, lde1, e1, mle, mue, z1, ip1)
	    call solbc(n, lde1, e2r, e2i, mle, mue, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    5  continue
	    ! ---  b is a full matrix, jacobian a full matrix
	    do i = 1, n
	        s1 = 0.0d0
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = 1, n
	            bb = fmas(i, j)
	            s1 = s1 - bb * f1(j)
	            s2 = s2 - bb * f2(j)
	            s3 = s3 - bb * f3(j)
	        end do
	        z1(i) = z1(i) + s1 * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    call sol (n, lde1, e1, z1, ip1)
	    call solc(n, lde1, e2r, e2i, z2, z3, ip2)
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    15  continue
	    ! ---  b is a full matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do i = 1, nm1
	        im1 = i + m1
	        s1 = 0.0d0
	        s2 = 0.0d0
	        s3 = 0.0d0
	        do j = 1, nm1
	            jm1 = j + m1
	            bb = fmas(i, j)
	            s1 = s1 - bb * f1(jm1)
	            s2 = s2 - bb * f2(jm1)
	            s3 = s3 - bb * f3(jm1)
	        end do
	        z1(im1) = z1(im1) + s1 * fac1
	        z2(im1) = z2(im1) + s2 * alphn - s3 * betan
	        z3(im1) = z3(im1) + s3 * alphn + s2 * betan
	    end do
	    goto 48
	    !
	    ! -----------------------------------------------------------
	    !
	    6  continue
	    ! ---  b is a full matrix, jacobian a banded matrix
	    ! ---  this option is not provided
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    7  continue
	    ! ---  b=identity, jacobian a full matrix, hessenberg-option
	    do i = 1, n
	        s2 = -f2(i)
	        s3 = -f3(i)
	        z1(i) = z1(i) - f1(i) * fac1
	        z2(i) = z2(i) + s2 * alphn - s3 * betan
	        z3(i) = z3(i) + s3 * alphn + s2 * betan
	    end do
	    do mm = n - 2, 1, -1
	        mp = n - mm
	        mp1 = mp - 1
	        i = iphes(mp)
	        if (i==mp) goto 746
	        zsafe = z1(mp)
	        z1(mp) = z1(i)
	        z1(i) = zsafe
	        zsafe = z2(mp)
	        z2(mp) = z2(i)
	        z2(i) = zsafe
	        zsafe = z3(mp)
	        z3(mp) = z3(i)
	        z3(i) = zsafe
	        746      continue
	        do i = mp + 1, n
	            e1imp = fjac(i, mp1)
	            z1(i) = z1(i) - e1imp * z1(mp)
	            z2(i) = z2(i) - e1imp * z2(mp)
	            z3(i) = z3(i) - e1imp * z3(mp)
	        end do
	    end do
	    call solh(n, lde1, e1, 1, z1, ip1)
	    call solhc(n, lde1, e2r, e2i, 1, z2, z3, ip2)
	    do mm = 1, n - 2
	        mp = n - mm
	        mp1 = mp - 1
	        do i = mp + 1, n
	            e1imp = fjac(i, mp1)
	            z1(i) = z1(i) + e1imp * z1(mp)
	            z2(i) = z2(i) + e1imp * z2(mp)
	            z3(i) = z3(i) + e1imp * z3(mp)
	        end do
	        i = iphes(mp)
	        if (i==mp) goto 750
	        zsafe = z1(mp)
	        z1(mp) = z1(i)
	        z1(i) = zsafe
	        zsafe = z2(mp)
	        z2(mp) = z2(i)
	        z2(i) = zsafe
	        zsafe = z3(mp)
	        z3(mp) = z3(i)
	        z3(i) = zsafe
	        750      continue
	    end do
	    return
	    !
	    ! -----------------------------------------------------------
	    !
	    55  continue
	    return
	end
8c17ca9fb9c517408f2c131495ace2ca|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/radau.f90|6142|1|V|fortran
	   !
b96a86d4f32c6a62a069d6114903bf0d|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/radau.f90|6142|4|V|fortran
	   !     end of subroutine estrav
7096f38253e1dd8d4bc3014a21fdf82b|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/dc_decsol.f90|1274|1|V|fortran
	subroutine estrad(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, &
	        h, dd1, dd2, dd3, fcn, nfcn, y0, y, ijob, x, m1, m2, nm1, &
	        e1, lde1, z1, z2, z3, cont, f1, f2, ip1, iphes, scal, err, &
	        first, reject, fac1, rpar, ipar)
	    implicit double precision (a-h, o-z)
	    dimension fjac(ldjac, n), fmas(ldmas, nm1), e1(lde1, nm1), ip1(nm1), &
	            scal(n), iphes(n), z1(n), z2(n), z3(n), f1(n), f2(n), y0(n), y(n)
	    dimension cont(n), rpar(1), ipar(1)
	    logical first, reject
	    common/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
	    hee1 = dd1 / h
	    hee2 = dd2 / h
	    hee3 = dd3 / h
	    goto (1, 2, 3, 4, 5, 6, 7, 55, 55, 55, 11, 12, 13, 14, 15), ijob
	    !
	    1  continue
	    ! ------  b=identity, jacobian a full matrix
	    do  i = 1, n
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    call sol (n, lde1, e1, cont, ip1)
	    goto 77
	    !
	    11  continue
	    ! ------  b=identity, jacobian a full matrix, second order
	    do i = 1, n
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    48  mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        do k = mm - 1, 0, -1
	            sum1 = (cont(j + k * m2) + sum1) / fac1
	            do i = 1, nm1
	                im1 = i + m1
	                cont(im1) = cont(im1) + fjac(i, j + k * m2) * sum1
	            end do
	        end do
	    end do
	    call sol (nm1, lde1, e1, cont(m1 + 1), ip1)
	    do i = m1, 1, -1
	        cont(i) = (cont(i) + cont(m2 + i)) / fac1
	    end do
	    goto 77
	    !
	    2  continue
	    ! ------  b=identity, jacobian a banded matrix
	    do i = 1, n
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    call solb (n, lde1, e1, mle, mue, cont, ip1)
	    goto 77
	    !
	    12  continue
	    ! ------  b=identity, jacobian a banded matrix, second order
	    do i = 1, n
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    45  mm = m1 / m2
	    do j = 1, m2
	        sum1 = 0.d0
	        do k = mm - 1, 0, -1
	            sum1 = (cont(j + k * m2) + sum1) / fac1
	            do i = max(1, j - mujac), min(nm1, j + mljac)
	                im1 = i + m1
	                cont(im1) = cont(im1) + fjac(i + mujac + 1 - j, j + k * m2) * sum1
	            end do
	        end do
	    end do
	    call solb (nm1, lde1, e1, mle, mue, cont(m1 + 1), ip1)
	    do i = m1, 1, -1
	        cont(i) = (cont(i) + cont(m2 + i)) / fac1
	    end do
	    goto 77
	    !
	    3  continue
	    ! ------  b is a banded matrix, jacobian a full matrix
	    do i = 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, n
	        sum = 0.d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            sum = sum + fmas(i - j + mbdiag, j) * f1(j)
	        end do
	        f2(i) = sum
	        cont(i) = sum + y0(i)
	    end do
	    call sol (n, lde1, e1, cont, ip1)
	    goto 77
	    !
	    13  continue
	    ! ------  b is a banded matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    do i = m1 + 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, nm1
	        sum = 0.d0
	        do j = max(1, i - mlmas), min(nm1, i + mumas)
	            sum = sum + fmas(i - j + mbdiag, j) * f1(j + m1)
	        end do
	        im1 = i + m1
	        f2(im1) = sum
	        cont(im1) = sum + y0(im1)
	    end do
	    goto 48
	    !
	    4  continue
	    ! ------  b is a banded matrix, jacobian a banded matrix
	    do i = 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, n
	        sum = 0.d0
	        do j = max(1, i - mlmas), min(n, i + mumas)
	            sum = sum + fmas(i - j + mbdiag, j) * f1(j)
	        end do
	        f2(i) = sum
	        cont(i) = sum + y0(i)
	    end do
	    call solb (n, lde1, e1, mle, mue, cont, ip1)
	    goto 77
	    !
	    14  continue
	    ! ------  b is a banded matrix, jacobian a banded matrix, second order
	    do i = 1, m1
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    do i = m1 + 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, nm1
	        sum = 0.d0
	        do j = max(1, i - mlmas), min(nm1, i + mumas)
	            sum = sum + fmas(i - j + mbdiag, j) * f1(j + m1)
	        end do
	        im1 = i + m1
	        f2(im1) = sum
	        cont(im1) = sum + y0(im1)
	    end do
	    goto 45
	    !
	    5  continue
	    ! ------  b is a full matrix, jacobian a full matrix
	    do i = 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, n
	        sum = 0.d0
	        do j = 1, n
	            sum = sum + fmas(i, j) * f1(j)
	        end do
	        f2(i) = sum
	        cont(i) = sum + y0(i)
	    end do
	    call sol (n, lde1, e1, cont, ip1)
	    goto 77
	    !
	    15  continue
	    ! ------  b is a banded matrix, jacobian a full matrix, second order
	    do i = 1, m1
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    do i = m1 + 1, n
	        f1(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	    end do
	    do i = 1, nm1
	        sum = 0.d0
	        do j = 1, nm1
	            sum = sum + fmas(i, j) * f1(j + m1)
	        end do
	        im1 = i + m1
	        f2(im1) = sum
	        cont(im1) = sum + y0(im1)
	    end do
	    goto 48
	    !
	    6  continue
	    ! ------  b is a full matrix, jacobian a banded matrix
	    ! ------  this option is not provided
	    return
	    !
	    7  continue
	    ! ------  b=identity, jacobian a full matrix, hessenberg-option
	    do i = 1, n
	        f2(i) = hee1 * z1(i) + hee2 * z2(i) + hee3 * z3(i)
	        cont(i) = f2(i) + y0(i)
	    end do
	    do mm = n - 2, 1, -1
	        mp = n - mm
	        i = iphes(mp)
	        if (i==mp) goto 310
	        zsafe = cont(mp)
	        cont(mp) = cont(i)
	        cont(i) = zsafe
	        310     continue
	        do i = mp + 1, n
	            cont(i) = cont(i) - fjac(i, mp - 1) * cont(mp)
	        end do
	    end do
	    call solh(n, lde1, e1, 1, cont, ip1)
	    do mm = 1, n - 2
	        mp = n - mm
	        do i = mp + 1, n
	            cont(i) = cont(i) + fjac(i, mp - 1) * cont(mp)
	        end do
	        i = iphes(mp)
	        if (i==mp) goto 440
	        zsafe = cont(mp)
	        cont(mp) = cont(i)
	        cont(i) = zsafe
	        440     continue
	    end do
	    !
	    ! --------------------------------------
	    !
	    77  continue
	    err = 0.d0
	    do  i = 1, n
	        err = err + (cont(i) / scal(i))**2
	    end do
	    err = max(sqrt(err / n), 1.d-10)
	    !
	    if (err<1.d0) return
	    if (first.or.reject) then
	        do i = 1, n
	            cont(i) = y(i) + cont(i)
	        end do
	        call fcn(n, x, cont, f1, rpar, ipar)
	        nfcn = nfcn + 1
	        do i = 1, n
	            cont(i) = f1(i) + f2(i)
	        end do
	        goto (31, 32, 31, 32, 31, 32, 33, 55, 55, 55, 41, 42, 41, 42, 41), ijob
	        ! ------ full matrix option
	        31      continue
	        call sol(n, lde1, e1, cont, ip1)
	        goto 88
	        ! ------ full matrix option, second order
	        41      continue
	        do j = 1, m2
	            sum1 = 0.d0
	            do k = mm - 1, 0, -1
	                sum1 = (cont(j + k * m2) + sum1) / fac1
	                do i = 1, nm1
	                    im1 = i + m1
	                    cont(im1) = cont(im1) + fjac(i, j + k * m2) * sum1
	                end do
	            end do
	        end do
	        call sol(nm1, lde1, e1, cont(m1 + 1), ip1)
	        do i = m1, 1, -1
	            cont(i) = (cont(i) + cont(m2 + i)) / fac1
	        end do
	        goto 88
	        ! ------ banded matrix option
	        32      continue
	        call solb (n, lde1, e1, mle, mue, cont, ip1)
	        goto 88
	        ! ------ banded matrix option, second order
	        42      continue
	        do j = 1, m2
	            sum1 = 0.d0
	            do k = mm - 1, 0, -1
	                sum1 = (cont(j + k * m2) + sum1) / fac1
	                do i = max(1, j - mujac), min(nm1, j + mljac)
	                    im1 = i + m1
	                    cont(im1) = cont(im1) + fjac(i + mujac + 1 - j, j + k * m2) * sum1
	                end do
	            end do
	        end do
	        call solb (nm1, lde1, e1, mle, mue, cont(m1 + 1), ip1)
	        do i = m1, 1, -1
	            cont(i) = (cont(i) + cont(m2 + i)) / fac1
	        end do
	        goto 88
	        ! ------ hessenberg matrix option
	        33      continue
	        do mm = n - 2, 1, -1
	            mp = n - mm
	            i = iphes(mp)
	            if (i==mp) goto 510
	            zsafe = cont(mp)
	            cont(mp) = cont(i)
	            cont(i) = zsafe
	            510         continue
	            do i = mp + 1, n
	                cont(i) = cont(i) - fjac(i, mp - 1) * cont(mp)
	            end do
	        end do
	        call solh(n, lde1, e1, 1, cont, ip1)
	        do mm = 1, n - 2
	            mp = n - mm
	            do i = mp + 1, n
	                cont(i) = cont(i) + fjac(i, mp - 1) * cont(mp)
	            end do
	            i = iphes(mp)
	            if (i==mp) goto 640
	            zsafe = cont(mp)
	            cont(mp) = cont(i)
	            cont(i) = zsafe
	            640         continue
	        end do
	        ! -----------------------------------
	        88     continue
	        err = 0.d0
	        do i = 1, n
	            err = err + (cont(i) / scal(i))**2
	        end do
	        err = max(sqrt(err / n), 1.d-10)
	    end if
	    return
	    ! -----------------------------------------------------------
	    55   continue
	    return
	end
71ec3187a8e182ce902dc66f1a9c72f4|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/main.f90|3|1|V|fortran
	   use radau_integrators
260cdb61916462c245c37a1ae497b293|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/radau.f90|4|1|v|fortran
	   private :: decomr, decomc, slvrar, slvrai, slvrad, estrad, estrav
1d2a78435aa0fcfa252b9b78e9ea820a|file:///Users/loganmorrison/Documents/coding/cpp/rambo/Makefile|1|1|V|make
	TARGET   = main
	
	CC       = g++
	# compiling flags here
	CFLAGS   = -std=c++11 -Wall -O2 -I/usr/local/include/boost
	
	LINKER   = g++
	# linking flags here
	LFLAGS   = -L/usr/local/lib -lgsl -lgslcblas -lboost_timer
	
	# change these to proper directories where each file should be
	SRCDIR     = src
	OBJDIR     = obj
	BINDIR     = bin
	RUNDATADIR = rundata
	
	SOURCES  := $(wildcard $(SRCDIR)/*.cpp)
	INCLUDES := $(wildcard $(SRCDIR)/*.h)
	OBJECTS  := $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)
	rm       = rm -f
	
	
	$(BINDIR)/$(TARGET): $(OBJECTS)
		@$(LINKER) $(OBJECTS) $(LFLAGS) -o $@
		@echo "Linking complete!"
	
	$(OBJECTS): $(OBJDIR)/%.o : $(SRCDIR)/%.cpp
		@$(CC) $(CFLAGS) -c $< -o $@
		@echo "Compiled "$<" successfully!"
	
	run:
		./$(BINDIR)/$(TARGET)
	
	.PHONY: clean
	clean:
		@$(rm) $(OBJECTS)
		@echo "Cleanup complete!"
	
	.PHONY: remove
	remove: clean
		@$(rm) $(BINDIR)/$(TARGET)
		@$(rm) $(wildcard $(RUNDATADIR)/*.csv)
		@$(rm) $(wildcard $(SRCDIR)/*.h.gch)
		@echo "Executable removed!"
392402480545363852fc6dd9cb8f4677|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/Makefile|5|12|v|make
	-std=c++11 
fbaddc5387a94eb55ff7a054f6b8b722|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/Makefile|5|21|v|make
	 -I/usr/local/include/boost
1e47f879b3e0547fd10b56f176d8f0e7|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/Makefile|9|1|V|make
	LFLAGS   = -L/usr/local/lib -lgsl -lgslcblas -lboost_timer
6bc839d1f501b6f9928e9ee418dfcdbc|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/Makefile|8|1|V|make
	# linking flags here
deaa811f222fa4fa3aa056d18fdae2bf|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/Makefile|16|1|V|make
	INCLUDES := $(wildcard $(SRCDIR)/*.h)
e4f6c7af9939f5838dfae14b66b265bc|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/main.f90|1|1|V|fortran
	program
	      end prog
69fe689d5b1c1b3ed5b278f111ec5a90|file:///Users/loganmorrison/Documents/research/SUN_DM/fortran/src/model.f|7|1|V|fortran
	      double precision :: lec1
c2da2362ebbe4bc1f2d1e2f05af5c5ae|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|127|1|v|cpp
	// c-----------------------------------------------------------------------
	// c  matrix triangularization by gaussian elimination of a hessenberg
	// c  matrix with lower bandwidth lb
	// c  input..
	// c     n = order of matrix a.
	// c     ndim = declared dimension of array  a .
	// c     a = matrix to be triangularized.
	// c     lb = lower bandwidth of a (diagonal is not counted, lb.ge.1).
	// c  output..
	// c     a(i,j), i.le.j = upper triangular factor, u .
	// c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	// c     ip(k), k.lt.n = index of k-th pivot row.
	// c     ip(n) = (-1)**(number of interchanges) or o .
	// c     ier = 0 if matrix a is nonsingular, or k if found to be
	// c           singular at stage k.
	// c  use  solh  to obtain solution of linear system.
	// c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	// c  if ip(n)=o, a is singular, sol will divide by zero.
	// c
	// c  reference..
	// c     this is a slight modification of
	// c     c. b. moler, algorithm 423, linear equation solver,
	// c     c.a.c.m. 15 (1972), p. 274.
	// c-----------------------------------------------------------------------
	template <int n, int ndim>
	int dech(Matrix<double, ndim, n> &a, int lb, Vector<int, n> &ip) {
	  int ier, nm1, k, kp1, m, i, j, na;
	  double t;
	  ier = 0;
	  ip(n - 1) = 1;
	  if (n == 1)
	    goto g70;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    na = fmin(n, lb + k);
	    for (i = kp1; i <= na; i++) {
	      if (fabs(a(i - 1, k - 1)) > fabs(a(m - 1, k - 1)))
	        m = i;
	    }
	    ip(k - 1) = m;
	    t = a(m - 1, k - 1);
	    if (m == k)
	      goto g20;
	    ip(n - 1) = -ip(n - 1);
	    a(m - 1, k - 1) = a(k - 1, k - 1);
	    a(k - 1, k - 1) = t;
	  g20:
	
	    if (t == 0.0)
	      goto g80;
	    t = 1.0 / t;
	    for (i = kp1; i <= na; i++) {
	      a(i - 1, k - 1) = -a(i - 1, k - 1) * t;
	    }
	    for (j = kp1; j <= n; j++) {
	      t = a(m - 1, j - 1);
	      a(m - 1, j - 1) = a(k - 1, j - 1);
	      a(k - 1, j - 1) = t;
	      if (t == 0.0)
	        continue;
	      for (i = kp1; i <= na; i++) {
	        a(i - 1, j - 1) = a(i - 1, j - 1) + a(i - 1, k - 1) * t;
	      }
	    }
	  }
	g70:
	  k = n;
	  if (a(n - 1, n - 1) == 0.0)
	    goto g80;
	  return ier;
	g80:
	  ier = k;
	  ip(n - 1) = 0;
	  return ier;
	};
	
f511c5c13dba9ff9520e9c6ea1a10c09|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/decsol.hpp|128|1|v|cpp
	// c-----------------------------------------------------------------------
	// c  solution of linear system, a*x = b .
	// c  input..
	// c    n = order of matrix a.
	// c    ndim = declared dimension of array  a .
	// c    a = triangularized matrix obtained from dech.
	// c    lb = lower bandwidth of a.
	// c    b = right hand side vector.
	// c    ip = pivot vector obtained from dec.
	// c  do not use if dech has set ier .ne. 0.
	// c  output..
	// c    b = solution vector, x .
	// c-----------------------------------------------------------------------
	template <int n, int ndim>
	void solh(Matrix<double, ndim, n> &a, int lb, Vector<double, n> &b,
	          Vector<int, n> &ip) {
	  int nm1, k, kp1, m, i, kb, km1, na;
	  double t;
	  if (n == 1)
	    goto g50;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = ip(k - 1);
	    t = b(m - 1);
	    b(m - 1) = b(k - 1);
	    b(k - 1) = t;
	    na = fmin(n, lb + k);
	    for (i = kp1; i <= na; i++) {
	      b(i - 1) = b(i - 1) + a(i - 1, k - 1) * t;
	    }
	  }
	  for (kb = 1; kb <= nm1; kb++) {
	    km1 = n - kb;
	    k = km1 + 1;
	    b(k - 1) = b(k - 1) / a(k - 1, k - 1);
	    t = -b(k - 1);
	    for (i = 1; i <= km1; i++) {
	      b(i - 1) = b(i - 1) + a(i - 1, k - 1) * t;
	    }
	  }
	g50:
	  b(1 - 1) = b(1 - 1) / a(1 - 1, 1 - 1);
	  return;
	};
	
e8764e0185cc192836b36432d13706c0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|119|1|V|cmake
	add_executable(test_phase_space test_phase_space.cpp)
	set_property(TARGET test_phase_space PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_phase_space PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_phase_space PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
ff8d9eb63211f3fc8763c1e60617a3ac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|135|28|v|cmake
	test_phase_space
cbf04a998b338744714e9f6248efe5c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|18|1|V|cpp
	  std::cout << mat << std::endl;
5b580f7ba66ba25a59900c62f72a1c33|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/parameters.hpp|9|1|V|cpp
	enum class DarkSunParameters { n,
	  Lam,
	  C,
	  Adel,
	  Lec1,
	  Lec2,
	  MuEta,
	  MuDel,
	  XiInf,
	};
e685ceb2afe482aa893681cb7ad76c38|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|19|1|V|cpp
	  std::cout << ip << std::endl;
f186f8a2cd666917a77478d79d622c8e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|24|1|V|cpp
	  std::cout << ier << std::endl;
501ae1e5c51189b16551eca2ceefcf25|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|26|1|V|cpp
	  std::cout << mat << std::endl;
	  std::cout << ip << std::endl;
	  std::cout << ier << std::endl;
	  std::cout << b << std::endl;
fa2c4239cf046a39ba0d89b9fe95b836|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|26|1|V|cpp
	  ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
2baa8ab410cdaa2295dfb97f0e0f5f31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|7|1|V|cpp
	  {
	    Matrix<double, 4, 4> mat;
	    mat << 0.08823928550576365, 0.4366011322519572, 0.5757622339313386,
	        0.179505767165407, 0.36562973885367844, 0.321105147872627,
	        0.12186862579281454, 0.8441594970550272, 0.18586006125322818,
	        0.8118574391821631, 0.4318675992972878, 0.35344372941325,
	        0.646804707626244, 0.5022684089075349, 0.10875331495865792,
	        0.07588179485412039;
	    Vector<int, 4> ip;
	    Vector<double, 4> b;
	    b << 0.7238358433172154, 0.0936030851273697, 0.5932736770573785,
	        0.21736157039940096;
	
	    int ier = dec(mat, ip);
	    sol(mat, b, ip);
	
	    Vector<double, 4> mma_sol;
	    mma_sol << 0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	        -0.13233648654772068;
	
	    ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
	    ASSERT_LE(abs(b(1) - mma_sol(1)) / mma_sol(1), 1e-5);
	    ASSERT_LE(abs(b(2) - mma_sol(2)) / mma_sol(2), 1e-5);
	    ASSERT_LE(abs(b(3) - mma_sol(3)) / mma_sol(3), 1e-5);
	  }
19d205cc397d5d6b699a2c7a24eb1014|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|35|12|v|cpp
	0.08823928550576365, 0.4366011322519572, 0.5757622339313386,
	        0.179505767165407, 0.36562973885367844, 0.321105147872627,
	        0.12186862579281454, 0.8441594970550272, 0.18586006125322818,
	        0.8118574391821631, 0.4318675992972878, 0.35344372941325,
	        0.646804707626244, 0.5022684089075349, 0.10875331495865792,
	        0.07588179485412039;
bfb330623835fd510aab82158fa76bac|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|42|4|v|cpp
	List(
50e29cf47a08acce81674c21424611fa|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|35|12|v|cpp
	List(List(
a2ecfaa29980bfceb38c25b478072402|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|43|10|v|cpp
	0.7238358433172154, 0.0936030851273697, 0.5932736770573785,
	        0.21736157039940096
42d8622f80a19853103572afc8a1afa8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|50|16|v|cpp
	0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	        -0.13233648654772068
3430309ab42784348ce2af1a4c8118d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|6|1|V|cpp
	TEST(TestDecSol, TestReal) {
	  {
	    Matrix<double, 4, 4> mat;
	    mat << 0.08823928550576365, 0.4366011322519572, 0.5757622339313386,
	        0.179505767165407, 0.36562973885367844, 0.321105147872627,
	        0.12186862579281454, 0.8441594970550272, 0.18586006125322818,
	        0.8118574391821631, 0.4318675992972878, 0.35344372941325,
	        0.646804707626244, 0.5022684089075349, 0.10875331495865792,
	        0.07588179485412039;
	    Vector<int, 4> ip;
	    Vector<double, 4> b;
	    b << 0.7238358433172154, 0.0936030851273697, 0.5932736770573785,
	        0.21736157039940096;
	
	    int ier = dec(mat, ip);
	    sol(mat, b, ip);
	
	    Vector<double, 4> mma_sol;
	    mma_sol << 0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	        -0.13233648654772068;
	
	    ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
	    ASSERT_LE(abs(b(1) - mma_sol(1)) / mma_sol(1), 1e-5);
	    ASSERT_LE(abs(b(2) - mma_sol(2)) / mma_sol(2), 1e-5);
	    ASSERT_LE(abs(b(3) - mma_sol(3)) / mma_sol(3), 1e-5);
	  }
	
	  {
	    Matrix<double, 4, 4> mat;
	    mat << 0.3906598222194304, 0.29180478029035184, 0.9136976134133592,
	        0.0844650550435071, 0.890014723515246, 0.738455476971625,
	        0.9184329943634018, 0.8789587067845854, 0.21177567691416432,
	        0.9682895344190974, 0.3489025641606862, 0.7247496424016304,
	        0.6277314451386931, 0.3085632473102675, 0.009395156840419583,
	        0.0893705901092845;
	    Vector<int, 4> ip;
	    Vector<double, 4> b;
	    b << 0.20545005196667088, 0.5730310628646669, 0.5364149524698127,
	        0.5999051625091176;
	
	    int ier = dec(mat, ip);
	    sol(mat, b, ip);
	
	    Vector<double, 4> mma_sol;
	    mma_sol << 0.6244094151878243, 0.7896099711562888, -0.2598890371078468,
	        -0.37214905427041267;
	
	    ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
	    ASSERT_LE(abs(b(1) - mma_sol(1)) / mma_sol(1), 1e-5);
	    ASSERT_LE(abs(b(2) - mma_sol(2)) / mma_sol(2), 1e-5);
	    ASSERT_LE(abs(b(3) - mma_sol(3)) / mma_sol(3), 1e-5);
	  }
	}
27de66429a3cf6d347b4db90230138c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|64|12|v|cpp
	0.08823928550576365, 0.4366011322519572, 0.5757622339313386,
	        0.179505767165407, 0.36562973885367844, 0.321105147872627,
	        0.12186862579281454, 0.8441594970550272, 0.18586006125322818,
	        0.8118574391821631, 0.4318675992972878, 0.35344372941325,
	        0.646804707626244, 0.5022684089075349, 0.10875331495865792,
	        0.07588179485412039
4ee29ca12c7d126654bd0e5275de6135|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|70|4|v|cpp
	List
b2eca761f9529251d0386aa5f54abd06|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|62|1|V|cpp
	    Matrix<double, 4, 4> ar;
867a2c242e5deaac5e61e8961eff2de0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|64|1|V|cpp
	    ar << 0.1291187697346574, 0.5263424393544771, 0.6033308837455076,
	        0.3670062614030687, 0.9430977357532899, 0.762507230664045,
	        0.7145949345306861, 0.7770921057984113, 0.10575399094620042,
	        0.069697934573834, 0.19213265307498628, 0.38256428505406914,
	        0.9901354559781239, 0.1600746717092394, 0.6685239730157391,
	        0.6447162257110048;
ae1044bfe848334f0bad3cb3445882b1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|70|11|v|cpp
	0.1291187697346574, 0.5263424393544771, 0.6033308837455076,
	        0.3670062614030687, 0.9430977357532899, 0.762507230664045,
	        0.7145949345306861, 0.7770921057984113, 0.10575399094620042,
	        0.069697934573834, 0.19213265307498628, 0.38256428505406914,
	        0.9901354559781239, 0.1600746717092394, 0.6685239730157391,
	        0.6447162257110048;
804bc8f7f509ac0dd38c65b7a550315a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|77|1|V|cpp
	    Vector<double, 4> b;
73d00993163ebc5ceaddb7229d28cde7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|79|1|V|cpp
	    b << 0.7238358433172154, 0.0936030851273697, 0.5932736770573785,
	        0.21736157039940096;
7057057b4a06cea08f80526f65e4a842|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|79|1|V|cpp
	    br <<;
8f2c7ef7af9d08c334790c9b0ecc942d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|87|1|V|cpp
	    Vector<double, 4> mma_sol_r;
8f14d3ece06c3b483c924ad4bb650e60|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|89|1|V|cpp
	    mma_sol_r <<0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	        -0.13233648654772068 ;
06e53d4ce73aefdc7d373b060e2af293|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|94|1|V|cpp
	    ASSERT_LE(abs(br(0) - mma_sol_r(0)) / mma_sol_r(0), 1e-5);
	    ASSERT_LE(abs(br(1) - mma_sol_r(1)) / mma_sol_r(1), 1e-5);
	    ASSERT_LE(abs(br(2) - mma_sol_r(2)) / mma_sol_r(2), 1e-5);
	    ASSERT_LE(abs(br(3) - mma_sol_r(3)) / mma_sol_r(3), 1e-5);
f325f6cdffeacd81d0b5090c55885d7c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|105|1|V|cpp
	  {
	    Matrix<double, 4, 4> mat;
	    mat << 0.3906598222194304, 0.29180478029035184, 0.9136976134133592,
	        0.0844650550435071, 0.890014723515246, 0.738455476971625,
	        0.9184329943634018, 0.8789587067845854, 0.21177567691416432,
	        0.9682895344190974, 0.3489025641606862, 0.7247496424016304,
	        0.6277314451386931, 0.3085632473102675, 0.009395156840419583,
	        0.0893705901092845;
	    Vector<int, 4> ip;
	    Vector<double, 4> b;
	    b << 0.20545005196667088, 0.5730310628646669, 0.5364149524698127,
	        0.5999051625091176;
	
	    int ier = dec(mat, ip);
	    sol(mat, b, ip);
	
	    Vector<double, 4> mma_sol;
	    mma_sol << 0.6244094151878243, 0.7896099711562888, -0.2598890371078468,
	        -0.37214905427041267;
	
	    ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
	    ASSERT_LE(abs(b(1) - mma_sol(1)) / mma_sol(1), 1e-5);
	    ASSERT_LE(abs(b(2) - mma_sol(2)) / mma_sol(2), 1e-5);
	    ASSERT_LE(abs(b(3) - mma_sol(3)) / mma_sol(3), 1e-5);
	  }
d1491a5cd8d4c27e7ca353e35d63087a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|88|16|v|cpp
	0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	      -0.13233648654772068
29f0a63840b987ae27a1eda02dd5d190|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|12|5|V|cpp
	    Vector<double>
c48a7cdd2097253fdcb8093738e9ab4b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|399|1|V|fortran
	   nfcn = 0
	   njac = 0
	   nstep = 0
	   naccpt = 0
	   nrejct = 0
	   ndec = 0
	   nsol = 0
1d564c648a303c1e7c94ceb5ef608aea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|407|1|V|fortran
	   ! -------- number maximal and minimal of stages  ns
	   if (iwork(11) == 0) then
	      nsmin = 3
	   else
	      nsmin = max(1, iwork(11))
	      if (iwork(11) >= 2) nsmin = max(3, iwork(11))
	      if (iwork(11) >= 4) nsmin = max(5, iwork(11))
	      if (iwork(11) >= 6) nsmin = 7
	   end if
	   if (iwork(12) == 0) then
	      nsmax = 7
	   else
	      nsmax = min(7, iwork(12))
	      if (iwork(12) <= 6) nsmax = min(5, iwork(12))
	      if (iwork(12) <= 4) nsmax = min(3, iwork(12))
	      if (iwork(12) <= 2) nsmax = 1
	   end if
	   ns = nsmax
	   if (iwork(13) == 0) then
	      nsus = nsmin
	   else
	      nsus = iwork(13)
	      if (nsus <= 0 .or. ns >= 8 .or. ns == 2 .or. ns == 4 .or. ns == 6) then
	         write (6, *) ' wrong input iwork(13)=', iwork(13)
	         arret = .true.
	      end if
	   end if
	   ! -------- nmax , the maximal number of steps -----
	   if (iwork(2) == 0) then
	      nmax = 100000
	   else
	      nmax = iwork(2)
	      if (nmax <= 0) then
	         write (6, *) ' wrong input iwork(2)=', iwork(2)
	         arret = .true.
	      end if
	   end if
	   ! -------- nit    maximal number of newton iterations
	   if (iwork(3) == 0) then
	      nit = 7
	   else
	      nit = iwork(3)
	      if (nit <= 0 .or. nit > 50) then
	         write (6, *) ' curious input iwork(3)=', iwork(3)
	         arret = .true.
	      end if
	   end if
	   ! -------- startn  switch for starting values of newton iterations
	   if (iwork(4) == 0) then
	      startn = .false.
	   else
	      startn = .true.
	   end if
	   ! -------- parameter for differential-algebraic components
	   nind1 = iwork(5)
	   nind2 = iwork(6)
	   nind3 = iwork(7)
	   if (nind1 == 0) nind1 = n
	   if (nind1 + nind2 + nind3 /= n) then
	      write (6, *) ' curious input for iwork(5,6,7)=', nind1, nind2, nind3
	      arret = .true.
	   end if
	   ! -------- pred   step size control
	   if (iwork(8) <= 1) then
	      pred = .true.
	   else
	      pred = .false.
	   end if
	   ! -------- parameter for second order equations
	   m1 = iwork(9)
	   m2 = iwork(10)
	   nm1 = n - m1
	   if (m1 == 0) m2 = n
	   if (m2 == 0) m2 = m1
	   if (m1 < 0 .or. m2 < 0 .or. m1 + m2 > n) then
	      write (6, *) ' curious input for iwork(9,10)=', m1, m2
	      arret = .true.
	   end if
	   ! -------- uround   smallest number satisfying 1.0d0+uround>1.0d0
	   if (work(1) == 0.0d0) then
	      uround = 1.0d-16
	   else
	      uround = work(1)
	      if (uround <= 1.0d-19 .or. uround >= 1.0d0) then
	         write (6, *) ' coefficients have 20 digits, uround=', work(1)
	         arret = .true.
	      end if
	   end if
	   ! --------- check if tolerances are o.k.
	   if (itol == 0) then
	      if (atol(1) <= 0.d0 .or. rtol(1) <= 10.d0*uround) then
	         write (6, *) ' tolerances are too small'
	         arret = .true.
	      end if
	   else
	      do i = 1, n
	      if (atol(i) <= 0.d0 .or. rtol(i) <= 10.d0*uround) then
	         write (6, *) ' tolerances(', i, ') are too small'
	         arret = .true.
	      end if
	      end do
	   end if
	   ! --------- safe     safety factor in step size prediction
	   if (work(2) == 0.0d0) then
	      safe = 0.9d0
	   else
	      safe = work(2)
	      if (safe <= 0.001d0 .or. safe >= 1.0d0) then
	         write (6, *) ' curious input for work(2)=', work(2)
	         arret = .true.
	      end if
	   end if
	   ! ------ thet     decides whether the jacobian should be recomputed;
	   if (work(3) == 0.d0) then
	      thet = 0.001d0
	   else
	      thet = work(3)
	      if (thet >= 1.0d0) then
	         write (6, *) ' curious input for work(3)=', work(3)
	         arret = .true.
	      end if
	   end if
	   ! --- quot1 and quot2: if quot1 < hnew/hold < quot2, step size = const.
	   if (work(5) == 0.d0) then
	      quot1 = 1.d0
	   else
	      quot1 = work(5)
	   end if
	   if (work(6) == 0.d0) then
	      quot2 = 1.2d0
	   else
	      quot2 = work(6)
	   end if
	   if (quot1 > 1.0d0 .or. quot2 < 1.0d0) then
	      write (6, *) ' curious input for work(5,6)=', quot1, quot2
	      arret = .true.
	   end if
	   ! -------- maximal step size
	   if (work(7) == 0.d0) then
	      hmax = xend - x
	   else
	      hmax = work(7)
	   end if
	   ! -------  facl,facr     parameters for step size selection
	   if (work(8) == 0.d0) then
	      facl = 5.d0
	   else
	      facl = 1.d0/work(8)
	   end if
	   if (work(9) == 0.d0) then
	      facr = 1.d0/8.0d0
	   else
	      facr = 1.d0/work(9)
	   end if
	   if (facl < 1.0d0 .or. facr > 1.0d0) then
	      write (6, *) ' curious input work(8,9)=', work(8), work(9)
	      arret = .true.
	   end if
	   ! -------- parameters for order selection strategy
	   if (work(10) == 0.d0) then
	      vitu = 0.002d0
	   else
	      vitu = work(10)
	   end if
	   if (work(11) == 0.d0) then
	      vitd = 0.8d0
	   else
	      vitd = work(11)
	   end if
	   if (work(12) == 0.d0) then
	      hhou = 1.2d0
	   else
	      hhou = work(12)
	   end if
	   if (work(13) == 0.d0) then
	      hhod = 0.8d0
	   else
	      hhod = work(13)
	   end if
	   ! *** *** *** *** *** *** *** *** *** *** *** *** ***
	   !         computation of array entries
	   ! *** *** *** *** *** *** *** *** *** *** *** *** ***
	   ! ---- implicit, banded or not ?
	   implct = imas /= 0
	   jband = mljac < nm1
	   ! -------- computation of the row-dimensions of the 2-arrays ---
	   ! -- jacobian  and  matrices e1, e2
	   if (jband) then
	      ldjac = mljac + mujac + 1
	      lde1 = mljac + ldjac
	   else
	      mljac = nm1
	      mujac = nm1
	      ldjac = nm1
	      lde1 = nm1
	   end if
	   ! -- mass matrix
	   if (implct) then
	      if (mlmas /= nm1) then
	         ldmas = mlmas + mumas + 1
	         if (jband) then
	            ijob = 4
	         else
	            ijob = 3
	         end if
	      else
	         ldmas = nm1
	         ijob = 5
	      end if
	      ! ------ bandwith of "mas" not smaller than bandwith of "jac"
	      if (mlmas > mljac .or. mumas > mujac) then
	         write (6, *) 'bandwith of "mas" not smaller than bandwith of &
	            "jac"'
	         arret = .true.
	      end if
	   else
	      ldmas = 0
	      if (jband) then
	         ijob = 2
	      else
	         ijob = 1
	         if (n > 2 .and. iwork(1) /= 0) ijob = 7
	      end if
	   end if
	   ldmas2 = max(1, ldmas)
	   ! ------ hessenberg option only for explicit equ. with full jacobian
	   if ((implct .or. jband) .and. ijob == 7) then
	      write (6, *) ' hessenberg option only for explicit equations with &
	         full jacobian'
	      arret = .true.
	   end if
	   ! ------- prepare the entry-points for the arrays in work -----
	   nns = ns*n
	   nm1ns = ns*nm1
	   nmee = (ns - 1)*nm1
	   iezz = 21
	   iey0 = iezz + nns
	   iescal = iey0 + n
	   ieff = iescal + n
	   iecon = ieff + nns
	   iejac = iecon + nns + n
	   iemas = iejac + n*ldjac
	   iee1 = iemas + nm1*ldmas
	   iee = iee1 + nm1*lde1
	   ! ------ total storage requirement -----------
	   istore = iee + nmee*lde1 - 1
	   if (istore > lwork) then
	      write (6, *) ' insufficient storage for work, min. lwork=', istore
	      arret = .true.
	   end if
	   ! ------- entry points for integer workspace -----
	   ieip1 = 21
	   ieip2 = ieip1 + nm1
	   ieiph = ieip2 + nm1*(ns - 1)/2
	   ! --------- total requirement ---------------
	   istore = ieiph + nm1 - 1
	   if (istore > liwork) then
	      write (6, *) ' insuff. storage for iwork, min. liwork=', istore
	      arret = .true.
	   end if
	   ! ------ when a fail has occured, we return with idid=-1
	   if (arret) then
	      idid = -1
	      return
	   end if
a5c08cb05d858dca1c769d84504d29f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|34|4|V|cpp
	   end if
dc6b7acfee27b2614748c9ebdcaa8305|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|24|1|V|cpp
	   int nsmin;
87e907d80ed9697965156476760dec83|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|25|4|V|cpp
	   int nsmax;
15b43bcb733e03aed939faa6fd3d2480|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|55|7|V|cpp
	      end i
5b8ae7fe6b352f6e507b995e96fd42a6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|67|7|V|cpp
	      end if
5c111ea2ce3a96235630f01de13acff8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|96|4|V|cpp
	   end 
9f7628a1f828bb36412a5d967e35f951|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|138|7|V|cpp
	      end do
b37c7f6f51640e04e16349fbfdf0ccf8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|255|10|V|cpp
	         end if
8ab414507ff1503226fa0c33d8545dd4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|23|40|v|cpp
	, nind1, nind2, nind3;
f55680c13027b5d3ff68beb47b20535d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|86|1|V|cpp
	  // -------- parameter for differential-algebraic components
	  nind1 = iwork(5);
	  nind2 = iwork(6);
	  nind3 = iwork(7);
	  if (nind1 == 0)
	    nind1 = n;
	  if (nind1 + nind2 + nind3 /= n) {
	    // write (6, *) ' curious input for iwork(5,6,7)=', nind1, nind2, nind3
	    arret = true;
	  }
aee4ae031d5399c30f58ce2d2b48ee24|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|92|1|V|cpp
	  // -------- parameter for second order equations
	  m1 = iwork(9);
	  m2 = iwork(10);
	  nm1 = n - m1;
	  if (m1 == 0)
	    m2 = n;
	  if (m2 == 0)
	    m2 = m1;
	  if (m1 < 0.or.m2 < 0.or.m1 + m2 > n) {
	    // write (6, *) ' curious input for iwork(9,10)=', m1, m2
	    arret = true;
	  }
6b9596c1ad261f5f8affaec594fb8967|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|92|1|V|cpp
	  // -------- uround   smallest number satisfying 1.0d0+uround>1.0d0
	  if (work(1) == 0.0d0) {
	    uround = 1.0d - 16;
	  } else {
	    uround = work(1);
	    if (uround <= 1.0d - 19.or.uround >= 1.0d0) {
	      // write (6, *) ' coefficients have 20 digits, uround=', work(1)
	      arret = true;
	    }
	  }
ddcdfbc6856cdf230b91d084864a85b3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|93|3|V|cpp
	  if (itol == 0) {
d21173ff43bc782a6069244e9292821d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|97|1|V|cpp
	  } else {
	    for (size_t i = 1; i <= n; i++) {
	      if (atol(i) <= 0.d0.or.rtol(i) <= 10.d0 * uround) {
	        // write (6, *) ' tolerances(', i, ') are too small'
	        arret = true;
	      }
	    }
	  }
f13fc28d311b10dc6e1fdffd5e71e4b4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|176|1|V|cpp
	  // *** *** *** *** *** *** *** *** *** *** *** *** ***
	  //         computation of array entries
	  // *** *** *** *** *** *** *** *** *** *** *** *** ***
	  // ---- implicit, banded or not ?
	  implct = imas /= 0;
	  jband = mljac < nm1;
73ac0f7c95337df0d2ba95cd1fb2193c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|176|1|V|cpp
	  // -------- computation of the row-dimensions of the 2-arrays ---
	  // -- jacobian  and  matrices e1, e2
	  if (jband) {
	    ldjac = mljac + mujac + 1;
	    lde1 = mljac + ldjac;
	  } else {
	    mljac = nm1;
	    mujac = nm1;
	    ldjac = nm1;
	    lde1 = nm1;
	  }
	  // -- mass matrix
	  if (implct) {
	    if (mlmas /= nm1) {
	      ldmas = mlmas + mumas + 1;
	      if (jband) {
	        ijob = 4;
	      } else {
	        ijob = 3;
	      }
	    } else {
	      ldmas = nm1;
	      ijob = 5;
	    }
	    // ------ bandwith of "mas" not smaller than bandwith of "jac"
	    if (mlmas > mljac.or.mumas > mujac) {
	      // write (6, *) 'bandwith of "mas" not smaller than bandwith of &
	      //  "jac"'
	      arret = true;
	    }
	  } else {
	    ldmas = 0;
	    if (jband) {
	      ijob = 2;
	    } else {
	      ijob = 1;
	      if (n > 2.and.iwork(1) /= 0)
	        ijob = 7;
	    }
	  }
	  ldmas2 = max(1, ldmas);
	  // ------ hessenberg option only for explicit equ. with full jacobian
	  if ((implct.or.jband).and.ijob == 7) {
	    // write (6, *) ' hessenberg option only for explicit equations with &
	    // full jacobian'
	    arret = true;
	  }
d0bcf0bfee414542af83b283ba247d69|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|177|1|V|cpp
	  nns = ns * n;
	  nm1ns = ns * nm1;
	  nmee = (ns - 1) * nm1;
	  iezz = 21;
	  iey0 = iezz + nns;
	  iescal = iey0 + n;
	  ieff = iescal + n;
	  iecon = ieff + nns;
	  iejac = iecon + nns + n;
	  iemas = iejac + n * ldjac;
	  iee1 = iemas + nm1 * ldmas;
	  iee = iee1 + nm1 * lde1;
5f03368b0e367b45dcafff9699684742|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|30|3|V|cpp
	  nns = ns * n;
18699e45a1d1331fdf54b429b6e91a98|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|31|1|V|cpp
	  nm1ns = ns * nm1;
	  nmee = (ns - 1) * nm1;
14e19b9f0f4713aff43fb37113d372b7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|32|1|V|cpp
	  iezz = 21;
	  iey0 = iezz + nns;
	  iescal = iey0 + n;
	  ieff = iescal + n;
	  iecon = ieff + nns;
	  iejac = iecon + nns + n;
	  iemas = iejac + n * ldjac;
	  iee1 = iemas + nm1 * ldmas;
	  iee = iee1 + nm1 * lde1;
8661cf906a1ddd4178a6ffd969b669ab|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|399|1|V|fortran
	   nfcn = 0
	   njac = 0
	   nstep = 0
	   naccpt = 0
	   nrejct = 0
	   ndec = 0
	   nsol = 0
	   arret = .false.
	   ! -------- number maximal and minimal of stages  ns
	   if (iwork(11) == 0) then
	      nsmin = 3
	   else
	      nsmin = max(1, iwork(11))
	      if (iwork(11) >= 2) nsmin = max(3, iwork(11))
	      if (iwork(11) >= 4) nsmin = max(5, iwork(11))
	      if (iwork(11) >= 6) nsmin = 7
	   end if
	   if (iwork(12) == 0) then
	      nsmax = 7
	   else
	      nsmax = min(7, iwork(12))
	      if (iwork(12) <= 6) nsmax = min(5, iwork(12))
	      if (iwork(12) <= 4) nsmax = min(3, iwork(12))
	      if (iwork(12) <= 2) nsmax = 1
	   end if
	   ns = nsmax
	   if (iwork(13) == 0) then
	      nsus = nsmin
	   else
	      nsus = iwork(13)
	      if (nsus <= 0 .or. ns >= 8 .or. ns == 2 .or. ns == 4 .or. ns == 6) then
	         write (6, *) ' wrong input iwork(13)=', iwork(13)
	         arret = .true.
	      end if
	   end if
	   ! -------- nmax , the maximal number of steps -----
	   if (iwork(2) == 0) then
	      nmax = 100000
	   else
	      nmax = iwork(2)
	      if (nmax <= 0) then
	         write (6, *) ' wrong input iwork(2)=', iwork(2)
	         arret = .true.
	      end if
	   end if
	   ! -------- nit    maximal number of newton iterations
	   if (iwork(3) == 0) then
	      nit = 7
	   else
	      nit = iwork(3)
	      if (nit <= 0 .or. nit > 50) then
	         write (6, *) ' curious input iwork(3)=', iwork(3)
	         arret = .true.
	      end if
	   end if
	   ! -------- startn  switch for starting values of newton iterations
	   if (iwork(4) == 0) then
	      startn = .false.
	   else
	      startn = .true.
	   end if
	   ! -------- parameter for differential-algebraic components
	   nind1 = iwork(5)
	   nind2 = iwork(6)
	   nind3 = iwork(7)
	   if (nind1 == 0) nind1 = n
	   if (nind1 + nind2 + nind3 /= n) then
	      write (6, *) ' curious input for iwork(5,6,7)=', nind1, nind2, nind3
	      arret = .true.
	   end if
	   ! -------- pred   step size control
	   if (iwork(8) <= 1) then
	      pred = .true.
	   else
	      pred = .false.
	   end if
	   ! -------- parameter for second order equations
	   m1 = iwork(9)
	   m2 = iwork(10)
	   nm1 = n - m1
	   if (m1 == 0) m2 = n
	   if (m2 == 0) m2 = m1
	   if (m1 < 0 .or. m2 < 0 .or. m1 + m2 > n) then
	      write (6, *) ' curious input for iwork(9,10)=', m1, m2
	      arret = .true.
	   end if
	   ! -------- uround   smallest number satisfying 1.0d0+uround>1.0d0
	   if (work(1) == 0.0d0) then
	      uround = 1.0d-16
	   else
	      uround = work(1)
	      if (uround <= 1.0d-19 .or. uround >= 1.0d0) then
	         write (6, *) ' coefficients have 20 digits, uround=', work(1)
	         arret = .true.
	      end if
	   end if
	   ! --------- check if tolerances are o.k.
	   if (itol == 0) then
	      if (atol(1) <= 0.d0 .or. rtol(1) <= 10.d0*uround) then
	         write (6, *) ' tolerances are too small'
	         arret = .true.
	      end if
	   else
	      do i = 1, n
	      if (atol(i) <= 0.d0 .or. rtol(i) <= 10.d0*uround) then
	         write (6, *) ' tolerances(', i, ') are too small'
	         arret = .true.
	      end if
	      end do
	   end if
	   ! --------- safe     safety factor in step size prediction
	   if (work(2) == 0.0d0) then
	      safe = 0.9d0
	   else
	      safe = work(2)
	      if (safe <= 0.001d0 .or. safe >= 1.0d0) then
	         write (6, *) ' curious input for work(2)=', work(2)
	         arret = .true.
	      end if
	   end if
	   ! ------ thet     decides whether the jacobian should be recomputed;
	   if (work(3) == 0.d0) then
	      thet = 0.001d0
	   else
	      thet = work(3)
	      if (thet >= 1.0d0) then
	         write (6, *) ' curious input for work(3)=', work(3)
	         arret = .true.
	      end if
	   end if
	   ! --- quot1 and quot2: if quot1 < hnew/hold < quot2, step size = const.
	   if (work(5) == 0.d0) then
	      quot1 = 1.d0
	   else
	      quot1 = work(5)
	   end if
	   if (work(6) == 0.d0) then
	      quot2 = 1.2d0
	   else
	      quot2 = work(6)
	   end if
	   if (quot1 > 1.0d0 .or. quot2 < 1.0d0) then
	      write (6, *) ' curious input for work(5,6)=', quot1, quot2
	      arret = .true.
	   end if
	   ! -------- maximal step size
	   if (work(7) == 0.d0) then
	      hmax = xend - x
	   else
	      hmax = work(7)
	   end if
	   ! -------  facl,facr     parameters for step size selection
	   if (work(8) == 0.d0) then
	      facl = 5.d0
	   else
	      facl = 1.d0/work(8)
	   end if
	   if (work(9) == 0.d0) then
	      facr = 1.d0/8.0d0
	   else
	      facr = 1.d0/work(9)
	   end if
	   if (facl < 1.0d0 .or. facr > 1.0d0) then
	      write (6, *) ' curious input work(8,9)=', work(8), work(9)
	      arret = .true.
	   end if
	   ! -------- parameters for order selection strategy
	   if (work(10) == 0.d0) then
	      vitu = 0.002d0
	   else
	      vitu = work(10)
	   end if
	   if (work(11) == 0.d0) then
	      vitd = 0.8d0
	   else
	      vitd = work(11)
	   end if
	   if (work(12) == 0.d0) then
	      hhou = 1.2d0
	   else
	      hhou = work(12)
	   end if
	   if (work(13) == 0.d0) then
	      hhod = 0.8d0
	   else
	      hhod = work(13)
	   end if
	   ! *** *** *** *** *** *** *** *** *** *** *** *** ***
	   !         computation of array entries
	   ! *** *** *** *** *** *** *** *** *** *** *** *** ***
	   ! ---- implicit, banded or not ?
	   implct = imas /= 0
	   jband = mljac < nm1
	   ! -------- computation of the row-dimensions of the 2-arrays ---
	   ! -- jacobian  and  matrices e1, e2
	   if (jband) then
	      ldjac = mljac + mujac + 1
	      lde1 = mljac + ldjac
	   else
	      mljac = nm1
	      mujac = nm1
	      ldjac = nm1
	      lde1 = nm1
	   end if
	   ! -- mass matrix
	   if (implct) then
	      if (mlmas /= nm1) then
	         ldmas = mlmas + mumas + 1
	         if (jband) then
	            ijob = 4
	         else
	            ijob = 3
	         end if
	      else
	         ldmas = nm1
	         ijob = 5
	      end if
	      ! ------ bandwith of "mas" not smaller than bandwith of "jac"
	      if (mlmas > mljac .or. mumas > mujac) then
	         write (6, *) 'bandwith of "mas" not smaller than bandwith of &
	            "jac"'
	         arret = .true.
	      end if
	   else
	      ldmas = 0
	      if (jband) then
	         ijob = 2
	      else
	         ijob = 1
	         if (n > 2 .and. iwork(1) /= 0) ijob = 7
	      end if
	   end if
	   ldmas2 = max(1, ldmas)
	   ! ------ hessenberg option only for explicit equ. with full jacobian
	   if ((implct .or. jband) .and. ijob == 7) then
	      write (6, *) ' hessenberg option only for explicit equations with &
	         full jacobian'
	      arret = .true.
	   end if
	   ! ------- prepare the entry-points for the arrays in work -----
	   nns = ns*n
	   nm1ns = ns*nm1
	   nmee = (ns - 1)*nm1
	   iezz = 21
	   iey0 = iezz + nns
	   iescal = iey0 + n
	   ieff = iescal + n
	   iecon = ieff + nns
	   iejac = iecon + nns + n
	   iemas = iejac + n*ldjac
	   iee1 = iemas + nm1*ldmas
	   iee = iee1 + nm1*lde1
	   ! ------ total storage requirement -----------
	   istore = iee + nmee*lde1 - 1
	   if (istore > lwork) then
	      write (6, *) ' insufficient storage for work, min. lwork=', istore
	      arret = .true.
	   end if
	   ! ------- entry points for integer workspace -----
	   ieip1 = 21
	   ieip2 = ieip1 + nm1
	   ieiph = ieip2 + nm1*(ns - 1)/2
	   ! --------- total requirement ---------------
	   istore = ieiph + nm1 - 1
	   if (istore > liwork) then
	      write (6, *) ' insuff. storage for iwork, min. liwork=', istore
	      arret = .true.
	   end if
	   ! ------ when a fail has occured, we return with idid=-1
	   if (arret) then
	      idid = -1
	      return
	   end if
	   ! -------- call to core integrator ------------
	   call radcov(n, fcn, x, y, xend, hmax, h, rtol, atol, itol, nsus, &
	               jac, ijac, mljac, mujac, mas, mlmas, mumas, solout, iout, idid, &
	               nmax, uround, safe, thet, quot1, quot2, nit, ijob, startn, &
	               nind1, nind2, nind3, pred, facl, facr, m1, m2, nm1, nsmin, ns, nns, nm1ns, &
	               nmee, implct, jband, ldjac, lde1, ldmas2, work(iezz), work(iey0), &
	               work(iescal), work(ieff), work(iejac), work(iee1), work(iee), &
	               work(iemas), work(iecon), iwork(ieip1), iwork(ieip2), &
	               iwork(ieiph), vitu, vitd, hhou, hhod, nfcn, njac, nstep, naccpt, &
	               nrejct, ndec, nsol, rpar, ipar)
	   iwork(13) = nsus
	   iwork(14) = nfcn
	   iwork(15) = njac
	   iwork(16) = nstep
	   iwork(17) = naccpt
	   iwork(18) = nrejct
	   iwork(19) = ndec
	   iwork(20) = nsol
	   ! ----------- return -----------
	   return
39ef5617bf370c988ebbb66e411b6ead|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|33|1|V|cpp
	  // -------- number maximal and minimal of stages  ns
	  if (iwork(11) == 0) {
	    nsmin = 3;
	  } else {
	    nsmin = fmax(1, iwork(11));
	    if (iwork(11) >= 2)
	      nsmin = fmax(3, iwork(11));
	    if (iwork(11) >= 4)
	      nsmin = fmax(5, iwork(11));
	    if (iwork(11) >= 6)
	      nsmin = 7;
	  }
	  if (iwork(12) == 0) {
	    nsmax = 7;
	  } else {
	    nsmax = fmin(7, iwork(12));
	    if (iwork(12) <= 6)
	      nsmax = fmin(5, iwork(12));
	    if (iwork(12) <= 4)
	      nsmax = fmin(3, iwork(12));
	    if (iwork(12) <= 2)
	      nsmax = 1;
	  }
	  ns = nsmax;
	  if (iwork(13) == 0) {
	    nsus = nsmin;
	  } else {
	    nsus = iwork(13);
	    if (nsus <= 0 or ns >= 8 or ns == 2 or ns == 4 or ns == 6) {
	      // write (6, *) ' wrong input iwork(13)=', iwork(13);
	      arret = true;
	    }
	  }
	  // -------- nmax , the maximal number of steps -----
	  if (iwork(2) == 0) {
	    nmax = 100000;
	  } else {
	    nmax = iwork(2);
	    if (nmax <= 0) {
	      // write (6, *) ' wrong input iwork(2)=', iwork(2)
	      arret = true;
	    }
	  }
	  // -------- nit    maximal number of newton iterations
	  if (iwork(3) == 0) {
	    nit = 7;
	  } else {
	    nit = iwork(3);
	    if (nit <= 0 or nit > 50) {
	      // write (6, *) ' curious input iwork(3)=', iwork(3)
	      arret = true;
	    }
	  }
	  // -------- startn  switch for starting values of newton iterations
	  if (iwork(4) == 0) {
	    startn = false;
	  } else {
	    startn = true;
	  }
	
	  // -------- pred   step size control
	  if (iwork(8) <= 1) {
	    pred = true;
	  } else {
	    pred = false;
	  }
	  // --------- check if tolerances are o.k.
	  if (atol <= 0.0 or rtol <= 10.0 * std::numeric_limits<double>::epsilon()) {
	    // write (6, *) ' tolerances are too small'
	    arret = true;
	  }
	  // --------- safe     safety factor in step size prediction
	  if (work(2) == 0.0) {
	    safe = 0.90;
	  } else {
	    safe = work(2);
	    if (safe <= 0.001 or safe >= 1.0) {
	      // write (6, *) ' curious input for work(2)=', work(2)
	      arret = true;
	    }
	  }
	  // ------ thet     decides whether the jacobian should be recomputed;
	  if (work(3) == 0.0) {
	    thet = 0.0010;
	  } else {
	    thet = work(3);
	    if (thet >= 1.00) {
	      // write (6, *) ' curious input for work(3)=', work(3)
	      arret = true;
	    }
	  }
	  // --- quot1 and quot2: if quot1 < hnew/hold < quot2, step size = const.
	  if (work(5) == 0.0) {
	    quot1 = 1.0;
	  } else {
	    quot1 = work(5);
	  }
	  if (work(6) == 0.0) {
	    quot2 = 1.20;
	  } else {
	    quot2 = work(6);
	  }
	  if (quot1 > 1.00 or quot2 < 1.0) {
	    // write (6, *) ' curious input for work(5,6)=', quot1, quot2
	    arret = true;
	  }
	  // -------- maximal step size
	  if (work(7) == 0.0) {
	    hmax = xend - x;
	  } else {
	    hmax = work(7);
	  }
	  // -------  facl,facr     parameters for step size selection
	  if (work(8) == 0.0) {
	    facl = 5.0;
	  } else {
	    facl = 1.0 / work(8);
	  }
	  if (work(9) == 0.0) {
	    facr = 1.0 / 8.00;
	  } else {
	    facr = 1.0 / work(9);
	  }
	  if (facl < 1.00 or facr > 1.0) {
	    // write (6, *) ' curious input work(8,9)=', work(8), work(9)
	    arret = true;
	  }
	  // -------- parameters for order selection strategy
	  if (work(10) == 0.0) {
	    vitu = 0.0020;
	  } else {
	    vitu = work(10);
	  }
	  if (work(11) == 0.0) {
	    vitd = 0.80;
	  } else {
	    vitd = work(11);
	  }
	  if (work(12) == 0.0) {
	    hhou = 1.20;
	  } else {
	    hhou = work(12);
	  }
	  if (work(13) == 0.0) {
	    hhod = 0.80;
	  } else {
	    hhod = work(13);
	  }
	  // ------- prepare the entry-points for the arrays in work -----
	  nns = ns * N;
	  nm1ns = ns * nm1;
	  nmee = (ns - 1) * nm1;
	  iezz = 21;
	  iey0 = iezz + nns;
	  iescal = iey0 + n;
	  ieff = iescal + n;
	  iecon = ieff + nns;
	  iejac = iecon + nns + n;
	  iemas = iejac + n * ldjac;
	  iee1 = iemas + nm1 * ldmas;
	  iee = iee1 + nm1 * lde1;
	  // ------ total storage requirement -----------
	  istore = iee + nmee * lde1 - 1;
	  if (istore > lwork) {
	    // write (6, *) ' insufficient storage for work, min. lwork=', istore
	    arret = true;
	  }
	  // ------- entry points for integer workspace -----
	  ieip1 = 21;
	  ieip2 = ieip1 + nm1;
	  ieiph = ieip2 + nm1 * (ns - 1) / 2;
	  // --------- total requirement ---------------
	  istore = ieiph + nm1 - 1;
	  if (istore > liwork) {
	    // write (6, *) ' insuff. storage for iwork, min. liwork=', istore
	    arret = true;
	  }
	  // ------ when a fail has occured, we return with idid=-1
	  if (arret) {
	    idid = -1;
	    return;
	  }
82f93bb7312cb869eca7db19c8329f14|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|24|1|V|cpp
	  int nsmin, nsmax, ns, nsus, nmax, nit, nns;
	  int nm1, nm1ns, nmee;
	  int iezz, iey0, iescal, ieff, iecon, iejac, iemas, iee1;
	  bool arret, startn, pred;
	  double thet, safe, quot1, quot2, hmax, facl, facr, vitu, vitd;
	  double hhod, hhou;
1bfa94a820489f3607d75635b1796fc6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|11|12|v|cpp
	Func &func, double x, Vector<double, N> &y, double xend, double h,
	           double rtol, double atol, SolOut &solout, Vector<double, 20> &work,
	           Vector<int, 20> &iwork
a06d5b3a65cb2d3a835d4037fbaf240d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|10|1|V|cpp
	template <class Func, class SolOut, size_t N>
24abe7532f80784aa8e1761d495f0386|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|10|1|V|cpp
	typedef void(int,double,Vector<double>,
bfd618dda6eab79e9ed5594f410ed0a7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|11|1|V|cpp
	template<int N>
	using OdeFunc = std::function<void(double,const Vector<double,N>&,Vector<double,N>)>;
7f83cafdcc6d9984deb4ef107ddb65d7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|19|5|V|cpp
	    int n, 
1800ce6c7cce01d68ff67ce6c953cb1f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|1|18|v|fortran
	n, fcn, x, y, xend, h, &
	                 rtol, atol, itol, &
	                 jac, ijac, mljac, mujac, &
	                 mas, imas, mlmas, mumas, &
	                 solout, iout, &
	                 work, lwork, iwork, liwork, rpar, ipar, idid
37af4784ee8128c6d0cb4f490ac0859f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|14|1|V|cpp
	template<int N>
	using OdeJac = std::function<void(double,const Vector<double,N>&,Matrix<double,N,N>)>;
0e3e0a5df5c13f3ac3a36f5744799dc2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|18|35|v|cpp
	double,const Vector<double,N>&,Matrix<double,N,N>
2982f6dc7dbb125be7071b27176f9482|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|44|5|V|cpp
	    rpar, 
d0ccbadf08c5680e2b8565dc425efa87|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|44|5|V|cpp
	    ipar, 
4f3c578eb6b308298b93dea66389f477|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|44|3|V|cpp
	    int &idid
1057435b69ef0aaedd887012114bdf7b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|17|1|V|cpp
	template<int N>
	using OdeMas = std::function<void(Matrix<double,N,N>, int)>;
f4848022083101257ebfde4fd14d21c8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|21|33|v|cpp
	void(Matrix<double,N,N>, int)>;
90f28dfce8a30193410c938479bea1ca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|20|1|V|cpp
	template<int N>
c52a640b35fcc65099de04f40c57da5c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|66|1|V|cpp
	   nfcn = 0
	   njac = 0
	   nstep = 0
	   naccpt = 0
	   nrejct = 0
	   ndec = 0
	   nsol = 0
	   arret = .false.
232a1abdbb2a8c819b4d1bedde51f58c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|336|7|V|cpp
	      idid = -1
f86aec6ca8462ba9c944e6725fda2d5a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/radau.f90|698|19|v|fortran
	n, fcn, x, y, xend, hmax, h, rtol, atol, itol, ns, &
	                  jac, ijac, mljac, mujac, mas, mlmas, mumas, solout, iout, idid, &
	                  nmax, uround, safe, thet, quot1, quot2, nit1, ijob, startn, nind1, &
	                  nind2, nind3, pred, facl, facr, m1, m2, nm1, nsmin, nsmax, nnms, nm1ns, &
	                  nmee, implct, banded, ldjac, lde1, ldmas, zz, y0, scal, ff, fjac, &
	                  e1, ee2, fmas, cont, ip1, ip2, iphes, vitu, vitd, hhou, hhod, &
	                  nfcn, njac, nstep, naccpt, nrejct, ndec, nsol, rpar, ipar
546320bec141e6c4783634cc64e13ab9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|35|1|V|cpp
	  size_t nfcn = 0;
	  size_t njac = 0;
	  size_t nstep = 0;
	  size_t naccpt = 0;
	  size_t nrejct = 0;
	  size_t ndec = 0;
	  size_t nsol = 0;
345ae60f10381e7f66c811ce25d6cc19|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|53|1|V|cpp
	  int nsmin, nsmax, ns, nsus, nmax, nit, nns;
	  int nm1, nm1ns, nmee;
	  int nind1, nind2, nind3;
	  int m1, m2;
	  int iezz, iey0, iescal, ieff, iecon, iejac, iemas, iee1;
	  bool arret, startn, pred;
	
	  double thet, safe, quot1, quot2, hmax, facl, facr, vitu, vitd, uround;
	  double hhod, hhou;
8b36bb8af647f1fb8998400f8338ea51|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|266|1|V|cpp
	  bool implct = imas != 0;
	  bool jband = mljac < nm1;
	  // -------- computation of the row-dimensions of the 2-arrays ---
	  // -- jacobian  and  matrices e1, e2
	
	  int ldjac, lde1, ldmas, ldmas2;
	  int ijob;
a002e32e03d1a1ab59576079287ec800|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|75|14|v|cpp
	 = imas != 0;
38583e1f8daf8dca3e11706f07b8a1a4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|76|13|v|cpp
	 = mljac < nm1;
0430714724031d8ba69259f74badac7d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|77|1|V|cpp
	  // -------- computation of the row-dimensions of the 2-arrays ---
	  // -- jacobian  and  matrices e1, e2
3ef27b8da74e8196e0d10d02982835e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|53|11|v|cpp
	OdeFunc<N> &fcn, double &x, Vector<double, N> &y, double xend,
	          double h, double *rtol, double *atol, int itol, OdeJac<N> &jac,
	          int ijac, int mljac, int mujac, OdeMas<N> &mas, int imas, int mlmas,
	          int mumas, OdeSolOut<N> &solout, int iout, Vector<double> &work,
	          int lwork, Vector<int> &iwork, int liwork
38c9ae01ec549f726d05da10e9557c15|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|11|1|V|cpp
	template <int N>
acc4f644459e2385d3b6349fddfa736c|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|14|48|v|cpp
	, N, N
18186dedd8650b0b9dc1a0305e7a6a90|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|16|1|v|cpp
	template <int N> 
f67185366725082a23b97bc70da9f975|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|39|9|v|cpp
	int n, OdeFunc &fcn, double &x, Vector<double> &y, double xend,
	          double h, double *rtol, double *atol, int itol, OdeJac &jac,
	          int ijac, int mljac, int mujac, OdeMas &mas, int imas, int mlmas,
	          int mumas, OdeSolOut &solout, int iout, Vector<double> &work,
	          int lwork, Vector<int> &iwork, int liwork
2684db8c41dc55be55b9a793981274a6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|64|1|V|cpp
	  bool implct;
	  bool jband;
	
	  int ldjac, lde1, ldmas, ldmas2;
	  int ijob;
59146d83584947b7b6477f0e77c4e0c4|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|319|1|V|cpp
	  int iee = iee1 + nm1 * lde1;
	  // ------ total storage requirement -----------
	  int istore = iee + nmee * lde1 - 1;
cecf71f413036f516e5320ac55df9632|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|33|10|v|cpp
	 = iee1 + nm1 * lde1;
ffc24076ee3bd247e724119ed3540087|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|34|3|V|cpp
	  // ------ total storage requirement -----------
df160ed2f0eb59860332ac597ded919b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|34|13|v|cpp
	 = iee + nmee * lde1 - 1;
8c4907c97901ce0240dc5d1c675c7102|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|343|5|V|cpp
	    return -1;
b55a09063d8e4213e022b7f2d0b2a3db|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|365|3|V|cpp
	  return ;
6838d576778720a2c4b4177d6866aa7d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/radau.hpp|364|1|V|cpp
	  // ----------- return -----------
771b27e2b9735e41155f14ffbb50c100|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_VERBOSE_MAKEFILE ON)
	project(DarkSun)
	
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
	
	# Core c++ library
	add_subdirectory(darksun)
	
	# Fortran library for stiff solvers
	add_subdirectory(stiff)
9364311b2ba691958aa9943833ea297b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|6|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
9c5c153cb50a8c9c030331c501ad6a03|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|10|1|V|cmake
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
f9151c650f14fdf6923f3d249fc1b6d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/CMakeLists.txt|8|1|V|cmake
	message("sources = ${sources}")
1046ee7ba277b31ddd097247a3d3d087|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|20|1|V|cmake
	# --------------------------------------------------------------------------cc
8791a237b932612d9b07f047f945ebfd|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|20|1|V|cmake
	# ===========================================================================
	# ---- Testing files --------------------------------------------------------
	# ===========================================================================
0f57cebcf33486ab3b5dc30ea2d241ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|21|8|v|cmake
	Testing files
a474c36c39f27599dc49bece2993bd94|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|15|1|V|cmake
	include_directories(include)
a199df361dbf537251643a9018a01125|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|15|1|V|cmake
	file(GLOB_RECURSE SOURCES src/*.cpp)
ab74e2e95bbd9029e8ea07aea8caac4e|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|26|1|V|cmake
	# ===========================================================================
	# ---- Applications ---------------------------------------------------------
	# ===========================================================================
	
	# ===========================================================================
	# ---- Testing files --------------------------------------------------------
	# ===========================================================================
	
7c9af1c275f6ef0e27dd0733575afa83|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|16|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
fbbc6e081ef134d422e9ebf14c05d1d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|18|1|V|cmake
	# Build the tests
	add_subdirectory(test)
c6b3f28c654c5e58c7d57553da48d72b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|2|1|V|cmake
	set(CMAKE_VERBOSE_MAKEFILE ON)
	project(DarkSun)
4643249f92b8cc6ad5ccbb96547c2578|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/CMakeLists.txt|5|1|V|cmake
	# Boost and its components
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
9815adfd91b7e2fda78338938e3f7388|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|1|1|V|cmake
	set(CMAKE_CXX_STANDARD 17)
	
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	find_package(fmt REQUIRED)
	
	include_directories(${Boost_INCLUDE_DIRS})
d9fc955e03e2acd9a18a99ace8dcc30b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|115|1|V|cmake
	# --------------------------------------------------------------------------
	# test_phase_space.cpp: Check phase space Monte Carlo
	# --------------------------------------------------------------------------
	
	add_executable(test_phase_space test_phase_space.cpp)
	set_property(TARGET test_phase_space PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_phase_space PUBLIC
	        darksun
		stiff
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	 
	 set_target_properties(test_phase_space PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
32e15f53d9b80e19d7f5815858965074|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|58|2|V|cmake
	 set_target_properties(test_phase_space PROPERTIES
f9d75efc75d5f5987ea21b1bcfc4c768|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|58|1|V|cmake
	 set_target_properties(test_phase_space PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
81a160dd245850b1801d6cc1cb5502b8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|109|1|v|cpp
	/**
	 * Compute the decay width or scattering cross-section.
	 * @param num_events number of events to generate.
	 * @return average and standard-deviation.
	 */
	std::pair<double, double>
	PhaseSpaceGenerator::compute_width_cross_section(size_t num_events) {
	  generate_events(num_events);
	  auto num_events_d = (double)m_events.size();
	
	  // Compute average: <w_i> and average of squares: <w_i^2>
	  double avg = 0.0, avg2 = 0.0;
	  for (auto &event : m_events) {
	    double weight = event.weight;
	    avg += weight;
	    avg2 += weight * weight;
	  }
	  avg /= num_events_d;
	  avg2 /= num_events_d;
	
	  /* Compute the pre-factor of width or cross-section based on the number
	   * of initial state particles.
	   */
	  double pre_factor;
	  if (isp_masses.size() == 2) {
	    double m1 = isp_masses[0];
	    double m2 = isp_masses[1];
	    double eng1 = (cme * cme + m1 * m1 - m2 * m2) / (2.0 * cme);
	    double eng2 = (cme * cme - m1 * m1 + m2 * m2) / (2.0 * cme);
	    double p = sqrt((m1 - m2 - cme) * (m1 + m2 - cme) * (m1 - m2 + cme) *
	                    (m1 + m2 + cme)) /
	               (2.0 * cme);
	
	    double v1 = p / eng1, v2 = p / eng2;
	    double v_rel = v1 + v2;
	
	    pre_factor = 1.0 / (2.0 * eng1 * 2.0 * eng2 * v_rel);
	
	  } else {
	    pre_factor = 1.0 / (2.0 * cme);
	  }
	
	  /* Compute standard deviation:
	   *  var = <x^2> - <x>^2
	   *  sig = sqrt(var / N)
	   */
	  double var = avg2 - avg * avg;
	  double sig = sqrt(var / num_events_d);
	  if (std::isnan(sig))
	    sig = avg * 1e-12;
	  return std::make_pair(pre_factor * avg, pre_factor * sig);
	}
6ffbe7d3fead4e73f1aa50b5075af629|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|16|1|V|cpp
	struct FourVector {
	  double t;
	  double x;
	  double y;
	  double z;
	};
805819c32c7807afbbf3cb2333a1cf54|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_vector.hpp|14|1|V|cpp
	FourMomentum operator+(const FourMomentum&, const FourMomentum&);
3285a26fbf21bd09deb740ad0af3e338|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|31|1|V|cpp
	std::ostream &operator<<(std::ostream &os, const FourVector &fv) {
	  os << "FourVector(" << fv.t << ", " << fv.x << ", " << fv.y << ", " << fv.z
	     << ")";
	  return os;
	}
f0eceed4a03f5d378ddafc044437560d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_vector.hpp|20|1|V|cpp
	  os << "FourVector(" << fv.t << ", " << fv.x << ", " << fv.y << ", " << fv.z
	     << ")";
	  return os;
bb0797436f2f9719156887ba0116a444|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|37|1|V|cpp
	double mass(FourVector &fv) {
b42c442c774c6afa2df2d7cc78114fd8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|42|1|V|cpp
	double scalar_product(const FourVector &fv1, const FourVector &fv2) {
cfcd4e3fb7d593b24d0175ee90a2fb86|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|23|1|V|cpp
	FourVector operator+(const FourVector &fv1, const FourVector &fv2) {
	  return FourVector{fv1.t + fv2.t, fv1.x + fv2.x, fv1.y + fv2.y, fv1.z + fv2.z};
	}
	
	FourVector operator-(const FourVector &fv1, const FourVector &fv2) {
	  return FourVector{fv1.t - fv2.t, fv1.x - fv2.x, fv1.y - fv2.y, fv1.z - fv2.z};
	}
	
	std::ostream &operator<<(std::ostream &os, const FourVector &fv) {
	  os << "FourVector(" << fv.t << ", " << fv.x << ", " << fv.y << ", " << fv.z
	     << ")";
	  return os;
	}
	
	double mass(FourVector &fv) {
	  double m = fv.t * fv.t - fv.x * fv.x - fv.y * fv.y - fv.z * fv.z;
	  return m >= 0 ? std::sqrt(m) : -std::sqrt(-m);
	}
	
	double scalar_product(const FourVector &fv1, const FourVector &fv2) {
	  return fv1.t * fv2.t - fv1.x * fv2.x - fv1.y * fv2.y - fv1.z * fv2.z;
	}
4db331a54ec6239da89957d3f4ae3c52|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|4|1|v|cpp
	FourVector
6b7a83a3b3223fdd1bf4c6c941676b8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|18|27|v|cpp
	FourMomentum 
e81b80bf51f707b2ea163280900ebe1f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|5|1|V|cpp
	FourMomentum operator+(const FourMomentum &fv1, const FourMomentum &fv2) {
	  return FourMomentum{fv1.e + fv2.e, fv1.px + fv2.px, fv1.py + fv2.py,
	                      fv1.pz + fv2.pz};
	}
	
	FourMomentum operator-(const FourMomentum &fv1, const FourMomentum &fv2) {
	  return FourMomentum{fv1.e - fv2.e, fv1.px - fv2.px, fv1.py - fv2.py,
	                      fv1.pz - fv2.pz};
	}
9ec875e28abbd9224aa5fed276fc9691|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|5|61|v|cpp
	, const FourMomentum &fv2
51915faa2e3dc87774c6e2f879a2b5c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|10|61|v|cpp
	, const FourMomentum &fv2) {
644eb34d1c178ad2b85cff950b3ef5ee|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/four_momentum.cpp|29|1|V|cpp
	  return fv1.e * fv2.e - fv1.px * fv2.px - fv1.py * fv2.py - fv1.pz * fv2.pz;
c6523157bad09a24df32d3852fdd6b1a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|7|1|V|cpp
	  FourMomentum fv1{1.0, 1.0, 1.0, 1.0};
d5844189a377d73b347c3520fab521dc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|8|1|V|cpp
	  FourMomentum fv2{1.0, 1.0, 1.0, 1.0};
38802c035f8aec4b55cc5ee6cc0382df|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|9|19|v|cpp
	{1.0, 1.0, 1.0, 1.0};
a66a7134b8a506deb1cd9dd0014ca722|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|46|1|V|cpp
	struct PhaseSpaceEvent {
	  std::vector<FourVector> momenta;
	  double weight;
	};
	
	class PhaseSpaceGenerator {
	protected:
	  const size_t phase_space_dim;
	  /* mutex lock for locking access to m_events */
	  std::mutex m_mtx;
	
	  /* common weight factor to all events */
	  double m_base_weight{};
	
	  /* private storage container for the events produced by generate_events */
	  std::vector<PhaseSpaceEvent> m_events;
	
	  /**
	   * Uniform random number generator that is thread-safe.
	   * @return random number between (0,1)
	   */
	  static double phase_space_uniform_rand() {
	    static thread_local std::random_device rd{};
	    static thread_local std::mt19937 generator{rd()};
	    std::uniform_real_distribution<double> distribution(0.0, 1.0);
	    return distribution(generator);
	  }
	
	public:
	  std::vector<double> isp_masses{};
	  std::vector<double> fsp_masses{};
	  double cme{};
	  std::function<double(const std::vector<FourVector> &)> mat_squared;
	
	  // Full constructor
	  PhaseSpaceGenerator(
	      std::vector<double> isp_masses, std::vector<double> fsp_masses,
	      double cme,
	      std::function<double(const std::vector<FourVector> &mat_squared)>
	          mat_squared)
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme), mat_squared(std::move(mat_squared)) {}
	
	  // Constructor assuming constant matrix element
	  PhaseSpaceGenerator(std::vector<double> isp_masses,
	                      std::vector<double> fsp_masses, double cme)
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme),
	        mat_squared([](const std::vector<FourVector> &) { return 1.0; }) {}
	
	  virtual ~PhaseSpaceGenerator() = default;
	
	  /**
	   * Generate several events.
	   * @return Vector of PhaseSpaceEvent's containing four-momenta and weight.
	   */
	  virtual std::vector<PhaseSpaceEvent> generate_events(size_t num_events) = 0;
	
	  std::pair<double, double> compute_width_cross_section(size_t num_events);
	};
f5db5ed5fce7de26d7b86350aee01e55|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|162|1|V|cpp
	class Rambo : public PhaseSpaceGenerator {
	private:
	  double compute_scale_factor(std::vector<FourVector> &);
	
	  void initialize_four_momenta(std::vector<FourVector> &);
	
	  void boost_four_momenta(std::vector<FourVector> &);
	
	  double correct_masses(std::vector<FourVector> &);
	
	  PhaseSpaceEvent internal_generate_event();
	
	  void internal_generate_events(std::size_t);
	
	public:
	  Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses,
	        double cme)
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme) {}
	
	  Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses,
	        double cme,
	        std::function<double(const std::vector<FourVector> &)> t_mat_squared)
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme,
	                            std::move(t_mat_squared)) {}
	
	  PhaseSpaceEvent generate_event();
	
	  std::vector<PhaseSpaceEvent> generate_events(std::size_t) override;
	};
7b4088990f67a8e8d329fffdefc31255|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|192|1|V|cpp
	/* Function for finding the scaling parameter to turn mass-less four-vectors
	 * into four-vectors with the correct masses.
	 * @param momenta 4-momenta of final-state particles
	 */
	double Rambo::compute_scale_factor(std::vector<FourVector> &momenta) {
	  static thread_local const int MAX_ITER = 50;
	  static thread_local const double TOL = 1e-4;
	
	  double mass_sum = std::accumulate(fsp_masses.begin(), fsp_masses.end(), 0.0);
	
	  double xi = sqrt(1.0 - (mass_sum / cme) * (mass_sum / cme));
	
	  int iter_count = 0;
	  bool converged = false;
	  do { // Perform newton iterations to solve for xi
	    double f = -cme;
	    double df = 0.0;
	
	    for (size_t i = 0; i < fsp_masses.size(); i++) {
	      // Compute residual and derivative of residual
	      double m2 = fsp_masses[i] * fsp_masses[i];
	      double xi2 = xi * xi;
	      double e2 = momenta[i].t * momenta[i].t;
	      double del_f = sqrt(m2 + xi2 * e2);
	      f += del_f;
	      df += xi * e2 / del_f;
	    }
	
	    // Newton correction
	    double delta_xi = -(f / df);
	    xi += delta_xi;
	
	    iter_count++;
	    if (fabs(delta_xi) < TOL || iter_count >= MAX_ITER) {
	      converged = true;
	    }
	  } while (!converged);
	  return xi;
	}
	
	/**
	 * Initialize the four-momenta with isotropic, random four-momenta with
	 * energies, q, distributed according to q * exp(-q).
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::initialize_four_momenta(std::vector<FourVector> &momenta) {
	
	  std::uniform_real_distribution<double> distribution(0.0, 1.0);
	
	  for (size_t i = 0; i < fsp_masses.size(); i++) {
	    double rho1 = phase_space_uniform_rand();
	    double rho2 = phase_space_uniform_rand();
	    double rho3 = phase_space_uniform_rand();
	    double rho4 = phase_space_uniform_rand();
	
	    double c = 2.0 * rho1 - 1.0;
	    double phi = 2.0 * M_PI * rho2;
	
	    momenta[i].t = -log(rho3 * rho4);
	    momenta[i].x = momenta[i].t * sqrt(1.0 - c * c) * cos(phi);
	    momenta[i].y = momenta[i].t * sqrt(1.0 - c * c) * sin(phi);
	    momenta[i].z = momenta[i].t * c;
	  }
	}
	
	/**
	 * Boost the four-momenta into the center-of-mass frame and compute the
	 * initial weight of the event.
	 * @param momenta 4-momenta of final-state particles
	 */
	void Rambo::boost_four_momenta(std::vector<FourVector> &momenta) {
	  // Total momentum and its mass
	  FourVector Q = std::accumulate(momenta.begin(), momenta.end(), FourVector{});
	  double massQ = mass(Q);
	
	  // Boost three-vector
	  double bx = -Q.x / massQ;
	  double by = -Q.y / massQ;
	  double bz = -Q.z / massQ;
	  // Boost factors
	  double x = cme / massQ;
	  double gamma = Q.t / massQ;
	  double a = 1.0 / (1.0 + gamma);
	
	  for (size_t i = 0; i < fsp_masses.size(); i++) {
	    double qe = momenta[i].t;
	    double qx = momenta[i].x;
	    double qy = momenta[i].y;
	    double qz = momenta[i].z;
	
	    double b_dot_q = bx * qx + by * qy + bz * qz;
	
	    momenta[i].t = x * (gamma * qe + b_dot_q);
	    momenta[i].x = x * (qx + bx * qe + a * b_dot_q * bx);
	    momenta[i].y = x * (qy + by * qe + a * b_dot_q * by);
	    momenta[i].z = x * (qz + bz * qe + a * b_dot_q * bz);
	  }
	}
	
	/**
	 * Correct the masses of the four-momenta and correct the weight of the
	 * event.
	 * @param momenta 4-momenta of final-state particles
	 * @return new event weight factor
	 */
	double Rambo::correct_masses(std::vector<FourVector> &momenta) {
	  double xi = compute_scale_factor(momenta);
	
	  double term1 = 0.0;
	  double term2 = 0.0;
	  double term3 = 1.0;
	
	  for (size_t i = 0; i < fsp_masses.size(); i++) {
	    double m = fsp_masses[i];
	    double eng = momenta[i].t;
	    momenta[i].t = sqrt(m * m + (xi * eng) * (xi * eng));
	    momenta[i].x *= xi;
	    momenta[i].y *= xi;
	    momenta[i].z *= xi;
	
	    double mod =
	        sqrt(momenta[i].x * momenta[i].x + momenta[i].y * momenta[i].y +
	             momenta[i].z * momenta[i].z);
	    eng = momenta[i].t;
	
	    term1 += mod / cme;
	    term2 += mod * mod / eng;
	    term3 *= mod / eng;
	  }
	
	  term1 = pow(term1, 2.0 * fsp_masses.size() - 3.0);
	  term2 = 1.0 / term2;
	
	  // re-weight
	  return term1 * term2 * term3 * cme;
	}
	
	/**
	 * generate single phase space event
	 * @return event
	 */
	PhaseSpaceEvent Rambo::internal_generate_event() {
	  std::vector<FourVector> momenta(fsp_masses.size(), FourVector{});
	  double weight;
	
	  initialize_four_momenta(momenta);
	  boost_four_momenta(momenta);
	  weight = correct_masses(momenta) * mat_squared(momenta) * m_base_weight;
	
	  return PhaseSpaceEvent{momenta, weight};
	}
	
	/**
	 * Generate many phase space events.
	 * @param num_points
	 * @return vector of events
	 */
	void Rambo::internal_generate_events(size_t num_points) {
	  std::vector<PhaseSpaceEvent> local_events;
	  local_events.reserve(num_points);
	
	  for (size_t n = 0; n < num_points; n++)
	    local_events.emplace_back(internal_generate_event());
	
	  {
	    // Add events to class level event array. Avoid data races by lock guard.
	    std::lock_guard<std::mutex> lck(m_mtx);
	    for (auto &event : local_events)
	      m_events.emplace_back(event);
	  }
	}
	
	/**
	 * Generate a set of Rambo event.
	 * @return RamboEvent.
	 */
	PhaseSpaceEvent Rambo::generate_event() {
	  auto num_fsp_d = (double)fsp_masses.size();
	  m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) *
	                  pow(cme, 2.0 * num_fsp_d - 4.0) / tgamma(num_fsp_d) /
	                  tgamma(num_fsp_d - 1.0) *
	                  pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	  return internal_generate_event();
	}
	
	/**
	 * Generate a set of Rambo events.
	 * @param num_events number of events to generate.
	 * @return nothing; events stored in 'events'.
	 */
	std::vector<PhaseSpaceEvent> Rambo::generate_events(size_t num_events) {
	  auto num_fsp_d = (double)fsp_masses.size();
	  m_base_weight = pow(M_PI / 2.0, num_fsp_d - 1.0) *
	                  pow(cme, 2.0 * num_fsp_d - 4.0) / tgamma(num_fsp_d) /
	                  tgamma(num_fsp_d - 1.0) *
	                  pow(2.0 * M_PI, 4.0 - 3.0 * num_fsp_d);
	
	  m_events.clear();
	  size_t num_threads = std::thread::hardware_concurrency();
	  std::vector<std::thread> threads;
	
	  for (size_t n = 0; n < num_threads - 1; n++) {
	    threads.emplace_back(
	        [this](size_t num_points) {
	          this->internal_generate_events(num_points);
	        },
	        num_events / num_threads);
	  }
	  // add the remainder of points into last thread
	  threads.emplace_back(
	      [this](size_t num_points) { this->internal_generate_events(num_points); },
	      num_events / num_threads + (num_events % num_threads));
	  for (auto &thread : threads) {
	    thread.join();
	  }
	
	  return m_events;
	}
c2b4b77e635f852574596a74230376e5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|10|1|V|cpp
	#include <thread>
8e63b1cb922c253b5cdb2787a2e68fe5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/rambo.cpp|3|1|V|cpp
	#include <mutex>
	#include <random>
	#include <thread>
5891cd69b25b8efd23a62a0d81b4ac8f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/rambo.hpp|7|1|V|cpp
	#include <functional>
	#include <mutex>
	#include <random>
	#include <thread>
30789f84cbe4131642d7cf3df033f354|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_phase_space.cpp|45|1|V|cpp
	TEST(TestRambo, TestMomentumConservationAndMasses) {
	  std::vector<double> isp_masses = {1.0, 2.0};
	  std::vector<double> fsp_masses = {3.0, 4.0};
	  double cme = 10.0;
	
	  Rambo rambo{isp_masses, fsp_masses, cme};
	  auto events = rambo.generate_events(100);
	
	  for (auto &event : events) {
	    FourVector sum = event.momenta[0] + event.momenta[1];
	    ASSERT_NEAR(sum.t, cme, 1e-3);
	    ASSERT_NEAR(sum.x, 0.0, 1e-3);
	    ASSERT_NEAR(sum.y, 0.0, 1e-3);
	    ASSERT_NEAR(sum.z, 0.0, 1e-3);
	
	    ASSERT_NEAR(mass(event.momenta[0]), fsp_masses[0], 1e-3);
	    ASSERT_NEAR(mass(event.momenta[1]), fsp_masses[1], 1e-3);
	  }
	}
412c6adb1020e3116473312ca456a5aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|12|1|V|cpp
	Test(TestRambo, TestM
75e9f3c18ed8ef1dcbad0a6511324900|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|1|1|V|cpp
	#include "darksun/phase_space/rambo.hpp"
59931dbc55de73dc815ac4a0170e5443|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space.hpp|2|31|v|cpp
	rambo
9645cc93905be7702cd18d76611346eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|1|30|v|cpp
	/four_momentum.hpp>
31e04414d8f9e2b4c5d39df35ee92f21|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|27|17|v|cpp
	mass(
6f1b8d3d885cd0b2c229def75d4b2fcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/rambo.hpp|28|1|V|cpp
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme) {}
4c66c7f01473db37d0e59567fbc83a61|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/rambo.hpp|26|1|V|cpp
	  Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses,
	        double cme)
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme) {}
	
	  Rambo(std::vector<double> &isp_masses, std::vector<double> &fsp_masses,
	        double cme,
	        std::function<double(const std::vector<FourMomentum> &)> t_mat_squared)
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme,
	                            std::move(t_mat_squared)) {}
	
4180de1bb8d6bd6ee529036b86a77ba8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/rambo.hpp|32|7|V|cpp
	      : PhaseSpaceGenerator(isp_masses, fsp_masses, cme,
1333f836ce8a908bc3e63a340780a39e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/rambo.hpp|32|29|V|cpp
	                            std::move(t_mat_squared)) {}
8571d525b853ca366572bb4d3d04ce51|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|47|1|V|cpp
	  // Full constructor
	  PhaseSpaceGenerator(
	      std::vector<double> isp_masses, std::vector<double> fsp_masses,
	      double cme,
	      std::function<double(const std::vector<FourMomentum> &mat_squared)>
	          mat_squared)
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme), mat_squared(std::move(mat_squared)) {}
	
	  // Constructor assuming constant matrix element
	  PhaseSpaceGenerator(std::vector<double> isp_masses,
	                      std::vector<double> fsp_masses, double cme)
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme),
	        mat_squared([](const std::vector<FourMomentum> &) { return 1.0; }) {}
edb6e06bc93cd4419dc3dde0940ce752|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/base.cpp|8|1|V|cpp
	  PhaseSpaceGenerator(
f7b35bf1de9feb1ac3b7dbcb6931d1ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/phase_space/base.cpp|8|1|V|cpp
	  PhaseSpaceGenerator::
d6d85b88ce4a27354bdb4c800c7b8d1f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|53|1|V|cpp
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme), mat_squared(std::move(mat_squared)) {}
4975c937087617639df48158ea05dca8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|57|1|V|cpp
	      : phase_space_dim(3 * fsp_masses.size() - 4),
	        isp_masses(std::move(isp_masses)), fsp_masses(std::move(fsp_masses)),
	        cme(cme),
	        mat_squared([](const std::vector<FourMomentum> &) { return 1.0; }) {}
97761783eb21315f0c628353c4606c97|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|56|43|v|cpp
	fsp_masses
6be0fc883fcd93d0e6626af1f98fa124|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|55|43|v|cpp
	isp_masses
e66f6cc2c0c7170dc0ad7a6196f50cf8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/base.hpp|51|61|v|cpp
	mat_squared
72f4f03b1bf237051a8aa8f346a134ff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|1|1|V|cpp
	#include <darksun/phase_space.hpp>
0784b865ca74d7d4f2ea1cd70a263dca|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_phase_space.cpp|6|1|v|cpp
	static constexpr double kG_FERMI = 1.1663787e-5;
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTOP_QUARK_MASS = 172.9;
	static constexpr double kHIGGS_MASS = 125.10;
	static constexpr double kALPHA_EM = 1.0 / 137.0; // at p^2 = 0
	static constexpr double kSIN_THETA_WEAK = 0.480853;
	static constexpr double kW_BOSON_MASS = 80.379;
3c46330ecb57cee3c81fe60d0ed82733|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_phase_space.cpp|15|1|V|cpp
	double mat_squared_mu_to_e_nu_nu(const std::vector<FourVector> &momenta) {
	  double s = scalar_product(momenta[1] + momenta[2], momenta[1] + momenta[2]);
	  double t = scalar_product(momenta[0] + momenta[2], momenta[0] + momenta[2]);
	  return -16 * kG_FERMI * kG_FERMI * (s + t) *
	         (s + t - kMUON_MASS * kMUON_MASS);
	}
ca6165bff4de00680698c4f658904b21|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_phase_space.cpp|112|1|V|cpp
	TEST(TestRambo, TestMuonDecay) {
	
	  std::vector<double> isp_masses = {kMUON_MASS};
	  std::vector<double> fsp_masses = {kELECTRON_MASS, 0.0, 0.0};
	  Rambo rambo{isp_masses, fsp_masses, kMUON_MASS, mat_squared_mu_to_e_nu_nu};
	
	  double width =
	      (pow(kG_FERMI, 2) * pow(kMUON_MASS, 5)) / (192.0 * pow(M_PI, 3));
	
	  auto res = rambo.compute_width_cross_section(100000);
	  std::cout << "avg = " << std::get<0>(res) << " +- " << std::get<1>(res)
	            << std::endl;
	  std::cout << "actual = " << width << std::endl;
	
	  ASSERT_NEAR(std::get<0>(res), width, 3.0 * std::get<1>(res));
	}
483d76aeb9803717d75692335b522b9e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|44|1|v|cpp
	double mat_squared_mu_to_e_nu_nu
23372e42873b3381e11616b7dd2ee486|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|55|50|v|cpp
	mat_squared_mu_to_e_nu_nu
839c388999cca13b9382c41db9e36f09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|38|1|V|cpp
	  static constexpr double kTOP_QUARK_MASS = 172.9;
	  static constexpr double kHIGGS_MASS = 125.10;
	  static constexpr double kALPHA_EM = 1.0 / 137.0; // at p^2 = 0
	  static constexpr double kSIN_THETA_WEAK = 0.480853;
	  static constexpr double kW_BOSON_MASS = 80.379;
1cfe664cd5a42870d3cd11c330c9a804|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_phase_space.cpp|39|16|v|cpp
	0.0; // 
8e7907b1c105ffd1a7b0e67e529cddbf|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/phase_space.hpp|23|1|V|cpp
	FourVector operator+(const FourVector &fv1, const FourVector &fv2) {
	  return FourVector{fv1.t + fv2.t, fv1.x + fv2.x, fv1.y + fv2.y, fv1.z + fv2.z};
	}
	
	FourVector operator-(const FourVector &fv1, const FourVector &fv2) {
	  return FourVector{fv1.t - fv2.t, fv1.x - fv2.x, fv1.y - fv2.y, fv1.z - fv2.z};
	}
2c8f1f4ba76bc94405cb9263cd032e78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_momentum.hpp|23|2|V|cpp
	  return FourMomentum{fv1.t + fv2.t, fv1.x + fv2.x, fv1.y + fv2.y, fv1.z + fv2.z};
e80d6c30109e8df88a6727aeeddf71ee|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_momentum.hpp|25|3|V|cpp
	  return FourMomentum{fv1.t - fv2.t, fv1.x - fv2.x, fv1.y - fv2.y, fv1.z - fv2.z};
9127da41bef6ee4325f8b4c0b26e1d91|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_momentum.hpp|24|1|V|cpp
	FourMomentum operator+(const FourMomentum &, const FourMomentum &);
	FourMomentum operator-(const FourMomentum &, const FourMomentum &);
0644f1b3f5e3b3ec034eafda917e4943|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/diffeq/vector_matrix.hpp|8|1|V|cpp
	template <class Type, int n = Eigen::Dynamic>
	using Vector = Eigen::Matrix<Type, n, 1>;
	
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Matrix = Eigen::Matrix<Type, n, m>;
	
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Array = Eigen::Array<Type, n, m>;
7b31c3242298f030f7ad7960bbaf2561|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/vector.hpp|8|1|V|cpp
	template <
0fcbfe3101413d60d042679d77df8edf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|8|1|V|cpp
	template <int N, int M> int dec(Matrix<double, N, M> &, Vector<int, M> &);
a2510650a36556e13b52598aa05b8912|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|8|1|V|cpp
	template <int N, int M> int dec(Matrix<double, N, M> &, Vector<int, M> &);
	
	template <int N, int M>
	void sol(Matrix<double, N, M> &, Vector<double, M> &, Vector<int, M> &);
4c61709ba10eb4a6670099b9a43dbea7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|13|1|V|cpp
	template <int N, int M> int dech(Matrix<double, N, M> &, int, Vector<int, M> &);
	
	template <int N, int M>
	void solh(Matrix<double, N, M> &, int, Vector<double, M> &, Vector<int, M> &);
dcee59ef166c0dbc10018bed78eda895|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|4|1|V|cpp
	#include "darksun/vector.hpp"
	
	namespace darksun {
	
	template <int N, int M> int dec(Matrix<double, N, M> &, Vector<int, M> &);
	
	template <int N, int M>
	void sol(Matrix<double, N, M> &, Vector<double, M> &, Vector<int, M> &);
	
	} // namespace darksun
24af0808d2a5738cec93b64a919bdb7a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|43|1|V|cmake
	# --------------------------------------------------------------------------
	# test_phase_space.cpp: Check phase space Monte Carlo
	# --------------------------------------------------------------------------
	
	add_executable(test_phase_space test_phase_space.cpp)
	set_property(TARGET test_phase_space PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_phase_space PUBLIC
	        darksun
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	 set_target_properties(test_phase_space PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
e802e2df0797cac18da7e899a3bffe5c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|62|20|v|cmake
	Check phase space Monte Carlo
28314dad744d65bd56c2e98db3c15285|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_decsol.cpp|7|1|V|cpp
	Test(TestDecSol, TestReal) {}
e3f2dceb6b03a1840f4eba5336966f52|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|48|1|V|cmake
	set_property(TARGET test_phase_space PROPERTY CXX_STANDARD 17)
	target_link_libraries(test_phase_space PUBLIC
	        darksun
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
a2d9e3b7a6b23728f5dfd49acc6e192b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|20|1|V|cmake
	target_link_libraries(darksun PUBLIC
638ee9599982d9d25dfdb0d733929705|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|22|9|V|cmake
	        darksun
46136813a2bd8c274fdaa40cdb5e93bd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|22|2|V|cmake
		fmt::fmt
2454cbf518d906dda61802802fdf32b7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|40|21|v|cmake
	${Boost_INCLUDE_DIRS}
973502a2b1dd7ec0449f3d84aad0c170|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|55|1|V|cmake
	        Eigen3::Eigen
5baf8cfb60e9c8284601ad0060b6201d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|24|9|v|cmake
	gtest_main
3afdec3c0d0c08d5f41677479d665696|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|17|51|v|cmake
	"/usr/local/include/eigen3"
8f59003c96f96244eae0e9bb6f649ff5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|17|51|v|cmake
	${Eigen3_INCLUDE_DIRS}
078d8dba3afa028ecaf990e043e34ef6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|40|42|v|cmake
	 "/usr/local/include/eigen3"
a20bedfcfce221cf3577af204176d1c2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|23|9|V|cmake
	        ${Boost_LIBRARIES})
84c6d22cfdf3772e66b07bde636e0571|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|21|31|v|cmake
	PRIVATE
4d310ca0b42a643da3a49572e6860c57|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|21|31|v|cmake
	PUBLIC 
bad979a1fc86bd0201dd0fe879387c8e|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|14|1|V|cmake
	#set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
a14b7337979eaf5c5630e7596452dbd6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|40|1|V|cmake
	include_directories(${Boost_INCLUDE_DIRS} ../include)
8d8a82ab2fbd820ec5a78f1f2205de6e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|35|1|V|cmake
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	find_package(Eigen3 REQUIRED)
	find_package(fmt REQUIRED)
6b4005480dd46eba6a34cb49c39e0795|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|59|1|V|cmake
	set_property(TARGET test_decsol PROPERTY CXX_STANDARD 17)
42987fb353124db2455e15288dbc1bfc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|41|1|V|cmake
	set_property(TARGET test_phase_space PROPERTY CXX_STANDARD 17)
0dc9c5da04f6a03a3e40061f1ab31736|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|43|1|V|cmake
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        ${Boost_LIBRARIES})
b632c9c16e71ca0404d9ababf04318f7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|42|1|V|cmake
	        darksun
		fmt::fmt
		GSL::gsl
	 	GSL::gslcblas
	        gtest_main
	        ${Boost_LIBRARIES})
e18fe873bdba2ed76124ac7ed25eec80|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|11|1|v|cpp
	template <int N, int M> 
0f5779bf19df280a40f96803f01613f3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|9|1|V|cpp
	class MyClass {};
bf417da12a4d73bbaab19a7f37a12edf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|10|22|v|cpp
	, N, M
07aa3d1c25f7d7a66156d75ef8994669|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|12|1|V|cpp
	template <int N, int M>
dafba5ee2026e4472ef2f4b6d7418dc9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|9|1|V|cpp
	int dec(Matrix<double> &, Vector<int> &);
	
	void sol(Matrix<double> &, Vector<double> &, Vector<int> &);
94af31198c211e8a9b0b28e2b19539f9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|7|1|V|cpp
	template <int N, int M> int dec(Matrix<double, N, M> &, Vector<int, M> &) {
	  return 0;
	}
	
	template <int N, int M>
	void sol(Matrix<double, N, M> &, Vector<double, M> &, Vector<int, M> &) {}
dca63093e06721c290d36c3b23ffbec8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|9|1|V|cpp
	  class MyClass{
	  };
61757b55f3fd37cab97c8245b4e3b90e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|4|1|V|cpp
	#include "darksun/vector.hpp"
	#include <Eigen/Dense>
	
	namespace darksun {
	
	int dec(Matrix<double> &, Vector<int> &);
	
	void sol(Matrix<double> &, Vector<double> &, Vector<int> &);
	
	} // namespace darksun
daacbbcbad8cd87985e7893b7f79b6cb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|27|1|V|fortran
	   ier = 0
	   ip(n) = 1
	   if (n == 1) go to 70
	   nm1 = n - 1
	   do k = 1, nm1
	      kp1 = k + 1
	      m = k
	      do i = kp1, n
	         if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	      end do
	      ip(k) = m
	      t = a(m, k)
	      if (m == k) go to 20
	      ip(n) = -ip(n)
	      a(m, k) = a(k, k)
	      a(k, k) = t
	20    continue
	      if (t == 0.d0) go to 80
	      t = 1.d0/t
	      do i = kp1, n
	         a(i, k) = -a(i, k)*t
	      end do
	      do j = kp1, n
	         t = a(m, j)
	         a(m, j) = a(k, j)
	         a(k, j) = t
	         if (t == 0.d0) go to 45
	         do i = kp1, n
	            a(i, j) = a(i, j) + a(i, k)*t
	         end do
	45       continue
	      end do
	   end do
	70 continue
	   k = n
	   if (a(n, n) == 0.d0) go to 80
	   return
	80 continue
	   ier = k
	   ip(n) = 0
	   return
dc24ce92e46a8300c1cee37d7cd11470|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|19|10|V|cpp
	         {r
c238516d74a31f13be86f2d7458b5086|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|39|10|V|cpp
	         end do
b732b46df513d0ee9804ad726c8fae96|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|42|4|V|cpp
	   end do
e56753c58ab014822e6ca8bf0ca81cdd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|13|5|V|cpp
	    go to 70;
10f9e4b5c1c965704ee1a6933b1ab0c8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|25|9|V|cpp
	        go to 20;
fac196bd76a3babef9aea0a0d4de9d4a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|29|7|V|cpp
	      20 continue;
6e5e172992e16a45cfddf395eaa86397|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|30|9|V|cpp
	        //go to 80;
c5f49e9b9799f0ce6c9de0a063fb9058|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|43|11|V|cpp
	          go to 45;
70ad3bea008eb4da9a8245c7b6f44f1d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|48|9|V|cpp
	        45 continue;
0b98f227f5fd7b77ec1ea43c52359750|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|51|3|V|cpp
	  70 continue;
96e9aa195757db2a4ac06c2e24be9ed5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|56|3|V|cpp
	  return ier;
938feed820c4fd4a8b8cee79f55b636e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|54|1|V|cpp
	    go to 80;
29db098fd84dc259f972be18864ff273|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|56|3|v|cpp
	80 continue 
0ee4d5a41eaa9a2553007229fa33e1ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|11|1|V|cpp
	  int ier = 0;
	  ip(n) = 1;
	  if (n != 1) {
	    int nm1 = n - 1;
	    for (k = 1; k <= nm1; k++) {
	      int kp1 = k + 1;
	      int m = k;
	      for (int i = kp1; i <= n; i++) {
	        if (fabs(a(i, k)) > fabs(a(m, k))) {
	          m = i;
	        }
	      }
	      ip(k) = m;
	      double t = a(m, k);
	      if (m != k) {
	        ip(n) = -ip(n);
	        a(m, k) = a(k, k);
	        a(k, k) = t;
	      }
	      if (t == 0.0) {
	        ier = k;
	        ip(n) = 0;
	        return ier;
	      }
	      t = 1.0 / t;
	      for (int i = kp1; i <= n; i++) {
	        a(i, k) = -a(i, k) * t;
	      }
	      for (int j = kp1; j <= n; j++) {
	        t = a(m, j);
	        a(m, j) = a(k, j);
	        a(k, j) = t;
	        if (t == 0.0) {
	          continue;
	        }
	        for (int i = kp1; i <= n; i++) {
	          a(i, j) = a(i, j) + a(i, k) * t;
	        }
	      }
	    }
	  }
	  k = n;
	  if (a(n, n) != 0.0) {
	    return ier;
	  }
	  ier = k;
	  ip(n) = 0;
	  return ier;
4f84c780fd0b47d9acee6a3bcbf71ca1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|43|9|v|cpp
	d do
4232cfb6b060681c64281a05c0ffa69d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|47|5|v|cpp
	 continue
cab7c3b969f801b29b7618d4d71aaac4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|9|1|V|cpp
	int dec(Matrix<double> &, Vector<int> &);
14151200619084d59d9305742fb0e66a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|10|10|v|cpp
	Matrix<double> &
e8082a1a7e8b1a65c9d3abac74fb99ea|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|12|1|V|cpp
	void sol(Matrix<double> &, Vector<double> &, Vector<int> &);
b63b786faaf52561b6413d3b7d3868a3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|13|47|v|cpp
	Vector<double> &,
a86e25e6ed95cdedde6f4bddea5fd8f9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|7|1|V|cpp
	int dec(Matrix<double> &a, Vector<int> &ip) {
ccf7ee0c21fc86b1ba7cf555bee39634|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|63|10|v|cpp
	Matrix<double> &a,
492ad182b1f2726026b42b387d1a0cc5|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|264|1|V|fortran
	   ier = 0
	   ip(n) = 1
	   if (n == 1) go to 70
	   nm1 = n - 1
	   do k = 1, nm1
	      kp1 = k + 1
	      m = k
	      do i = kp1, n
	         if (dabs(ar(i, k)) + dabs(ai(i, k)) > &
	             dabs(ar(m, k)) + dabs(ai(m, k))) m = i
	      end do
	      ip(k) = m
	      tr = ar(m, k)
	      ti = ai(m, k)
	      if (m == k) go to 20
	      ip(n) = -ip(n)
	      ar(m, k) = ar(k, k)
	      ai(m, k) = ai(k, k)
	      ar(k, k) = tr
	      ai(k, k) = ti
	20    continue
	      if (dabs(tr) + dabs(ti) == 0.d0) go to 80
	      den = tr*tr + ti*ti
	      tr = tr/den
	      ti = -ti/den
	      do i = kp1, n
	         prodr = ar(i, k)*tr - ai(i, k)*ti
	         prodi = ai(i, k)*tr + ar(i, k)*ti
	         ar(i, k) = -prodr
	         ai(i, k) = -prodi
	      end do
	      do j = kp1, n
	         tr = ar(m, j)
	         ti = ai(m, j)
	         ar(m, j) = ar(k, j)
	         ai(m, j) = ai(k, j)
	         ar(k, j) = tr
	         ai(k, j) = ti
	         if (dabs(tr) + dabs(ti) == 0.d0) go to 48
	         if (ti == 0.d0) then
	            do i = kp1, n
	               prodr = ar(i, k)*tr
	               prodi = ai(i, k)*tr
	               ar(i, j) = ar(i, j) + prodr
	               ai(i, j) = ai(i, j) + prodi
	            end do
	            go to 48
	         end if
	         if (tr == 0.d0) then
	            do i = kp1, n
	               prodr = -ai(i, k)*ti
	               prodi = ar(i, k)*ti
	               ar(i, j) = ar(i, j) + prodr
	               ai(i, j) = ai(i, j) + prodi
	            end do
	            go to 48
	         end if
	         do i = kp1, n
	            prodr = ar(i, k)*tr - ai(i, k)*ti
	            prodi = ai(i, k)*tr + ar(i, k)*ti
	            ar(i, j) = ar(i, j) + prodr
	            ai(i, j) = ai(i, j) + prodi
	         end do
	48       continue
	      end do
	   end do
	70 k = n
	   if (dabs(ar(n, n)) + dabs(ai(n, n)) == 0.d0) go to 80
	   return
	80 ier = k
	   ip(n) = 0
	   return
2f90e74585462c85c72208ae64fddeed|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|89|6|v|cpp
	   continue
7f4d9771dc2c2133eaaea4f60978e12d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|89|1|V|fortran
	   if (n == 1) go to 50
	   nm1 = n - 1
	   do k = 1, nm1
	      kp1 = k + 1
	      m = ip(k)
	      t = b(m)
	      b(m) = b(k)
	      b(k) = t
	      do i = kp1, n
	         b(i) = b(i) + a(i, k)*t
	      end do
	   end do
	   do kb = 1, nm1
	      km1 = n - kb
	      k = km1 + 1
	      b(k) = b(k)/a(k, k)
	      t = -b(k)
	      do i = 1, km1
	         b(i) = b(i) + a(i, k)*t
	      end do
	   end do
	50 b(1) = b(1)/a(1, 1)
	   return
7f4d9771dc2c2133eaaea4f60978e12d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|89|1|V|fortran
	   if (n == 1) go to 50
	   nm1 = n - 1
	   do k = 1, nm1
	      kp1 = k + 1
	      m = ip(k)
	      t = b(m)
	      b(m) = b(k)
	      b(k) = t
	      do i = kp1, n
	         b(i) = b(i) + a(i, k)*t
	      end do
	   end do
	   do kb = 1, nm1
	      km1 = n - kb
	      k = km1 + 1
	      b(k) = b(k)/a(k, k)
	      t = -b(k)
	      do i = 1, km1
	         b(i) = b(i) + a(i, k)*t
	      end do
	   end do
	50 b(1) = b(1)/a(1, 1)
	   return
3950ed8439938eff785e2f3378a9892e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|177|4|V|cpp
	   return;
d3ec45f5fa28fd3198c6df3d438e18e6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/decsol.f90|357|1|V|fortran
	   if (n == 1) go to 50
	   nm1 = n - 1
	   do k = 1, nm1
	      kp1 = k + 1
	      m = ip(k)
	      tr = br(m)
	      ti = bi(m)
	      br(m) = br(k)
	      bi(m) = bi(k)
	      br(k) = tr
	      bi(k) = ti
	      do i = kp1, n
	         prodr = ar(i, k)*tr - ai(i, k)*ti
	         prodi = ai(i, k)*tr + ar(i, k)*ti
	         br(i) = br(i) + prodr
	         bi(i) = bi(i) + prodi
	      end do
	   end do
	   do kb = 1, nm1
	      km1 = n - kb
	      k = km1 + 1
	      den = ar(k, k)*ar(k, k) + ai(k, k)*ai(k, k)
	      prodr = br(k)*ar(k, k) + bi(k)*ai(k, k)
	      prodi = bi(k)*ar(k, k) - br(k)*ai(k, k)
	      br(k) = prodr/den
	      bi(k) = prodi/den
	      tr = -br(k)
	      ti = -bi(k)
	      do i = 1, km1
	         prodr = ar(i, k)*tr - ai(i, k)*ti
	         prodi = ai(i, k)*tr + ar(i, k)*ti
	         br(i) = br(i) + prodr
	         bi(i) = bi(i) + prodi
	      end do
	   end do
	50 continue
	   den = ar(1, 1)*ar(1, 1) + ai(1, 1)*ai(1, 1)
	   prodr = br(1)*ar(1, 1) + bi(1)*ai(1, 1)
	   prodi = bi(1)*ar(1, 1) - br(1)*ai(1, 1)
	   br(1) = prodr/den
	   bi(1) = prodi/den
	   return
8dc955e54f37130894839cf9983e7bcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|150|1|V|cpp
	void sol(const Matrix<double> &a, Vector<double> &b, const Vector<int> &ip) {
17511e14372f6ff2e2e8487d289b91f9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|181|1|V|cpp
	void solc(){
123b8ab334dad3cc2559c6e1e27f38d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|181|11|v|cpp
	const Matrix<double> &a
cf8203125ebd37ac4f56ce872972a68e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|182|5|v|cpp
	Vector<double> &b,
599467085114b7f24b951bf4d6247855|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|226|4|V|cpp
	   return
f8b1b576d70fabc23dbeba6b09a07933|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_decsol.cpp|9|18|v|cpp
	, 4, 4
87ea20565caee58f2e8ba1ef56426ff1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|9|1|v|cpp
	typedef
8ff7d254c2d0b766b5c946dac01704c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|9|1|V|cpp
	using OdeFunc = std::function<void(double, const Vector<double>&, Vector<double>&)>;
b5a3941030b5bf1b15ac5506453ad661|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|10|1|V|cpp
	using OdeJac = std::function<void(double, const Vector<double>&, Matrix<double>&)>;
c63540048fc05e9b422b1be56858d6f7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|11|35|v|cpp
	double, const Vector<double>&, 
af9411be912d58a4e0e62b2046e2db5c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|11|1|V|cpp
	using OdeMas = std::function<void(Matrix<double>&, int)>;
a2d9ca6a4526f6039b001aebe89afc10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|12|38|v|cpp
	Matrix<double>&, int
4f2a91e15af2631ff9424564b8a45fb2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|14|16|v|cpp
	Initial
1c263437473f979545272a3f588807c3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|39|1|V|cpp
	  int nind1;
e4682e7c23c525804a340bcbd168522b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|42|1|V|cpp
	  bool startn;
985d1e01d2b86ac5530a576b3265fa0b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|54|1|V|cpp
	  double vitu; // 11
495642b6fdb396ecdb71a75c587a690d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|50|3|V|cpp
	  double quot2; // 6
8f009b6b01515adf214ff37d29cb2411|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|52|3|V|cpp
	  double facr; // 9
edc3d6fb19facb69d4711dd871c22815|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|52|1|V|cpp
	  double vitu; // order increases if contractivity factor < vitu 
108cbbf915fba2add8c3ffd2ef9ab58a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|53|1|V|cpp
	  double vitd; // 1
f47ea60127f4e934b5d921c16920d6c1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|53|25|v|cpp
	increases
4d86c5909ece65eaa4ffb8d9931b5c83|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|54|3|V|cpp
	  double hhod;         // 13
e282e5f682c08a0677e3ea3dd1d8707d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|36|3|V|cpp
	  int nmax; // 2
633aa19ab71ed820222577c80b7d8f63|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|37|3|V|cpp
	  int nit; // 3
02fcdb014f1e3a68993322655a904ad6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|38|1|V|cpp
	  int nind1; // 5
	  int nind2; // 6
	  int nind3; // 7
cf024d73c9eca2ca6adf84a707ee7f84|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|43|3|V|cpp
	  bool pred; // 8
2733a823e3f14c2bf00c8a3a580696a6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|42|1|V|cpp
	  int m1; // 9
	  int m2; // 10
558731a5ba0478fc679244ec7c22ad92|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|42|58|v|cpp
	 __|
448b8506e4050ac234400d26c259ea59|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|41|27|v|cpp
	y(i)' = y(i+m2) for i=1,...,m1 
2bcc45c8f3791c2461cd80f72988f6fa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|43|27|v|cpp
	maximal
20fc31297b8506065f20955083c273a5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|42|27|v|cpp
	y(i)' = y(i+m2) for i=1,...,m1
5211d00e530d3c3c52dfe916e60d745c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|66|1|V|cpp
	  void slvrar();
5d6a3afc46d090e756f04a52a0fa4c6b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|7|1|V|cpp
	void Radau::decomr() {
	}
e9e865d265d133ca578c84b7799a69af|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|71|1|V|cpp
	  Vector<double> alph;
	  Vector<double> beta;
8835d48973a3a7c7a2e2db73544d9ce0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|74|1|V|cpp
	  Vector<double> betan;
bc5da7ee06054c7a2a8e88c9393589d2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|75|18|v|cpp
	betan
9d60013117c249349e1d0de32928b3a9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|76|1|V|cpp
	  Vector<int> ip1;
d5c25dd74c30072b011d9a1ce95552a1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|77|1|V|cpp
	  Vector<int> ip2;
22ba57432f437bfae74831c67cae1b94|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|76|1|V|cpp
	  bool index1;
12a4a59ab6c128455a5f5ac70d78cd32|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|77|3|V|cpp
	  bool index2;
690849191be1268e37663fbc509e1358|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|77|3|V|cpp
	  bool index3;
133ddaf72d18ec5ac45027450b54d100|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|77|3|V|cpp
	  bool last;
f453ed095e9c7d0ee14fa2de86b90bcc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|75|3|V|cpp
	  bool calhes;
cd6c63c63a90969c09c1e9e54d3dc475|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|71|8|v|cpp
	implct
7154b89a96af4597061878c772ffa776|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|71|3|V|cpp
	  bool ;
bb34896a7103b724dc813583200a19b8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|94|1|V|cpp
	  Matrix<double> fjac;
efc7a76e5d8a20cec312e20f0570bcb1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|95|18|v|cpp
	fjac;
581281897dc4900085049f506c90da85|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|96|1|V|cpp
	  Matrix<double> e1;
6edb8ce5ed9030487def38b6661a7c41|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/dc_decsol.f90|19|1|V|fortran
	    do j = 1, n
	        do  i = 1, n
	            e1(i, j) = -fjac(i, j)
	        end do
	        e1(j, j) = e1(j, j) + fac1
	    end do
	    call dec (n, lde1, e1, ip1, ier)
5453aa931b0045d2b5b4aa9b7fca4c39|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|10|9|v|cpp
	do  
5fcd84cc07db42a078bf661876ed4ee7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|15|5|v|cpp
	call 
fd4f3f6d236ebd99a2e2ca8f26c87cfe|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|15|7|v|cpp
	n, lde1, 
291b2c27cc8847783a17fd052b74fc36|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/stiff/src/dc_decsol.f90|224|1|V|fortran
	    do j = 1, n
	        do i = 1, n
	            e2r(i, j) = -fjac(i, j)
	            e2i(i, j) = 0.d0
	        end do
	        e2r(j, j) = e2r(j, j) + alphn
	        e2i(j, j) = betan
	    end do
	    call decc (n, lde1, e2r, e2i, ip2, ier)
65d2f8c526d446d931be3f110ca25cf6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|7|1|V|cpp
	int Radau::decomr(Matrix<double>&e1, Matrix<double>&fjac, double fac1) {
670ed082df1cde6cec027f7db2fdf69e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|101|1|V|cpp
	  int decomr();
9459487061dc0c5f2bcf90e4877eff79|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|101|5|v|cpp
	Radau
6b80d8a99fda631280fd9cb4b8282a44|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|101|1|V|cpp
	  int decomr(Matrix<double> &, Matrix<double> &, double);
328c6f703e4de9c4122213607780201a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|7|39|v|cpp
	Matrix<double> &fjac
76b79c1833808dae57e2aee5862d2a8a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|8|1|V|cpp
	  int i, j;
	  for (j = 1; j <= n; j++) {
	    for (i = 1; i <= n; i++) {
	      e1(i, j) = -fjac(i, j);
	    }
	    e1(j, j) = e1(j, j) + fac1;
	  }
	  return dec(e1, ip1);
c30b4abf3e2e7f9bf50934f09b5064d2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decomp.cpp|13|1|V|cpp
	  int i, j;
	  for (j = 1; j <= n; j++) {
	    for (i = 1; i <= n; i++) {
	      e2r(i, j) = -fjac(i, j);
	      e2i(i, j) = 0.0;
	    }
	    e2r(j, j) = e2r(j, j) + alphn;
	    e2i(j, j) = betan;
	  }
	  return decc(e2r, e2i, ip2);
97432bc3c4c5b1439e9548b30865b0b5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|7|1|V|cpp
	int dec(Matrix<double> &a, Vector<int> &ip) {
	  int n = a.rows();
	  int ier, nm1, i, j, k, kp1, m;
	  double t;
	
	  ier = 0;
	  ip(n - 1) = 1;
	  if (n == 1)
	    goto _70;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= n; i++) {
	      if (fabs(a(i - 1, k - 1)) > fabs(a(m - 1, k - 1)))
	        m = i;
	    }
	    ip(k - 1) = m;
	    t = a(m - 1, k - 1);
	    if (m == k)
	      goto _20;
	    ip(n - 1) = -ip(n - 1);
	    a(m - 1, k - 1) = a(k - 1, k - 1);
	    a(k - 1, k - 1) = t;
	  _20:
	    if (t == 0.0)
	      goto _80;
	    t = 1.0 / t;
	    for (i = kp1; i <= n; i++) {
	      a(i - 1, k - 1) = -a(i - 1, k - 1) * t;
	    }
	    for (j = kp1; j <= n; j++) {
	      t = a(m - 1, j - 1);
	      a(m - 1, j - 1) = a(k - 1, j - 1);
	      a(k - 1, j - 1) = t;
	      if (t == 0.0)
	        goto _45;
	      for (i = kp1; i <= n; i++) {
	        a(i - 1, j - 1) = a(i - 1, j - 1) + a(i - 1, k - 1) * t;
	      }
	    _45:
	      continue;
	    }
	  }
	_70:
	  k = n;
	  if (a(n - 1, n - 1) == 0.0)
	    goto _80;
	  return ier;
	_80:
	  ier = k;
	  ip(n - 1) = 0;
	  return ier;
	}
	
	int decc(Matrix<double> &ar, Matrix<double> &ai, Vector<int> &ip) {
	  int n = ar.rows();
	  int ier, i, j, k, kp1, nm1, m;
	  double tr, ti, prodr, prodi, den;
	
	  ier = 0;
	  ip(n - 1) = 1;
	  if (n == 1)
	    goto _70;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= n; i++) {
	      if (fabs(ar(i - 1, k - 1)) + fabs(ai(i - 1, k - 1)) >
	          fabs(ar(m - 1, k - 1)) + fabs(ai(m - 1, k - 1))) {
	        m = i;
	      }
	    }
	    ip(k - 1) = m;
	    tr = ar(m - 1, k - 1);
	    ti = ai(m - 1, k - 1);
	    if (m == k)
	      goto _20;
	    ip(n - 1) = -ip(n - 1);
	    ar(m - 1, k - 1) = ar(k - 1, k - 1);
	    ai(m - 1, k - 1) = ai(k - 1, k - 1);
	    ar(k - 1, k - 1) = tr;
	    ai(k - 1, k - 1) = ti;
	  _20:
	    if (fabs(tr) + fabs(ti) == 0.0)
	      goto _80;
	    den = tr * tr + ti * ti;
	    tr = tr / den;
	    ti = -ti / den;
	    for (i = kp1; i <= n; i++) {
	      prodr = ar(i - 1, k - 1) * tr - ai(i - 1, k - 1) * ti;
	      prodi = ai(i - 1, k - 1) * tr + ar(i - 1, k - 1) * ti;
	      ar(i - 1, k - 1) = -prodr;
	      ai(i - 1, k - 1) = -prodi;
	    }
	    for (j = kp1; j <= n; j++) {
	      tr = ar(m - 1, j - 1);
	      ti = ai(m - 1, j - 1);
	      ar(m - 1, j - 1) = ar(k - 1, j - 1);
	      ai(m - 1, j - 1) = ai(k - 1, j - 1);
	      ar(k - 1, j - 1) = tr;
	      ai(k - 1, j - 1) = ti;
	      if (fabs(tr) + fabs(ti) == 0.0)
	        goto _48;
	      if (ti == 0.0) {
	        for (i = kp1; i <= n; i++) {
	          prodr = ar(i - 1, k - 1) * tr;
	          prodi = ai(i - 1, k - 1) * tr;
	          ar(i - 1, j - 1) = ar(i - 1, j - 1) + prodr;
	          ai(i - 1, j - 1) = ai(i - 1, j - 1) + prodi;
	        }
	        goto _48;
	      }
	      if (tr == 0.0) {
	        for (i = kp1; i <= n; i++) {
	          prodr = -ai(i - 1, k - 1) * ti;
	          prodi = ar(i - 1, k - 1) * ti;
	          ar(i - 1, j - 1) = ar(i - 1, j - 1) + prodr;
	          ai(i - 1, j - 1) = ai(i - 1, j - 1) + prodi;
	        }
	        goto _48;
	      }
	      for (i = kp1; i <= n; i++) {
	        prodr = ar(i - 1, k - 1) * tr - ai(i - 1, k - 1) * ti;
	        prodi = ai(i - 1, k - 1) * tr + ar(i - 1, k - 1) * ti;
	        ar(i - 1, j - 1) = ar(i - 1, j - 1) + prodr;
	        ai(i - 1, j - 1) = ai(i - 1, j - 1) + prodi;
	      }
	    _48:
	      continue;
	    }
	  }
	_70:
	  k = n;
	  if (fabs(ar(n - 1, n - 1)) + fabs(ai(n - 1, n - 1)) == 0.0)
	    goto _80;
	  return ier;
	_80:
	  ier = k;
	  ip(n - 1) = 0;
	  return ier;
	}
	
	void sol(const Matrix<double> &a, Vector<double> &b, const Vector<int> &ip) {
	  int n = a.rows();
	  int i, k, kb, nm1, kp1, km1, m;
	  double t;
	
	  if (n == 1)
	    goto _50;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = ip(k - 1);
	    t = b(m - 1);
	    b(m - 1) = b(k - 1);
	    b(k - 1) = t;
	    for (i = kp1; i <= n; i++) {
	      b(i - 1) = b(i - 1) + a(i - 1, k - 1) * t;
	    }
	  }
	  for (kb = 1; kb <= nm1; kb++) {
	    km1 = n - kb;
	    k = km1 + 1;
	    b(k - 1) = b(k - 1) / a(k - 1, k - 1);
	    t = -b(k - 1);
	    for (i = 1; i <= km1; i++) {
	      b(i - 1) = b(i - 1) + a(i - 1, k - 1) * t;
	    }
	  }
	_50:
	  b(0) = b(0) / a(0, 0);
	}
	
	void solc(const Matrix<double> &ar, const Matrix<double> &ai,
	          Vector<double> &br, Vector<double> &bi, const Vector<int> &ip) {
	  int n = ar.rows();
	  int i, m, k, kp1, km1, kb, nm1;
	  double tr, ti, prodr, prodi, den;
	
	  if (n == 1)
	    goto _50;
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; k++) {
	    kp1 = k + 1;
	    m = ip(k - 1);
	    tr = br(m - 1);
	    ti = bi(m - 1);
	    br(m - 1) = br(k - 1);
	    bi(m - 1) = bi(k - 1);
	    br(k - 1) = tr;
	    bi(k - 1) = ti;
	    for (i = kp1; i <= n; i++) {
	      prodr = ar(i - 1, k - 1) * tr - ai(i - 1, k - 1) * ti;
	      prodi = ai(i - 1, k - 1) * tr + ar(i - 1, k - 1) * ti;
	      br(i - 1) = br(i - 1) + prodr;
	      bi(i - 1) = bi(i - 1) + prodi;
	    }
	  }
	  for (kb = 1; kb <= nm1; kb++) {
	    km1 = n - kb;
	    k = km1 + 1;
	    den = ar(k - 1, k - 1) * ar(k - 1, k - 1) +
	          ai(k - 1, k - 1) * ai(k - 1, k - 1);
	    prodr = br(k - 1) * ar(k - 1, k - 1) + bi(k - 1) * ai(k - 1, k - 1);
	    prodi = bi(k - 1) * ar(k - 1, k - 1) - br(k - 1) * ai(k - 1, k - 1);
	    br(k - 1) = prodr / den;
	    bi(k - 1) = prodi / den;
	    tr = -br(k - 1);
	    ti = -bi(k - 1);
	    for (i = 1; i <= km1; i++) {
	      prodr = ar(i - 1, k - 1) * tr - ai(i - 1, k - 1) * ti;
	      prodi = ai(i - 1, k - 1) * tr + ar(i - 1, k - 1) * ti;
	      br(i - 1) = br(i - 1) + prodr;
	      bi(i - 1) = bi(i - 1) + prodi;
	    }
	  }
	_50:
	  den = ar(0, 0) * ar(0, 0) + ai(0, 0) * ai(0, 0);
	  prodr = br(0) * ar(0, 0) + bi(0) * ai(0, 0);
	  prodi = bi(0) * ar(0, 0) - br(0) * ai(0, 0);
	  br(0) = prodr / den;
	  bi(0) = prodi / den;
	}
f9f5f2c61fde44afbd6d85d6ff438e46|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|9|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination
	
	          Input:
	                  n		order of matrix
	                  A		matrix to be triangularized
	
	          Output:
	                  A[i][j], i <= j		upper triangular factor, U
	                  A[i][j], i > j		multipliers = lower triangular
	  factor, i - l ip[k], k < n - 1	index of k-th pivot rowf ip[n-1]
	  (-1)^(number of interchanges) or 0
	                  ier 				0 if matrix A is nonsingular, or
	  k if found to be singular at stage k
	
	          Use sol to obtain solution of linear system
	
	          determ(A) = ip[n-1]*A[0][0]*A[1][1]*...*A[n-1][n-1]
	
	          If ip[n-1] = 0, A is singular, sol will divide by zero
	
	          Reference:
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  ----------------------------------------------------------------------*/
cde6e90e3ebc7987b75ec9f81bc46cfc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|32|9|v|cpp
	const int n, double **
04bb6e53900cc1e274805fa7cd87deba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|86|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b
	
	          Input:
	                  n		order of matrix
	                  A		triangularized matrix obtained from dec
	                  b		right hand side vector
	                  ip		pivot vector obtained from dec
	
	          Do not use if dec has set ier != 0
	
	          Output:
	                  b		solution vector, x
	
	  -----------------------------------------------------------------------*/
7c09d3f48eb5ea7711fe057bcf7fcf62|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|99|28|v|cpp
	double *
cb983bc11fc67cece99cfc6215b21868|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|99|46|v|cpp
	int *
289ce4ddc5dda6247d08d37866661086|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|134|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination of a Hessenberg
	                  matrix with lower bandwidth lb
	
	          Input:
	                  n		order of matrix
	                  A		matrix to be triangularized
	                  lb		lower bandwidth of A (diagonal is not counted,
	  lb >= 1)
	
	          Output:
	                  A[i][j], i <= j		upper triangular factor, U
	                  A[i][j], i > j		multipliers = lower triangular
	  factor, i - l ip[k], k < n - 1	index of k-th pivot row ip[n-1]
	  (-1)^(number of interchanges) or 0
	                  ier 				0 if matrix A is nonsingular, or
	  k if found to be singular at stage k
	
	          Use solh to obtain solution of linear system
	
	          determ(A) = ip[n-1]*A[0][0]*A[1][1]*...*A[n-1][n-1]
	
	          If ip[n-1] = 0, A is singular, solh will divide by zero
	
	          Reference:
	                  This is a slight modification of
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  -----------------------------------------------------------------------*/
777732b3262b5b026d8e2c8aaca0df25|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|215|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b -- Hessenberg matrix
	
	          Input:
	                  n		order of matrix
	                  A		triangularized matrix obtained from dech
	                  lb		lower bandwidth of A
	                  b		right hand side vector
	                  ip		pivot vector obtained from dec
	
	          Do not use if dec has set ier != 0
	
	          Output:
	                  b		solution vector, x
	
	  -----------------------------------------------------------------------*/
cc0f763a430d3fac51d708258c081a9c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|229|55|v|cpp
	int *i
644411e4a8c228b96ba9fe61ad3f554c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|264|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination
	          ------ Modification for complex matrices -------
	
	          Input:
	                  n			order of matrix
	                  AR, AI		matrix to be triangularized
	
	          Output:
	                  AR[i][j], i <= j	upper triangular factor, U; real part
	                  AI[i][j], i <= j	upper triangular factor, U; imaginary
	  part AR[i][j], i > j		multipliers = lower triangular factor, i - l
	                                                                  real part
	                  AI[i][j], i > j		multipliers = lower triangular
	  factor, i - l imaginary part ip[k], k < n - 1	index of k-th pivot row ip[n-1]
	  (-1)^(number of interchanges) or 0
	                  ier					0 if matrix A is
	  nonsingular, or k if found to be singular at stage k
	
	          Use solc to obtain solution of linear system
	
	          If ip[n-1] = 0, A is singular, sol will divide by zero
	
	          Reference:
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  -----------------------------------------------------------------------*/
f9138a5ead76bda1f55f36022cb32137|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|377|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b
	
	          Input:
	                  n			order of matrix
	                  AR, AI		triangularized matrix obtained from decc
	                  br, bi		right hand side vector
	                  ip			pivot vector obtained from dec
	
	          Do not use if decc has set ier != 0
	
	          Output:
	                  br, bi		solution vector, x
	
	  -----------------------------------------------------------------------*/
6a206759f008fe63a27552a25d55f509|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|444|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination
	          ------ Modification for complex matrices -------
	
	          Input:
	                  n			order of matrix
	                  AR, AI		matrix to be triangularized
	
	          Output:
	                  AR[i][j], i <= j	upper triangular factor, U; real part
	                  AI[i][j], i <= j	upper triangular factor, U; imaginary
	  part AR[i][j], i > j		multipliers = lower triangular factor, i - l
	                                                                  real part
	                  AI[i][j], i > j		multipliers = lower triangular
	  factor, i - l imaginary part
	                  lb					lower bandwidth of A
	  (diagonal not counted), lb >= 1 ip[k], k < n - 1	index of k-th pivot row
	  ip[n-1]
	  (-1)^(number of interchanges) or 0
	                  ier					0 if matrix A is
	  nonsingular, or k if found to be singular at stage k
	
	          Use solhc to obtain solution of linear system
	
	          If ip[n-1] = 0, A is singular, solhc will divide by zero
	
	          Reference:
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  -----------------------------------------------------------------------*/
ea1c1f60a84264b0d511f2268ee9789a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|561|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b
	
	          Input:
	                  n			order of matrix
	                  AR, AI		triangularized matrix obtained from dec
	                  br, bi		right hand side vector
	                  lb			lower bandwidth of A
	                  ip			pivot vector obtained from dec
	
	          Do not use if dechc has set ier != 0
	
	          Output:
	                  br, bi		solution vector, x
	
	  -----------------------------------------------------------------------*/
13ca2111582c5dfb1a77d50cef105413|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|630|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination of a banded
	                  matrix with lower bandwidth ml and upper bandwidth mu
	
	          Input:
	                  n		order of matrix
	                  A		contains the matrix in band storage.
	                                  The columns of the matrix are stored in the
	  columns of A and the diagonals of the matrix are stored in rows ml	through
	  2*ml + mu of A. ml		lower bandwidth of A (diagonal is not counted)
	                  mu		upper bandwidth of A (diagonal is not counted)
	
	          Output:
	                  A 		upper triangular matrix in band storage and the
	                                  multipliers which were used to obtain it
	                  ip		index vector of pivot indices
	                  ip[n-1]	(-1)^(number of interchanges) or 0
	                  ier		0 if matrix A is nonsingular, or k if found to
	  be singular at stage k
	
	          Use solb to obtain solution of linear system
	
	          determ(A) = ip[n-1]*A[md][0]*A[md][1]*...*A[md][n-1] with
	                          md = ml + mu
	
	          If ip[n-1] = 0, A is singular, solb will divide by zero
	
	          Reference:
	                  This is a modification of:
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  -----------------------------------------------------------------------*/
33f6d16b61951a73f5fa413ecadbf0b5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|733|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b
	
	          Input:
	                  n 		order of matrix
	                  A		triangularized matrix obtained from decb
	                  ml		lower bandwidth of A (diagonal not counted)
	                  mu		upper bandwidth of A (diagonal not counted)
	                  b		right hand side vector
	                  ip		pivot vector obtained from dec
	
	          Do not use if decb has set ier != 0
	
	          Output:
	                  b		solution vector, x
	
	  -----------------------------------------------------------------------*/
0d2ca414d59a16abdc1fa5eed1ce6a03|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|790|29|v|cpp
	 double **
2c7fc066b9b7263a858aa0c285c239ec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|793|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Matrix Triangularization by Gaussian Elimination of a banded complex
	                  matrix with lower bandwidth ml and upper bandwidth mu
	
	          Input:
	                  n			order of the original matrix A
	                  AR, AI		contains the matrix in band storage.
	                                          The columns of the matrix are stored
	  in the columns of AR (real part) and AI (imaginary part) and the diagonals of
	  the matrix are stored in rows ml through 2*ml+mu of AR and AI ml
	  lower bandwidth of A (diagonal is not counted) mu			upper
	  bandwidth of A (diagonal is not counted)
	
	          Output:
	                  AR, AI		an upper triangular matrix in band
	  storage and the multipliers which were used to obtain it ip
	  index vector of pivot indices ip[n-1]		(-1)^(number of interchanges) or
	  0 ier 		0 if matrix A is nonsingular, or k if found to be
	  singular at stage k
	
	          Use solbc to obtain solution of linear system
	
	          determ(A) = ip[n-1]*A[md][0]*A[md][1]*...*A[md][n-1] with md = ml+mu
	
	          If ip[n-1] = 0, A is singular, solbc will divide by zero
	
	          Reference:
	                  This is a modification of:
	                  C.B. Moler, Algorithm 423, Linear Equation Solver,
	                  C.A.C.M. 15 (1972), p. 274.
	  -----------------------------------------------------------------------*/
a2069d549eef8628487bd4eb3cd52ea3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|934|1|V|cpp
	  /*-----------------------------------------------------------------------
	          Solution of linear system A*x = b
	                  version banded and complex
	
	          Input:
	                  n			order of matrix
	                  AR, AI		triangularized matrix obtained from decb
	                                                  (real and imaginary parts)
	                  ml			lower bandwidth of A (diagonal is not
	  counted) mu			upper bandwidth of A (diagonal is not counted)
	                  br, bi		right hand side vector (real and
	  imaginary parts) ip			pivot vector obtained from decbc
	
	          Do not use if decbc has set ier != 0
	
	          Output:
	                  br, bi		solution vector, x (real and imaginary
	  parts)
	
	  -----------------------------------------------------------------------*/
89aa8d404c0d30a84df3391936181887|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|1012|1|V|cpp
	  /* --------------------------------------------------------------------
	          This subroutine is a translation of the algol procedure elmhes,
	          Num. Math. 12, 349-368(1968) by Martin and Wilkinson.
	          Handbook for Auto. Comp., Vol.II-Linear Algebra, 339-358(1971).
	
	          Given a real general matrix, this subroutine reduces a submatrix
	          situated in rows and columns low through igh to upper Hessenberg
	          form by stabilized elementary similarity transformations.
	
	          Input:
	                  n 		order of the matrix;
	
	                  low, igh	integers determined by the balancing subroutine
	  balanc. If balanc has not been used, set low=0, igh=n;
	
	                  A 		the input matrix.
	
	          Output:
	
	                  A		contains the Hessenberg matrix. The multipliers
	  which were used in the reduction are stored in the remaining triangle under
	  the Hessenberg matrix;
	
	                  inter	contains information on the rows and columns
	                                  interchanged in the reduction. Only elements
	  low through igh are used.
	
	          Questions and comments should be directed to B. S. Garbow,
	          Applied Mathematics Division, Argonne National Laboratory
	
	  ------------------------------------------------------------------*------*/
bd5388c16ed31fbf65b1c047cfda60b7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|1041|13|v|cpp
	const int n, 
3734838c4871f3a34fbe802e76a3493e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|23|1|V|cpp
	#include "decsol.h"
	#include <cmath>
4f9ba13dcddbb8a50dffc10c9fbe35de|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|51|1|V|cpp
	  int n = A.cols();
57a08973d7d3825cc86ea429b00b9297|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/decsol.cpp|312|1|V|cpp
	  int n = AR.cols();
52287004ce50091ecee7e1fea26a42ec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/decsol.hpp|9|1|V|cpp
	int dec(Matrix<double> &, Vector<int> &);
	int decc(Matrix<double> &, Matrix<double> &, Vector<int> &);
	
	void sol(const Matrix<double> &, Vector<double> &, const Vector<int> &);
	void solc(const Matrix<double> &, const Matrix<double> &, Vector<double> &,
	          Vector<double> &, const Vector<int> &);
026843ad3d5bea40b15afc14a852478f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|11|2|v|cpp
	IntegratorT
d963f26a99122660690b67e713cb3a66|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|9|3|V|cpp
	  // Constructor
53c9cda3f9191d9955ec9525931a75f5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|15|3|V|cpp
	  // Still need to implement copy constructor and default constructor
b1a1df9eba9e9b5b318eaa531a28c139|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|16|1|V|cpp
	  // Destructor
15d9a72d137956fa0390a080a9b38d4a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|5|39|v|cpp
	double yin[]
ea32e23d00ec72a371c63f30f18904d2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|4|1|V|cpp
	// constructors
f05cc82f3e66a5cbe3ac3885924d0b18|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|8|1|v|cpp
	
	class Radau {
	private:
	  // Inputs
	  int n;            // Dimension of the system
	  OdeFunc fcn;      // Function computing RHS of ODE: f(x, y)
	  double x;         // Current (initial) value of x
	  Vector<double> y; // Current (initial) value of y
	  double xend;      // Final value of x
	  double h;         // Step size
	  double *rtol;     // Relative tolerances
	  double *atol;     // Absolute tolerances
	  int itol;         // Flag for vector or scalar tolerances
	  OdeJac jac;       // Function computing jacobian of RHS of ODE: dfdy
	  int ijac;         // Flag specifying if jacobian was supplied
	  int mljac;        // Lower bandwidth of jacobian
	  int mujac;        // Upper bandwidth of jacobian
	  OdeMas mas;       // Function computing mass matrix for M.dydt = f(x,y)
	  int imas;         // Flag specifying if mass matrix was specified
	  int mlmas;        // Lower bandwidth of mass matrix
	  int mumas;        // Upper bandwidth of mass matrix
	  OdeSolOut solout; // Function for outputing numerical solution
	  int iout;         // Flag specifying if output is requested
	
	  // Algorithm Parameters
	  bool hess;           // true => convert jac to hessenberg form
	  int nmax;            // maximum # of allowed steps
	  int nit;             // maximum # of newton iterations
	  bool startn;         // true => extrapolated collocation is used for newton
	  int nind1;           // dim of index 1 variables (for ODEs, nind1 = n)
	  int nind2;           // dim of index 2 variables
	  int nind3;           // dim of index 3 variables
	  bool pred;           // true => uses Gustafsson controller
	  int m1;              // y(i)' = y(i+m2) for i=1,...,m1
	  int m2;              // """"""""""""""""""""""""""""""
	  int nsmin;           // minimum number of stages (can be 1,3,5,7)
	  int nsmax;           // maximum number of stages (can be 1,3,5,7)
	  int nsus;            // starting order
	  double uround;       // rounding unit
	  double safe;         // safety factor for step-size prediction
	  double thet;         // decides if the jacobian should be recomputed
	  double quot1, quot2; // quot1 < hnew/hold < quot2 => h not changed
	  double hmax;         // Maximal step-size
	  double facl, facr;   // hnew chosen so facl < hnew < facr
	  double vitu;         // order increased if contractivity factor < vitu
	  double vitd;         // order decreased if contractivity factor > vitu
	  double hhou, hhod;   // order decreased only if hhod <= hnew/h<=hhou
	
	  // Counting varaibles
	  int nfcn = 0;   // # of function evaluations
	  int njac = 0;   // # of jacobian evaluations
	  int nstep = 0;  // # of steps taken
	  int naccpt = 0; // # of accepted steps
	  int nrejct = 0; // # of rejected steps
	  int ndec = 0;   // # of decompositions
	  int nsol = 0;   // # of linear solves
	
	  //=========================================================================
	  // ---- Working variables -------------------------------------------------
	  //=========================================================================
	
	  bool reject;
	  bool first, last;
	  bool banded, implct;
	  bool caljac, calhes;
	  // bool startn;
	  bool index1, index2, index3;
	  bool change;
	  bool unexp;
	  bool unexn;
	  bool variab;
	
	  // Arrays
	  Vector<double> zz;
	  Vector<double> ff;
	  Vector<double> y0;
	  Vector<double> scal;
	  Vector<double> cont;
	  Vector<double> alph;
	  Vector<double> beta;
	  Vector<double> alphn;
	  Vector<double> betan;
	  Vector<double> dd;
	  Vector<int> ip1;
	  Vector<int> ip2;
	  Vector<int> iphes;
	  Matrix<double> fjac;
	  Matrix<double> fmas;
	  Matrix<double> e1;
	  Matrix<double> ee2;
	
	  void coertv();
	  void coercv();
	  int decomr(Matrix<double> &, Matrix<double> &, double);
	  int decomc();
	  void radcov();
	  void slvrad();
	  void slvrar();
	  void slvrai();
	  void estrad();
	  void estrav();
	
	public:
	  void integrate();
	};
5b6d2deb85c3b7ff0ec4b7e1a0e90fa5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|14|34|v|cpp
	[], 
333da1f6fa33ab31b8670b7d2e190002|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|27|7|v|cpp
	NumFunction
790269f42d09e6d2349029f8731a2048|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|29|7|v|cpp
	NumStep
cf0b845a46524554f955cf560a0e450b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|31|7|v|cpp
	NumAccept
01c2ac1d30a16820231cbde3972093e8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|33|7|v|cpp
	NumReject
113a3e64c3c0545d8e2046c3ed13e6a0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|14|3|v|cpp
	StiffIntegrator
12c9a247cb08f82e352f2d92e2bfb780|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|35|7|v|cpp
	NumJacobian
252ae77714d23d9f9ebaaf7ad1ad8c1a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|38|7|v|cpp
	NumDecomp
74db796203cc26b054eba84864cceb83|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|41|7|v|cpp
	NumSol
8761905c133f74172315c307c34754ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|12|1|V|cpp
	#include "StiffIntegratorT.h"
b6a91c9210881f1e57cc0f1a35abaaa6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|14|1|v|cpp
	StiffIntegratorT
7dee0eb357d1b29b018d377d2da1e6fc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|13|1|V|cpp
	// Constructor
4bc0779b098fb0d2cf5047b822246c2e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|4|1|V|cpp
	/***************************************************************************
	                            StiffIntegratorT.cpp
	                             -------------------
	    written by:          : Blake Ashby
	    last modified        : Nov 15, 2002
	    email                : bmashby@stanford.edu
	 ***************************************************************************/
	
	#include "StiffIntegratorT.h"
	
56ab9bdba5e79d0430332d6e58df8f36|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|13|1|V|cpp
	#include "Radau5.h"
5d3224cf8357563ea82e70608cbb115f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|205|6|v|cpp
	= new double[n];
2b667981c8869e7018fea72a4cbec243|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|209|5|v|cpp
	 = new double[n];
e897bf7c48c0059a548d7b9e2c754f77|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|216|7|v|cpp
	 = new double[4 * n];
1711fe470234737c30d09f715e7013f3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|217|6|v|cpp
	 = new int[nm1];
827f5a5ee760db43d35f17202ca66528|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|219|8|v|cpp
	 = new int[n];
ec09f7660f08f803b25a3beef52b0fef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|222|7|v|cpp
	 = new double *[ldjac];
756ee69b1bd92d5e74b6d2294b56c660|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|223|7|v|cpp
	 = new double *[ldmas];
b99f884cf97ee5c50d659c8080621073|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|224|5|v|cpp
	 = new double *[lde1];
2c46a0d504394141daaf93f45b1f460f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|228|1|V|cpp
	  for (int i = 0; i < ldjac; i++)
	    fjac[i] = new double[n];
	
	  for (int i = 0; i < ldmas; i++)
	    fmas[i] = new double[n];
	
	  for (int i = 0; i < lde1; i++) {
	    e1[i] = new double[nm1];
	    e2r[i] = new double[nm1];
	    e2i[i] = new double[nm1];
	  }
f2ace5ee3f98949fd6eb9d739ba9464f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|207|1|V|cpp
	  // Allocate memory for 1-D arrays
	  z1.resize(n);
	  z2.resize(n);
	  z3.resize(n);
	  y0.resize(n);
	  scal.resize(n);
	  f1.resize(n);
	  f2.resize(n);
	  f3.resize(n);
	  cont.resize(4 * n);
	  ip1.resize(nm1);
	  ip2.resize(nm1);
	  iphes.resize(n);
	
	  // Allocate memory for 2-D arrays
	  fjac.resize(ldjac, n);
	  fmas.resize(ldmas, n);
	  e1.resize(lde1, nm1);
	  e2r.resize(lde1, nm1);
	  e2i.resize(lde1, nm1);
57580a8b425dfa2808614bf39dc88625|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|412|2|v|cpp
	 z1 = new double[n];
	  z2 = new double[n];
	  z3 = new double[n];
	  y0 = new double[n];
	  scal = new double[n];
	  f1 = new double[n];
	  f2 = new double[n];
	  f3 = new double[n];
	  cont = new double[4 * n];
	  ip1 = new int[nm1];
	  ip2 = new int[nm1];
	  iphes = new int[n];
	
	  // Allocate memory for 2-D arrays
	  fjac = new double *[ldjac];
	  fmas = new double *[ldmas];
	  e1 = new double *[lde1];
	  e2r = new double *[lde1];
	  e2i = new double *[lde1];
dfdd1855eb187859d9caf98b13b1d7f6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|208|1|V|cpp
	  z1.resize(n);
	  z2.resize(n);
	  z3.resize(n);
	  y0.resize(n);
	  scal.resize(n);
	  f1.resize(n);
	  f2.resize(n);
	  f3.resize(n);
	  cont.resize(4 * n);
	  ip1.resize(nm1);
	  ip2.resize(nm1);
	  iphes.resize(n);
	
	  // Allocate memory for 2-D arrays
	  fjac.resize(ldjac, n);
	  fmas.resize(ldmas, n);
	  e1.resize(lde1, nm1);
	  e2r.resize(lde1, nm1);
	  e2i.resize(lde1, nm1);
7d3f95b4f0bb96655f8cc71ae6f02d40|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|431|1|V|cpp
	 
	
	  for (int i = 0; i < ldjac; i++)
	    fjac[i] = new double[n];
	
	  for (int i = 0; i < ldmas; i++)
	    fmas[i] = new double[n];
	
	  for (int i = 0; i < lde1; i++) {
	    e1[i] = new double[nm1];
	    e2r[i] = new double[nm1];
	    e2i[i] = new double[nm1];
	  }
178a70360079aafe619130c6955d0a89|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|436|1|V|cpp
	  delete[] z1;
	  delete[] z2;
	  delete[] z3;
	  delete[] y0;
	  delete[] scal;
	  delete[] f1;
	  delete[] f2;
	  delete[] f3;
	  delete[] cont;
	  delete[] ip1;
	  delete[] ip2;
	  delete[] iphes;
	  for (int i = 0; i < lde1; i++) {
	    delete[] e1[i];
	    delete[] e2r[i];
	    delete[] e2i[i];
	  }
	  for (int i = 0; i < ldjac; i++)
	    delete[] fjac[i];
	  for (int i = 0; i < ldmas; i++)
	    delete[] fmas[i];
	  delete[] e1;
	  delete[] e2r;
	  delete[] e2i;
	  delete[] fjac;
	  delete[] fmas;
54275c1e31f92cfc073407aa93efd9b2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|11|1|V|cpp
	using OdeJac =
	    std::function<void(double, const Vector<double> &, Matrix<double> &)>;
98f716c62890773569d384fc371b262e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|13|7|v|cpp
	OdeJac
0e87faa12b023e3da98a4498c173ea97|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|14|24|v|cpp
	double, const Vector<double> &, 
130bb8254797b2b65eae64a7213a4340|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|21|25|v|cpp
	OdeFunc func, std::optional<OdeJac>,
	         std::optional<OdeMass>
159b7e135cf568427b67d24de999648c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|73|21|V|cpp
	  // compute the Jacobian analytically (ijac = 1) or not (ijac = 1)
	  const int ijac;
0a9eb8a1976904705b8cf524a09199b0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|72|1|V|cpp
	  std::optional<OdeJac> jac;
2383472ba6ee77a16ddcd11b583a0a2d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|80|1|V|cpp
	  // differential equation is in explicit form (imas = 0) or not (imas = 1)
	  const int imas;
d16d6ffd0c7feae15cd8d4bfaece7c24|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/base.hpp|13|51|v|cpp
	, int
ca0e3664fbb3c2dad42c8d9a0fb5873f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|12|1|V|cpp
	using OdeJac =
	    std::function<void(double, const Vector<double> &, Matrix<double> &)>;
	using OdeMas = std::function<void(Matrix<double> &)>;
d4daf13a0ac2b4909d65653d8eee4910|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|9|1|V|cpp
	using OdeFunc =
	    std::function<void(double, const Vector<double> &, Vector<double> &)>;
ed29b0f3ef7a87898cc24f6be3c34de5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|5|1|V|cpp
	#include <functional>
988ad0f1e15862d3facc099d6d5fc480|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|32|47|v|cpp
	, ijac(ijacin)
8f054f5e8e6411d93d6cee936e7c665f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|33|21|v|cpp
	, imas(imasin)
798c74ee720081b8e40b9b7ac3459c3d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|24|29|v|cpp
	, const int ijacin
d8b7c41b2016487ff1a33b00dfc67593|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|25|16|v|cpp
	const int imasin,
0f083ed2558aeef07af6d056bd4e0a5e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|22|10|v|cpp
	const int ijacin, 
8162ef566e572de1327ffa6ed61dbe91|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|22|34|v|cpp
	, const int imasin
633fb8c63e06dfd4b6f90a150d4d8b1c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|143|13|v|cpp
	imas
d0aa334a1ab4bc31cebe58f68cd7dbd6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|143|11|v|cpp
	 ( != 0);
09bcb319d69d22bbc4389997102188d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|238|7|v|cpp
	imas(imasin), 
8dedb095c6124a5867cbfe882a03ff64|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/radau.hpp|28|1|V|cpp
	  Radau5(int nin, OdeFunc func, std::optional<OdeJac>, std::optional<OdeMas>,
	         Vector<double> &yin, double xin, double xendin, double dxin,
	         int mljacin, int mujacin, int mlmasin, int mumasin);
a3b932711609ca5728d9e9f78154f7cc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|348|12|v|cpp
	(imas != 0);
c3edaa78e9d7f29b144f4dd637f2c1fb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|902|6|v|cpp
	(ijac == 0) {
43edbc8263d96269239b71559637c2e3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1645|18|v|cpp
	&z1(m1)
e7b2cb21242f45a5b5dcce3f27f71a7f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1644|1|V|cpp
	    Vector<double> z1seg = z1.segment(m1, z1.size());
9c528d9632f80ac484c04949c2d736d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1648|25|v|cpp
	&z2(m1)
33a3d4dff13e3f6e7346a0e2555d62bf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1648|32|v|cpp
	&z3(m1)
31e5fc4b8fa0f61b1de8b3f7590eb7f5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1644|1|V|cpp
	    Vector<double> z1seg = z1.segment(m1, z1.size());
	    Vector<double> z2seg = z2.segment(m1, z2.size());
	    Vector<double> z3seg = z3.segment(m1, z3.size());
fdd32b9061681edb52c554bd9bbf0712|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	segment
fdd32b9061681edb52c554bd9bbf0712|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	segment
fdd32b9061681edb52c554bd9bbf0712|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	segment
08573553e1195ef7f9b2657721c02a8f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	());
08573553e1195ef7f9b2657721c02a8f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	());
08573553e1195ef7f9b2657721c02a8f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1652|15|v|cpp
	());
5196482f3fd6c196cdb03c1e3a639303|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1649|1|V|cpp
	    z1.segment(m1, z1.size()) = z1seg;
0912a65c61f67b00dd085ebfb9e17a94|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1653|1|V|cpp
	    z1seg = z1.co
	    z2seg = z2.co
	    z3seg = z3.co
f09e3241467a9bffdac33b8c7f82bce7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1649|1|V|cpp
	    z1.segment(m1, z1.size()) = z1seg;
	    z2.segment(m1, z2.size()) = z2seg;
	    z3.segment(m1, z3.size()) = z3seg;
22bbc4e655c15eff459140115d5043fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1406|25|v|cpp
	 = z1.segment(m1, z1.size());
170c4676eeac7a6ede69d1d6618e0804|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1406|25|v|cpp
	 = z2.segment(m1, z2.size());
4d15bf1df6e3e1d751a6f85da8f5b795|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1406|25|v|cpp
	 = z3.segment(m1, z3.size());
eb41de049c7b1c5744559051e1f181b6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1650|5|v|cpp
	Vector<double> 
eb41de049c7b1c5744559051e1f181b6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1650|5|v|cpp
	Vector<double> 
eb41de049c7b1c5744559051e1f181b6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1650|5|v|cpp
	Vector<double> 
f807a661cd70ac03d6f84c431cdad0b8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1930|1|V|cpp
	    contseg = cont.segment(m1, cont.size());
3c8ff49fd0a2320b11d4e907e69bda92|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1932|1|V|cpp
	    cont.segment(m1, cont.size()) = contseg;
416d092bc2db8fce362caf605b17d503|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|1948|1|V|cpp
	    contseg = cont.segment(m1, cont.size());
	    solb(nm1, e1, mle, mue, cont, ip1);
	    cont.segment(m1, cont.size()) = contseg;
b12573698332dbe63105603795de5a5d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|2031|5|V|cpp
	    solb(nm1, e1, mle, mue, cont, ip1);
797f2f03888564f50b67864c0b2031cc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|2030|1|V|cpp
	    contseg = cont.segment(m1, cont.size());
	      sol(nm1, e1, &cont(m1), ip1);
	    cont.segment(m1, cont.size()) = contseg;
4e08660df5bb4a62342f0d742040c6b9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|2050|5|V|cpp
	      sol(nm1, e1, &cont(m1), ip1);
08309df112ef86de286a25702179c24f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|2031|24|v|cpp
	(m1)
041cf52882ef2dcff00bbfc215d78333|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|46|1|V|cmake
	# --------------------------------------------------------------------------
	# test_decsol.cpp: Check the decomposition/linear solver
	# --------------------------------------------------------------------------
	
	add_executable(test_decsol test_decsol.cpp)
	target_link_libraries(test_decsol PUBLIC gtest_main darksun)
	
	 set_target_properties(test_decsol PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
b0224ebdcd30c9ec7c01e50c4e3c68bc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|57|19|v|cmake
	Check the decomposition/linear solver
d43377cc0c25b8e8199d879b54fd7e19|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|1|1|V|cpp
	#include <darksun/diffeq/radau.hpp>
8d676aa4ac5a76072b3905f97cdb8b88|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq.hpp|4|1|V|cpp
	#include "darksun/diffeq/base.hpp"
593616de15330c0fb2d55e55410bf994|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq.hpp|5|26|v|cpp
	base
8a466aea5e655461d63b5d91c9196a31|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_fortran_radau5.cpp|7|1|V|cpp
	  fy[0] = y[1];
	  fy[1] = ((1 - y[0] * y[0]) * y[1] - y[0]) / rpar[0];
46fca52663a7faee79c06e6ddee5e5cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|13|47|v|cpp
	rpar[0];
4b5a5ed91da29142fe7f056e18d4672a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|10|1|V|cpp
	  auto vdpol = [](double x, const Vector<double> &y, Vector<double> &dy) {
	    dy[0] = y[1];
	    dy[1] = ((1 - y[0] * y[0]) * y[1] - y[0]) / eps;
	  };
970e9fb18f9721729dafde3578438785|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|15|1|V|cpp
	    df(0,0)=0.0;
99fd944698d0e5de9eaecb1a9e334355|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|22|13|v|cpp
	((1 - y[0] * y[0]) * y[1] - y[0]) / eps;
fa4d25f6a7e9a639c5bce727ce2f80bc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|21|5|V|cpp
	    dy[0] = y[1];
2102da0b00f035a10748dbcbb38ae648|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|21|5|V|cpp
	    dy[1] = ((1 - y[0] * y[0]) * y[1] - y[0]) / eps;
fa60ac76e8b136ba6c8aaacc01d25b29|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|17|29|v|cpp
	 * y[0])
d3089d256ed57bb9bc91054c46ba0878|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|17|36|v|cpp
	y[0]
e96cbbcaf4a7c67b98709e4e5118c197|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|18|32|v|cpp
	* y[1] - y[0]
98119cc0c219fc29c2afe4c6b166f610|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|22|28|v|cpp
	[](Matrix)
94361ffe3bbf47225ee99c77c1cfddf9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|35|59|v|cpp
	0, 0, 0, 0);
fa401134ac30ac83bc91e2fe1459d2b5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|33|1|V|cpp
	  int mlmas = 0;
5d8fd3b46d7b7fa3ad32ca1a29c83413|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_decsol.cpp|9|5|V|cpp
	    int n = 4;
9ccfd2856ca28d380cf290c7fa0965cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|41|1|V|cpp
	  std::array<std::array<double,3>, 41> xs = {0.,
	                               0.05,
	                               0.1,
	                               0.15000000000000002,
	                               0.2,
	                               0.25,
	                               0.30000000000000004,
	                               0.35000000000000003,
	                               0.4,
	                               0.45,
	                               0.5,
	                               0.55,
	                               0.6000000000000001,
	                               0.65,
	                               0.7000000000000001,
	                               0.75,
	                               0.8,
	                               0.8500000000000001,
	                               0.9,
	                               0.9500000000000001,
	                               1.,
	                               1.05,
	                               1.1,
	                               1.1500000000000001,
	                               1.2000000000000002,
	                               1.25,
	                               1.3,
	                               1.35,
	                               1.4000000000000001,
	                               1.4500000000000002,
	                               1.5,
	                               1.55,
	                               1.6,
	                               1.6500000000000001,
	                               1.7000000000000002,
	                               1.75,
	                               1.8,
	                               1.85,
	                               1.9000000000000001,
	                               1.9500000000000002,
	                               2.};
	  std::array<double, 41> ys = {2.,
	                               1.9661892484754215,
	                               1.9313610478721095,
	                               1.8954088384677206,
	                               1.8582056276363659,
	                               1.8195979561669557,
	                               1.7793974167757798,
	                               1.7373683162108742,
	                               1.6932090256578511,
	                               1.6465226506589787,
	                               1.5967684573030676,
	                               1.543175413976293,
	                               1.4845750932363537,
	                               1.4190350204854123,
	                               1.342890898941202,
	                               1.2472019295857966,
	                               1.0839201216017382,
	                               -1.971118662159346,
	                               -1.936443129338714,
	                               -1.9006600748947884,
	                               -1.8636457734095244,
	                               -1.8252510347857684,
	                               -1.7852931284223588,
	                               -1.7435441383035513,
	                               -1.6997134197726316,
	                               -1.6534202018998279,
	                               -1.6041486131673408,
	                               -1.5511684254192748,
	                               -1.4933841570646318,
	                               -1.4290107372008636,
	                               -1.3547447410455409,
	                               -1.2629136764948916,
	                               -1.1208100241551344,
	                               1.976027273175076,
	                               1.9415022557335877,
	                               1.9058857983366582,
	                               1.8690573261425005,
	                               1.8308717492878046,
	                               1.791151777035892,
	                               1.7496769138953059,
	                               1.706166942293804};
	  std::array<double, 41> yps = {-0.66,
	                                -0.6860638715110897,
	                                -0.7074178507553899,
	                                -0.7310918015640505,
	                                -0.7575455973910044,
	                                -0.7873851758826808,
	                                -0.8214160097192423,
	                                -0.8607441151327514,
	                                -0.9069350923615699,
	                                -0.9622955673428706,
	                                -1.0303919311654355,
	                                -1.117116105141874,
	                                -1.2330713461728815,
	                                -1.399907588330944,
	                                -1.6715916588912154,
	                                -2.2451024277919465,
	                                -6.195465640457782,
	                                0.6831570250070442,
	                                0.7042090923029367,
	                                0.7275230893444639,
	                                0.7535434289873758,
	                                0.7828513484575084,
	                                0.8162189064954589,
	                                0.8547008616567286,
	                                0.8997826986496342,
	                                0.9536402719476197,
	                                1.0196113464070558,
	                                1.1031511437264612,
	                                1.2139377356322454,
	                                1.3713136172955742,
	                                1.6217935234704024,
	                                2.122693038582543,
	                                4.373902091600681,
	                                -0.6802900790098091,
	                                -0.7010472435573056,
	                                -0.7240101812979894,
	                                -0.7496089960511384,
	                                -0.7784013725146435,
	                                -0.8111271853438429,
	                                -0.8487931530970122,
	                                -0.8928105392359631};
22ca7443af9dd604a5ef26eba4c84208|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|40|14|v|cpp
	std::array<double,3>
da9cc8d857d9ca9879109bc0bad14e50|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|40|23|v|cpp
	= {1,2,3};
33f56a53ad33140479c486767fb47853|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|41|35|v|cpp
	, 41
f1f713c9e000f5d3f280adbd124df4f5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|42|8|v|cpp
	array
f2be034a253e2b5c69f1acdf161a12df|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|442|1|V|cpp
	  solution.xs.reserve(1000);
e08eb00dbb6a6f134af506a5066bb628|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|90|1|V|cpp
	      std::cout << "Step " << naccpt << ": t = " << std::setw(5)
	                << std::setprecision(2) << xd << "  y = ";
d6227cf524d3d1da01f43980dba821e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|92|1|V|cpp
	
	        std::cout << std::setw(10) << std::setprecision(8)
	                  << continuous_output(i) << "  ";
20f12462546e637ad4c741b5b9dfa8d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|92|7|V|cpp
	      std::cout << std::endl;
8b9c582989652bfd527c55468702d82e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|91|7|V|cpp
	      for (unsigned i = 0; i < n; i++)
eb0376d9f9b4f5604c835ab56e8d033e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|46|44|v|cpp
	unsigned i
8cd676ef98ea416afc1f82de059813f1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/integrator.cpp|91|1|V|cpp
	      for (unsigned i = 0; i < n; i++)
	
	        std::cout << std::setw(10) << std::setprecision(8)
	                  << continuous_output(i) << "  ";
	      std::cout << std::endl;
29f813a323a0af24f3e61c5e43260c47|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|448|5|V|cpp
	    std::cout << " Computation failed " << std::endl;
e8546dc69894bb5b643797eefde1ddd6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|479|1|V|cpp
	// return value of CoreIntegrator
	//  1  computation successful,
	//  2  comput. successful (interrupted by solution_output)
	// -1  error in linear algebra routines,
	// -2  larger nmax is needed,
	// -3  step size becomes too small,
	// -4  matrix is repeatedly singular.
	// -5 not enough memory
aee5fce5d5908c2ec0711f0026663e0c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/diffeq/integrator.hpp|21|3|V|cpp
	  MaxStepsExceeded,
830624ca364e754f2faa5757066f6b7f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|585|1|V|cpp
	        solution.code = OdeRetcode::LinAlgError;
f18a17afb58b45356dfeb580a7ab85bf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|592|37|v|cpp
	LinAlgError
4e83eb83f5e29e5c182ad75445f45e81|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|619|1|V|cpp
	        solution.code = OdeRetcode::SingularMatrix;
de2e45aece7bcbb9fe7540cc9e11c40f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|638|37|v|cpp
	SingularMatrix
d8f170f06eef667cf7f3ee4a93c75d10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|638|1|V|cpp
	        solution.code = OdeRetcode::MaxStepsExceeded;
08e68aafadb44dce2269d49976d66461|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|645|37|v|cpp
	MaxStepsExceeded
4fa5f838f01e05bae32802bb13164dad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|645|1|V|cpp
	        solution.code = OdeRetcode::StepSizeTooSmall;
a7033ad067b170f1fc64a804dd4c940d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|697|37|v|cpp
	StepSizeTooSmall
dcf81df5af32f328c30b3b29ea6f8d23|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|697|1|V|cpp
	              solution.code = OdeRetcode::SingularMatrix;
01492ae28ca50307797dd4e675993630|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|736|1|V|cpp
	          solution.code = OdeRetcode::LinAlgError;
6ceced00550b60d24d30e82f38e34e8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|778|1|V|cpp
	                solution.code = OdeRetcode::SingularMatrix;
e9cd4158690f0648e291f49137b0e6ab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|864|1|V|cpp
	            solution.code = OdeRetcode::UserInterupt;
86734a4a32ba62a4de73adbd07fe9364|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|871|41|v|cpp
	UserInterupt
ca206526054bbcb0e24f7ef1b9663d97|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|871|1|V|cpp
	          solution.code = OdeRetcode::Success;
514d877e45fb15f775782507cf519021|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|65|7|v|cpp
	(auto &sol : mma) {
b5e14d1615a34482f4264f4ab63eab8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|66|20|v|cpp
	mma[i][0]
a7b917b325c6ec1d3ae7ce8532286c65|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|66|1|V|cpp
	    ASSERT_LE(abs((mma[i][0] - sol.xs[i]) / mma[i][0]), 1e-5);
59a45234470d79b05061ccf36805be2c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|67|51|v|cpp
	sol.ys[i](0)
c1bfeff06c4864787d4257198222f333|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|442|23|v|cpp
	ceil(abs(xend - x) / dx)
83487161c2cf59fa914f94e52fa485eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|466|1|V|cpp
	    solution.xs.push_back(xend);
6c1e7ee13e938793a8acc5e5ecf5bdad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|468|1|V|cpp
	    std::cout << "Step " << naccpt << ": t = " << std::setw(5)
	              << std::setprecision(2) << xend << "  y = ";
	    for (int i = 0; i < n; i++)
	      std::cout << std::setw(10) << std::setprecision(8) << y[i] << "  ";
	    std::cout << std::endl;
711a2c2adfa0089743069cb4a0abbd21|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|20|1|V|cpp
	Radau5::Radau5(const int nin, OdeFunc func, std::optional<OdeJac> jac,
	               std::optional<OdeMas> mas, Vector<double> &yin, double xin,
	               double xendin, double dxin, int itolerin, double *rtolerin,
	               double *atolerin, const int ioutin, double hin, double hmaxin,
	               int nmaxin, double uroundin, double safein, double faclin,
	               double facrin, int mljacin, int mujacin, int mlmasin,
	               int mumasin, int nitin, bool startnin, int nind1in, int nind2in,
	               int nind3in, int npredin, int m1in, int m2in, bool hessin,
	               double fnewtin, double quot1in, double quot2in, double thetin)
92b61c58f418d4416086ece13b929a62|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|45|39|v|cpp
	{
	      {0., 2., -0.66},           {0.05, 1.96619, -0.686064},
	      {0.1, 1.93136, -0.707418}, {0.15, 1.89541, -0.731092},
	      {0.2, 1.85821, -0.757546}, {0.25, 1.8196, -0.787385},
	      {0.3, 1.7794, -0.821416},  {0.35, 1.73737, -0.860744},
	      {0.4, 1.69321, -0.906935}, {0.45, 1.64652, -0.962296},
	      {0.5, 1.59677, -1.03039},  {0.55, 1.54318, -1.11712},
	      {0.6, 1.48458, -1.23307},  {0.65, 1.41904, -1.39991},
	      {0.7, 1.34289, -1.67159},  {0.75, 1.2472, -2.2451},
	      {0.8, 1.08392, -6.19547},  {0.85, -1.97112, 0.683157},
	      {0.9, -1.93644, 0.704209}, {0.95, -1.90066, 0.727523},
	      {1., -1.86365, 0.753543},  {1.05, -1.82525, 0.782851},
	      {1.1, -1.78529, 0.816219}, {1.15, -1.74354, 0.854701},
	      {1.2, -1.69971, 0.899783}, {1.25, -1.65342, 0.95364},
	      {1.3, -1.60415, 1.01961},  {1.35, -1.55117, 1.10315},
	      {1.4, -1.49338, 1.21394},  {1.45, -1.42901, 1.37131},
	      {1.5, -1.35474, 1.62179},  {1.55, -1.26291, 2.12269},
	      {1.6, -1.12081, 4.3739},   {1.65, 1.97603, -0.68029},
	      {1.7, 1.9415, -0.701047},  {1.75, 1.90589, -0.72401},
	      {1.8, 1.86906, -0.749609}, {1.85, 1.83087, -0.778401},
	      {1.9, 1.79115, -0.811127}, {1.95, 1.74968, -0.848793},
	      {2., 1.70617, -0.892811}
16acc87306c02ac06640d38793ff7e34|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/constants.hpp|6|1|V|cpp
	static constexpr double M_PLANK = 1.220910e19;
	static constexpr double RHO_CRIT = 1.05375e-5;
	static constexpr double S_TODAY = 2891.2;
	static constexpr double T_CMB = 2.56215e-10;
	static constexpr double T_BBN = 0.0001; // 0.1 MeV in GeV
	static constexpr double OMEGA_H2_CDM = 0.1198;
f5588f4d7bf1254fb5e38d7d73c72bad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|15|3|V|cpp
	  // Confinement scale
c6869f32e04ba4a93b0bdda0ac1a17d7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|13|3|V|cpp
	  // N in SU(N)
5cb16f34a6a4e00d1d76f83ff7048d95|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|26|1|V|cpp
	  std::optional<double> xi_bbn{}; // xi at BBN
6c977ee7047d6a0e1307601f71296b2b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|28|1|V|cpp
	  std::optional<double> rd_eta{}; // eta relic density
4e073973a8cc5ed5c0d254daad932075|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|30|1|V|cpp
	  std::optional<double> dneff_cmb{}; // delta Neff at CMB
41e0b70f167f36e871514710329d07c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|32|1|V|cpp
	  std::optional<double> eta_si_per_mass{}; // eta SI cross section today
6874f39a3b9a74a95a449252fb857896|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|33|25|v|cpp
	eta_si_per_mass
5d4611c73f6d855a85697255fdedc20d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|85|1|V|cpp
	  double cross_section_2eta_4eta(const double cme) const {
a1d6906293566ca5a748c5c84685a2b7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|93|1|V|cpp
	  double thermal_cross_section_2eta_4eta(const double x) const {
8967c591f24cdc1da9c691ff3694a4c9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|101|1|V|cpp
	  double thermal_cross_section_4eta_2eta(const double x) const {
9a98c3c50ed473b202016f9ad7b75ef7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|109|1|V|cpp
	  double thermal_cross_section_2eta_2del(const double x) const {
76e5f047c62566efda4ab32824c66e41|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|118|1|V|cpp
	  double cross_section_2eta_2eta() const {
11a57a7b82eabc3b8c9b608d99ef61c8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|127|1|V|cpp
	  double cross_section_2del_2del() const {
c63c48809369a5140d7ba5f57dba1ccb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|139|1|V|cpp
	  double neq_eta(const double td) const {
5b0e869809245390328cff1d4e4dad07|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|147|1|V|cpp
	  double neq_del(const double td) const {
1f85541fe0938cbfe9de5fd9d47fd383|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|151|1|V|cpp
	  double dark_heff(const double td) const {
f8a0114ca97469c165aaf6d2742da78e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|155|1|V|cpp
	  double dark_geff(const double td) const {
77e45ba2c2cc38c988458a37d798230e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|159|1|V|cpp
	  double sqrt_gstar(const double tsm, const double xi) const {
9e902aaf4f5c8516d0139aaf3b152969|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|166|1|V|cpp
	  double dark_heff_inf() { return darksun::dark_heff_inf(m_rpar.data()); }
67c01669c03933b9ff181bc1f286451a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|47|26|v|cpp
	{ return darksun::dark_heff_inf(m_rpar.data()); }
496f6827df22cdd0f32acb0bb0032288|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|173|1|V|cpp
	  double dark_sum_g() { return darksun::dark_sum_g(m_rpar.data()); }
306692b99fa311537e54f4efc90732db|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|48|23|v|cpp
	{ return darksun::dark_sum_g(m_rpar.data()); }
a19c19209d5419c9fd2db4e1813699d9|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|178|1|V|cpp
	  std::pair<double, double> xi_bounds_const_td(const double td) const {
6bd79f4309947acb862f2e4e07c08784|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|182|1|V|cpp
	  std::pair<double, double> xi_bounds_const_tsm(const double tsm) const {
5c8a138ffb56d052741ac649c559566a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|190|1|V|cpp
	  double compute_xi_const_td(const double td) const {
5ea8a3067a70eceb04b55875b0823750|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|198|1|V|cpp
	  double compute_xi_const_tsm(const double tsm) const {
2fd8e214b4575de80da8b0b485b9dd04|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/model.hpp|210|1|V|cpp
	  double delta_n_eff_cmb() const {
274cb94c403b30e3dbf63a6eb57d8257|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|50|1|V|cpp
	  //=========================================================================
	  //---- Functions for computing xi = Td / Tsm ------------------------------
	  //=========================================================================
7fcaa56eacb74719979c3e1abc868c09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|38|34|v|cpp
	xi = Td / Tsm
18a2a6ffdecda66898d2377d463963df|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|36|1|V|cpp
	  //=========================================================================
	  //---- Functions for computing Cross Sections -----------------------------
	  //=========================================================================
7466a841abf3e8f522cd507cc88805a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|48|34|v|cpp
	for computing Cross Sections 
b3d6e53f7c260439e66c8266ac77aeb2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|70|10|v|cpp
	Functions for computing xi = Td / Tsm
644b821138dbf30c52a3b3cdcad33312|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1068|1|V|cpp
	double sm_geff(const double tsm) {
1dbef40e903728508859a1dd55f22559|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1083|1|V|cpp
	double sm_heff(const double tsm) {
89a1e08dc4fd0fdfd1119c8224859350|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|1064|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in energy of the standard model at a
	 * temperature tsm.
	 */
	double sm_geff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_GEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_GEFF_0;
	  } else {
	    return SM_GEFF_INF;
	  }
	}
	
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
	 */
	double sm_heff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_HEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_HEFF_0;
	  } else {
	    return SM_HEFF_INF;
	  }
	}
	
	/**
	 * Compute the square-root of gstar of the standard model at a temperature
	 * tsm. This quantity is defined as h/sqrt(g) (1+h/3T dh/dt).
	 */
	double sm_sqrt_gstar(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_SQRT_GSTAR_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_SQRT_GSTAR_0;
	  } else {
	    return SM_SQRT_GSTAR_INF;
	  }
	}
	
	/**
	 * Compute the total energy density of the standard model at a temperature tsm.
	 */
	double sm_energy_density(const double tsm) {
	  using boost::math::pow;
	  return pow<2>(M_PI) / 30.0 * sm_geff(tsm) * pow<4>(tsm);
	}
	
	/**
	 * Compute the total entropy density of the standard model at a temperature tsm.
	 */
	double sm_entropy_density(const double tsm) {
	  using boost::math::pow;
	  return 2.0 * pow<2>(M_PI) / 45.0 * sm_heff(tsm) * pow<3>(tsm);
	}
112b40e4282f2f930efa1ed8a457ff86|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|6|1|V|cpp
	double sm_geff(const double tsm);
89978ad164b23b375123119cecf5c6a0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|11|1|V|cpp
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_GEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_GEFF_0;
	  } else {
	    return SM_GEFF_INF;
	  }
	}
775e49b3cbaaa15ef7b803c92f3fc026|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|16|33|v|cpp
	 {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_HEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_HEFF_0;
	  } else {
	    return SM_HEFF_INF;
	  }
	}
	
b27bfce099a64698672b76683c0b9f04|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|21|39|v|cpp
	 {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_SQRT_GSTAR_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_SQRT_GSTAR_0;
	  } else {
	    return SM_SQRT_GSTAR_INF;
	  }
	}
	
5791d19203db6770079b2b2332c12189|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|25|43|v|cpp
	 {
	  using boost::math::pow;
	  return pow<2>(M_PI) / 30.0 * sm_geff(tsm) * pow<4>(tsm);
	}
	
fa6b734a4e7bf064e423472a37f6bff1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|29|44|v|cpp
	 {
	  using boost::math::pow;
	  return 2.0 * pow<2>(M_PI) / 45.0 * sm_heff(tsm) * pow<3>(tsm);
	}
	
a090b4dd2a2b71a7b78c2b79a899770b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|26|1|V|cpp
	/**
	 * Compute the total entropy density of the standard model at a temperature tsm.
	 */
b7acc8418f3c647c4b3d96acf1abced1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|17|1|V|cpp
	/**
	 * Compute the square-root of gstar of the standard model at a temperature
	 * tsm. This quantity is defined as h/sqrt(g) (1+h/3T dh/dt).
	 */
e54e494183e4305ebb220e33bb654a0a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|6|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in energy of the standard model at a
	 * temperature tsm.
	 */
	double sm_geff(const double tsm);
	
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
	 */
	double sm_heff(const double tsm);
	
	/**
	 * Compute the square-root of gstar of the standard model at a temperature
	 * tsm. This quantity is defined as h/sqrt(g) (1+h/3T dh/dt).
	 */
	double sm_sqrt_gstar(const double tsm);
	
	/**
	 * Compute the total energy density of the standard model at a temperature tsm.
	 */
	double sm_energy_density(const double tsm);
	
	/**
	 * Compute the total entropy density of the standard model at a temperature tsm.
	 */
	double sm_entropy_density(const double tsm);
891dcae94d29071034c49fadfd503c66|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/standard_model.hpp|4|1|V|cpp
	#include <array>
	#include <boost/math/interpolators/cubic_b_spline.hpp>
5fdd2cf6b77283cfbf9de96831024c60|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|11|1|V|cpp
	  static std::array<double, 500> log_eta_cs44;
1dd6c3e27876c3d36050efc32b9dcb78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|4|1|v|cpp
	std::array<double, 500> LOG_ETA_CS44
cf22b1475865dc08358ba940912251ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|6|1|v|cpp
	std::array<double, 500> DarkSun::
05b4a996500da93186ae9138767e1f76|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|176|34|v|cpp
	LOG_ETA_CS66 
4740cf3e06d1845dc40a4d49b3e09f1d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|16|1|V|cpp
	constexpr double LOG_ETA_Z_MIN = 0.60206107706280998056; // log10(4 + 1e-5)
	constexpr double LOG_ETA_Z_MAX = 2.0;
	constexpr double LOG_ETA_Z_STEP = 0.0028014808074893587564;
	// Fitting results for 2eta->4eta for large z (100 < z = cme / meta)
	constexpr double ETA_CS_INTERCEPT44 = -9.744896762121916;
	constexpr double ETA_CS_INTERCEPT66 = -10.667768576761643;
	constexpr double ETA_CS_INTERCEPT46 = -10.206870194730394;
a18ced8174ed87368c2191474bb060de|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|11|1|V|cpp
	private:
	  constexpr double LOG_ETA_Z_MIN = 0.60206107706280998056; // log10(4 + 1e-5)
	  constexpr double LOG_ETA_Z_MAX = 2.0;
	  constexpr double LOG_ETA_Z_STEP = 0.0028014808074893587564;
	  // Fitting results for 2eta->4eta for large z (100 < z = cme / meta)
	  constexpr double ETA_CS_INTERCEPT44 = -9.744896762121916;
	  constexpr double ETA_CS_INTERCEPT66 = -10.667768576761643;
	  constexpr double ETA_CS_INTERCEPT46 = -10.206870194730394;
	  static const std::array<double, 500> log_eta_cs44;
	  static const std::array<double, 500> log_eta_cs66;
	  static const std::array<double, 500> log_eta_cs46;
	
04ecc13044f6713f5de5b2a917b6e135|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|24|1|V|cpp
	const boost::math::cubic_b_spline<double>
0a260b24e4bdd5c4ffe6007647002d05|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|24|1|V|cpp
	const boost::math::cubic_b_spline<double>
	    LOG_ETA_CS44_SPLINE(LOG_ETA_CS44.begin(), LOG_ETA_CS44.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP);
	const boost::math::cubic_b_spline<double>
	    LOG_ETA_CS66_SPLINE(LOG_ETA_CS66.begin(), LOG_ETA_CS66.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP);
	const boost::math::cubic_b_spline<double>
	    LOG_ETA_CS46_SPLINE(LOG_ETA_CS46.begin(), LOG_ETA_CS46.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP);
f8c548825ffc2dc52d9dc306af27c786|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|88|1|V|cpp
	const boost::math::cubic_b_spline<double>;
1b47adf13a090aef218fea08bac25636|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|89|24|v|cpp
	(LOG_ETA_CS44.begin(), LOG_ETA_CS44.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP)
a4e24e3b49757faf69bc2f5422dbb242|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|90|24|v|cpp
	(LOG_ETA_CS66.begin(), LOG_ETA_CS66.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP)
908a69482622b4c4ea5bf3e973bcea0e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|92|24|v|cpp
	(LOG_ETA_CS46.begin(), LOG_ETA_CS46.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP)
7147de168ac08d6b6ad10b83eae6e91d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|88|45|v|cpp
	LOG_ETA_CS44_SPLINE
450e73bf69eb31c10e16f01d5987ff8a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|88|45|v|cpp
	log_eta_cs44_spline
deef9f410a07db6c33c5f918f84e50ab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|89|45|v|cpp
	LOG_ETA_CS66_SPLINE;
f25a9a163c8ecca887a5a640b463d5a3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|90|45|v|cpp
	LOG_ETA_CS46_SPLINE;
cb164fb4729476bc685cabf079023394|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|27|v|cpp
	ETA_CS
cb164fb4729476bc685cabf079023394|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|27|v|cpp
	ETA_CS
cb164fb4729476bc685cabf079023394|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|27|v|cpp
	ETA_CS
488ad7528a915081b9aec9abe393afcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|34|v|cpp
	INTERCEPT
488ad7528a915081b9aec9abe393afcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|34|v|cpp
	INTERCEPT
488ad7528a915081b9aec9abe393afcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|34|v|cpp
	INTERCEPT
6ccf14e03a91fd314ff8b6750cf1d6d0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|78|27|v|cpp
	LOG_ETA_Z_MAX
48fe5369907c8a5854c6f481507bc5a3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|79|27|v|cpp
	LOG_ETA_Z_STEP 
f1d6b7334a10a237b263b5444b009a67|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|76|27|v|cpp
	LOG_ETA_Z_MIN
c121154e6396db57e90ba4ce550b9770|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|38|1|V|cpp
	static double scaled_cs_eta_24_44(double z) {
40dd298883071e0c986344e48347f6c2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|53|1|V|cpp
	static double scaled_cs_eta_24_66(double z) {
6e7fd2bfc028be0839fa43df220b2c7d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|69|1|V|cpp
	  //=========================================================================
	  //---- Solving Boltzman Equation ------------------------------------------
	  //=========================================================================
ea8644bcee071a8ecf711831a43b8cbe|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|77|10|v|cpp
	Solving Boltzman Equation 
8153f6f01a21786bdf2e62a8e3bcb7af|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|98|6|v|cpp
	"darksun/src/model/cs_data.cpp"
b167c4e8a8739c0c5ec57816485df795|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|1|V|cpp
	  // Compute the equillibrium number density of the eta
bec1861a9a8ae970d589484e82c5c2d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|56|1|V|cpp
	  // Compute the effective dof stored in entropy of the dark sector
37a184204b9448f00fb83003d8a6cc69|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|58|42|v|cpp
	entropy
ea61254c9ee8842615fbd0a94f0fedb1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|58|1|V|cpp
	  // Compute the effective dof stored in energy of the dark sector
ebb7fc0567c5d4f5624a7c3b81e46daf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|62|1|V|cpp
	  // Compute the effective dof stored in entropy of the dark sector td ~ inf
b168ce4551e2dc18d0c3594d39438e65|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|64|18|v|cpp
	effective dof stored in entropy of the dark sector td ~ inf
f55c8d0c37a5aaa6ab5d55cb24afa240|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|46|1|V|cpp
	  // Compute the self-interaction cross-section of the delta
864c323849da9e3ec329fbe33ad7cf31|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|45|1|V|cpp
	  // Compute the self-interaction cross-section of the eta
c70a20d6411ed7add5b217986ac12a31|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|44|18|v|cpp
	self-interaction cross-section of the eta
8382540951dbe7d2429a92bf563aa273|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|44|1|V|cpp
	  // Compute the thermal cross section for 2eta -> 2delta
c8af70654f58fc78a09996413c01e16f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|43|52|v|cpp
	2delta
f903ee4b1f3cb67f80d2036b7a9b9ad0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|43|1|V|cpp
	  // Compute the thermal cross section for 4eta -> 2eta
d05e73d904675fe7afc9abc3cf2f8bba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|42|1|V|cpp
	  // Compute the thermal cross section for 2eta -> 4eta
8583a92c03bd112997223a82c48e991b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|48|1|V|cpp
	  // Compute the self-interaction cross-section of the eta
	  double cross_section_2eta_2eta() const;
	  // Compute the self-interaction cross-section of the delta
	  double cross_section_2del_2del() const;
5ad2e4a962234ba468ba092b2e9efc3c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|77|1|V|cpp
	  // Compute the lower and upper bounds of xi assuming td is known
e356fb9e09c1f85714a7c02565d547aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|81|18|v|cpp
	lower and upper bounds of xi assuming td is known
0fce09fae9c165b3635521f4d9b0efb4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|81|1|V|cpp
	  // Compute the xi assuming td is known
5c99e3c783b922dd457455d28c400600|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|9|43|v|cpp
	LOG_ETA_Z_STEP
6709e269fa11877df5247e2417e479cf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|5|1|V|cpp
	const boost::math::cubic_b_spline<double> DarkSun::log_eta_cs44_spline(
	    DarkSun::log_eta_cs44.begin(), DarkSun::log_eta_cs44.end(),
	    DarkSun::log_eta_z_min, DarkSun::log_eta_z_step);
ba537d593410e699d55d0d15b66fece6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|9|1|V|cpp
	const boost::math::cubic_b_spline<double>
	    LOG_ETA_CS66_SPLINE(LOG_ETA_CS66.begin(), LOG_ETA_CS66.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP);
	const boost::math::cubic_b_spline<double>
	    LOG_ETA_CS46_SPLINE(LOG_ETA_CS46.begin(), LOG_ETA_CS46.end(), LOG_ETA_Z_MIN,
	                        LOG_ETA_Z_STEP);
97141496f16d153554bb789aaabce784|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|6|1|V|cpp
	//===========================================================================
1158022ac3674323148cfada17d77fd7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|38|8|v|cpp
	double scaled_cs_eta_24_44(double z) {
	  const double logz = log10(z);
	  if (LOG_ETA_Z_MIN <= logz && logz <= LOG_ETA_Z_MAX) {
	    return std::pow(10.0, LOG_ETA_CS44_SPLINE(logz));
	  } else if (logz >= LOG_ETA_Z_MAX) {
	    return pow(z, 14) * pow(10.0, ETA_CS_INTERCEPT44);
	  } else {
	    return 0.0;
	  }
	}
	
66e1b43bce60c92996866953e00ec370|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|25|7|v|cpp
	log_eta_z_min 
10b7f72ac7a7e62a2abb97df1932dc0e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|25|40|v|cpp
	LOG_ETA_Z_MAX)
261a4861ed533d03447e672e54bbb122|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|28|35|v|cpp
	ETA_CS_INTERCEPT44
39663e483abc8defab7383ee1643dfc7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|22|1|V|cpp
	double DarkSun::scaled_cs_eta_24_44(double z) {
	  const double logz = log10(z);
	  if (log_eta_z_min <= logz && logz <= log_eta_z_max) {
	    return std::pow(10.0, log_eta_cs44_spline(logz));
	  } else if (logz >= log_eta_z_max) {
	    return pow(z, 14) * pow(10.0, eta_cs_intercept44);
	  } else {
	    return 0.0;
	  }
	}
66669ea8538b06c62e4077ff757d6d37|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|6|1|V|cpp
	//===========================================================================
	//---- Define the interpolators ---------------------------------------------
	//===========================================================================
b2a0f5fb145c288949251bdd58a110e1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|23|8|v|cpp
	Define the interpolators
716e056f1fbcb04b04bac86139e7dd4e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|22|1|V|cpp
	//===========================================================================
	//---- Scaled cross-sections valid for all z = cme / meta -------------------
	//===========================================================================
71623ec823c81d46033973c8278a96d4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|61|8|v|cpp
	Scaled cross-sections valid for all z = cme / meta -------------------
b9982236186e3d29fbc166c350918751|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|89|1|V|cpp
	double cross_section_2eta_4eta(const double cme, const double *rpar) {
	  using boost::math::pow;
	  const double mu = get_mu_eta(rpar);
	  const double n = get_n(rpar);
	  const double lam = get_lam(rpar);
	  const double l1 = get_lec1(rpar);
	  const double l2 = get_lec2(rpar);
	
	  // Common prefactos of the cross section terms
	  const double pref = pow<2>((256.0 * pow<4>(M_PI) / 9.0));
	  const double norm = pref * pow<14>(mu) / (lam * lam * pow<11>(n));
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = norm * pow<4>(l1) / 9.0;
	  const double c66 = norm * pow<2>(l2) / 25.0;
	  const double c46 = -2.0 * norm * l2 * pow<2>(l1) / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / get_m_eta(rpar);
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
	}
8bbc734f261951b1089209dd1766fd13|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|63|57|v|cpp
	, const double *rpar) {
9568c9fb99500ed9e48f9d9d367b4ae4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|1|V|cpp
	  const double mu = get_mu_eta(rpar);
	  const double n = get_n(rpar);
	  const double lam = get_lam(rpar);
	  const double l1 = get_lec1(rpar);
	  const double l2 = get_lec2(rpar);
07315fb93deca1003b238486e5afaa76|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|41|34|v|cpp
	Cross Sections -----------------------------
f5ad156b990d8dd4be39147c56210d32|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|44|1|V|cpp
	  double m_eta() const;
c0b7394766a9aaab55399d3ed24687ef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/masses.cpp|5|8|v|cpp
	Darm_eta
ded3ea73ee524dc21f09461bd422a481|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/masses.cpp|6|1|V|cpp
	double DarkSun::m_eta() const{
	  return mu_eta * lam / sqrt(double(n));
	}
c985c467a60f2d70eefe7cf74be422bd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/masses.cpp|11|25|v|cpp
	sqrt(double(n));
064d336ca61b2328a5ca7b8003ebdc93|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|75|26|v|cpp
	get_m_eta(rpar);
c87869d1f42fd3220d5cfb71893eecfe|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|198|1|V|cpp
	double cross_section_2eta_2eta(const double *rpar) {
	  using namespace boost::math;
	
	  // compute dark temperature today in order to compute eta velocity
	  const double Tsm_today = 2.7255 * 8.6173303e-14;
	  const double xi_today = compute_xi_const_tsm(Tsm_today, rpar);
	  const double Td_today = xi_today * Tsm_today;
	
	  const double me = get_m_eta(rpar);
	  const double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
	  const double z2 = 4.0 / (1.0 - vrel * vrel);         // CME^2/meta^2.
	  const double lec1 = get_lec1(rpar);
	  const double mu_eta = get_mu_eta(rpar);
	  const double lam = get_lam(rpar);
	  const double n = get_n(rpar);
	
	  return (pow<2>(lec1) * pow<3>(M_PI) *
	          (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	           21.0 * pow<4>(z2)) *
	          pow<6>(mu_eta)) /
	         (135.0 * pow<2>(lam) * pow<5>(n) * z2);
	}
880ca9ae5770c51bc9a90aea3b0f72dd|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|226|1|V|cpp
	double cross_section_2del_2del(const double *rpar) {
	  using namespace boost::math;
	  const double lam = get_lam(rpar);
	  return 4.0 * pow<3>(M_PI) / pow<2>(lam);
	}
79637bc12836c9fce6e0a32238be0229|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|236|1|V|cpp
	double delta_n_eff_cmb(const double *rpar) {
	  using namespace boost::math;
	  const double xi_cmb = get_xi_cmb(rpar);
	  return 4.0 / 7.0 * pow(11.0 / 4.0, 4.0 / 3.0) *
	         dark_geff(T_CMB * xi_cmb, rpar) * pow<4>(xi_cmb);
	}
ed8bd04029dcf59f92a1f6f75cbf1dba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|87|57|v|cpp
	, rpar);
09d69291000d12fe719916cfc1fe5a9e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|93|3|V|cpp
	  const double lec1 = get_lec1(rpar);
625b82ae216462799348c5cc2679d47a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|93|3|V|cpp
	  const double mu_eta = get_mu_eta(rpar);
27215b856dafff95bed6fa495d9493cc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|93|3|V|cpp
	  const double lam = get_lam(rpar);
262b02ef2ec7b704cdb99e09075f2729|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|93|3|V|cpp
	  const double n = get_n(rpar);
824bfaf6f14c2dd8dd7d3d45e5f7c99f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|60|1|V|cpp
	//===========================================================================
	//---- Zero-temperature cross-sections --------------------------------------
	//===========================================================================
e78e7ace6c06c5dc58f6784ee1705d13|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|106|8|v|cpp
	Zero-temperature cross-sections --------------------------------------
7172acc177b18265a4874cd816134778|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|115|1|V|cpp
	double thermal_cross_section_2eta_4eta(const double x, const double *rpar) {
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double meta = get_m_eta(rpar);
	
	  auto f = [x, &rpar, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, rpar);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 4eta -> 2eta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_4eta_2eta(const double x, const double *rpar) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = get_m_eta(rpar);
	  const double bes = gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = pow<4>(M_PI) * pow<3>(x) / (pow<6>(meta) * pow<4>(bes));
	
	  auto f = [x, &rpar, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, rpar);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
	
	  return pre * integral;
	}
	
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 2delta given a scaled temperature x = meta / T.
	 */
	double thermal_cross_section_2eta_2del(const double x, const double *rpar) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double c = get_c(rpar);
	  const double n = get_n(rpar);
	  const double lam = get_lam(rpar);
	  const double meta = get_m_eta(rpar);
	  const double mdel = get_m_del(rpar);
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double zmin = 2.0 * mdel / meta;
	  const double sig = exp(-2.0 * c * n) / (64.0 * M_PI * n * n * lam * lam);
	
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * sig * integral;
	}
9a0a560d30ca50affd1f2b480914b96a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|131|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 4eta -> 2eta given a scaled temperature x = meta / T.
	 */
6eb8e7ccbdb928c638a4d9a1fe08d8bc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|153|1|V|cpp
	/**
	 * Compute the thermally-averaged annihilation cross section for
	 * 2eta -> 2delta given a scaled temperature x = meta / T.
	 */
cef70330ccacc2dd721db4f5c27e8a06|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|158|2|V|cpp
	  const double c = get_c(rpar);
823c183cacd189a0ebc3c8ee2542c6e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|159|23|v|cpp
	get_m_del(rpar);
d867927f51060af71669d65178b9264c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|142|56|v|cpp
	, rpar
a7456f858dbd600911b6df8f64a46b3a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|118|16|v|cpp
	&rpar, 
f3457a8fc60e406c5df5bccf65b01010|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/cross_sections.hpp|236|1|V|cpp
	double delta_n_eff_cmb(const double *rpar) {
	  using namespace boost::math;
	  const double xi_cmb = get_xi_cmb(rpar);
	  return 4.0 / 7.0 * pow(11.0 / 4.0, 4.0 / 3.0) *
	         dark_geff(T_CMB * xi_cmb, rpar) * pow<4>(xi_cmb);
	}
	
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at BBN.
	 * @return Delta N_eff at BBN
	 */
	double delta_n_eff_bbn(const double *rpar) {
	  using namespace boost::math;
	  const double xi_bbn = get_xi_bbn(rpar);
	  return 4.0 / 7.0 * dark_geff(T_BBN * xi_bbn, rpar) * pow<4>(xi_bbn);
	}
821b219b6243e9c349a783b0ef4dde2a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|9|25|v|cpp
	get_xi_cmb(rpar);
316a726234ae73b0706d6ff60896f64d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|9|41|v|cpp
	std::nan("")
97e000f5ea8964de9935aab3cc615062|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|10|39|v|cpp
	_or(NAN);
e29f9660f293c73d4331329ba7ba0c64|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|12|73|v|cpp
	_cmb
5670f10d889fff0cc0cd3b89fd85e4d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|28|1|V|cpp
	  const double xi_bbn = get_xi_bbn(rpar);
	  return 4.0 / 7.0 * dark_geff(T_BBN * xi_bbn, rpar) * pow<4>(xi_bbn);
529c3c1cafcb629129aedee907e3b876|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|25|23|v|cpp
	get_xi_bbn(rpar);
5c1fa34327a4639705d56cccc338d8d0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|18|4|V|cpp
	/**
	 * Compute the contribution to delta N_eff from the dark SU(N) sector at BBN.
	 * @return Delta N_eff at BBN
	 */
41ed162d4a3a6e8396ccd60ee3f8d1d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|39|1|V|cpp
	  //=========================================================================
	  //---- Functions for computing masses -------------------------------------
	  //=========================================================================
96890650902906f3bebc32c87114fe0a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|112|1|V|cpp
	  double compute_dneff_bbn() const;
42be4b8ac119fdbca84412f04bb4a98c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|7|1|V|cpp
	double DarkSun::delta_n_eff_cmb() const {
4017d2c453b3c1e4d033ec05073ee15a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|7|17|v|cpp
	delta_n_eff_cmb
1b106ead9541d09aa165f15a5d912221|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|18|17|v|cpp
	delta_n_eff_bbn
eae47634bd5d4a703e17b7890a73000e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|22|1|V|cpp
	#include <boost/math/special_functions/pow.hpp>
	#include <boost/math/tools/roots.hpp>
3a71e27597fa9405e8ac853761a9db70|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|25|1|V|cpp
	#include <gsl/gsl_sf_bessel.h>
	#include <gsl/gsl_sf_lambert.h>
609a2203240795c1458046160306ef72|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|27|1|V|cpp
	#include <optional>
ed639111a530858734c58ac92f338d73|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/thermal_functions.hpp|29|1|V|cpp
	namespace darksun {
	
	/**
	 * Compute the equillibrium number density of the eta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_eta(const double td, const double *rpar) {
	  using boost::math::pow;
	  const double x = get_m_eta(rpar) / td;
	  return pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) * gsl_sf_bessel_Kn(2, x);
	}
	
	/**
	 * Compute the equillibrium number density of the delta using the leading order
	 * approximation valid for small temperatures.
	 */
	double neq_del(const double td, const double *rpar) {
	  using boost::math::pow;
	  const double x = get_m_del(rpar) / td;
	  const double g = get_g_del(rpar);
	  return g * pow<3>(td) / (2.0 * pow<2>(M_PI)) * pow<2>(x) *
	         gsl_sf_bessel_Kn(2, x);
	}
	
	double dark_heff(const double td, const double *rpar) {
	  using boost::math::pow;
	  const double xe = get_m_eta(rpar) / td;
	  const double xd = get_m_del(rpar) / td;
	  const double g = get_g_del(rpar);
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  return pre * (pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	                g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd));
	}
	
	double dark_geff(const double td, const double *rpar) {
	  using boost::math::pow;
	  const double xe = get_m_eta(rpar) / td;
	  const double xd = get_m_del(rpar) / td;
	  const double g = get_g_del(rpar);
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  const double geffe =
	      pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) + 3.0 * gsl_sf_bessel_Kn(2, xe));
	  const double geffd =
	      g * pow<2>(xd) *
	      (xe * gsl_sf_bessel_K1(xd) + 3.0 * gsl_sf_bessel_Kn(2, xd));
	  return pre * (geffe + geffd);
	}
	
	double sqrt_gstar(const double tsm, const double xi, const double *rpar) {
	  double gd = dark_geff(tsm * xi, rpar);
	  double gsm = sm_geff(tsm);
	  return sm_sqrt_gstar(tsm) * sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
	}
	
	/**
	 * Compute the degrees-of-freedom in entropy above confinement.
	 */
	static double dark_heff_inf(const double *rpar) {
	  const double n = get_n(rpar);
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	}
	
	/**
	 * Compute the sum of the internal degrees-of-freedom in the energy of the
	 * dark sector below the confinement scaled (i.e. the relativistic d.o.f. of
	 * the eta + delta.)
	 */
	static double dark_sum_g(const double *rpar) { return 2.0 + get_n(rpar); }
	
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
	static auto xi_bounds_const_td(const double td, const double *rpar)
	    -> std::pair<double, double> {
	  const double hd = dark_heff(td, rpar);
	  const double xi_inf = get_xi_inf(rpar);
	  const double cr_rhd = cbrt(dark_heff_inf(rpar) / hd);
	
	  double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	  double ub = cr_rhd * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	static auto xi_bounds_const_tsm(const double tsm, const double *rpar)
	    -> std::pair<double, double> {
	  using boost::math::pow;
	  const double xl = get_m_eta(rpar) / tsm;
	  const double hsm = sm_heff(tsm);
	  const double hdinf = dark_heff_inf(rpar);
	  const double xi_inf = get_xi_inf(rpar);
	  const double sg = dark_sum_g(rpar);
	
	  const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	  const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	  const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	  const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
	double compute_xi_const_td(const double td, const double *rpar) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double hd = dark_heff(td, rpar);
	  const double c1 =
	      dark_heff_inf(rpar) * pow<3>(get_xi_inf(rpar)) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	  // Function specifying when to stop bisection algorithm
	  auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	  // Perform bisection algorith to find xi.
	  const auto bounds = xi_bounds_const_td(td, rpar);
	  const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	  // Return average of the bounding points
	  return (res.second + res.first) / 2.0;
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
	double compute_xi_const_tsm(const double tsm, const double *rpar) {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double tsm_fo = get_tsm_fo(rpar);
	  const bool frozen = tsm_fo < 0.0;
	
	  if (frozen || tsm > tsm_fo) {
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(rpar) * pow<3>(get_xi_inf(rpar)) / SM_HEFF_INF;
	
	    auto f = [c1, &rpar, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, rpar) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, rpar);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
	  } else {
	    // If tsm_fo has a value, that means the eta has frozen out. In this case,
	    // there is no need to perform a root finding algorithm. We just readshift.
	    const double xifo = get_xi_fo(rpar);
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tsm_fo * xifo > get_m_eta(rpar)) {
	      return xifo;
	    } else {
	      return xifo * tsm / tsm_fo;
	    }
	  }
	}
d3abe3ad33c788e07364fd49fa9dbb04|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|11|1|V|cpp
	/** * Compute the equillibrium number density of the eta using the leading order
	 * approximation valid for small temperatures.
	 */
5fc843f09013af08597cb20155a0613a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|17|1|V|cpp
	/**
	 * Compute the equillibrium number density of the delta using the leading order
	 * approximation valid for small temperatures.
	 */
cccf578cfd5e5575a9c27d63d91e45ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|17|20|v|cpp
	get_m_eta(rpar) / td;
f874403f983435a826469d26fdd38ac5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|17|20|v|cpp
	get_m_eta(rpar)
a44f2b1693535d8c90087f8331ef82ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|23|20|v|cpp
	get_m_del(rpar)
a21bc5fa9c6e5742ebee1900d31650aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/masses.cpp|6|1|V|cpp
	double DarkSun::m_eta() const { return mu_eta * lam / sqrt(double(n)); }
	
	double DarkSun::m_del() const { return mu_eta * lam * double(n); }
dcd784ea6516c174b133069c708b9fe1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|43|1|V|cpp
	  // Compute the eta mass
	  double m_eta() const;
	  // Compute the del mass
	  double m_del() const;
ecdb3a8eebbe865eb3b024209a125054|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|40|34|v|cpp
	masses
6fc75390ca5dbddcf275adc8205c941c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|24|20|v|cpp
	get_g_del(rpar);
5d3a969543fdc1fac2873aab3a545b13|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|63|22|v|cpp
	const double *rpar) {
91cc7e207de0c8f45590a5e84bf23543|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|72|51|v|cpp
	get_n(rpar)
f10d90971f45784dd919a805b9221177|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|80|25|v|cpp
	get_xi_inf(rpar);
ea700f4c4b9347b622d3025d2189d9e8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|80|3|V|cpp
	  const double xi_inf = xi_in
347810a9dc84f553183266611a33b4d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|88|52|v|cpp
	 const double *rpar
5ec1dadfd25dd955221a075495dbde51|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|94|3|V|cpp
	  const double xi_inf = get_xi_inf();
ea63ba5f881528cf2ba5b7165770eb75|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|115|42|v|cpp
	(rpar)
7f1584ff8e64f7b79aa9c590b4487f32|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|137|3|V|cpp
	  const double tsm_fo = get_tsm_fo(rpar);
0fd0c49642fe2a56fc10d773c1884624|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|138|23|v|cpp
	tsm_fo < 0.0;
19cb095d5aacf3003001901dfef56f35|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|74|1|V|cpp
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
	auto DarkSun::xi_bounds_const_td(const double td) const
	    -> std::pair<double, double> {
	  const double hd = dark_heff(td);
	  const double cr_rhd = cbrt(dark_heff_inf() / hd);
	
	  double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	  double ub = cr_rhd * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	auto DarkSun::xi_bounds_const_tsm(const double tsm) const
	    -> std::pair<double, double> {
	  using boost::math::pow;
	  const double xl = m_eta() / tsm;
	  const double hsm = sm_heff(tsm);
	  const double hdinf = dark_heff_inf();
	  const double sg = dark_sum_g();
	
	  const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	  const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	  const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	  const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
	double DarkSun::compute_xi_const_td(const double td) const {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double hd = dark_heff(td);
	  const double c1 = dark_heff_inf() * pow<3>(xi_inf) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	  // Function specifying when to stop bisection algorithm
	  auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	  // Perform bisection algorith to find xi.
	  const auto bounds = xi_bounds_const_td(td);
	  const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	  // Return average of the bounding points
	  return (res.second + res.first) / 2.0;
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
	double DarkSun::compute_xi_const_tsm(const double tsm) const {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double tsmfo = get_tsm_fo(rpar);
	  const bool frozen = tsm_fo.has_value();
	
	  if (frozen || tsm > tsm_fo) {
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(rpar) * pow<3>(get_xi_inf(rpar)) / SM_HEFF_INF;
	
	    auto f = [c1, &rpar, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, rpar) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, rpar);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
	  } else {
	    // If tsm_fo has a value, that means the eta has frozen out. In this case,
	    // there is no need to perform a root finding algorithm. We just readshift.
	    const double xifo = get_xi_fo(rpar);
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tsm_fo * xifo > get_m_eta(rpar)) {
	      return xifo;
	    } else {
	      return xifo * tsm / tsm_fo;
	    }
	  }
39668d4f7cad7e3d36d99a745789efab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|74|1|V|cpp
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
	auto DarkSun::xi_bounds_const_td(const double td) const
	    -> std::pair<double, double> {
	  const double hd = dark_heff(td);
	  const double cr_rhd = cbrt(dark_heff_inf() / hd);
	
	  double lb = cr_rhd * cbrt(SM_HEFF_0 / SM_HEFF_INF) * xi_inf;
	  double ub = cr_rhd * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	auto DarkSun::xi_bounds_const_tsm(const double tsm) const
	    -> std::pair<double, double> {
	  using boost::math::pow;
	  const double xl = m_eta() / tsm;
	  const double hsm = sm_heff(tsm);
	  const double hdinf = dark_heff_inf();
	  const double sg = dark_sum_g();
	
	  const double lw_arg_num = pow<2>(45.0 * SM_HEFF_INF * pow<3>(xl));
	  const double lw_arg_den = pow<2>(4.0 * hdinf * hsm * xi_inf) * pow<7>(M_PI);
	
	  const double ub = 2.0 * xl / gsl_sf_lambert_W0(lw_arg_num / lw_arg_den);
	  const double lb = cbrt(hsm * hdinf / sg / SM_HEFF_INF) * xi_inf;
	
	  return std::make_pair(lb, ub);
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
	double DarkSun::compute_xi_const_td(const double td) const {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double hd = dark_heff(td);
	  const double c1 = dark_heff_inf() * pow<3>(xi_inf) / SM_HEFF_INF;
	
	  auto f = [hd, td, c1](double xi) -> double {
	    return hd * pow<3>(xi) - sm_heff(td / xi) * c1;
	  };
	  // Function specifying when to stop bisection algorithm
	  auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	  // Perform bisection algorith to find xi.
	  const auto bounds = xi_bounds_const_td(td);
	  const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	  // Return average of the bounding points
	  return (res.second + res.first) / 2.0;
	}
	
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known standard model temperature.
	 */
	double DarkSun::compute_xi_const_tsm(const double tsm) const {
	  using namespace boost::math;
	  using namespace boost::math::tools;
	
	  const double tsmfo = get_tsm_fo(rpar);
	  const bool frozen = tsm_fo.has_value();
	
	  if (frozen || tsm > tsm_fo) {
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 =
	        hsm * dark_heff_inf(rpar) * pow<3>(get_xi_inf(rpar)) / SM_HEFF_INF;
	
	    auto f = [c1, &rpar, tsm](double xi) -> double {
	      return dark_heff(xi * tsm, rpar) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, rpar);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
	  } else {
	    // If tsm_fo has a value, that means the eta has frozen out. In this case,
	    // there is no need to perform a root finding algorithm. We just readshift.
	    const double xifo = get_xi_fo(rpar);
	    // Check if the eta is relativistic. If it is, its temperature redshifts
	    // like the standard model temperature. Otherwise, it redshifts like
	    // matter.
	    if (tsm_fo * xifo > get_m_eta(rpar)) {
	      return xifo;
	    } else {
	      return xifo * tsm / tsm_fo;
	    }
	  }
	}
e00ec8999c05a3be8291665cf15ab7b9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|1|1|V|cpp
	#include "darksun/model.hpp"
	#include "darksun/standard_model.hpp"
	#include <boost/math/special_functions/pow.hpp>
	#include <boost/math/tools/roots.hpp>
	#include <cmath>
	#include <gsl/gsl_sf_bessel.h>
	#include <gsl/gsl_sf_lambert.h>
	#include <optional>
407f2caec482440e6b1e5f27634e9101|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|6|1|V|cpp
	#include <gsl/gsl_sf_bessel.h>
3153fa3d7022f36fab9ca358318da983|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|60|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in entropy above confinement.
	 */
7292e6b5aefa77272100cf8fc36ef946|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|12|1|V|cpp
	//===========================================================================
	//---- Functions for computing equilibrium number densities -----------------
	//===========================================================================
1a9aee815516de809c841b49b1a9a1c7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|31|8|v|cpp
	Functions for computing equilibrium number densities -----------------
7042f0b2ec4d369cae3b4bb522156440|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|64|1|V|cpp
	double DarkSun::dark_heff_inf() const {
	  return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	}
	
	/**
	 * Compute the sum of the internal degrees-of-freedom in the energy of the
	 * dark sector below the confinement scaled (i.e. the relativistic d.o.f. of
	 * the eta + delta.)
	 */
	double DarkSun::dark_sum_g() const { return 2.0 + double(n); }
b68348116364b4cc3529fddf8f83f4f8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|86|1|V|cpp
	  double DarkSun::dark_heff_inf() const {
	    return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0);
	  }
07deca71043a90aff34272ddd832ba30|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|92|40|v|cpp
	return 2.0 + double(n); 
6915768baa8209b23cecf5d2c590f52b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|87|1|V|cpp
	  /**
	   * Compute the sum of the internal degrees-of-freedom in the energy of the
	   * dark sector below the confinement scaled (i.e. the relativistic d.o.f. of
	   * the eta + delta.)
	   */
	  double DarkSun::dark_sum_g() const { return 2.0 + double(n); }
36ce7c51cc70a8db2c326a260c85e244|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|1|V|cpp
	  // Compute the sum of the internal dof in the dark sector
	  double dark_sum_g() const{return 2.0 + double(n);  }
40559392dccefebb23dcb3af2360ab31|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|83|18|v|cpp
	 &rpar
8c62c44d7336ceee2517d07a7a5baaf1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|81|40|v|cpp
	get_
ece27e9e2c202284de5aaab4497e3c5c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|77|1|V|cpp
	    // The eta hasn't frozen out: assume that it is still in thermal
	    // equillibrium with itself.
	    const double hsm = sm_heff(tsm);
	    const double c1 = hsm * dark_heff_inf() * pow<3>(xi_inf) / SM_HEFF_INF;
	
	    auto f = [c1, this, tsm](double xi) -> double {
	      return dark_heff(xi * tsm) * pow<3>(xi) - c1;
	    };
	    // Function specifying when to stop bisection algorithm
	    auto tol = [](double min, double max) { return abs(max - min) <= 1e-8; };
	
	    // Perform bisection algorith to find xi.
	    const auto bounds = xi_bounds_const_tsm(tsm, rpar);
	    const auto res = bisect(f, 0.8 * bounds.first, 1.2 * bounds.second, tol);
	    // Return average of the bounding points
	    return (res.second + res.first) / 2.0;
8d2432296253a51266dff2a00b010de4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|76|1|V|cpp
	  if (!frozen || tsm > tsm_fo) {
	  } else {
b196f20f76addf41e9513a5869eacdf4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|79|7|V|cpp
	      break;
af4434e45128359fdbb87ed076ccafc1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|82|27|v|cpp
	get_xi_fo(rpar);
178f308df12877f272a11e24e761a29d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|73|3|V|cpp
	  const double tsmfo = get_tsm_fo(rpar);
b87bb1842d54aa990921e6620fb07a46|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|41|1|V|cpp
	/**
	 * Compute the ratio of the dark to standard model bath temperatures,
	 * xi = Td / Tsm, given a known darl sector temperature.
	 */
be570e6983a239bb7660c25a6b3599c1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|10|1|V|cpp
	/**
	 * Compute the lower and upper bounds on xi = Td / Tsm when Td is held fixed.
	 */
bbe6e2f614a044c1afb30f6a6ccbb02d|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|22|1|V|cpp
	  const double x = exp(*logx);
	  const double meta = get_m_eta(rpar);
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm, rpar);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	  double weq = log(neq_eta(td, rpar) / s);
	
	  // Determine if the eta' has frozen out
	  if (we - weq > 0.1 && get_xi_fo(rpar) < 0.0) {
	    set_xi_fo(rpar, xi);
	    set_tsm_fo(rpar, tsm);
	  }
	  // save xi at BBN
	  if (tsm < T_BBN && get_xi_bbn(rpar) < 0.0) {
	    set_xi_bbn(rpar, xi);
	  }
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, rpar);
	  double sigd = thermal_cross_section_2eta_2del(xd, rpar);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	
	  dy[0] = pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
	  dy[1] = pfd * sigd * exp(2.0 * we);
7da5cf4d5c24909b3f285f149834fd26|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|23|25|v|cpp
	get_xi_fo(rpar) < 0.0
e5d87c803cc0ea081eba9128c17c7d28|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|24|5|v|cpp
	set_xi_fo(rpar, xi);
53f250fa427029e755268d0554926831|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|25|5|v|cpp
	set_tsm_fo(rpar, tsm);
a70ed862b15fe59c867f3a5d14415895|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|27|1|V|cpp
	  // save xi at BBN
	  if (tsm < T_BBN && get_xi_bbn(rpar) < 0.0) {
	    set_xi_bbn(rpar, xi);
	  }
0438283b29f2d6aabb1321c209a0d8f6|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|56|1|V|cpp
	  const double x = exp(*logx);
	  const double meta = get_m_eta(rpar);
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm, rpar);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, rpar);
	  double sigd = thermal_cross_section_2eta_2del(xd, rpar);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	  double weq = log(neq_eta(td, rpar) / s);
	
	  double *df[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i) {
	    df[i] = &dfy[i * *ldfy];
	  }
	
	  df[0][0] = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	  df[1][0] = 0.0;
	
	  df[0][1] = 2.0 * pfd * sigd * exp(2.0 * we);
	  df[1][1] = 0.0;
752238b7e34e3df065d458eb2e767977|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|60|1|V|cpp
	    double *df[2];
	    int i;
	    /* set J to first elt. of each column */
	    for (i = 0; i < *n; ++i) {
	      df[i] = &dfy[i * *ldfy];
	    }
083bb92279e7e1d650cf59e579070e74|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|61|7|v|cpp
	[0][0]
47e51370eff62593151146e519afcc9c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|62|7|v|cpp
	[1][0]
f87f0100e5b5ea216eeb26b2692b0373|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|64|7|v|cpp
	[0][1]
b4ba2810ca0a0cf22e911b9722892696|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|65|7|v|cpp
	[1][1]
4dc18b915a33b3adb3f8c8e0f74634f8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|110|1|V|cpp
	  double meta = get_m_eta(rpar);             // Mass of the eta
	  double td = get_lam(rpar) / 2.0;           // Start Td at confinement
	  double xi = compute_xi_const_td(td, rpar); // Starting value of xi
	  double tsm = td / xi;                      // Initial SM temperature
	  double s = sm_entropy_density(tsm);        // Initial SM entropy density
	  log_xstart = log(meta / tsm);              // Log of initial x
	  log_xfinal = log(meta / T_CMB);            // Log of final x (end at CMB)
	
	  y[0] = log(neq_eta(td, rpar) / s); // y[0] is log(Y_eta)
	  y[1] = neq_del(td, rpar) / s;      // y[1] is Y_delta
24cd9db8f3b93eea55537a1df1c90294|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|71|25|v|cpp
	             // Mass of the eta
68c8728a5e67d5576b418e2ee526138f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|72|15|v|cpp
	get_lam(rpar)
39ffccb343639d73a2b83e69c5e50fe7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|80|35|v|cpp
	y[0] is 
3c6cc40beb5cec233ec58ab26a5a8a08|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|81|35|v|cpp
	y[1] is 
834fae18834e3f81b4b34a680bfb7c53|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|31|1|V|cpp
	  double x = 0.0;
	  double xend = 2.0;
	  double dx = 0.05;
	  int mljac = n;
	  int mujac = 0;
	  int mlmas = 0;
	  int mumas = 0;
	  double reltol = 1e-6;
	  double abstol = 1e-6;
	
	  auto rad = Radau5(n, vdpol, jvpol, mas, y, x, xend, dx, abstol, reltol, mljac,
	                    mujac, mlmas, mumas);
	  auto sol = rad.integrate();
702f593bdece47bd8999d586d247035d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|3|V|cpp
	  double x = 0.0;
52f6953dc36c4dd19cf6b543bc2f730a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|3|V|cpp
	  double xend = 2.0;
d5da8cb371c8c43642d6389dfed54c7f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|18|v|cpp
	0.05;
b3cebd50dd987439186ba6b9bf5c5945|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|89|3|V|cpp
	  double abstol = 1e-6;
9364b786d5094d3aa1604c30e1b654fb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|171|1|V|cpp
	    set_rd_eta(rpar, get_m_eta(rpar) * exp(y[0]) * S_TODAY / RHO_CRIT);
	    set_rd_del(rpar, get_m_del(rpar) * y[1] * S_TODAY / RHO_CRIT);
	    set_xi_cmb(rpar, compute_xi_const_tsm(T_CMB, rpar));
	    set_dneff_bbn(rpar, delta_n_eff_bbn(rpar));
	    set_dneff_cmb(rpar, delta_n_eff_cmb(rpar));
	    set_eta_si_per_mass(rpar, cross_section_2eta_2eta(rpar) / get_m_eta(rpar));
	    set_del_si_per_mass(rpar, cross_section_2del_2del(rpar) / get_m_del(rpar));
bb9f0c42bda58903a40ca9e547e9470b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|1|V|cpp
	   rd_eta =  
78c11f0e55887efff899444116b4fcc8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|5|v|cpp
	rpar, get_m_eta(rpar) * exp(y[0]) * S_TODAY / RHO_CRIT
4e97bed3d57c95becb6e17e5982c83ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|95|5|v|cpp
	rpar, get_m_del(rpar) * y[1] * S_TODAY / RHO_CRIT
a8c3c6c1ace1267813606ce7fac45a0f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|96|5|v|cpp
	rpar, compute_xi_const_tsm(T_CMB, rpar)
3fc1e39625013659e6852c01f6f47dc8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|96|13|v|cpp
	 rpar, 
6dd13ef86be6c39e36eed7da04fbd428|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|98|14|v|cpp
	(rpar, 
e75bf4c7ee4512f18ff523ebbe9dcd7b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|96|1|V|cpp
	    xi_cmb =compute_xi_const_tsm(T_CMB);
14a24b333ef4e8a90ff571eb082dcf16|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|100|51|v|cpp
	get_m_eta()
39c68e854897988d9995c46002a71d9e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|1|V|cpp
	    rd_eta = m_eta() * exp(y[0]) * S_TODAY / RHO_CRIT;
	    rd_del = m_del() * y[1] * S_TODAY / RHO_CRIT;
	    xi_cmb = compute_xi_const_tsm(T_CMB);
	    xi_bbn = compute_xi_const_tsm(T_BBN);
	    dneff_bbn = compute_dneff_bbn();
	    dneff_cmb = compute_dneff_cmb();
	    eta_si_per_mass = cross_section_2eta_2eta() / m_eta();
	    del_si_per_mass = cross_section_2del_2del() / m_del();
c1d87818c2f735f48e4031e6d73b3db3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= m_eta() * exp(y[0]) * S_TODAY / RHO_CRIT;
f1fba310d556874d677ec6daf2a0ac03|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= compute_xi_const_tsm(T_BBN);
a0675e2356aaf8f7d77a830f20559231|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= compute_xi_const_tsm(T_CMB);
9dcf4590911cae8dd581c549cf1bfcd7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= compute_dneff_bbn();
a10bf839ab730dc94f54e490a8901b83|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= cross_section_2eta_2eta() / m_eta();
cda5789bf6bfd9e81174c13edcd33fdf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= compute_dneff_cmb();
c97cd861a25d460aec79b70b3e4d7296|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= m_del() * y[1] * S_TODAY / RHO_CRIT;
963ff3196fc1564af678857eb24cef1a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|110|21|v|cpp
	= cross_section_2del_2del() / m_del();
beff72b365459240c6d71116d46c4e9e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|109|24|v|cpp
	computing masses
2c3661b97a1210dfea634a06d52cbddc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|110|1|V|cpp
	  //=========================================================================
	  //---- Functions for delta Neff -------------------------------------------
	  //=========================================================================
08a24591c5e6aa9c95805df20550e235|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|109|10|v|cpp
	Functions for delta Neff -------------------------------------------
5cf31b8d1e61675d2494026d1372d550|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|111|1|V|cpp
	  void boltzmann(double, const Vector<double>&, Vector<double>);
a54fb062112b7cd2de9b6d2d40b3e388|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|10|1|V|cpp
	  auto boltzmann = [this](double logx, const Vector<double> &y,
	                          Vector<double> &dy) {
	    const double x = exp(logx);
	    const double meta = m_eta();
	    const double tsm = meta / x;
	    const double we = y[0]; // log(Yeta)
	
	    double xi = compute_xi_const_tsm(tsm);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	    double weq = log(neq_eta(td) / s);
	
	    // Determine if the eta' has frozen out
	    if (we - weq > 0.1 && !xi_fo.has_value()) {
	      xi_fo = xi;
	      tsm_fo = tsm;
	    }
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd);
	    double sigd = thermal_cross_section_2eta_2del(xd);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi);
	    double pfe = -pf * tsm * s * s;
	    double pfd = pf * meta / (x * x);
	
	    dy[0] = pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
	    dy[1] = pfd * sigd * exp(2.0 * we);
	  };
200195a304c3507ae0b7b5b8ae6e1744|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|9|17|v|cpp
	 = [this]
54a30d80d68957c7657a1ddfc6f4cf56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|41|1|V|cpp
	  auto jacobian = std::optional([this](double logx, const Vector<double> &y,
	                                       Matrix<double> &df) {
	    const double x = exp(logx);
	    const double meta = m_eta();
	    const double tsm = meta / x;
	    const double we = y[0]; // log(Yeta)
	
	    double xi = compute_xi_const_tsm(tsm);
	    double td = xi * tsm;
	    double s = sm_entropy_density(tsm);
	
	    double xd = meta / td;
	    double sige = thermal_cross_section_4eta_2eta(xd);
	    double sigd = thermal_cross_section_2eta_2del(xd);
	
	    double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi);
	    double pfe = -pf * tsm * s * s;
	    double pfd = pf * meta / (x * x);
	    double weq = log(neq_eta(td) / s);
	
	    df(0, 0) = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	    df(0, 1) = 0.0;
	
	    df(1, 0) = 2.0 * pfd * sigd * exp(2.0 * we);
	    df(1, 1) = 0.0;
	  });
6cc6bfb4135ca6495b27221fb2ee0fb5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|39|3|v|cpp
	auto jacobian = std::optional([this]
a6225b55a1606b2fed44aadb815373a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|67|1|V|cpp
	  auto rhs = [this](double logx, const Vector<double> &y, Vector<double> &dy) {
	    boltzmann(logx, y, dy);
	  };
ce4091296bfc61a570d5751baf13fea8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|96|29|v|cpp
	jacobian
4932314947ebfd8cef52be0c4fe01905|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|10|1|V|cpp
	//===
95afc3ba4764f863b615670eef9465d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|8|1|V|cpp
	//===========================================================================
	//---- RHS of the Boltzmann -------------------------------------------------
	//===========================================================================
804bd9f7a401a0e0d2d251e70a3bd128|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|42|1|V|cpp
	//===========================================================================
	//---- Jacobian RHS of the Boltzmann ----------------------------------------
	//===========================================================================
0a544faad6d11d97a7105c84209cf745|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|74|8|v|cpp
	Jacobian RHS of the Boltzmann ----------------------------------------
6e94d81fb1a0abc9e3b3f0b32ffe6db2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|33|33|v|cpp
	+ Log(g) 
6ececb58a51eec667392e7d529c70295|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|33|21|v|cpp
	m_eta()
0ac7fb2a54a661f115dd9fdece426ff7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|30|1|V|cpp
	double DarkSun::weq_eta(const double tsm, const double xi) const {
69e36334cbb9e653228a184274e696e7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|77|1|V|cpp
	  // Compute the log equilibrium number density of the eta / sm entropy density
	  double weq_eta(double tsm, double xi) const;
86f1af78295e6851a8cff337b4c4456c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|30|1|V|cpp
	double DarkSun::weq_eta(const double tsm, const double xi) const {
	  const double td = xi * tsm;
	  const double me = m_eta();
	  const double xd = me / td;
	  return -2.158551414747171 - xd + 3.0 * log(me) - 4.0 * log(tsm) - log(xd) -
	         log(sm_heff(tsm)) + log(gsl_sf_bessel_Knu_scaled(2, xd));
	}
81545461488932b445dbd648c86eece8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|21|1|v|cpp
	
	double DarkSun::weq_eta(const double tsm, const double xi) const {
	  const double td = xi * tsm;
	  const double me = m_eta();
	  const double xd = me / td;
	  return -2.158551414747171 - xd + 3.0 * log(me) - 4.0 * log(tsm) - log(xd) -
	         log(sm_heff(tsm)) + log(gsl_sf_bessel_Knu_scaled(2, xd));
	}
31eded0496190c8f659850c6b85b99e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|1|V|cpp
	  double s = sm_entropy_density(tsm);    // Initial SM entropy density
2a9fc2b05a1e27b877fc7da2e957de49|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|99|10|v|cpp
	log(neq_eta(td) / s)
2b2fcdd27bb00da0af6bd163cbe7034a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|22|16|v|cpp
	log(neq_eta(td) / s);
9b1a74ebef2702c1edcc22685cdd0f6a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|22|1|V|cpp
	  double weq = weq_eta(tsm, xi);
9539adf433b75f042cbca6314ede7552|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|17|1|V|cpp
	  const double we = y[0]; // log(Yeta)
704206d31cae6ac22302b97a260fd9fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|37|22|v|cpp
	tsm * 
a4e5f8030c8d6a0b6e29fc854205bba5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|21|v|cpp
	meta 
aa3e0bca5b75c0e6d48b66b18a8336bb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|40|11|v|cpp
	pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
f0b54960d547fe1bc0d9ace797d0a43a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|40|1|V|cpp
	  dy[0] = -(
	      sigd * (exp(we) - exp(2*we_eq-we+2*wd-2*wd_eq)) +
	      s * s * sige * exp(we) * (exp(2*we) - exp(2*we_eq))
	  );
61b86483beccc0d050937d830f5028c7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|44|1|V|cpp
	  dy[1] = pfd * sigd * exp(2.0 * we);
4cd5258ffb5a4a3ed867feba0edd4f61|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|46|7|V|cpp
	      s * s * sige * exp(we) * (exp(2*we) - exp(2*we_eq))
a2b4746b61f26ef9931c320e285d135a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|3|V|cpp
	  double pfd = pf / x;
0bc63a12a3cba4e30977590eb0b851ad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|37|1|V|cpp
	  double pfe = -pf * s * s;
5518b00051112d2b5adb1ce116146931|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|14|1|V|cpp
	  const double x = exp(logx);
	  const double meta = m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	  const double wd = y[1]; // log(Ydel)
	
	  double xi = compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	  double we_eq = weq_eta(tsm, xi);
	  double wd_eq = weq_del(tsm, xi);
	
	  // Determine if the eta' has frozen out
	  if (we - we_eq > 0.1 && !xi_fo.has_value()) {
	    xi_fo = xi;
	    tsm_fo = tsm;
	  }
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd);
	  double sigd = thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi) * tsm;
	
	  dy[0] = -pf * (sigd * (exp(we) - exp(2 * we_eq - we + 2 * wd - 2 * wd_eq)) +
	                 s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)));
	  dy[1] = pf * sigd * (exp(2 * we - wd) - exp(2 * we_eq + wd - 2 * wd_eq));
b243fda1ba0c97346eed9cbed16f4bdd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|49|1|V|cpp
	  const double x = exp(logx);
	  const double meta = m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd);
	  double sigd = thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	  double weq = log(neq_eta(td) / s);
	
	  df(0, 0) = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	  df(0, 1) = 0.0;
	
	  df(1, 0) = 2.0 * pfd * sigd * exp(2.0 * we);
	  df(1, 1) = 0.0;
d96023ba9460ccba84482bd0714ee9eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|61|1|V|cpp
	  // Determine if the eta' has frozen out
	  if (we - we_eq > 0.1 && !xi_fo.has_value()) {
	    xi_fo = xi;
	    tsm_fo = tsm;
	  }
7801385d4e78a0ab458d04178d165fbb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|67|1|V|cpp
	  df(0, 0) =
	      -pf * (sigd * (exp(we) + exp(2 * we_eq - we + 2 * wd - 2 * wd_eq)) +
	             s * s * sige * exp(we) * (3.0 * exp(2 * we) - exp(2 * we_eq)));
63a38bc8b04459427c33c20ba33233fa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|1|V|cpp
	  dy[0] = -pf * (sigd * (exp(we) - exp(2 * we_eq - we + 2 * wd - 2 * wd_eq)) +
	                 s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)));
b82ff5f1a07297aa811ce23600372be7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|67|3|v|cpp
	df(0, 0)
25b90b2f610909d22063d963598aae53|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|70|3|v|cpp
	dy[0]
b2bee3d9b92f237519f6dab51d61961c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|71|18|v|cpp
	s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq))
e72b0e100ccc40c7befa8a8a7ba4c843|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|72|1|V|cpp
	  dy[1] = pf * sigd * (exp(2 * we - wd) - exp(2 * we_eq + wd - 2 * wd_eq));
881ebb1996becb4189d3f6bd535dffc7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|72|49|v|cpp
	- exp(2 * we_eq + wd - 2 * wd_eq)
93d0a07762129e06b30d9a25f256970f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|73|27|v|cpp
	-1.0 * 
bafdbdd27cd5e8b963679562146d3814|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|13|25|v|cpp
	 model.sol_boltz.xs.size()
388ba5034c018e7d67e9795ce86f3a13|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|56|1|V|cmake
	# --------------------------------------------------------------------------
	# test_radau.cpp: Test the ODE integrator
	# --------------------------------------------------------------------------
	
	add_executable(test_radau test_radau.cpp)
	target_link_libraries(test_radau PUBLIC gtest_main darksun fmt::fmt)
	
	 set_target_properties(test_radau PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
5ec0542c60933c73dc51a8f5ae376a55|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|67|3|v|cmake
	test_radau
f0768e35cb1c73a3eaa1fe996cc7b47b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|52|1|V|cmake
		GSL::gsl
	 	GSL::gslcblas
4b1b03b594b289d03cbbb2348d328e50|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|13|1|v|cmake
	gsl::gsl
408d0185f344a26b3c1616bedeff3391|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/CMakeLists.txt|56|9|v|cmake
	${Boost_LIBRARIES}
effc98e0a6731cce3f1a8bcf1f68b166|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1079|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
	 */
	double sm_heff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_HEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_HEFF_0;
	  } else {
	    return SM_HEFF_INF;
	  }
	}
	
	/**
	 * Compute the square-root of gstar of the standard model at a temperature
	 * tsm. This quantity is defined as h/sqrt(g) (1+h/3T dh/dt).
	 */
	double sm_sqrt_gstar(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_SQRT_GSTAR_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_SQRT_GSTAR_0;
	  } else {
	    return SM_SQRT_GSTAR_INF;
	  }
	}
	
	/**
	 * Compute the total energy density of the standard model at a temperature tsm.
	 */
	double sm_energy_density(const double tsm) {
	  using boost::math::pow;
	  return pow<2>(M_PI) / 30.0 * sm_geff(tsm) * pow<4>(tsm);
	}
	
	/**
	 * Compute the total entropy density of the standard model at a temperature tsm.
	 */
	double sm_entropy_density(const double tsm) {
	  using boost::math::pow;
	  return 2.0 * pow<2>(M_PI) / 45.0 * sm_heff(tsm) * pow<3>(tsm);
	}
4fd73775c42e849289c7183403dafb18|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1075|1|V|cpp
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_HEFF_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_HEFF_0;
	  } else {
	    return SM_HEFF_INF;
	  }
	}
1e3ee3289588127bfe05904bb8de9bc9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1054|1|V|cpp
	static const boost::math::cubic_b_spline<double>
	    SM_GEFF_SPLINE(SM_GEFF_DATA.begin(), SM_GEFF_DATA.end(), SM_LOG_TEMP_MIN,
	                   SM_LOG_TEMP_STP);
	static const boost::math::cubic_b_spline<double>
	    SM_HEFF_SPLINE(SM_HEFF_DATA.begin(), SM_HEFF_DATA.end(), SM_LOG_TEMP_MIN,
	                   SM_LOG_TEMP_STP);
	static const boost::math::cubic_b_spline<double>
	    SM_SQRT_GSTAR_SPLINE(SM_SQRT_GSTAR_DATA.begin(), SM_SQRT_GSTAR_DATA.end(),
	                         SM_LOG_TEMP_MIN, SM_LOG_TEMP_STP);
7e7d34c371812db8a4018e1aa60ad931|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1061|25|v|cpp
	(SM_SQRT_GSTAR_DATA.begin(), SM_SQRT_GSTAR_DATA.end(),
	                         SM_LOG_TEMP_MIN, SM_LOG_TEMP_STP);
f1e24f47062c7240c39025cf8befb099|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1058|19|v|cpp
	(SM_HEFF_DATA.begin(), SM_HEFF_DATA.end(), SM_LOG_TEMP_MIN,
	                   SM_LOG_TEMP_STP);
986736e93752c0d680320f5d0dc69e87|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|1055|19|v|cpp
	(SM_GEFF_DATA.begin(), SM_GEFF_DATA.end(), SM_LOG_TEMP_MIN,
	                   SM_LOG_TEMP_STP);
14792572d86e2ca36209c39e51ecdc70|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|23|1|v|cpp
	    2.141289997868463,
	    2.141641239600222,
	    2.1421099848988665,
	    2.1423743816414347,
	    2.143130008012523,
	    2.144764339392538,
	    2.1478799359327403,
	    2.153398739889584,
	    2.160750058048653,
	    2.1689613911348715,
	    2.180160138904919,
	    2.1962117262554206,
	    2.21692958201033,
	    2.24254151586023,
	    2.273669819788228,
	    2.310986313230254,
	    2.3545702411737506,
	    2.404790106260388,
	    2.4614499278151882,
	    2.524635068320252,
	    2.59387,
	    2.669149116920886,
	    2.7491480369692916,
	    2.8337351026484665,
	    2.9193263461693046,
	    3.003047262981907,
	    3.082637683280093,
	    3.154873274020067,
	    3.2197721598249207,
	    3.277109327543051,
	    3.324389760193869,
	    3.3585530467925744,
	    3.381070287315915,
	    3.390365806392904,
	    3.392520021653115,
	    3.3935581681999984,
	    3.392070064207229,
	    3.3884837204889333,
	    3.3833098959473715,
	    3.3770724967390504,
	    3.3701600913784824,
	    3.362910614940577,
	    3.3559998830690314,
	    3.3503255321275707,
	    3.3455599716392177,
	    3.342062527991385,
	    3.338670057114478,
	    3.3339343961380514,
	    3.329069964436909,
	    3.324891206496724,
	    3.3211499642706412,
	    3.3178337184222757,
	    3.31504997924517,
	    3.3131037469563824,
	    3.3113900091178534,
	    3.309290625724426,
	    3.3071499894038823,
	    3.305118744624142,
	    3.3031600023142444,
	    3.3012462505312565,
	    3.2995,
	    3.297967508466774,
	    3.2968500204808375,
	    3.2964543951763505,
	    3.296510029620001,
	    3.297008762366399,
	    3.2974699902875244,
	    3.297281859445965,
	    3.2968299847495746,
	    3.296327494735112,
	    3.2956800041831307,
	    3.29482436777356,
	    3.293879979861495,
	    3.292894359478376,
	    3.292019993962855,
	    3.291453126194753,
	    3.2911100058200073,
	    3.290979380500434,
	    3.291040002875626,
	    3.291279997353626,
	    3.2916599943550726,
	    3.29220375108024,
	    3.292710005860072,
	    3.2929350041172745,
	    3.2930300006077853,
	    3.2930731257995096,
	    3.2930400011235297,
	    3.2929512495626585,
	    3.2927499973479586,
	    3.2923556209013425,
	    3.2918599944748372,
	    3.2912968693404805,
	    3.2907599952104065,
	    3.290322497780271,
	    3.290080000608429,
	    3.290020628746942,
	    3.290540006356789,
	    3.292180626526222,
	    3.2944899968939008,
	    3.297181878865957,
	    3.3003,
	    3.303301747380361,
	    3.3076598717440273,
	    3.314894760073705,
	    3.324320726317179,
	    3.335240719515547,
	    3.349209522168081,
	    3.3671145918686,
	    3.3902609609837366,
	    3.420821004719461,
	    3.457079776037518,
	    3.49890530832402,
	    3.54372090890585,
	    3.589140811061479,
	    3.6344603954889956,
	    3.6784570671195094,
	    3.720299001616512,
	    3.758177309040611,
	    3.7938006389548744,
	    3.8284426491916834,
	    3.861599583609212,
	    3.8931969021713444,
	    3.9232205549403876,
	    3.9515610464133837,
	    3.9784301950276855,
	    4.003959490712717,
	    4.028309621750078,
	    4.05174021925105,
	    4.074550183025175,
	    4.097100327817213,
	    4.119860231686627,
	    4.143450100893565,
	    4.168540246354692,
	    4.19654993439492,
	    4.230929793700569,
	    4.275960254339784,
	    4.33495033569635,
	    4.405270214635249,
	    4.482479901845056,
	    4.568809784880339,
	    4.67508,
	    4.796808796884228,
	    5.002653119965267,
	    5.411365122564551,
	    5.917438769299523,
	    6.478302290230584,
	    7.179788359703159,
	    7.856429144968539,
	    8.350952119320674,
	    8.564474529235284,
	    8.543100549869138,
	    8.41707118418172,
	    8.298388149814915,
	    8.232150326290455,
	    8.214369993909546,
	    8.22516910148682,
	    8.24773937226796,
	    8.273020828696117,
	    8.297960445243808,
	    8.322710382016718,
	    8.348479657286694,
	    8.376419150066134,
	    8.407119040286302,
	    8.440620649899305,
	    8.476440273693164,
	    8.513870787361697,
	    8.552009395197521,
	    8.589768983891233,
	    8.626480291301597,
	    8.661619376988595,
	    8.694900325066234,
	    8.72643012840514,
	    8.756489466476689,
	    8.785789937649934,
	    8.81486984584274,
	    8.84423014378294,
	    8.874190155626446,
	    8.904810090448695,
	    8.93592996231311,
	    8.967199354899376,
	    8.99818,
	    9.028371810288613,
	    9.057319325098895,
	    9.08465085983787,
	    9.110068455819464,
	    9.133360413774337,
	    9.154419397963792,
	    9.173229107047057,
	    9.1898505436927,
	    9.20435916392654,
	    9.216919932920398,
	    9.227689916575413,
	    9.236850169705635,
	    9.244589944047,
	    9.251090052580713,
	    9.256529771920547,
	    9.261019899345381,
	    9.26478399575956,
	    9.26791005107098,
	    9.270478773838388,
	    9.272599975171541,
	    9.274399958939908,
	    9.275909958633646,
	    9.277190608185332,
	    9.278280007572494,
	    9.27922874950549,
	    9.280059987588558,
	    9.280802495180462,
	    9.281490005351355,
	    9.282147508893267,
	    9.28283000687285,
	    9.283564993863886,
	    9.284459981876887,
	    9.28557623771749,
	    9.287079990771886,
	    9.289083716821338,
	    9.291809947238562,
	    9.295433092478296,
	    9.300209993449117,
	    9.306395870743073,
	    9.31417,
	    9.323730643874415,
	    9.335279699076857,
	    9.34891047879047,
	    9.364701260889584,
	    9.382680356045128,
	    9.402849358492148,
	    9.425148822257064,
	    9.449540889596031,
	    9.475971140037373,
	    9.504369830711155,
	    9.534709737251081,
	    9.566930667901762,
	    9.600959724507804,
	    9.636720323191923,
	    9.674061033635413,
	    9.712799028574947,
	    9.75271133464772,
	    9.793480742350749,
	    9.834748222794437,
	    9.876099469716339,
	    9.917120927003229,
	    9.957360756626844,
	    9.996390715105953,
	    10.03380027179466,
	    10.069300712701187,
	    10.102499492181899,
	    10.133300279847873,
	    10.161400217022496,
	    10.186900352022574,
	    10.209800216138225,
	    10.229998975856804,
	    10.24770015602039,
	    10.262999969576162,
	    10.276199935539697,
	    10.287400049705742,
	    10.29680004431801,
	    10.304700020958572,
	    10.311199992925626,
	    10.316499989148781,
	    10.3208,
	    10.324300186325504,
	    10.326999942569323,
	    10.329200062947745,
	    10.330900110768116,
	    10.332200021143153,
	    10.333199973327032,
	    10.333999964695455,
	    10.334600016913614,
	    10.335000014552058,
	    10.335299998559291,
	    10.335499981553205,
	    10.335700003023437,
	    10.33579999960545,
	    10.33579999885358,
	    10.335900000905022,
	    10.335900000411378,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.33590000090692,
	    10.33579999973006,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.3358,
	    10.335799999457308,
	    10.335799997889367,
	    10.33590000062198,
	    10.33590000050333,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	    10.3359,
	 
228439756946b0eec8b4876275082b22|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|23|1|V|cpp
	   10.3359,
d084f26f10aad4f411cdd08e1d5a2cee|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|24|1|V|cpp
	    static const std::array<double, 341> sqrt_gstar_data;
b8602134d9abdef097a93886f614ea23|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|25|42|v|cpp
	sqrt_gstar_data
5dc7d3bea06ddf32bc6c5eb03e421061|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|30|1|V|cpp
	static const std::array<double, 341> SM_SQRT_GSTAR_DATA;
9ba6f66c4fa62cb107f702021ae3e1d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|32|1|v|cpp
	static constexpr std::array<double, 341> SM_HEFF_DATA = {
	    3.9387999991430975,
	    3.938857495057558,
	    3.939029992374593,
	    3.9394199992353753,
	    3.9400200023255874,
	    3.9405506072828556,
	    3.941929968118308,
	    3.94494124979267,
	    3.949710043121497,
	    3.956211989444685,
	    3.965680111137088,
	    3.978887355858084,
	    3.9971896164213354,
	    4.021680276199021,
	    4.053919806380377,
	    4.0952788395341555,
	    4.147420297837358,
	    4.211901996248075,
	    4.2904098962085415,
	    4.384668913783994,
	    4.49612,
	    4.626378131871737,
	    4.776646154015349,
	    4.9488549981466,
	    5.142435352943627,
	    5.358423489711211,
	    5.593932612798939,
	    5.847619763418146,
	    6.115889630322266,
	    6.396207697398362,
	    6.6840483271625795,
	    6.976314066429208,
	    7.266185734065843,
	    7.546111244160505,
	    7.815192311303785,
	    8.069970597690702,
	    8.310574243364147,
	    8.535986941998477,
	    8.746183651945367,
	    8.940613503447796,
	    9.119837792813225,
	    9.283908135499344,
	    9.43380271729935,
	    9.569917263121496,
	    9.694050888018502,
	    9.808173156742438,
	    9.912168428652636,
	    10.006323138799969,
	    10.091400653807613,
	    10.168033928282645,
	    10.236900653727062,
	    10.298569371753427,
	    10.354000501799236,
	    10.404287602839673,
	    10.449599772715418,
	    10.490381192332134,
	    10.526900177058348,
	    10.5594688453592,
	    10.58839996718056,
	    10.613999995164312,
	    10.6366,
	    10.656493465381608,
	    10.674099602936625,
	    10.689756627239047,
	    10.704001049182839,
	    10.717581635913213,
	    10.730199633881007,
	    10.741824928694447,
	    10.752400349336721,
	    10.76183768691201,
	    10.770199954855684,
	    10.777518766096401,
	    10.783800114717605,
	    10.789000090744732,
	    10.79330003386672,
	    10.796781221388564,
	    10.799699933161406,
	    10.802331233938004,
	    10.804700040501185,
	    10.806875008653277,
	    10.808999972471936,
	    10.811275005499555,
	    10.813600045260483,
	    10.815975038588801,
	    10.818300016744887,
	    10.820481238621866,
	    10.822499969466849,
	    10.824312487950268,
	    10.825900012079304,
	    10.827256263547364,
	    10.828300008036576,
	    10.828918754232735,
	    10.829200000632296,
	    10.829137500666139,
	    10.82890000149907,
	    10.828537501297104,
	    10.828399999572207,
	    10.828649998431738,
	    10.829899997688761,
	    10.83298125926752,
	    10.8374,
	    10.84247481176551,
	    10.849599797974443,
	    10.859644362404321,
	    10.873501180444455,
	    10.891868858517212,
	    10.916199162553223,
	    10.947137901252058,
	    10.987801613397307,
	    11.040500563233637,
	    11.108299560218962,
	    11.195294620029074,
	    11.30070233651235,
	    11.425833620835107,
	    11.568501342145268,
	    11.728079155917563,
	    11.901195582676046,
	    12.084737101847567,
	    12.277303543165111,
	    12.476794260338602,
	    12.682197327310643,
	    12.89221297568728,
	    13.105604088296108,
	    13.321019271606094,
	    13.537501613529102,
	    13.753995579108716,
	    13.969596589460812,
	    14.183902028816686,
	    14.396301710943195,
	    14.60660304413771,
	    14.815202085983392,
	    15.022300865359306,
	    15.229101961195955,
	    15.43689955149194,
	    15.648798857968181,
	    15.870501111953832,
	    16.110201294121016,
	    16.376300821770897,
	    16.673599620998395,
	    17.006299196175366,
	    17.3825,
	    17.81672773105336,
	    18.33088576853192,
	    19.046628608352666,
	    20.09418970490948,
	    21.491230281088864,
	    23.36403554732082,
	    25.78376521823396,
	    28.688107928806346,
	    31.859201234384482,
	    35.017082236799915,
	    37.95437646080889,
	    40.59985045611013,
	    42.98048210407093,
	    45.1544184613274,
	    47.16911033788443,
	    49.052955010384366,
	    50.81965651115024,
	    52.47622896820607,
	    54.02872289866365,
	    55.48438187378059,
	    56.8520614050832,
	    58.14146251402683,
	    59.36252223933174,
	    60.524308447319974,
	    61.63472254490186,
	    62.70008343383558,
	    63.72517263243636,
	    64.71280785221128,
	    65.66488300213246,
	    66.58250904660159,
	    67.466303629751,
	    68.31728492887835,
	    69.13689827598066,
	    69.92729589043422,
	    70.69130364581491,
	    71.4320037480388,
	    72.1526020814846,
	    72.8561991609682,
	    73.54488590248961,
	    74.2203,
	    74.88324012052786,
	    75.53348459632291,
	    76.17032050101513,
	    76.79236111728054,
	    77.39811113614508,
	    77.98558255332685,
	    78.55307191271253,
	    79.09881869347045,
	    79.62116841256307,
	    80.11909720281376,
	    80.5914961419686,
	    81.03780872880081,
	    81.45769679012248,
	    81.85130336155706,
	    82.2188836409303,
	    82.56109186151474,
	    82.8785848751381,
	    83.1724050992544,
	    83.44352077267085,
	    83.69319692342157,
	    83.92260698691331,
	    84.13299398095259,
	    84.32556639998398,
	    84.50160125228153,
	    84.66241852240712,
	    84.80909777955165,
	    84.94282414076376,
	    85.06460094063524,
	    85.17548255405232,
	    85.27650096881764,
	    85.36869968841168,
	    85.45309854098299,
	    85.53062397909167,
	    85.60259963171038,
	    85.67009303896315,
	    85.73479893180316,
	    85.7980431308708,
	    85.8619999216585,
	    85.92846399908225,
	    85.9999,
	    86.07860508870539,
	    86.16729773859703,
	    86.26840352296135,
	    86.38450929083348,
	    86.51800266808385,
	    86.6711950564598,
	    86.84609060310302,
	    87.04440737024345,
	    87.2678098308423,
	    87.5176984811532,
	    87.79529755011251,
	    88.101506466041,
	    88.43719723218507,
	    88.80320336842719,
	    89.19981118597049,
	    89.6272890703168,
	    90.08551563972269,
	    90.5738090901216,
	    91.09117717933043,
	    91.63589283179887,
	    92.20581324930026,
	    92.79821148185921,
	    93.40961158196752,
	    94.03640471213421,
	    94.67441331594091,
	    95.31908974501125,
	    95.96600614539847,
	    96.6104051970725,
	    97.2481091983956,
	    97.8747062252834,
	    98.48636734911523,
	    99.07970553088383,
	    99.651798798897,
	    100.19999716506996,
	    100.723002467506,
	    101.21800247342479,
	    101.68600132623887,
	    102.12499948811279,
	    102.53499909813486,
	    102.918,
	    103.27202083159587,
	    103.59999246212048,
	    103.90200943679265,
	    104.18001990091277,
	    104.43500453334619,
	    104.66699331163939,
	    104.87898979530327,
	    105.07200645631241,
	    105.24800695036602,
	    105.40699912885154,
	    105.5509862321857,
	    105.68100249933426,
	    105.7989991161511,
	    105.90499310101568,
	    106.00000245218065,
	    106.08599798052656,
	    106.16400241159704,
	    106.23300119546467,
	    106.29600090418226,
	    106.35199932091506,
	    106.40199862325085,
	    106.44700082257413,
	    106.48799714828864,
	    106.52400025180003,
	    106.55599937952627,
	    106.58499849434241,
	    106.6109993243235,
	    106.63500017410645,
	    106.65500028587994,
	    106.67400018249637,
	    106.69100006278799,
	    106.70500013594169,
	    106.71899997143262,
	    106.73099994180055,
	    106.74100005011003,
	    106.7510000444878,
	    106.75899970585455,
	    106.7669997052772,
	    106.7729999863407,
	    106.78,
	    106.78500031563006,
	    106.78999988832835,
	    106.79400013564693,
	    106.79799976787382,
	    106.80100005596874,
	    106.80399990941137,
	    106.80700020795435,
	    106.81000008164065,
	    106.81199988652543,
	    106.81399998847277,
	    106.81599998600497,
	    106.8170000167957,
	    106.81799998947737,
	    106.82000001178021,
	    106.82100002714502,
	    106.82199997532162,
	    106.82300003853845,
	    106.82399992987605,
	    106.82400001269836,
	    106.82499998928847,
	    106.82499999515238,
	    106.82599997508082,
	    106.82600001557186,
	    106.82700000124032,
	    106.82699999659057,
	    106.82799998678215,
	    106.828,
	    106.82799999865053,
	    106.82800001211264,
	    106.82899995688712,
	    106.82900000902247,
	    106.829,
	    106.829,
	    106.829,
	    106.82899999919178,
	    106.82900000427776,
	    106.83000000097483,
	    106.83000000669797,
	    106.83,
	    106.83,
	};
054944f63d555ad7848711d524353265|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|34|1|v|cpp
	static constexpr std::array<double, 341> SM_GEFF_DATA = {
	    3.3839699989395835,
	    3.3840487437644517,
	    3.3842699903810276,
	    3.384735624825629,
	    3.3854900038512112,
	    3.3862912280687207,
	    3.3880999598306882,
	    3.3917099989920962,
	    3.3973800518739967,
	    3.405183885849205,
	    3.4164701323918063,
	    3.4321248326801963,
	    3.453609551704515,
	    3.482146469649636,
	    3.519339777655313,
	    3.56667197412332,
	    3.625730336042383,
	    3.6980913883908952,
	    3.7852698853256537,
	    3.8888564215194035,
	    4.0102,
	    4.150794807316553,
	    4.311795892941468,
	    4.494954121810155,
	    4.699976214930413,
	    4.927911218293275,
	    5.176482196900135,
	    5.444893579507091,
	    5.729750258626947,
	    6.029061098885618,
	    6.337818201506156,
	    6.652822969680463,
	    6.9666562245634225,
	    7.271231690587198,
	    7.565352533586669,
	    7.845235954042654,
	    8.110553641754548,
	    8.359949946825193,
	    8.59272403967336,
	    8.807570499056927,
	    9.00494757517125,
	    9.18429186814512,
	    9.347362952209552,
	    9.495029957384766,
	    9.629400961950292,
	    9.752973734862081,
	    9.865448301893807,
	    9.967108712735158,
	    10.058700701881913,
	    10.14078523513029,
	    10.21420069474718,
	    10.2795819076444,
	    10.338100529303755,
	    10.391075108886902,
	    10.438699761340171,
	    10.481537438750442,
	    10.519800185143403,
	    10.553781350015388,
	    10.583799966065143,
	    10.610118744432556,
	    10.6332,
	    10.65343721086418,
	    10.671299597352577,
	    10.687200386274478,
	    10.701701071584862,
	    10.715606640925841,
	    10.728599621802584,
	    10.740662429708268,
	    10.751700366541062,
	    10.761618946103374,
	    10.770399952742551,
	    10.777987514603408,
	    10.784400114885585,
	    10.789543840025653,
	    10.793700032836007,
	    10.797049973942578,
	    10.79979993789156,
	    10.802181234797406,
	    10.804300036285406,
	    10.806275005726231,
	    10.80829997290033,
	    10.810675008065274,
	    10.813200049389502,
	    10.815812542296054,
	    10.818400018605427,
	    10.82083123701361,
	    10.8230999655015,
	    10.825181236330375,
	    10.827000013496429,
	    10.828493764882047,
	    10.829600008371425,
	    10.83021250346392,
	    10.830399998814471,
	    10.830106250382935,
	    10.829600002909952,
	    10.829000001894816,
	    10.828699998716642,
	    10.828868747660579,
	    10.83029999725666,
	    10.834075011178859,
	    10.8395,
	    10.845681023602184,
	    10.854299756293019,
	    10.86640072989741,
	    10.883001405083759,
	    10.904843878232874,
	    10.93379900226057,
	    10.970500500305192,
	    11.019401960977774,
	    11.083906919233751,
	    11.167799453551327,
	    11.27754482503736,
	    11.408502862062473,
	    11.559602804184298,
	    11.726601524068334,
	    11.90507898935648,
	    12.094495202826907,
	    12.293349519026512,
	    12.500103797163375,
	    12.713206829095649,
	    12.93119717296118,
	    13.152519220199826,
	    13.375904265336509,
	    13.599899423093277,
	    13.823501659544904,
	    14.045595477169236,
	    14.265496532622665,
	    14.482602050526342,
	    14.696801721875234,
	    14.908003048983103,
	    15.116602085146253,
	    15.323500863266368,
	    15.529801958508713,
	    15.737699550277814,
	    15.950798846416452,
	    16.176101137251248,
	    16.423301347251392,
	    16.70280087021931,
	    17.019999592881767,
	    17.379599126059833,
	    17.7909,
	    18.270631701571034,
	    18.886282262611214,
	    19.810533868948983,
	    21.014403816051455,
	    22.6405354400298,
	    24.837624307484827,
	    27.677842245112068,
	    31.059624742778315,
	    34.68787520006785,
	    38.20338054032787,
	    41.35827519819795,
	    44.08965109338545,
	    46.459982467376946,
	    48.56451768154225,
	    50.4770155788509,
	    52.240658134062045,
	    53.87705209265294,
	    55.39742647308172,
	    56.8108207705348,
	    58.12718365397002,
	    59.35806532439285,
	    60.51556636614012,
	    61.61151997509638,
	    62.65630760906369,
	    63.65852039676292,
	    64.62468493956084,
	    65.55887499903574,
	    66.46320720601332,
	    67.33858434423519,
	    68.18490835611833,
	    69.00220335949038,
	    69.79048602738794,
	    70.5509983988954,
	    71.28569617578638,
	    71.99760340213557,
	    72.69000351079194,
	    73.3664019579262,
	    74.02969920721264,
	    74.68198661689348,
	    75.3246,
	    75.95773837641659,
	    76.5804852316591,
	    77.19151967954201,
	    77.7886626799343,
	    78.36971067439409,
	    78.93218331877144,
	    79.47377324503925,
	    79.99251772483608,
	    80.48647021574627,
	    80.95449737927565,
	    81.39559641067538,
	    81.80920805965577,
	    82.19539706002443,
	    82.55430305264244,
	    82.88668527392075,
	    83.19329274218097,
	    83.47515986863573,
	    83.73360446463396,
	    83.96989554534252,
	    84.18549735561933,
	    84.38183905931078,
	    84.5602949171765,
	    84.72228550370983,
	    84.86910104011582,
	    85.00213108401348,
	    85.12249818494024,
	    85.23144929178228,
	    85.33000075924294,
	    85.41926354891706,
	    85.50020077443466,
	    85.57379975195202,
	    85.64109883606507,
	    85.70299918661287,
	    85.76089970199104,
	    85.81587440276637,
	    85.86979909693483,
	    85.9241182235268,
	    85.98119992864254,
	    86.04299897252092,
	    86.1122,
	    86.19130520069095,
	    86.28329762412618,
	    86.39070377964339,
	    86.51631012470597,
	    86.66260293703776,
	    86.83179452602216,
	    87.02578955993744,
	    87.2464081995925,
	    87.49491093540041,
	    87.7726983130649,
	    88.08059728588013,
	    88.41940714660666,
	    88.78989694991898,
	    89.19250369915848,
	    89.62731224417233,
	    90.09438807988965,
	    90.59311699253986,
	    91.12260983686882,
	    91.68127541057189,
	    92.26689231034163,
	    92.87691414475941,
	    93.50771219649683,
	    94.15541223413081,
	    94.81550494706401,
	    95.4832138931542,
	    96.15358937333521,
	    96.82140632176937,
	    97.48180530423376,
	    98.13000931202002,
	    98.76170624872508,
	    99.37296751786185,
	    99.9605054543766,
	    100.52199882732157,
	    101.05399726242167,
	    101.55700236082052,
	    102.02800233824621,
	    102.46800124142977,
	    102.87699952549443,
	    103.2549991740175,
	    103.603,
	    103.92201865274248,
	    104.21399332758733,
	    104.48000823751889,
	    104.72101716282664,
	    104.94000388661394,
	    105.13799432822954,
	    105.31599147646948,
	    105.4770053190239,
	    105.62100569611079,
	    105.75099929117114,
	    105.8669889656256,
	    105.97100198200053,
	    106.06399930686312,
	    106.14699461375038,
	    106.22100189569144,
	    106.28699846174712,
	    106.34600184999128,
	    106.39900090036218,
	    106.44600067813667,
	    106.48799949229294,
	    106.52499898682889,
	    106.55800060343306,
	    106.5879979226772,
	    106.61400018729906,
	    106.63799953634835,
	    106.65899893235168,
	    106.67699953292117,
	    106.69400012956741,
	    106.70900020108502,
	    106.72200012724518,
	    106.73400004534686,
	    106.74400008852021,
	    106.75299998107411,
	    106.76199995590956,
	    106.76900003556192,
	    106.77600002823267,
	    106.78099980816616,
	    106.78699977895873,
	    106.79099999165261,
	    106.795,
	    106.79900026472362,
	    106.80299992023633,
	    106.80500009223833,
	    106.80799982062926,
	    106.81000005596869,
	    106.81299992451235,
	    106.81400010944914,
	    106.81600007581007,
	    106.8179998968443,
	    106.81899999519676,
	    106.81999999160291,
	    106.82100002015498,
	    106.82199999210815,
	    106.8230000088352,
	    106.82400003166985,
	    106.82499998354879,
	    106.82500002752529,
	    106.82599991234072,
	    106.82600001269836,
	    106.82699998928847,
	    106.82700000484743,
	    106.82699999003177,
	    106.8280000062294,
	    106.828,
	    106.828,
	    106.82799999471271,
	    106.82900000316936,
	    106.829,
	    106.829,
	    106.829,
	    106.829,
	    106.829,
	    106.82899998195742,
	    106.82999999559071,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
	    106.83,
	};
6de661d375cf76122e1fa4c83b5e92ef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|36|1|V|cpp
	const boost::math::cubic_b_spline<double> SM_GEFF_SPLINE;
	const boost::math::cubic_b_spline<double> SM_HEFF_SPLINE;
	const boost::math::cubic_b_spline<double> SM_SQRT_GSTAR_SPLINE;
a8f2b4d2dda910eb9443f05d6b0f8599|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|35|1|V|cpp
	const boost::math::cubic_b_spline<double>
	    SM_GEFF_SPLINE;
	const boost::math::cubic_b_spline<double> SM_HEFF_SPLINE;
	const boost::math::cubic_b_spline<double> SM_SQRT_GSTAR_SPLINE;
3f9fab7bd37449da456a976526b1c99e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|28|52|v|cpp
	SM_GEFF_SPLINE
641c38c45027fd5fddb8442b56701580|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|29|52|v|cpp
	SM_HEFF_SPLINE
66c7c3676375c646b68b493c7a7ef05b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|30|52|v|cpp
	SM_SQRT_GSTAR_SPLINE
24d90c53fa06fb86798b8da435d964d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|33|1|V|cpp
	  static double sm_geff(const double tsm);
471cc04b8da7198ed71a68f34fa6de2f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|37|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in energy of the standard model at a
	 * temperature tsm.
	 */
	double sm_geff(const double tsm);
	
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
	 */
	double sm_heff(const double tsm);
4fed1ca1625ceb3be3d09ee82ed65788|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|38|1|V|cpp
	/**
	 * Compute the square-root of gstar of the standard model at a temperature
	 * tsm. This quantity is defined as h/sqrt(g) (1+h/3T dh/dt).
	 */
	double sm_sqrt_gstar(const double tsm);
	/**
	 * Compute the total energy density of the standard model at a temperature tsm.
	 */
	double sm_energy_density(const double tsm);
	/**
	 * Compute the total entropy density of the standard model at a temperature tsm.
	 */
	double sm_entropy_density(const double tsm);
2188162fdefa136b0f8881e78a91022c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|9|1|V|cpp
	static constexpr double SM_LOG_TEMP_MIN = -4.5;
	static constexpr double SM_LOG_TEMP_MAX = 4.0;
	static constexpr double SM_LOG_TEMP_STP = 0.025;
31728947cdbac180e6a89905f0754a40|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|5|53|v|cpp
	SM_SQRT_GSTAR_DATA
a61f69d39f4dcdc41c4a786b7930b7f7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|693|31|v|cpp
	SM_GEFF_DATA
3fa4503f79439e28c1c7dbfa48806a5c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|9|1|V|cpp
	static constexpr double SM_SQRT_GSTAR_0 = 2.141289997868463;
	static constexpr double SM_SQRT_GSTAR_INF = 10.3359;
	
	static constexpr double SM_GEFF_0 = 3.3839699989395835;
	static constexpr double SM_GEFF_INF = 106.83;
	
	constexpr double SM_HEFF_0 = 3.9387999991430975;
	constexpr double SM_HEFF_INF = 106.83;
5422d5125fb085828f6204975d4db5dd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|21|1|V|cpp
	  static constexpr double SM_HEFF_0 = 3.9387999991430975;
	  static constexpr double SM_HEFF_INF = 106.83;
65098309b11bd043c6ee57a27353238e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|9|47|v|cpp
	SM_LOG_TEMP_MIN
b6a926008f9b822e05e6594d71925093|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|10|32|v|cpp
	SM_LOG_TEMP_STP
b0807980f9dae9f8606091ea8bb143ba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|9|1|V|cpp
	                               StandardModel::LOG_TEMP_MIN,
	                               StandardModel::LOG_TEMP_STP);
77eea47255c85cf5ca67588e5023ba12|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|14|1|V|cpp
	                               SM_LOG_TEMP_MIN,
	                               SM_LOG_TEMP_STP);
0c49a44ceedc5db6ac0795d3c1ca0160|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|19|1|V|cpp
	                                     SM_LOG_TEMP_MIN, SM_LOG_TEMP_STP);
4e7c67453bd324b33385e72ef160308e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|23|54|v|cpp
	SM_LOG_TEMP_MAX
4690f7ae9c7c532f4dba94ad113dbd09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|25|5|V|cpp
	    return (ltsm);
73a3d0ad8fe510c503d840b6910a067f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|21|1|V|cpp
	double StandardModel::heff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (StandardModel::LOG_TEMP_MIN <= ltsm &&
	      ltsm <= StandardModel::LOG_TEMP_MAX) {
	    return StandardModel::heff_spline(ltsm);
	  } else if (ltsm <= StandardModel::LOG_TEMP_MIN) {
	    return SM_HEFF_0;
	  } else {
	    return SM_HEFF_INF;
	  }
	}
c8b9f8573673104fa039489987ac38c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|37|1|V|cpp
	double sm_sqrt_gstar(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (SM_LOG_TEMP_MIN <= ltsm && ltsm <= SM_LOG_TEMP_MAX) {
	    return SM_SQRT_GSTAR_SPLINE(ltsm);
	  } else if (ltsm <= SM_LOG_TEMP_MIN) {
	    return SM_SQRT_GSTAR_0;
	  } else {
	    return SM_SQRT_GSTAR_INF;
	  }
	}
94b87974d0e6133a72228ed791986d89|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|41|27|v|cpp
	heff_spline
bc28b2c7f3c2911453614d913e37e7c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|43|15|v|cpp
	HEFF_0
58679bcbac0e09af53770af6cfaf6607|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|45|15|v|cpp
	HEFF_INF
949a42f3511f0cce0a36a5afd4070852|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|21|1|V|cpp
	double StandardModel::heff(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (StandardModel::LOG_TEMP_MIN <= ltsm &&
	      ltsm <= StandardModel::LOG_TEMP_MAX) {
	    return StandardModel::heff_spline(ltsm);
	  } else if (ltsm <= StandardModel::LOG_TEMP_MIN) {
	    return HEFF_0;
	  } else {
	    return HEFF_INF;
	  }
	}
8297ffe394b5ef85c9144b121f60dd25|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|37|1|V|cpp
	double StandardModel::sqrt_gstar(const double tsm) {
	  const double ltsm = log10(tsm);
	  if (StandardModel::LOG_TEMP_MIN <= ltsm &&
	      ltsm <= StandardModel::LOG_TEMP_MAX) {
	    return StandardModel::sqrt_gstar_spline(ltsm);
	  } else if (ltsm <= StandardModel::LOG_TEMP_MIN) {
	    return SQRT_GSTAR_0;
	  } else {
	    return SQRT_GSTAR_INF;
	  }
	}
0eba982533513a6f4cb37b137f013911|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|29|1|V|cpp
	/**
	 * Compute the degrees-of-freedom in entropy of the standard model at a
	 * temperature tsm.
be5dc54c6f2590455a045c5f0e6fa40d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|86|22|v|cpp
	sm_heff
f59ce13b89b62e129c734a4240278876|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|3|22|v|cpp
	special_functions
55a847ff16c3f4171da38914ecb1921b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|3|55|v|cpp
	/pow.hpp>
37ef5f40c5229a259307f29146e731a5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|93|1|V|cpp
	  auto mass = std::optional([](const Matrix<double> &) {});
d3935c353b3b74cd8a31f21fadeac6d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|87|1|V|cpp
	//  auto rhs_jac =
	//      std::optional([this](double logx, const Vector<double> &y,
	//                           Matrix<double> &df) { boltzmann_jac(logx, y, df); });
d3d0da10ae9ede3755ba9e8d793ddf70|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|92|1|v|cpp
	//                           
993bff6d867f65590413645bbdf888f4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|92|23|v|cpp
	boltzmann_jac(logx, y, df);
c0240a64e3b174349fab0cbfedb969bc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|91|15|v|cpp
	[this](double logx, const Vector<double> &y,
	Matrix<double> &df) {  }
850240a2187dc747a54c5f6c2b2036f8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|29|v|cpp
	[](const Matrix<double> &) {}
033597241436b26f531f459443d65097|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|40|17|v|cpp
	(sigd * (exp(we) - exp(2 * we_eq - we + 2 * wd - 2 * wd_eq)) +
38b705a08cb6f6e8ef189e0a770fb0af|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|42|3|V|cpp
	  std::cout << "dy[0] = " << dy[0] << ", dy[1] = " << dy[1] << std::endl;
69214ff6d20126fb6f847af39cfe542c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|40|1|V|cpp
	  dy[0] = -pf * s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq));
	  dy[1] = pf * sigd * exp(2 * we);
28a844a87e3041a9bb6ea52996d0a06c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|68|1|V|cpp
	  df(0, 0) =
	      -pf * (0.0 * sigd * (exp(we) + exp(2 * we_eq - we + 2 * wd - 2 * wd_eq)) +
	             s * s * sige * exp(we) * (3.0 * exp(2 * we) - exp(2 * we_eq)));
	  df(0, 1) = -0.0 * pf * sigd *
	             (exp(we) - 2.0 * exp(2 * we_eq - we + 2 * wd - 2 * wd_eq));
	  df(1, 0) = 0.0 * pf * sigd * 2.0 * exp(2 * we - wd);
	  df(1, 1) =
	      -pf * sigd * (exp(2 * we - wd) + 0.0 * exp(2 * we_eq + wd - 2 * wd_eq));
616a52c77c25e1ecd37e779c57bd6670|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|68|1|V|cpp
	  df(0,0) = -pf * s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq));
036ce75f1f5d26b507bda2d44e57a242|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|70|1|V|cpp
	  df(1,0) = pf * sigd * exp(2 * we);
9f5750976cef15f00e831a7af18e1bc0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|69|13|v|cpp
	-pf * s * s * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq));
d3d467641ebb2c017e0569e49937aabb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|71|13|v|cpp
	pf * sigd * exp(2 * we);
b50b7021c6645a898997f28a11b43dc6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|54|3|V|cpp
	  const double wd = y[1]; // log(Ydel)
09a2d1dbf2a90160f8c9627794f28657|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|25|1|V|cpp
	  double wd_eq = weq_del(tsm, xi);
04174f4b7597db97ea20bfc12e15bd09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|101|62|v|cpp
	- adel * n;
6dff8f105b4038970dba68be0edd9c9a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|101|80|v|cpp
	log(
cb5ec0a27947e4cefb0d94214f789c2c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|102|25|v|cpp
	energy_density
96c6eba92841c8beead2adb9292d8d8f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|48|27|v|cpp
	(x * x);
31507116970fa62913d286cef7b2983a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|30|1|V|cpp
	double DarkSun::weq_eta(const double tsm, const double xi) const {
	  const double td = xi * tsm;
	  const double me = m_eta();
	  const double xd = me / td;
	  return -2.158551414747171 - xd + 3.0 * log(me) - 3.0 * log(tsm) - log(xd) -
	         log(StandardModel::heff(tsm)) + log(gsl_sf_bessel_Knu_scaled(2, xd));
	}
	
	double DarkSun::weq_del(const double tsm, const double xi) const {
	  const double td = xi * tsm;
	  const double md = m_del();
	  const double xd = md / td;
	  const double gd = g_del();
	  return -2.158551414747171 + log(gd) - xd + 3.0 * log(md) - 3.0 * log(tsm) -
	         log(xd) - log(StandardModel::heff(tsm)) +
	         log(gsl_sf_bessel_Knu_scaled(2, xd));
	}
dbd7bcd57a546f2694acbfb1c3673b78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|77|1|V|cpp
	  // Compute the comoving number density of the eta.
	  double yeq_eta(double td) const;
ad8efb0c9189e27798ed06ea7a97d6a5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|1|V|cpp
	  return -2.158551414747171 - xd + 3.0 * log(me) - 3.0 * log(tsm) - log(xd) -
	         log(StandardModel::heff(tsm)) + log(gsl_sf_bessel_Knu_scaled(2, xd));
d4b3a537a271d22842b6f878189ae3c0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|36|1|V|cpp
	return (0.11549230036519878*g*pow<3>(me)*
	     Ke(2.,xd))/
	   (Power(E,1.*xd)*heff*pow<3>(tsm)*xd)
dc2e8e472cef7dee9d044328dde5b4e3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|34|3|V|cpp
	  const double xd = me / td;
f6fb8161cbdf89541b0e9f7e3f5ed5a0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|32|3|V|cpp
	  const double td = xi * tsm;
0d40938530807fc35672b2b5318f0a23|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|31|1|V|cpp
	  using boost::math::pow;
	  const double m = m_eta();
	  const double g = 1.0;
	  return (0.11549230036519878 * g * pow<2>(m) * tsm * xi *
	          gsl_sf_bessel_Knu_scaled(2, m / (tsm * xi))) /
	         (exp((m) / (tsm * xi)) * StandardModel::heff(tsm) * pow<3>(tsm));
d08787581a76679bacaf9c698330a817|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|40|1|V|cpp
	  const double td = xi * tsm;
	  const double md = m_del();
	  const double xd = md / td;
	  const double gd = g_del();
	  return -2.158551414747171 + log(gd) - xd + 3.0 * log(md) - 3.0 * log(tsm) -
	         log(xd) - log(StandardModel::heff(tsm)) +
	         log(gsl_sf_bessel_Knu_scaled(2, xd));
4f086d8279fba3e7c5a27118b17b7120|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|34|10|v|cpp
	(0.11549230036519878 * g * pow<2>(m) * tsm * xi *
	          gsl_sf_bessel_Knu_scaled(2, m / (tsm * xi))) /
	         (exp((m) / (tsm * xi)) * StandardModel::heff(tsm) * pow<3>(tsm))
63d76d3c2964de4df734970bd3016902|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|36|5|v|cpp
	Power(E,
96a20b0f73bc59a34d38c0ca648ec4fb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|34|1|V|cpp
	  return (0.11549230036519878 * g * pow<2>(m) * xi *
	          gsl_sf_bessel_Knu_scaled(2, m / (tsm * xi))) /
	         (exp(m / (tsm * xi)) * StandardModel::heff(tsm) * pow<2>(tsm));
2b9eaad69b429d1b8ac33b8c08a5fad1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|43|1|V|cpp
	  return (0.11549230036519878 * g * pow<2>(m) * tsm * xi *
	          gsl_sf_bessel_Knu_scaled(2, m / (tsm * xi))) /
	         (exp((m) / (tsm * xi)) * StandardModel::heff(tsm) * pow<3>(tsm));
42f81c89e227f3553568a87e37b6338a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|42|1|V|cpp
	  const double g = g_del();
24e0d26e2131261709c747e5e43ee760|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|51|20|v|cpp
	g_del();
313e385de96b2f4aef5738ad833a8f8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|52|1|V|cpp
	  return -2.1585514147471714 - m / (tsm * xi) + log(g) -
	         log(StandardModel::heff(tsm)) + 2.0 * log(m) - 2 * log(tsm) + log(xi) +
	         log(gsl_sf_bessel_Knu_scaled(2, m / (tsm * xi)));
9f437b47c1ad606301db99649ba9400b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|62|1|V|cpp
	  return -2.158551414747171 + log(gd) - xd + 3.0 * log(md) - 3.0 * log(tsm) -
	         log(xd) - log(StandardModel::heff(tsm)) +
	         log(gsl_sf_bessel_Knu_scaled(2, xd));
8f3378b80ed9c8664cc7d82ea3f3ce2a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|60|3|V|cpp
	  const double xd = md / td;
ba107c0ab02cb775c815c7d484b2853e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|102|10|V|cpp
	         StandardModel::entropy_density(tsm); // e^(-a*n) * Y_delta
377af66dfb65070bbcb2476a27c57a11|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|924|1|V|cpp
	    std::cout << "Using numerical jac" << std::endl;
73a0c86ac25428728fa74fc7d3ee1d5e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|976|25|v|cpp
	numerical
670f6c83d63d0a807ba06a56414314c3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/diffeq/radau.cpp|976|5|V|cpp
	    std::cout << "Using analytic jac" << std::endl;
d78029adc12598fabc818fd524492896|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|16|1|V|cpp
	  const double x = exp(logx);
	  const double meta = m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = StandardModel::entropy_density(tsm);
	  double we_eq = weq_eta(tsm, xi);
	
	  // Determine if the eta' has frozen out
	  if (we - we_eq > 0.1 && !xi_fo.has_value()) {
	    xi_fo = xi;
	    tsm_fo = tsm;
	  }
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd);
	  double sigd = thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi) * tsm;
bf5b875d5608c12e865ef36c239dd49d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|48|1|V|cpp
	  const double x = exp(logx);
	  const double meta = m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = StandardModel::entropy_density(tsm);
	  double we_eq = weq_eta(tsm, xi);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd);
	  double sigd = thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi) * tsm;
f96ecfcc4539822515c34a012eae78bb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|64|3|V|cpp
	  const bool frozen = tsm_fo.has_value();
9f6c8140b65242acf79cae382335d666|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|7|1|V|cpp
	extern "C" void
	radau_(int *N, void FCN(int *, double *, double *, double *, double *, int *),
	       double *X, double *Y, double *XEND, double *H, double *RTOL,
	       double *ATOL, int *ITOL,
	       void JAC(int *, double *, double *, double *, int *, double *, double *),
	       int *IJAC, int *MLJAC, int *MUJAC,
	       void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	       int *MLMAS, int *MUMAS,
	       void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                   double *, int *, int *),
	       int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK,
	       double *RPAR, int *IPAR, int *IDID);
	
	extern "C" double contra_(int *I, double *S, double *CONT, int *LRC);
	
	extern "C" void radau5_(
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    double *X, double *Y, double *XEND, double *H, double *RTOL, double *ATOL,
	    int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
	
	extern "C" double contr5_(int *I, double *S, double *CONT, int *LRC);
	
	extern "C" void seulex_(
	    int *N, void FCN(int *, double *, double *, double *, double *, int *),
	    int *IFCN, double *X, double *Y, double *XEND, double *H, double *RTOL,
	    double *ATOL, int *ITOL,
	    void JAC(int *, double *, double *, double *, int *, double *, double *),
	    int *IJAC, int *MLJAC, int *MUJAC,
	    void MAS(int *n, double *am, int *lmas, int *rpar, int *ipar), int *IMAS,
	    int *MLMAS, int *MUMAS,
	    void SOLOUT(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int *IOUT, double *WORK, int *LWORK, int *IWORK, int *LIWORK, double *RPAR,
	    int *IPAR, int *IDID);
	
	extern "C" void contex_(int *II, double *X, double *RC, double *LRC, double *IC,
	                        double *LIC);
8b0468ff502c36db08b2811d79edcc41|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|4|1|V|cpp
	//===========================================================================
	//---- Fortran Functions for Radau and Seulex -------------------------------
	//===========================================================================
a3b59c0ec04c7b10a1d48d476c3be67c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|59|8|v|cpp
	Fortran Functions for Radau and Seulex -------------------------------
8092ecda9fb53580c274110d0f98276a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|56|1|V|cpp
	void radau(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
	  int N = n;
a72ce6010b1e7742fb29c2e1f175b928|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|73|3|V|cpp
	  int N = n;
db3772e3260408ec67014969a92d7e1b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|133|1|V|cpp
	void radau5(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
fac9662ead7a2ab3dc982daca50763a3|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|204|1|V|cpp
	void seulex(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    int ifcn, double x, double *y, double xend, double h, double rtol,
	    double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
f52c3fa389a7acba1278f1a2d606c58b|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|278|1|V|cpp
	void contex(int *II, double *X, double *RC, double *LRC, double *IC,
	            double *LIC);
30591eb03095b4f27547ed69d53c81c7|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|281|1|V|cpp
	double contra(int i, double s, double *cont, int *lrc) {
65e8a820d589b43ba5e80d5ba9c2c1da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|288|1|V|cpp
	double contr5(int i, double s, double *cont, int *lrc) {
4b519d3b40b95c12d7883f92ec99138d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|96|1|V|cpp
	double contra(int i, double s, double *cont, int *lrc);
6e3649af7f42ec0c44deca99699c4b7f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|98|1|V|cpp
	double contr5(int i, double s, double *cont, int *lrc);
ef90bfc8285dba79ec946b9f6883132c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|58|1|V|cpp
	//---- Interface to fortran functions ---------------------------------------
0a1ff1cf74159fbf54fb9f0e074f451c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|62|8|v|cpp
	Interface to fortran functions ---------------------------------------
3faefc35ea26c58547e2958f1c9a6981|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|62|1|V|cpp
	//---- Order-switching Radau ------------------------------------------------
46bfbf0fbded0c315dbd88a1b238ecce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|78|8|v|cpp
	Order-switching Radau ------------------------------------------------
8a524f9ee0944cff7801656246e5abff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|78|1|V|cpp
	//---- Fixed-order Radau ----------------------------------------------------
d6ef78e52e0586c2a110a35c181824b7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|94|8|v|cpp
	Fixed-order Radau ----------------------------------------------------
d64bf61f004339243163f9902368b774|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/stiff.hpp|56|1|V|cpp
	void radau(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int nsmax = iwork[11];
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  if (nsmax == 0)
	    nsmax = 7;
	
	  /* allocation of workspace */
	
	  int LWORK = n * (ljac + lmas + nsmax * le + 3 * nsmax + 3) + 20;
	  int LIWORK = (2 + (nsmax - 1) / 2) * n + 20;
	
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  radau_(&N, fcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC, &MLJAC,
	         &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT, WORK.data(), &LWORK,
	         IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
	}
	
	void radau5(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  /* allocation of workspace */
	  int LWORK = n * (ljac + lmas + 3 * le + 12) + 20;
	  int LIWORK = 3 * n + 20;
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  radau5_(&N, fcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC, &MLJAC,
	          &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT, WORK.data(),
	          &LWORK, IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
	}
	
	void seulex(
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    int ifcn, double x, double *y, double xend, double h, double rtol,
	    double atol,
	    void jac(int *, double *, double *, double *, int *, double *, double *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *NR, double *XOLD, double *X, double *Y, double *RC,
	                double *LRC, double *IC, double *LIC, int *N, double *RPAR,
	                int *IPAR, int *IRTRN),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid) {
	
	  int N = n;
	  double X = x;
	  double XEND = xend;
	  double H = h;
	  /* we have scalar tolerances */
	  int ITOL = 0;
	  double RTOL = rtol;
	  double ATOL = atol;
	
	  int IJAC = ijac;
	  int MLJAC = mljac;
	  int MUJAC = mujac;
	
	  int IMAS = imas;
	  int MLMAS = mlmas;
	  int MUMAS = mumas;
	
	  int IOUT = iout;
	
	  int ljac, lmas, le;
	
	  /* computing the size of the working arrays */
	
	  if (mljac == n) { /* full jacobian */
	    ljac = n;
	    le = n;
	  } else { /* banded case */
	    ljac = mljac + mujac + 1;
	    le = 2 * mljac + mujac + 1;
	  }
	
	  if (imas == 0) /* no mass */
	    lmas = 0;
	  else if ((mlmas = n)) /* full mass */
	    lmas = n;
	  else /*banded mass */
	    lmas = mlmas + mumas + 1;
	
	  /* allocation of workspace */
	  int LWORK = n * (ljac + lmas + 3 * le + 12) + 20;
	  int LIWORK = 3 * n + 20;
	  std::vector<double> WORK(LWORK);
	  std::vector<int> IWORK(LIWORK);
	
	  /* copy parameters */
	  for (le = 0; le < 20; ++le) {
	    WORK[le] = work[le];
	    IWORK[le] = iwork[le];
	  }
	
	  seulex_(&N, fcn, &ifcn, &X, y, &XEND, &H, &RTOL, &ATOL, &ITOL, jac, &IJAC,
	          &MLJAC, &MUJAC, mas, &IMAS, &MLMAS, &MUMAS, solout, &IOUT,
	          WORK.data(), &LWORK, IWORK.data(), &LIWORK, rpar, ipar, idid);
	
	  /* copy results */
	  for (le = 0; le < 20; ++le) {
	    work[le] = WORK[le];
	    iwork[le] = IWORK[le];
	  }
	}
	
	void contex(int *II, double *X, double *RC, double *LRC, double *IC,
	            double *LIC);
	
	double contra(int i, double s, double *cont, int *lrc) {
	  int I = i;
	  double S = s;
	
	  return contra_(&I, &S, cont, lrc);
	}
	
	double contr5(int i, double s, double *cont, int *lrc) {
	  int I = i;
	  double S = s;
	
	  return contr5_(&I, &S, cont, lrc);
	}
a550af1a2c24c09e4cd18cb52c5e3be8|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|20|1|V|cpp
	void boltzmann(int *, double *logx, double *y, double *dy, double *rpar,
	               int *ipar) {
6c4293d0d6e7a7efc91302e6139d6457|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|22|1|V|cpp
	  const double x = exp(*logx);
	  const double meta = get_m_eta(rpar);
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm, rpar);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	  double weq = log(neq_eta(td, rpar) / s);
	
	  // Determine if the eta' has frozen out
	  if (we - weq > 0.1 && get_xi_fo(rpar) < 0.0) {
	    set_xi_fo(rpar, xi);
	    set_tsm_fo(rpar, tsm);
	  }
	  // save xi at BBN
	  if (tsm < T_BBN && get_xi_bbn(rpar) < 0.0) {
	    set_xi_bbn(rpar, xi);
	  }
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, rpar);
	  double sigd = thermal_cross_section_2eta_2del(xd, rpar);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * tsm / x;
	
	  dy[0] = pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
	  dy[1] = pfd * sigd * exp(2.0 * we);
611a0dbbe6b14e6eb442339f74a89194|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|16|23|v|cpp
	get_m_eta
fe7e90cf2706d291907c694b03f71925|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|16|23|v|cpp
	(rpar);
bf8e5e8cee4f29d25c4aed57df588073|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|16|v|cpp
	log(neq_eta(td, rpar) / s);
ce59083e18c309331cfe6837fd23a26c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|28|25|v|cpp
	get_xi_fo(rpar) < 0.0) {
d24c906304e4b8fb26a364f52feee9b2|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|54|1|V|cpp
	void boltzmann_jac(int *n, double *logx, double *y, double *dfy, int *ldfy,
	                   double *rpar, double *) {
	  const double x = exp(*logx);
	  const double meta = get_m_eta(rpar);
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm, rpar);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, rpar);
	  double sigd = thermal_cross_section_2eta_2del(xd, rpar);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	  double weq = log(neq_eta(td, rpar) / s);
	
	  double *df[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i) {
	    df[i] = &dfy[i * *ldfy];
	  }
	
	  df[0][0] = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	  df[1][0] = 0.0;
	
	  df[0][1] = 2.0 * pfd * sigd * exp(2.0 * we);
	  df[1][1] = 0.0;
	}
58f73e889c6935ff5360f5c875070c8e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|1|V|cpp
	  const double x = exp(*logx);
	  const double meta = gmodel.m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = gmodel.compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = StandardModel::entropy_density(tsm);
	  double weq = gmodel.weq_eta(tsm, xi);
	
	  // Determine if the eta' has frozen out
	  if (we - weq > 0.1 && !gmodel.tsm_fo.has_value()){
	    gmodel.xi_fo = xi;
	    gmodel.tsm_fo = tsm;
	  }
	
	  double xd = meta / td;
	  double sige = gmodel.thermal_cross_section_4eta_2eta(xd);
	  double sigd = gmodel.thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * gmodel.sqrt_gstar(tsm, xi);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * tsm / x;
	
d33eb9213f0d6e652588d69cc4ced152|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|47|1|V|cpp
	  const double x = exp(*logx);
	  const double meta = get_m_eta(rpar);
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = compute_xi_const_tsm(tsm, rpar);
	  double td = xi * tsm;
	  double s = sm_entropy_density(tsm);
	
	  double xd = meta / td;
	  double sige = thermal_cross_section_4eta_2eta(xd, rpar);
	  double sigd = thermal_cross_section_2eta_2del(xd, rpar);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	  double weq = log(neq_eta(td, rpar) / s);
	
1477afd631e15348be25d69daad61ed7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|57|1|V|cpp
	  // Determine if the eta' has frozen out
	  if (we - weq > 0.1 && !gmodel.tsm_fo.has_value()){
	    gmodel.xi_fo = xi;
	    gmodel.tsm_fo = tsm;
	  }
cda3fa31d6db441161fa64a977543626|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|29|1|V|cpp
	  std::optional<double> xi_fo{};           // xi when eta freezes
	  std::optional<double> tsm_fo{};          // SM temp when eta freezes
	  std::optional<double> xi_cmb{};          // xi at CMB
	  std::optional<double> xi_bbn{};          // xi at BBN
	  std::optional<double> rd_eta{};          // eta relic density
	  std::optional<double> rd_del{};          // delta relic density
	  std::optional<double> dneff_cmb{};       // delta Neff at CMB
	  std::optional<double> dneff_bbn{};       // delta Neff at BBN
	  std::optional<double> eta_si_per_mass{}; // eta SI cross section today
	  std::optional<double> del_si_per_mass{}; // delta SI cross section today
	  std::optional<OdeSolution> sol_boltz{};  // solution to boltzmann equation
eaf027e1c8d6c18b7b29d4df379f49e6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};           
9287410e4ec60a06e06f05f746fe6001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};          
9287410e4ec60a06e06f05f746fe6001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};          
9287410e4ec60a06e06f05f746fe6001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};          
9287410e4ec60a06e06f05f746fe6001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};          
c942d001e998f47bfee2183f99508586|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};       
c942d001e998f47bfee2183f99508586|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};       
9287410e4ec60a06e06f05f746fe6001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};          
3ca63e01fc82a60362504ab459915af7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{}; 
f3597701bb6be126dd363e43ea8acde7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{};  
3ca63e01fc82a60362504ab459915af7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	{}; 
e8721e88a29af95a5e3843f56dfdf599|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	delta 
e8721e88a29af95a5e3843f56dfdf599|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	delta 
a5dc9370d5323c26b45d6266f87e0e48|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	solution 
e8721e88a29af95a5e3843f56dfdf599|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	delta 
e8721e88a29af95a5e3843f56dfdf599|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	delta 
320e95b97355d8d13fcee4addb877ac8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	when 
c0c8f7bf1e74b7f24549faa31d0a15cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	relic 
c0c8f7bf1e74b7f24549faa31d0a15cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	relic 
706fdadcaedff7426f522691eb678f72|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	Neff 
706fdadcaedff7426f522691eb678f72|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	Neff 
8603050c8b1310c430288bbe95b51dbe|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	when eta freezes
23017ebb479ceef6ac817b3e918f75f8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	eta freezes
35f3675343000d6bb5f10ce451a571a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	density
35f3675343000d6bb5f10ce451a571a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	density
ef9345f4fb8c659804e30927ef406a0d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	at BBN
9946c6c7e14bc23aab125f0f3f15346f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	at CMB
d9b30889bed48f8703a878c3e6c8da8c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	cross section today
d9b30889bed48f8703a878c3e6c8da8c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	cross section today
a489610ab7b612c3aafbbb3314356897|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|53|12|v|cpp
	boltzmann equation
02ee8f8f4d739a3fea4ca94e6a71b41b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|43|8|v|cpp
	.clear();
685fbcc17aafd0f9a1f9b3f856ed7443|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|80|3|V|cpp
	  DarkSun model{10, 1e-3};
e342e0f189416ba93494c347a4d78055|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|79|26|v|cpp
	TestBM
33a217c96fdedefdaec32715b953d066|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|88|1|V|cpp
	void mm(int *n, double *am, int *lmas, int *rpar, int *ipar){};
2e50f503e214cc4129975e0ef6f47111|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|89|1|V|cpp
	void solout(int *nr, double *xold, double *x, double *y, double *cont, int *lrc,
	            int *n, double *rpar, int *ipar, int *irtrn) {
	  double dx = get_dxout(rpar);
	  double d = get_xout(rpar);
	  double yd[2];
	  if (*nr == 1) {
	    d = *xold;
	  }
	  while ((*xold <= d) && (*x >= d)) {
	    int len = *ipar;
	    yd[0] = contra(1, d, cont, lrc);
	    yd[1] = contra(2, d, cont, lrc);
	    solution_push_back(rpar, ipar, d, yd[0], yd[1]);
	
	    d += dx;
	  }
	  set_xout(rpar, d);
	};
15d343fd6db61d3dbb9059c7e27bcb84|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|84|15|v|cpp
	get_dxout(rpar);
7868fe30b80a3a973c5aecb36ed01e86|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|85|14|v|cpp
	get_xout(rpar);
5b532a5bb3f75cda706e7117ef87ea33|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|95|5|V|cpp
	    solution_push_back(rpar, ipar, d, yd[0], yd[1]);
50be22947af9a696bb6dc9baa401a752|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|99|3|V|cpp
	  set_xout(rpar, d);
99abc15a918f76f312edf201a2e8dda1|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|123|1|V|cpp
	  clear(rpar, ipar); // Reset the values which will be set during integration
	
	  gsl_set_error_handler_off(); // Turn off the gsl errors
	
	  double log_xstart;        // Log of initial x
	  double log_xfinal;        // Log of final x (end at CMB)
	  std::vector<double> y(2); // Storage for the solution
	  set_diffeq_params(rpar, y.data(), log_xstart, log_xfinal);
	
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-7;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	
	  size_t num_xs = SOL_SIZE - 1; // Number of points in solution
	  set_dxout(rpar, (log_xfinal - log_xstart) / double(num_xs));
	  // Extract the model parameters and put then in rpar and ipar
	
	  radau(nd, boltzmann, log_xstart, y.data(), log_xfinal, 1e-6, rtol, atol,
	        boltzmann_jac, ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout,
	        work.data(), iwork.data(), rpar, ipar, &idid);
	
	  // Add on final solution to the end of the solution
	  solution_push_back(rpar, ipar, log_xfinal, y[0], y[1]);
0ef0bb1bb43a58cf1f6b1131d19b222f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|113|1|V|cpp
	  clear(rpar, ipar); // Reset the values which will be set during integration
	
	  gsl_set_error_handler_off(); // Turn off the gsl errors
	
	  double log_xstart;        // Log of initial x
	  double log_xfinal;        // Log of final x (end at CMB)
	  std::vector<double> y(2); // Storage for the solution
dc013a29b5567d25b2f1951af87c6a7c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|123|3|V|cpp
	  set_diffeq_params(rpar, y.data(), log_xstart, log_xfinal);
b4bf17f35190bb720d615f60edc71fde|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|120|10|v|cpp
	log(neq_eta(td, rpar) / s); // y[0] is log(Y_eta)
b1049c3c3f6c90776d78067e17963ab1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|121|10|v|cpp
	neq_del(td, rpar) / s;      // y[1] is Y_delta
d6db57acbdbe707dc4ece5e9262b66d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|150|3|V|cpp
	  size_t num_xs = SOL_SIZE - 1; // Number of points in solution
cae38a5f739c45819677d5e9a8f0423a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|150|3|V|cpp
	  set_dxout(rpar, (log_xfinal - log_xstart) / double(num_xs));
95184dd4a477dc6fc2119a5e62025001|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|158|1|V|cpp
	  // Add on final solution to the end of the solution
	  solution_push_back(rpar, ipar, log_xfinal, y[0], y[1]);
051c8546c9cf30e436c6f7672615726c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|103|3|V|cpp
	  clear(rpar, ipar); // Reset the values which will be set during integration
4aab9b77dd37bfc7bb906093f693dd2a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|101|1|V|cpp
	void solve_boltzmann() {
c8622081135ec5201d7cea193e7b4283|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|1|V|cpp
	std::vector<double> f_logxs;
df0e43ee75bfeaba7b73680c2aa8f84f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|19|23|v|cpp
	logxs;
d459813313df373fd1dc6330eb1247c7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|1|V|cpp
	static constexpr size_t num_sols = 100;
e086bbbdf2981e3944a6e3bda542fdda|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|99|5|V|cpp
	    fmt::print("logx = {}, we = {}, yd = {}", d, yd[0], yd[1]);
10b4afbc751af3cbd8145f6f6772897e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|100|1|V|cpp
	    f_wes.push_back(yd[0]);
eddb7996f52bf1a367d295b5dcb4df9e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|110|1|V|cpp
	  f_logxs.reserve(num_sols);
15e19a3b4c3d5111a47ef33c2e209e24|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|176|1|V|cpp
	  for (size_t i = 0; i < sol.xs.size(); i++) {
	    fmt::print("logx = {}, we = {}, wd = {}\n", sol.xs[i], sol.ys[i](0),
	               sol.ys[i](1));
	  }
aa3b9943025907630dfe7660451552b3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|181|26|v|cpp
	sol.xs.size()
1370da9f354ef79565efc4138ea541d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|182|49|v|cpp
	sol.xs[i]
d909dae0dbe4d63e2cddf46cefd87f0d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|182|61|v|cpp
	sol.ys[i](0),
783c860fe9f0517668ee7927e3ed88a6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|183|16|v|cpp
	sol.ys[i](1));
01bc6f8efa4202821e95f4fdf6298b30|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|178|10|v|cpp
	clear
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
fa54decef10544882e67d92527b80686|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|20|v|cpp
	.reset();
7935f49acae9e246b5052f687d05f817|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|125|3|V|cpp
	  double s = StandardModel::entropy_density(tsm); // Initial SM entropy density
eea7ddc6270d05262e5c31cab2a40085|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/include/darksun/boltzmann.hpp|69|1|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, rpar);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
7f34e18e0678b9785c20843fd6b819fb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|62|1|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi) * tsm;
3cb04515e49fe903eb719fea58d0c807|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|67|7|v|cpp
	-pf * s * s
cbdbf3e8b15107c47038496b9cb604cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|69|14|v|cpp
	2.0 * pf / x
915f83dec6f96e14e8d2a07fa72bfadf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|62|1|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
31331f734c7d6b2120abbed0c01fb667|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|41|15|v|cpp
	/ x 
792cef4ad623c0a5f95279447ef90cb4|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.f|6|49|v|fortran
	RPAR,IPAR
548cef87e655728344929f9219ea62c1|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.f|393|7|V|fortran
	      USE ISO_C_BINDING, ONLY : C_PTR
950a3b9951bd3bd5dd8d0517ef08c2a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.f|393|12|v|fortran
	c_ptr
c8efd583d5e28b5f3825f98a18efddc6|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.f|393|34|v|fortran
	c_object
9b1523ed88f11b854cd0f18247e7ffe5|file:///Users/loganmorrison/.config/nvim/init.vim|66|1|V|vim
	Plug 'rudrab/vimf90'
67e8077b44c87944a2d75db2bd7ee7ff|file:///Users/loganmorrison/Documents/coding/fortran/tutorial/math.f90|1|1|V|fortran
	module MyMath
	
	end module MyMath
c0cbbff53e481fdd64409a7a640215a8|file:///Users/loganmorrison/Documents/coding/fortran/c_fortran_interface/fortran/lib.f|5|1|V|fortran
	  interface
	    subroutine cfun(x) bind(c)
	      use, intrinsic :: iso_c_binding
	      real (kind = c_double), value :: x
	    end subroutine
	  end interface
83d78357065fbc0ba57e4ae5f725e5c1|file:///Users/loganmorrison/Documents/coding/fortran/c_fortran_interface/fortran/lib.f|10|1|V|fortran
	      real (kind = c_double), value :: b
401ad71c8b85934937f9d95edd1199ce|file:///Users/loganmorrison/Documents/coding/fortran/c_fortran_interface/fortran/lib.f|12|20|v|fortran
	 bind(c)
cfb4db1459d8ca8a8787bd0e8ea70116|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.c|18|1|v|c
	/* Subroutine */ 
21554f8f74661f2cfc8db36e3728e654|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.c|13|1|V|c
	#ifdef __cplusplus
	extern "C" {
	#endif
	#include "f2c.h"
1349c32c7cc0af9dc186433a16d38891|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.c|1620|1|V|c
	#ifdef __cplusplus
		}
	#endif
289b8b1203ce835ac8d440953176d0cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.c|1|1|V|c
	/* decsol.f -- translated by f2c (version 20191129).
	   You must link the resulting object file with libf2c:
	        on Microsoft Windows system, link with libf2c.lib;
	        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	        or, if you install libf2c.a in a standard place, with -lf2c -lm
	        -- in that order, at the end of the command line, as in
	                cc *.o -lf2c -lm
	        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
	
	                http://www.netlib.org/f2c/libf2c.zip
	*/
46396059fd56e2be33b8df07acaf8173|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|7|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION. */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*     A = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U . */
	  /*     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N). */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], fabs(d__1)) >
	          (d__2 = a[m + k * a_dim1], fabs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    t = a[m + k * a_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[k + k * a_dim1];
	    a[k + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      t = a[m + j * a_dim1];
	      a[m + j * a_dim1] = a[k + j * a_dim1];
	      a[k + j * a_dim1] = t;
	      if (t == 0.) {
	        goto L45;
	      }
	      i__3 = *n;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        /* L40: */
	        a[i__ + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if (a[*n + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DEC ------------------------- */
555cc84756eef3cbec5ac8ba204c47ab|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|8|1|V|cpp
	} /* dec_ */
f946edd6196ecfa243ee257886f1b354|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|10|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, km1, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*    A = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    B = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L10: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    b[k] /= a[k + k * a_dim1];
	    t = -b[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L30: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[a_dim1 + 1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOL ------------------------- */
83aa4f2cb7863284a153c58e48fc37bb|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|11|1|V|cpp
	} /* sol_ */
f2b5516868d7d4431673dc4a1028972e|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|13|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int na, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION OF A HESSENBERG */
	  /*  MATRIX WITH LOWER BANDWIDTH LB */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX A. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*     A = MATRIX TO BE TRIANGULARIZED. */
	  /*     LB = LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED, LB.GE.1). */
	  /*  OUTPUT.. */
	  /*     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U . */
	  /*     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOLH  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N). */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A SLIGHT MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    /* Computing fmin */
	    i__2 = *n, i__3 = *lb + k;
	    na = fmin(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], fabs(d__1)) >
	          (d__2 = a[m + k * a_dim1], fabs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    t = a[m + k * a_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[k + k * a_dim1];
	    a[k + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      t = a[m + j * a_dim1];
	      a[m + j * a_dim1] = a[k + j * a_dim1];
	      a[k + j * a_dim1] = t;
	      if (t == 0.) {
	        goto L45;
	      }
	      i__3 = na;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        /* L40: */
	        a[i__ + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if (a[*n + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECH ------------------------ */
d0c5a4b093eae72d6deb28fe5cb2ae92|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|14|1|V|cpp
	} /* dech_ */
2dcebffd3fbd7a8abe4b460649bb9d8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|15|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, na, km1, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX A. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*    A = TRIANGULARIZED MATRIX OBTAINED FROM DECH. */
	  /*    LB = LOWER BANDWIDTH OF A. */
	  /*    B = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DECH HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    /* Computing fmin */
	    i__2 = *n, i__3 = *lb + k;
	    na = fmin(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L10: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    b[k] /= a[k + k * a_dim1];
	    t = -b[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L30: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[a_dim1 + 1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLH ------------------------ */
b8b32dcb06a9e2432aace5b457fff081|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|16|1|V|cpp
	} /* solh_ */
ed71f35b31db2270d89ac3e23c70e83c|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|17|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double ti, tr;
	  int nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION */
	  /*  ------ MODIFICATION FOR COMPLEX MATRICES -------- */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI . */
	  /*     (AR, AI) = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     AR(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; REAL PART. */
	  /*     AI(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; IMAGINARY PART. */
	  /*     AR(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    REAL PART. */
	  /*     AI(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    IMAGINARY PART. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], fabs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], fabs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], fabs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], fabs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[k + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[k + k * ai_dim1];
	    ar[k + k * ar_dim1] = tr;
	    ai[k + k * ai_dim1] = ti;
	  L20:
	    if (fabs(tr) + fabs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      ar[m + j * ar_dim1] = ar[k + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[k + j * ai_dim1];
	      ar[k + j * ar_dim1] = tr;
	      ai[k + j * ai_dim1] = ti;
	      if (fabs(tr) + fabs(ti) == 0.) {
	        goto L48;
	      }
	      if (ti == 0.) {
	        i__3 = *n;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = *n;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = *n;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[i__ + j * ar_dim1] += prodr;
	        ai[i__ + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[*n + *n * ar_dim1], fabs(d__1)) +
	          (d__2 = ai[*n + *n * ai_dim1], fabs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECC ------------------------ */
7893e664aa4d0a7677d6927a4bafdbe7|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|18|1|V|cpp
	} /* decc_ */
6aa3f8f627f7585c3ad1255831659c77|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|20|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2;
	
	  /* Local variables */
	  int i__, k, m, kb;
	  double ti, tr;
	  int km1, nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI. */
	  /*    (AR,AI) = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    (BR,BI) = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    (BR,BI) = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    den = ar[k + k * ar_dim1] * ar[k + k * ar_dim1] +
	          ai[k + k * ai_dim1] * ai[k + k * ai_dim1];
	    prodr = br[k] * ar[k + k * ar_dim1] + bi[k] * ai[k + k * ai_dim1];
	    prodi = bi[k] * ar[k + k * ar_dim1] - br[k] * ai[k + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	L50:
	  den = ar[ar_dim1 + 1] * ar[ar_dim1 + 1] + ai[ai_dim1 + 1] * ai[ai_dim1 + 1];
	  prodr = br[1] * ar[ar_dim1 + 1] + bi[1] * ai[ai_dim1 + 1];
	  prodi = bi[1] * ar[ar_dim1 + 1] - br[1] * ai[ai_dim1 + 1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLC ------------------------ */
33c38950cd022c8a98d69d811c161bc4|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|21|1|V|cpp
	} /* solc_ */
e3d70497d794096c89918dc6e7759cd1|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|24|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m, na;
	  double ti, tr;
	  int nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION */
	  /*  ------ MODIFICATION FOR COMPLEX MATRICES -------- */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI . */
	  /*     (AR, AI) = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     AR(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; REAL PART. */
	  /*     AI(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; IMAGINARY PART. */
	  /*     AR(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    REAL PART. */
	  /*     AI(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    IMAGINARY PART. */
	  /*     LB = LOWER BANDWIDTH OF A (DIAGONAL NOT COUNTED), LB.GE.1. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*lb == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    /* Computing fmin */
	    i__2 = *n, i__3 = *lb + k;
	    na = fmin(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], fabs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], fabs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], fabs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], fabs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[k + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[k + k * ai_dim1];
	    ar[k + k * ar_dim1] = tr;
	    ai[k + k * ai_dim1] = ti;
	  L20:
	    if (fabs(tr) + fabs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      ar[m + j * ar_dim1] = ar[k + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[k + j * ai_dim1];
	      ar[k + j * ar_dim1] = tr;
	      ai[k + j * ai_dim1] = ti;
	      if (fabs(tr) + fabs(ti) == 0.) {
	        goto L48;
	      }
	      if (ti == 0.) {
	        i__3 = na;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = na;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = na;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[i__ + j * ar_dim1] += prodr;
	        ai[i__ + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[*n + *n * ar_dim1], fabs(d__1)) +
	          (d__2 = ai[*n + *n * ai_dim1], fabs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECHC ----------------------- */
9526ec23c826594fa3d79c20d57c8ef4|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|25|1|V|cpp
	} /* dechc_ */
eb7ec505c05dfcc2972a8866448ace84|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|27|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3, i__4;
	
	  /* Local variables */
	  int i__, k, m, kb;
	  double ti, tr;
	  int km1, nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI. */
	  /*    (AR,AI) = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    (BR,BI) = RIGHT HAND SIDE VECTOR. */
	  /*    LB = LOWER BANDWIDTH OF A. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    (BR,BI) = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  if (*lb == 0) {
	    goto L25;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    /* Computing fmin */
	    i__3 = *n, i__4 = *lb + k;
	    i__2 = fmin(i__3, i__4);
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    den = ar[k + k * ar_dim1] * ar[k + k * ar_dim1] +
	          ai[k + k * ai_dim1] * ai[k + k * ai_dim1];
	    prodr = br[k] * ar[k + k * ar_dim1] + bi[k] * ai[k + k * ai_dim1];
	    prodi = bi[k] * ar[k + k * ar_dim1] - br[k] * ai[k + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	L50:
	  den = ar[ar_dim1 + 1] * ar[ar_dim1 + 1] + ai[ai_dim1 + 1] * ai[ai_dim1 + 1];
	  prodr = br[1] * ar[ar_dim1 + 1] + bi[1] * ai[ai_dim1 + 1];
	  prodi = bi[1] * ar[ar_dim1 + 1] - br[1] * ai[ai_dim1 + 1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLHC ----------------------- */
79673944f230173e5267ae1f908a406a|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|28|1|V|cpp
	} /* solhc_ */
55d5bfcb5cecd41d94bfa6fcd7886acf|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|31|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3, i__4;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int md, jk, mm, ju, md1, nm1, kp1, mdl, ijk;
	
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION OF A BANDED */
	  /*  MATRIX WITH LOWER BANDWIDTH ML AND UPPER BANDWIDTH MU */
	  /*  INPUT.. */
	  /*     N       ORDER OF THE ORIGINAL MATRIX A. */
	  /*     NDIM    DECLARED DIMENSION OF ARRAY  A. */
	  /*     A       CONTAINS THE MATRIX IN BAND STORAGE.   THE COLUMNS */
	  /*                OF THE MATRIX ARE STORED IN THE COLUMNS OF  A  AND */
	  /*                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS */
	  /*                ML+1 THROUGH 2*ML+MU+1 OF  A. */
	  /*     ML      LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*     MU      UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*  OUTPUT.. */
	  /*     A       AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
	  /*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
	  /*     IP      INDEX VECTOR OF PIVOT INDICES. */
	  /*     IP(N)   (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER     = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE */
	  /*                SINGULAR AT STAGE K. */
	  /*  USE  SOLB  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(MD,1)*A(MD,2)*...*A(MD,N)  WITH MD=ML+MU+1. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOLB WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  ju = 0;
	  if (*ml == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  if (*n < *mu + 2) {
	    goto L7;
	  }
	  i__1 = *n;
	  for (j = *mu + 2; j <= i__1; ++j) {
	    i__2 = *ml;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L5: */
	      a[i__ + j * a_dim1] = 0.;
	    }
	  }
	L7:
	  nm1 = *n - 1;
	  i__2 = nm1;
	  for (k = 1; k <= i__2; ++k) {
	    kp1 = k + 1;
	    m = md;
	    /* Computing fmin */
	    i__1 = *ml, i__3 = *n - k;
	    mdl = fmin(i__1, i__3) + md;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], fabs(d__1)) >
	          (d__2 = a[m + k * a_dim1], fabs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m + k - md;
	    t = a[m + k * a_dim1];
	    if (m == md) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[md + k * a_dim1];
	    a[md + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    /* Computing fmin */
	    /* Computing fmax */
	    i__3 = ju, i__4 = *mu + ip[k];
	    i__1 = fmax(i__3, i__4);
	    ju = fmin(i__1, *n);
	    mm = md;
	    if (ju < kp1) {
	      goto L55;
	    }
	    i__1 = ju;
	    for (j = kp1; j <= i__1; ++j) {
	      --m;
	      --mm;
	      t = a[m + j * a_dim1];
	      if (m == mm) {
	        goto L35;
	      }
	      a[m + j * a_dim1] = a[mm + j * a_dim1];
	      a[mm + j * a_dim1] = t;
	    L35:
	      if (t == 0.) {
	        goto L45;
	      }
	      jk = j - k;
	      i__3 = mdl;
	      for (i__ = md1; i__ <= i__3; ++i__) {
	        ijk = i__ - jk;
	        /* L40: */
	        a[ijk + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	  L55:
	      /* L60: */
	      ;
	  }
	L70:
	  k = *n;
	  if (a[md + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECB ------------------------ */
37eeaf89ff4cd0c421e0a69feb082176|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|32|1|V|cpp
	} /* decb_ */
bdd86490c99dc93e9e2ac1fde22cd166|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|35|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, md, lm, md1, nm1, imd, kmd, mdl, mdm;
	
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N      ORDER OF MATRIX A. */
	  /*    NDIM   DECLARED DIMENSION OF ARRAY  A . */
	  /*    A      TRIANGULARIZED MATRIX OBTAINED FROM DECB. */
	  /*    ML     LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    MU     UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    B      RIGHT HAND SIDE VECTOR. */
	  /*    IP     PIVOT VECTOR OBTAINED FROM DECB. */
	  /*  DO NOT USE IF DECB HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B      SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  mdm = md - 1;
	  nm1 = *n - 1;
	  if (*ml == 0) {
	    goto L25;
	  }
	  if (*n == 1) {
	    goto L50;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    /* Computing fmin */
	    i__2 = *ml, i__3 = *n - k;
	    mdl = fmin(i__2, i__3) + md;
	    i__2 = mdl;
	    for (i__ = md1; i__ <= i__2; ++i__) {
	      imd = i__ + k - md;
	      /* L10: */
	      b[imd] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    k = *n + 1 - kb;
	    b[k] /= a[md + k * a_dim1];
	    t = -b[k];
	    kmd = md - k;
	    /* Computing fmax */
	    i__2 = 1, i__3 = kmd + 1;
	    lm = fmax(i__2, i__3);
	    i__2 = mdm;
	    for (i__ = lm; i__ <= i__2; ++i__) {
	      imd = i__ - kmd;
	      /* L30: */
	      b[imd] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[md + a_dim1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLB ------------------------ */
2df1e07400d83f314bf776f4dafeae20|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|36|1|V|cpp
	} /* solb_ */
001c7f70bf6045724528e5b314d86502|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|39|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3, i__4;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m, md, jk, mm;
	  double ti;
	  int ju;
	  double tr;
	  int md1, nm1, kp1;
	  double den;
	  int mdl, ijk;
	  double prodi, prodr;
	
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIfminATION OF A BANDED COMPLEX */
	  /*  MATRIX WITH LOWER BANDWIDTH ML AND UPPER BANDWIDTH MU */
	  /*  INPUT.. */
	  /*     N       ORDER OF THE ORIGINAL MATRIX A. */
	  /*     NDIM    DECLARED DIMENSION OF ARRAY  A. */
	  /*     AR, AI     CONTAINS THE MATRIX IN BAND STORAGE.   THE COLUMNS */
	  /*                OF THE MATRIX ARE STORED IN THE COLUMNS OF  AR (REAL */
	  /*                PART) AND AI (IMAGINARY PART)  AND */
	  /*                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS */
	  /*                ML+1 THROUGH 2*ML+MU+1 OF  AR AND AI. */
	  /*     ML      LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*     MU      UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*  OUTPUT.. */
	  /*     AR, AI  AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
	  /*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
	  /*     IP      INDEX VECTOR OF PIVOT INDICES. */
	  /*     IP(N)   (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER     = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE */
	  /*                SINGULAR AT STAGE K. */
	  /*  USE  SOLBC  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(MD,1)*A(MD,2)*...*A(MD,N)  WITH MD=ML+MU+1. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOLBC WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  ju = 0;
	  if (*ml == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  if (*n < *mu + 2) {
	    goto L7;
	  }
	  i__1 = *n;
	  for (j = *mu + 2; j <= i__1; ++j) {
	    i__2 = *ml;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      ar[i__ + j * ar_dim1] = 0.;
	      ai[i__ + j * ai_dim1] = 0.;
	      /* L5: */
	    }
	  }
	L7:
	  nm1 = *n - 1;
	  i__2 = nm1;
	  for (k = 1; k <= i__2; ++k) {
	    kp1 = k + 1;
	    m = md;
	    /* Computing fmin */
	    i__1 = *ml, i__3 = *n - k;
	    mdl = fmin(i__1, i__3) + md;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], fabs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], fabs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], fabs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], fabs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m + k - md;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == md) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[md + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[md + k * ai_dim1];
	    ar[md + k * ar_dim1] = tr;
	    ai[md + k * ai_dim1] = ti;
	  L20:
	    if (fabs(tr) + fabs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    /* Computing fmin */
	    /* Computing fmax */
	    i__3 = ju, i__4 = *mu + ip[k];
	    i__1 = fmax(i__3, i__4);
	    ju = fmin(i__1, *n);
	    mm = md;
	    if (ju < kp1) {
	      goto L55;
	    }
	    i__1 = ju;
	    for (j = kp1; j <= i__1; ++j) {
	      --m;
	      --mm;
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      if (m == mm) {
	        goto L35;
	      }
	      ar[m + j * ar_dim1] = ar[mm + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[mm + j * ai_dim1];
	      ar[mm + j * ar_dim1] = tr;
	      ai[mm + j * ai_dim1] = ti;
	    L35:
	      if (fabs(tr) + fabs(ti) == 0.) {
	        goto L48;
	      }
	      jk = j - k;
	      if (ti == 0.) {
	        i__3 = mdl;
	        for (i__ = md1; i__ <= i__3; ++i__) {
	          ijk = i__ - jk;
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[ijk + j * ar_dim1] += prodr;
	          ai[ijk + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = mdl;
	        for (i__ = md1; i__ <= i__3; ++i__) {
	          ijk = i__ - jk;
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[ijk + j * ar_dim1] += prodr;
	          ai[ijk + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = mdl;
	      for (i__ = md1; i__ <= i__3; ++i__) {
	        ijk = i__ - jk;
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[ijk + j * ar_dim1] += prodr;
	        ai[ijk + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	  L55:
	      /* L60: */
	      ;
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[md + *n * ar_dim1], fabs(d__1)) +
	          (d__2 = ai[md + *n * ai_dim1], fabs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECBC ------------------------ */
b17e38d24a29dc41b568e83dfd0fa972|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|40|1|V|cpp
	} /* decbc_ */
164be77cc61361e8a7d95bd690d5e5bd|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|43|1|V|cpp
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m, kb, md, lm;
	  double ti, tr;
	  int md1, nm1;
	  double den;
	  int imd, kmd, mdl, mdm;
	  double prodi, prodr;
	
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B , */
	  /*                  VERSION BANDED AND COMPLEX-DOUBLE PRECISION. */
	  /*  INPUT.. */
	  /*    N      ORDER OF MATRIX A. */
	  /*    NDIM   DECLARED DIMENSION OF ARRAY  A . */
	  /*    AR, AI TRIANGULARIZED MATRIX OBTAINED FROM DECB (REAL AND IMAG. PART).
	   */
	  /*    ML     LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    MU     UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    BR, BI RIGHT HAND SIDE VECTOR (REAL AND IMAG. PART). */
	  /*    IP     PIVOT VECTOR OBTAINED FROM DECBC. */
	  /*  DO NOT USE IF DECB HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    BR, BI SOLUTION VECTOR, X (REAL AND IMAG. PART). */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  mdm = md - 1;
	  nm1 = *n - 1;
	  if (*ml == 0) {
	    goto L25;
	  }
	  if (*n == 1) {
	    goto L50;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    /* Computing fmin */
	    i__2 = *ml, i__3 = *n - k;
	    mdl = fmin(i__2, i__3) + md;
	    i__2 = mdl;
	    for (i__ = md1; i__ <= i__2; ++i__) {
	      imd = i__ + k - md;
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[imd] += prodr;
	      bi[imd] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    k = *n + 1 - kb;
	    den = ar[md + k * ar_dim1] * ar[md + k * ar_dim1] +
	          ai[md + k * ai_dim1] * ai[md + k * ai_dim1];
	    prodr = br[k] * ar[md + k * ar_dim1] + bi[k] * ai[md + k * ai_dim1];
	    prodi = bi[k] * ar[md + k * ar_dim1] - br[k] * ai[md + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    kmd = md - k;
	    /* Computing fmax */
	    i__2 = 1, i__3 = kmd + 1;
	    lm = fmax(i__2, i__3);
	    i__2 = mdm;
	    for (i__ = lm; i__ <= i__2; ++i__) {
	      imd = i__ - kmd;
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[imd] += prodr;
	      bi[imd] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	  den =
	      ar[md + ar_dim1] * ar[md + ar_dim1] + ai[md + ai_dim1] * ai[md + ai_dim1];
	  prodr = br[1] * ar[md + ar_dim1] + bi[1] * ai[md + ai_dim1];
	  prodi = bi[1] * ar[md + ar_dim1] - br[1] * ai[md + ai_dim1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	L50:
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLBC ------------------------ */
6c8a98da15d93548304a063ca3dc460b|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|44|1|V|cpp
	} /* solbc_ */
f8a5aa7cc632e4992be71360a91785dd|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|47|1|V|cpp
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1;
	
	  /* Local variables */
	  int i__, j, m;
	  double x, y;
	  int la, mm1, kp1, mp1;
	
	  /*     this subroutine is a translation of the algol procedure elmhes, */
	  /*     num. math. 12, 349-368(1968) by martin and wilkinson. */
	  /*     handbook for auto. comp., vol.ii-linear algebra, 339-358(1971). */
	
	  /*     given a real general matrix, this subroutine */
	  /*     reduces a submatrix situated in rows and columns */
	  /*     low through igh to upper hessenberg form by */
	  /*     stabilized elementary similarity transformations. */
	
	  /*     on input: */
	
	  /*      nm must be set to the row dimension of two-dimensional */
	  /*        array parameters as declared in the calling program */
	  /*        dimension statement; */
	
	  /*      n is the order of the matrix; */
	
	  /*      low and igh are ints deterfmined by the balancing */
	  /*        subroutine  balanc.      if  balanc  has not been used, */
	  /*        set low=1, igh=n; */
	
	  /*      a contains the input matrix. */
	
	  /*     on output: */
	
	  /*      a contains the hessenberg matrix.  the multipliers */
	  /*        which were used in the reduction are stored in the */
	  /*        remaining triangle under the hessenberg matrix; */
	
	  /*      int contains information on the rows and columns */
	  /*        interchanged in the reduction. */
	  /*        only elements low through igh are used. */
	
	  /*     questions and comments should be directed to b. s. garbow, */
	  /*     applied mathematics division, argonne national laboratory */
	
	  /*     ------------------------------------------------------------------ */
	
	  /* Parameter adjustments */
	  a_dim1 = *nm;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	  --int__;
	
	  /* Function Body */
	  la = *igh - 1;
	  kp1 = *low + 1;
	  if (la < kp1) {
	    goto L200;
	  }
	
	  i__1 = la;
	  for (m = kp1; m <= i__1; ++m) {
	    mm1 = m - 1;
	    x = 0.;
	    i__ = m;
	
	    i__2 = *igh;
	    for (j = m; j <= i__2; ++j) {
	      if ((d__1 = a[j + mm1 * a_dim1], fabs(d__1)) <= fabs(x)) {
	        goto L100;
	      }
	      x = a[j + mm1 * a_dim1];
	      i__ = j;
	    L100:;
	    }
	
	    int__[m] = i__;
	    if (i__ == m) {
	      goto L130;
	    }
	    /*    :::::::::: interchange rows and columns of a :::::::::: */
	    i__2 = *n;
	    for (j = mm1; j <= i__2; ++j) {
	      y = a[i__ + j * a_dim1];
	      a[i__ + j * a_dim1] = a[m + j * a_dim1];
	      a[m + j * a_dim1] = y;
	      /* L110: */
	    }
	
	    i__2 = *igh;
	    for (j = 1; j <= i__2; ++j) {
	      y = a[j + i__ * a_dim1];
	      a[j + i__ * a_dim1] = a[j + m * a_dim1];
	      a[j + m * a_dim1] = y;
	      /* L120: */
	    }
	  /*    :::::::::: end interchange :::::::::: */
	  L130:
	    if (x == 0.) {
	      goto L180;
	    }
	    mp1 = m + 1;
	
	    i__2 = *igh;
	    for (i__ = mp1; i__ <= i__2; ++i__) {
	      y = a[i__ + mm1 * a_dim1];
	      if (y == 0.) {
	        goto L160;
	      }
	      y /= x;
	      a[i__ + mm1 * a_dim1] = y;
	
	      i__3 = *n;
	      for (j = m; j <= i__3; ++j) {
	        /* L140: */
	        a[i__ + j * a_dim1] -= y * a[m + j * a_dim1];
	      }
	
	      i__3 = *igh;
	      for (j = 1; j <= i__3; ++j) {
	        /* L150: */
	        a[j + m * a_dim1] += y * a[j + i__ * a_dim1];
	      }
	
	    L160:;
	    }
	
	  L180:;
	  }
	
	L200:
	  return 0;
	  /*    :::::::::: last card of elmhes :::::::::: */
6b61782567d81bd8b5045fa534570fb4|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.hpp|48|1|V|cpp
	} /* elmhes_ */
97d3601aa4963463e55fcd7efca1366d|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/lapack.c|1|1|V|c
	/* lapack.f -- translated by f2c (version 20191129).
	   You must link the resulting object file with libf2c:
		on Microsoft Windows system, link with libf2c.lib;
		on Linux or Unix systems, link with .../path/to/libf2c.a -lm
		or, if you install libf2c.a in a standard place, with -lf2c -lm
		-- in that order, at the end of the command line, as in
			cc *.o -lf2c -lm
		Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
	
			http://www.netlib.org/f2c/libf2c.zip
	*/
	
3ceac72de4355a73112bfc5d1156af9a|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/lapack.c|4846|1|v|c
	#ifdef __cplusplus
	}
	#
e96d8afc259593a20838480dfb84400b|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/lapack.c|4846|1|V|c
	endif
8cf03fc1b1b4acb66843be77088d76b1|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.c|1|1|V|c
	/* radau.f -- translated by f2c (version 20191129).
	   You must link the resulting object file with libf2c:
		on Microsoft Windows system, link with libf2c.lib;
		on Linux or Unix systems, link with .../path/to/libf2c.a -lm
		or, if you install libf2c.a in a standard place, with -lf2c -lm
		-- in that order, at the end of the command line, as in
			cc *.o -lf2c -lm
		Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
	
			http://www.netlib.org/f2c/libf2c.zip
	*/
287e313bfa2c6d0724d15b4b1740caa8|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.c|2673|1|V|c
	#ifdef __cplusplus
	}
	#endif
4acff9e7b4183368e416549e15c31448|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau.c|2541|1|v|c
	/* Subroutine */
b3a3a2a53f2ecec53476d47268125a72|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/func.hpp|7|1|V|cpp
	using OdeFunc =
	    std::function<void(int *, double *, double *, double *, double *, int *)>;
413a11877614589fc1b115f6247315a2|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/func.hpp|9|7|v|cpp
	OdeFunc
7feec0df6a0ae76d46206ecc026d8adb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|9|1|V|cpp
	std::array<double>;
aa7a2e791d328abd0ae74cec98f1ecbf|file:///Users/loganmorrison/.config/nvim/coc-settings.json|13|1|V|json
	  "clangd.path": "/usr/local/bin/clangd",
0ac995152f29b025ebe32598acf06047|file:///Users/loganmorrison/.config/nvim/coc-settings.json|21|19|v|json
	clangd
1eead979e2a54685e51e5b97ec406696|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/vector.hpp|4|10|v|cpp
	<Eigen/Dense>
7407fb7e6a4df6392aaabd2368157312|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/vector.hpp|4|17|v|cpp
	Sparse
a130090803111bed4dda63998e2181c5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/phase_space/four_momentum.hpp|4|11|v|cpp
	c++/10.1.0/
a303edaa4a81c8aab35b1bda5c9ef7ba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|61|69|v|cmake
	gfortran
cdd3e39bad1a50de5702d884f364e019|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/CMakeLists.txt|9|29|v|cmake
	PUBLIC gfortran
f420c0f288928cb48c002879d97e9111|file:///Users/loganmorrison/.config/fish/config.fish|6|1|V|fish
	# ,/usr/local/opt/lapack/lib,/usr/local/opt/openblas/lib
3456228174beb2cdf49d42f4ec7ef92e|file:///Users/loganmorrison/.config/fish/config.fish|7|1|V|fish
	# ,/usr/local/opt/lapack/include,/usr/local/opt/openblas/include"
741cb8d001e1df3950a5e4d1a8061715|file:///Users/loganmorrison/.config/fish/config.fish|2|22|v|fish
	bin/clang"
4c06f5ee9aaeb981b1175de857d83075|file:///Users/loganmorrison/.config/fish/config.fish|3|24|v|fish
	bin/clang++"
9c5e7ecdac87199b69e6f7448458f7e1|file:///Users/loganmorrison/.config/fish/config.fish|2|11|v|fish
	/usr/local/Cellar/llvm/10.0.0_3/bin/clang"
89553dcffac6839e538ae66359f9f563|file:///Users/loganmorrison/.config/fish/config.fish|3|13|v|fish
	/usr/local/Cellar/llvm/10.0.0_3/bin/clang++"
85a072d4c27f12e141ac53957c1f889b|file:///Users/loganmorrison/.config/fish/config.fish|5|79|v|fish
	/usr/local/Cellar/gcc/10.1.0/lib
c26a23efd85b310927a64e59f32aacbd|file:///Users/loganmorrison/.config/fish/config.fish|5|44|v|fish
	-Wl,-rpath,
ec8761f98ba463407df38084e06cf177|file:///Users/loganmorrison/.config/fish/config.fish|8|1|V|fish
	set -gx LIBRARY_PATH "/usr/local/Cellar/gcc/10.1.0/lib"
e66db2b4c3194bf0eb22005dedef9a04|file:///Users/loganmorrison/.config/fish/config.fish|5|67|v|fish
	,/usr/local/Cellar/gcc/10.1.0/lib/gcc/10
8923b152b7641e8617f84d6bfa55de2d|file:///Users/loganmorrison/.config/fish/config.fish|5|43|v|fish
	,/usr/local/opt/llvm/lib,
f5890a6705db7227ddfd0d6cc0d1a533|file:///Users/loganmorrison/.config/fish/config.fish|5|43|v|fish
	 -Wl -rpath
8151ddc3c0a1a18ea25ab699d70efcbc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|178|3|V|cpp
	  std::cout << 
0f949f0ea34d47acb1f7071752f210af|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|177|1|V|cpp
	  std::cout << "Reseting model\n";
d19ed0c6b93a39385f8e8faadeb2fa7b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|181|17|v|cpp
	Reseting model\n";
c324b1f4c1fc2faf0f4d764dca65be10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|181|1|V|cpp
	  std::cout << "Solving with FORTRAN\n";
72a3350771ef23912a6e76f4b1eed728|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|161|17|v|cpp
	Solving with FORTRAN\n";
9ffde4f906f390d8f25568883dceae57|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|81|13|v|cpp
	boltz, this, 
9080aa278b3ec56f1af90ddad7f5c0a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|81|40|v|cpp
	std::placeholders::_1
0e9ef9e77467b6c05491a05107b4e135|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|85|3|V|cpp
	  boltz ff = &f;
80984fce8b6a6e5e6ddd64c9d4007e41|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|83|1|V|cpp
	  auto f = std::bind(&DarkSun::boltzmann, this, std::placeholders::_1,
d4de240262b13b5d3987181ebd63bef1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|83|13|V|cpp
	            std::placeholders::_2, std::placeholders::_3);
b175ccadbd50a354407b91cf81346b75|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|81|1|V|cpp
	  typedef void(*boltz)(double, const Vector<double>&, Vector<double>&);
05f7e28eb693a9d93e8fc17bd5ad7caa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|86|21|v|cpp
	[this](double logx, const Vector<double> &y,
	                           Matrix<double> &df) { boltzmann_jac(logx, y, df); }
62148d6b726b70f9dab8f3ca4caa0335|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|85|1|V|cpp
	  auto rhs_jac =
	      std::optional([this](double logx, const Vector<double> &y,
	                           Matrix<double> &df) { boltzmann_jac(logx, y, df); });
158467ccca77a28de4f8ff024175822f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|109|34|v|cpp
	rhs_jac
d9ea7b681780dad7d0089aa7a12f0715|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|87|1|V|cpp
	  // Dummy mass matrix
	  auto mass = std::optional<OdeMas>();
f74022d3ffe41754ca274ee485b713c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|85|1|V|cpp
	  // auto rhs_jac = std::optional<OdeJac>();
969a91c3794ba9aadcd995434116659c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|9|1|V|cpp
	namespace darksun {
	
	class DarkSun {
	public:
	  // Model Parameters
	
	  size_t n;             // N in SU(N)
	  double lam;           // confinement scale
	  double c = 1.0;       // exponential suppression factor for 2eta->2del
	  double adel = 1.0;    // suppression factor for initial delta abundance
	  double lec1 = 1.0;    // low-energy constant for 4pt eta interactions
	  double lec2 = 1.0;    // low-energy constant for 6pt eta interactions
	  double mu_eta = 1.0;  // prefactor of eta mass: m_eta = mu_eta * lam / sqrt(n)
	  double mu_del = 1.0;  // prefactor of del mass: m_del = mu_del * lam * n
	  double xi_inf = 1e-2; // initial ratio of dark to SM temperatures
	
	  DarkSun(size_t n, double lam) : n(n), lam(lam) {}
	
	  // Derived quantities
	
	  std::optional<double> xi_fo{};           // xi when eta freezes
	  std::optional<double> tsm_fo{};          // SM temp when eta freezes
	  std::optional<double> xi_cmb{};          // xi at CMB
	  std::optional<double> xi_bbn{};          // xi at BBN
	  std::optional<double> rd_eta{};          // eta relic density
	  std::optional<double> rd_del{};          // delta relic density
	  std::optional<double> dneff_cmb{};       // delta Neff at CMB
	  std::optional<double> dneff_bbn{};       // delta Neff at BBN
	  std::optional<double> eta_si_per_mass{}; // eta SI cross section today
	  std::optional<double> del_si_per_mass{}; // delta SI cross section today
	  std::optional<OdeSolution> sol_boltz{};  // solution to boltzmann equation
	
	  // Reset the derived quantities
	  void reset() {
	    xi_fo = std::optional<double>();
	    tsm_fo = std::optional<double>();
	    xi_cmb = std::optional<double>();
	    xi_bbn = std::optional<double>();
	    rd_eta = std::optional<double>();
	    rd_del = std::optional<double>();
	    dneff_cmb = std::optional<double>();
	    dneff_bbn = std::optional<double>();
	    eta_si_per_mass = std::optional<double>();
	    del_si_per_mass = std::optional<double>();
	    sol_boltz = std::optional<OdeSolution>();
	  }
	
	  //=========================================================================
	  //---- Functions for computing properities of eta and delta ---------------
	  //=========================================================================
	
	  // Compute the mass of the eta
	  double m_eta() const { return mu_eta * lam / sqrt(double(n)); }
	  // Compute the mass of the delta
	  double m_del() const { return mu_eta * lam * double(n); }
	  // Compute the internal dof of the delta
	  double g_del() const { return double(n + 1); }
	  // Compute the sum of the internal dof in the dark sector
	  double dark_sum_g() const { return 2.0 + double(n); }
	
	  //=========================================================================
	  //---- Functions for computing Cross Sections -----------------------------
	  //=========================================================================
	
	  // Compute the zero-temperature cross section for 2eta->4eta
	  double cross_section_2eta_4eta(double cme) const;
	  // Compute the self-interaction cross-section of the eta
	  double cross_section_2eta_2eta() const;
	  // Compute the self-interaction cross-section of the delta
	  double cross_section_2del_2del() const;
	  // Compute the thermal cross section for 2eta -> 4eta
	  double thermal_cross_section_2eta_4eta(double x) const;
	  // Compute the thermal cross section for 4eta -> 2eta
	  double thermal_cross_section_4eta_2eta(double x) const;
	  // Compute the thermal cross section for 2eta -> 2delta
	  double thermal_cross_section_2eta_2del(double x) const;
	
	  //=========================================================================
	  //---- Misc. Thermal Functions --------------------------------------------
	  //=========================================================================
	
	  // Compute the equillibrium number density of the eta
	  double neq_eta(double td) const;
	  // Compute the comoving number density of the eta.
	  double yeq_eta(double tsm, double xi) const;
	  // Compute the log equilibrium number density of the eta / sm entropy density
	  double weq_eta(double tsm, double xi) const;
	  // Compute the equillibrium number density of the delta
	  double neq_del(double td) const;
	  // Compute the comoving number density of the delta.
	  double yeq_del(double tsm, double xi) const;
	  // Compute the log equilibrium number density of the del / sm entropy density
	  double weq_del(double tsm, double xi) const;
	  // Compute the effective dof stored in entropy of the dark sector
	  double dark_heff(double td) const;
	  // Compute the effective dof stored in energy of the dark sector
	  double dark_geff(double td) const;
	  // Compute the sqrt(g_star) including dark sector contributions
	  double sqrt_gstar(double tsm, double xi) const;
	  // Compute the effective dof stored in entropy of the dark sector td ~ inf
	  double dark_heff_inf() const { return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0); }
	
	  //=========================================================================
	  //---- Functions for computing xi = Td / Tsm ------------------------------
	  //=========================================================================
	
	  // Compute the lower and upper bounds of xi assuming td is known
	  std::pair<double, double> xi_bounds_const_td(double td) const;
	  // Compute the lower and upper bounds of xi assuming tsm is known
	  std::pair<double, double> xi_bounds_const_tsm(double tsm) const;
	  // Compute the xi assuming td is known
	  double compute_xi_const_td(double td) const;
	  // Compute the xi assuming tsm is known
	  double compute_xi_const_tsm(double tsm) const;
	
	  //=========================================================================
	  //---- Solving Boltzman Equation ------------------------------------------
	  //=========================================================================
	
	  // Solve the boltzmann equation for the eta and delta comoving number
	  // densities
	  void solve_boltzmann(double reltol, double abstol);
	
	private:
	  //=========================================================================
	  //---- RHS of boltzmann equation and its Jacobian -------------------------
	  //=========================================================================
	
	  // Compute the RHS of the Boltzmann equation
	  void boltzmann(double, const Vector<double> &, Vector<double> &);
	  // Compute the Jacobian of the Boltzmann equation
	  void boltzmann_jac(double, const Vector<double> &, Matrix<double> &);
	
	  //=========================================================================
	  //---- Functions for delta Neff -------------------------------------------
	  //=========================================================================
	
	  // Compute delta Neff at BBN
	  double compute_dneff_bbn() const;
	  // Compute delta Neff at CMB
	  double compute_dneff_cmb() const;
	
	  //=========================================================================
	  //---- Functions used to compute 2eta -> 4eta cross-section ---------------
	  //=========================================================================
	  //
	  // The cross section for 2eta -> 4eta can be written as:
	  //    cs(cme) = f(...) * csbar(l1, l2, z)
	  // with f(...) being a function of the  model parameters and csbar(l1, l2, z)
	  // a function of the low-energy constants l1 and l2 and the center-of-mass
	  // energy scaled by the eta mass (z = cme / meta). The function csbar can be
	  // decomposed into functions which are indenpendent of l1 and l2 as:
	  //    csbar(l1, l2, z) = l1^4 cs44(z) + l2^2 cs66 - 2 l1^2 l2 cs46(z)
	  // Here, cs44 is the cross section constructed of only the 4pt eta
	  // interaction, cs66 is the cross section constructed of only the 6pt eta
	  // interaction and cs46 is the interference term.
	  //
	  // To compute the 2eta->4eta cross section, we use a Monte-Carlo phase-space
	  // integrator (see phase_space.hpp and its dependencies) to generate data
	  // for cs44, cs66 and cs46 as a function of z. We perform fits to determine
	  // the large energy behavior of the cross sections (all go like 10^c * z^14
	  // i.e. a linear function on a log-log scale: log(cs) ~ 14 log(z) + c)
	  // functions. Below are the definitions for the fitting data and functions
	  // for cs44, cs46 and cs66. The data is located in
	  // "darksun/src/model/cs_data.cpp" and other definitions in
	  // "darksun/src/model/cross_sections.cpp".
	
	  // Data was fit from log10(4+10^-5) to log10(100) with 500 steps
	  static constexpr double log_eta_z_min = 0.60206107706280998056;
	  static constexpr double log_eta_z_max = 2.0;
	  static constexpr double log_eta_z_step = 0.0028014808074893587564;
	
	  // Fitting results for 2eta->4eta for large z (100 < z = cme / meta)
	  static constexpr double eta_cs_intercept44 = -9.744896762121916;
	  static constexpr double eta_cs_intercept66 = -10.667768576761643;
	  static constexpr double eta_cs_intercept46 = -10.206870194730394;
	
	  // Data which is stored in "darksun/src/model/cs_data.cpp"
	  static const std::array<double, 500> log_eta_cs44;
	  static const std::array<double, 500> log_eta_cs66;
	  static const std::array<double, 500> log_eta_cs46;
	
	  // Boost splines for cs44, cs66 and cs46
	  static const boost::math::cubic_b_spline<double> log_eta_cs44_spline;
	  static const boost::math::cubic_b_spline<double> log_eta_cs66_spline;
	  static const boost::math::cubic_b_spline<double> log_eta_cs46_spline;
	
	  // Functions valid for all z
	  static double scaled_cs_eta_24_44(double z);
	  static double scaled_cs_eta_24_66(double z);
	  static double scaled_cs_eta_24_46(double z);
	};
	
	} // namespace darksun
f379b412f72ff2debef3ff4f37afe0e8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|206|1|V|cpp
	namespace darksun {
12eac2e6a818f727e3846d15f8a42a78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|398|1|V|cpp
	} // namespace darksun
6121c6f4848a12f53752347a3cad52f7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|218|3|V|cpp
	  DarkSun(size_t n, double lam) : n(n), lam(lam) {}
14bbe0352ec6fd16d40f7cabe9f82f49|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|203|3|V|cpp
	  private:
f63d0c131e499dcf07128f09c4240ee2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|203|5|V|cpp
	    std::
4a4db969433b059575185e88774bdc1c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|206|1|V|cpp
	  std::array<double>
af8ce50980c785c5b921489ae82b542f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|204|1|V|cpp
	    static constexpr size_t LEN = 
8537fdfd61c7f134d12bb25a7e5ecb9c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|204|1|V|cpp
	    static constexpr size_t N_PARS = 22;
118a1d5ffc1cdfd45b531106385de5a5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|205|29|v|cpp
	N_PARS
fb601a76add79b0bcb5d31f9d4f8f474|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|212|1|V|cpp
	  size_t n(double * model);
37a467df5f6e84756889154be33c443c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|212|1|V|cpp
	  size_t n(double * model);
	  double lam(double * model);
6e73536c07b6c92fc2dc7531b407cff6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|222|30|v|cpp
	f = 1e-2
31c19211c12c62addd637ae312b0a3c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|221|30|v|cpp
	l = 1.0
ee8610418d6964f271052dd113627ecf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|220|30|v|cpp
	a = 1.0
3c200b82f0a154e5c7ad7628952c31b4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|219|28|v|cpp
	2 = 1.0
b19d0e2c5dea7f444595d228b0e8fa0e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|218|28|v|cpp
	1 = 1.0
2317a796a148b60540a51aa3368a6271|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|216|26|v|cpp
	= 1.0
eda1b76bf93a5fe1d7cbc61121f33b71|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|221|49|v|cpp
	m_eta = 
e577de8aaa3b2abe62fe743a8e37fc3c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|222|51|v|cpp
	 m_del = 
f5ab3b2d4eb6a9b1db038bbc81da5109|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|216|41|v|cpp
	exponential 
1e60a86c5983a4802ac149729e69728e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|214|3|V|cpp
	  static size_t n(double *model);    // N in SU(N)
85bdc5280a413224fd36688fd84363bd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|214|38|v|cpp
	// N in SU(N)
ef43ec55b9dbd97e11662b8b41cdc547|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|216|39|v|cpp
	// confinement scale
a92e3ae539fe0db59ddb3c091c6e66b1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|218|38|v|cpp
	// suppression factor for 2eta->2del
cedd3e11305db7d80866fbc8a614d564|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|220|38|v|cpp
	// suppression factor for initial delta abundance
ee8e07f8af5ad3503e149f23de6514d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|222|38|v|cpp
	// low-energy constant for 4pt eta interactions
2a7607cfa28d30515358d8b92263ac3d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|224|38|v|cpp
	// low-energy constant for 6pt eta interactions
fcc23e7de3017ed785ae7bb016a75216|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|226|40|v|cpp
	// prefactor of eta mass: mu_eta * lam / sqrt(n)
6b957ef7464a4abdf65e43c262eb7bb1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|228|40|v|cpp
	// prefactor of del mass: mu_del * lam * n
f4c7c59499acea013cbea6134e311a36|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|230|40|v|cpp
	// initial ratio of dark to SM temperatures
fcedab6136312e6224c6d421688940b1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|233|3|V|cpp
	  DarkSunStatic() = delete;
2e7f7f7cc60eefdfa793b3faa90a3d00|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|248|3|v|cpp
	std::optional<OdeSolution>
145fd1444f70aa746853c3a483c6e578|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|210|1|V|cpp
	  static constexpr size_t IDX_N;
77791f8a0ffde9035ba08db10980e642|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|210|1|V|cpp
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_LAM;
	  static constexpr size_t IDX_C;
	  static constexpr size_t IDX_ADEL;
	  static constexpr size_t IDX_LEC1;
	  static constexpr size_t IDX_LEC2;
	  static constexpr size_t IDX_MU_ETA;
	  static constexpr size_t IDX_MU_DEL;
	  static constexpr size_t IDX_XI_INF;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	  static constexpr size_t IDX_N;
	
b0efa2cf9cfad6f4eb3f8e38b0f70605|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|274|1|V|cpp
	    xi_fo = std::optional<double>();
	    tsm_fo = std::optional<double>();
	    xi_cmb = std::optional<double>();
	    xi_bbn = std::optional<double>();
	    rd_eta = std::optional<double>();
	    rd_del = std::optional<double>();
	    dneff_cmb = std::optional<double>();
	    dneff_bbn = std::optional<double>();
	    eta_si_per_mass = std::optional<double>();
	    del_si_per_mass = std::optional<double>();
	    sol_boltz = std::optional<OdeSolution>();
dfe5bbae0c7d1884b28e4a75cdcb85c8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|274|1|V|cpp
	    model[DarkSunIdx::XiFo] = -1.0;
14ae4674e7397e9d1d36e9c76600793e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|275|23|v|cpp
	XiFo
4a8cd0ccf958dfac872cce9d116f3eab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|278|1|V|cpp
	    model[DarkSunIdx::RdEta] = -1.0;
	    model[DarkSunIdx::RdDel] = -1.0;
69876455eef1bc6955a75523dc72d362|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|280|23|v|cpp
	RdEta
ebc0376302632088dc5e4bf6e6d92175|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|281|23|v|cpp
	RdDel
2f7abc4ad522bd9c312a9e38967e4209|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|291|55|v|cpp
	double()
eec226ca5e27d00d2ade3d027345b9c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|295|50|v|cpp
	double(n); 
8517bf5b30c2a48aff1bbdc85aeed0c3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|299|12|v|cpp
	double(n + 1); 
5e93fd8cd7602d271574dd7fd2e635a6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|300|64|v|cpp
	double(n)
c17ac3b897b60c8978ae017ad294be84|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|226|1|V|cpp
	class DarkSunStatic {
c926c485b376557dbce064b8f3bb53d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|232|1|V|cpp
	public:
	  DarkSunStatic() = delete;
60a555844b4105f776cc6b4e1cc2bbed|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|321|25|v|cpp
	, const double*model
4b0dd43a1865dc52bed59bd6171b8fed|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|11|1|V|cpp
	class DarkSun {
	public:
	  // Model Parameters
	
	  size_t n;             // N in SU(N)
	  double lam;           // confinement scale
	  double c = 1.0;       // exponential suppression factor for 2eta->2del
	  double adel = 1.0;    // suppression factor for initial delta abundance
	  double lec1 = 1.0;    // low-energy constant for 4pt eta interactions
	  double lec2 = 1.0;    // low-energy constant for 6pt eta interactions
	  double mu_eta = 1.0;  // prefactor of eta mass: m_eta = mu_eta * lam / sqrt(n)
	  double mu_del = 1.0;  // prefactor of del mass: m_del = mu_del * lam * n
	  double xi_inf = 1e-2; // initial ratio of dark to SM temperatures
	
	  DarkSun(size_t n, double lam) : n(n), lam(lam) {}
	
	  // Derived quantities
	
	  std::optional<double> xi_fo{};           // xi when eta freezes
	  std::optional<double> tsm_fo{};          // SM temp when eta freezes
	  std::optional<double> xi_cmb{};          // xi at CMB
	  std::optional<double> xi_bbn{};          // xi at BBN
	  std::optional<double> rd_eta{};          // eta relic density
	  std::optional<double> rd_del{};          // delta relic density
	  std::optional<double> dneff_cmb{};       // delta Neff at CMB
	  std::optional<double> dneff_bbn{};       // delta Neff at BBN
	  std::optional<double> eta_si_per_mass{}; // eta SI cross section today
	  std::optional<double> del_si_per_mass{}; // delta SI cross section today
	  std::optional<OdeSolution> sol_boltz{};  // solution to boltzmann equation
	
	  // Reset the derived quantities
	  void reset() {
	    xi_fo = std::optional<double>();
	    tsm_fo = std::optional<double>();
	    xi_cmb = std::optional<double>();
	    xi_bbn = std::optional<double>();
	    rd_eta = std::optional<double>();
	    rd_del = std::optional<double>();
	    dneff_cmb = std::optional<double>();
	    dneff_bbn = std::optional<double>();
	    eta_si_per_mass = std::optional<double>();
	    del_si_per_mass = std::optional<double>();
	    sol_boltz = std::optional<OdeSolution>();
	  }
	
	  //=========================================================================
	  //---- Functions for computing properities of eta and delta ---------------
	  //=========================================================================
	
	  // Compute the mass of the eta
	  double m_eta() const { return mu_eta * lam / sqrt(double(n)); }
	  // Compute the mass of the delta
	  double m_del() const { return mu_eta * lam * double(n); }
	  // Compute the internal dof of the delta
	  double g_del() const { return double(n + 1); }
	  // Compute the sum of the internal dof in the dark sector
	  double dark_sum_g() const { return 2.0 + double(n); }
	
	  //=========================================================================
	  //---- Functions for computing Cross Sections -----------------------------
	  //=========================================================================
	
	  // Compute the zero-temperature cross section for 2eta->4eta
	  double cross_section_2eta_4eta(double cme) const;
	  // Compute the self-interaction cross-section of the eta
	  double cross_section_2eta_2eta() const;
	  // Compute the self-interaction cross-section of the delta
	  double cross_section_2del_2del() const;
	  // Compute the thermal cross section for 2eta -> 4eta
	  double thermal_cross_section_2eta_4eta(double x) const;
	  // Compute the thermal cross section for 4eta -> 2eta
	  double thermal_cross_section_4eta_2eta(double x) const;
	  // Compute the thermal cross section for 2eta -> 2delta
	  double thermal_cross_section_2eta_2del(double x) const;
	
	  //=========================================================================
	  //---- Misc. Thermal Functions --------------------------------------------
	  //=========================================================================
	
	  // Compute the equillibrium number density of the eta
	  double neq_eta(double td) const;
	  // Compute the comoving number density of the eta.
	  double yeq_eta(double tsm, double xi) const;
	  // Compute the log equilibrium number density of the eta / sm entropy density
	  double weq_eta(double tsm, double xi) const;
	  // Compute the equillibrium number density of the delta
	  double neq_del(double td) const;
	  // Compute the comoving number density of the delta.
	  double yeq_del(double tsm, double xi) const;
	  // Compute the log equilibrium number density of the del / sm entropy density
	  double weq_del(double tsm, double xi) const;
	  // Compute the effective dof stored in entropy of the dark sector
	  double dark_heff(double td) const;
	  // Compute the effective dof stored in energy of the dark sector
	  double dark_geff(double td) const;
	  // Compute the sqrt(g_star) including dark sector contributions
	  double sqrt_gstar(double tsm, double xi) const;
	  // Compute the effective dof stored in entropy of the dark sector td ~ inf
	  double dark_heff_inf() const { return 7.0 / 2.0 * n + 2.0 * (n * n - 1.0); }
	
	  //=========================================================================
	  //---- Functions for computing xi = Td / Tsm ------------------------------
	  //=========================================================================
	
	  // Compute the lower and upper bounds of xi assuming td is known
	  std::pair<double, double> xi_bounds_const_td(double td) const;
	  // Compute the lower and upper bounds of xi assuming tsm is known
	  std::pair<double, double> xi_bounds_const_tsm(double tsm) const;
	  // Compute the xi assuming td is known
	  double compute_xi_const_td(double td) const;
	  // Compute the xi assuming tsm is known
	  double compute_xi_const_tsm(double tsm) const;
	
	  //=========================================================================
	  //---- Solving Boltzman Equation ------------------------------------------
	  //=========================================================================
	
	  // Solve the boltzmann equation for the eta and delta comoving number
	  // densities
	  void solve_boltzmann(double reltol, double abstol);
	
	private:
	  //=========================================================================
	  //---- RHS of boltzmann equation and its Jacobian -------------------------
	  //=========================================================================
	
	  // Compute the RHS of the Boltzmann equation
	  void boltzmann(double, const Vector<double> &, Vector<double> &);
	  // Compute the Jacobian of the Boltzmann equation
	  void boltzmann_jac(double, const Vector<double> &, Matrix<double> &);
	
	  //=========================================================================
	  //---- Functions for delta Neff -------------------------------------------
	  //=========================================================================
	
	  // Compute delta Neff at BBN
	  double compute_dneff_bbn() const;
	  // Compute delta Neff at CMB
	  double compute_dneff_cmb() const;
	
	  //=========================================================================
	  //---- Functions used to compute 2eta -> 4eta cross-section ---------------
	  //=========================================================================
	  //
	  // The cross section for 2eta -> 4eta can be written as:
	  //    cs(cme) = f(...) * csbar(l1, l2, z)
	  // with f(...) being a function of the  model parameters and csbar(l1, l2, z)
	  // a function of the low-energy constants l1 and l2 and the center-of-mass
	  // energy scaled by the eta mass (z = cme / meta). The function csbar can be
	  // decomposed into functions which are indenpendent of l1 and l2 as:
	  //    csbar(l1, l2, z) = l1^4 cs44(z) + l2^2 cs66 - 2 l1^2 l2 cs46(z)
	  // Here, cs44 is the cross section constructed of only the 4pt eta
	  // interaction, cs66 is the cross section constructed of only the 6pt eta
	  // interaction and cs46 is the interference term.
	  //
	  // To compute the 2eta->4eta cross section, we use a Monte-Carlo phase-space
	  // integrator (see phase_space.hpp and its dependencies) to generate data
	  // for cs44, cs66 and cs46 as a function of z. We perform fits to determine
	  // the large energy behavior of the cross sections (all go like 10^c * z^14
	  // i.e. a linear function on a log-log scale: log(cs) ~ 14 log(z) + c)
	  // functions. Below are the definitions for the fitting data and functions
	  // for cs44, cs46 and cs66. The data is located in
	  // "darksun/src/model/cs_data.cpp" and other definitions in
	  // "darksun/src/model/cross_sections.cpp".
	
	  // Data was fit from log10(4+10^-5) to log10(100) with 500 steps
	  static constexpr double log_eta_z_min = 0.60206107706280998056;
	  static constexpr double log_eta_z_max = 2.0;
	  static constexpr double log_eta_z_step = 0.0028014808074893587564;
	
	  // Fitting results for 2eta->4eta for large z (100 < z = cme / meta)
	  static constexpr double eta_cs_intercept44 = -9.744896762121916;
	  static constexpr double eta_cs_intercept66 = -10.667768576761643;
	  static constexpr double eta_cs_intercept46 = -10.206870194730394;
	
	  // Data which is stored in "darksun/src/model/cs_data.cpp"
	  static const std::array<double, 500> log_eta_cs44;
	  static const std::array<double, 500> log_eta_cs66;
	  static const std::array<double, 500> log_eta_cs46;
	
	  // Boost splines for cs44, cs66 and cs46
	  static const boost::math::cubic_b_spline<double> log_eta_cs44_spline;
	  static const boost::math::cubic_b_spline<double> log_eta_cs66_spline;
	  static const boost::math::cubic_b_spline<double> log_eta_cs46_spline;
	
	  // Functions valid for all z
	  static double scaled_cs_eta_24_44(double z);
	  static double scaled_cs_eta_24_66(double z);
	  static double scaled_cs_eta_24_46(double z);
	};
1d392375c66924b99ff8b028c59a0989|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|238|1|V|cpp
	static double scaled_cs_eta_24_44(double z);
	static double scaled_cs_eta_24_66(double z);
	static double scaled_cs_eta_24_46(double z);
b1404b095f013b79b784e25d8fbdb590|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|67|46|v|cpp
	// xi when eta freezes
6c33cbbd55c9c11e8add3644f7d438f4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|69|46|v|cpp
	// SM temp when eta freezes
3411f86496dd1900ce554aa1fb100458|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|71|46|v|cpp
	// xi at CMB
0f1997514c5f59aedde8c3bc727ded96|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|73|46|v|cpp
	// xi at BBN
9f9ea1b0f412628fb1e81bc1ba1e54aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|75|46|v|cpp
	// eta relic density
1e8d94a65f1ab86bc08992c1107b04ea|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|77|46|v|cpp
	// delta relic density
753785a497cd10eaa40ea70c202e6c8e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|79|46|v|cpp
	// delta Neff at CMB
67ccc7cbd3d0a60c89818080e945066e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|81|46|v|cpp
	// delta Neff at BBN
88e367325044178ff863d4a38ec76846|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|83|46|v|cpp
	// eta SI cross section today
7e606ed90f8aa049d3fff47cfbf34b94|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|85|46|v|cpp
	// delta SI cross section today
b46ad6cd502ab324ebbdb8c47d6c00d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|87|46|v|cpp
	// solution to boltzmann equation
2cbc32de5ef47f40f5b259034d7b0680|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|74|50|v|cpp
	DarkSunIdx
fe7a1f8f0116ccaefe44c86e12adacc7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|72|50|v|cpp
	arkSunIdx
b4231fda59a77f53c7b306485290f7cf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|96|1|V|cpp
	  model[RdEta] = -1.0;
	  model[RdDel] = -1.0;
3c7e6556c857f9e44e44ccec78c83532|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|13|1|V|cpp
	static boost::math::cubic_b_spline<double>
cfee1c93ea5d387291f75815acc394c6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|72|22|v|cpp
	model[Lam];
bb8a1ba68cbf0ace259c0de0109db75a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|73|25|v|cpp
	model[MuEta];
3a29739b9beb9a5260b5149c1d12ad37|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|74|20|v|cpp
	model[N]
84985546db3d2e712540ca5be18ec895|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|75|1|V|cpp
	  const double lec1 = get_lec1(model);
3e08db112b3c5806f6499d8635c40da2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|72|1|V|cpp
	  const double lam = get_lam(model);
	  const double mu_eta = get_mu_eta(model);
	  const double n = get_n(model);
	  const double lec1 = get_lec1(model);
	  const double lec2 = get_lec2(model);
771fde63c8aff70f454e52fceb4bc1a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|95|3|V|cpp
	  const double mu_eta = get_mu_eta(model);
9e925e9341b490bfd3b4c4ca3b0c1ef2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|132|16|v|cpp
	this
611b95cf2fc52eeb1bb7b0fe1be6fdcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|172|1|V|cpp
	  const double n = get_n(model);
95e257fde93aeec20e5562ec12f7343a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|173|1|V|cpp
	  const double c = get_c(model);
cfbaf728368d017f96c71b8010cc5f50|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|15|5|v|cpp
	model::log_eta_cs44_spline
723ce1dc65aad5b88bc23558bd453377|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|14|30|v|cpp
	tatic 
7aae3f1fd126c3f58121eaf836b9c90f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|11|1|V|cpp
	namespace model {
5f9dcbbb3d9755c839121830570bc062|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|41|1|V|cpp
	using Idx = DarkSunIdx;
74669d85148df53d872df4dfe679e08c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|257|3|v|cpp
	 // namespace model
eb921b931c43a7ade5999dddeb174b39|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|34|1|V|cpp
	private:
	  static constexpr size_t N_PARS = 22;
	  static constexpr size_t N_SOL = 100;
	  static constexpr size_t LEN_SOL = 3 * N_SOL;
	  static constexpr size_t LEN = LEN_SOL + N_PARS;
fee0c87a5f5c1b34ea1ac5cd0d57545d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|69|57|v|cpp
	, const double *model
4ea9950c13ef1795a979fda24710c193|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|73|1|V|cpp
	  const double lam = get_lam(model);
9aaa3ec806d7142d65f40b4eccd5fb3a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|75|1|V|cpp
	  const double lec2 = get_lec2(model);
71db9a78857fc789761bc261fab04dff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|72|1|V|cpp
	  const double mu_eta = get_mu_eta(model);
	  const double lam = get_lam(model);
	  const double lec1 = get_lec1(model);
	  const double lec2 = get_lec2(model);
	  const double n = get_n(model);
649a1081ed55c126ce933efa731fcfc8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|9|7|v|cpp
	xi_bbn.has_value()
6ca362ee04ea86cef41f6b54af3878b0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|10|23|v|cpp
	xi_cmb.value();
b014e03319ab490dec1033f6c9332c48|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|10|23|v|cpp
	model[XiCmb];
b6bcaea0ed1de585d949cce9c15ce215|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|10|7|v|cpp
	model[XiCmb] != -1.0) {
80b816c0ecc71e2a1164024fef85ae88|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|11|5|V|cpp
	    const double xi = get_
a6c9cc30245d5c24be9eaa7a56d5ade9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|9|1|V|cpp
	  const double xi = get_xi_cmb(model);
b70d6d20d42bf249f0c6eac8d28f0020|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|21|7|v|cpp
	xi_bbn.has_value()) {
3369d45a203b5c0422c892101d4fd76e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|21|10|v|cpp
	!= -1.0){
6deef09efd7b40abe72a7fe997ffaf46|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|22|5|V|cpp
	    const double xi = xi_bbn.value();
0dd71a88db88a32487963fdae78e3190|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|15|1|V|cpp
	  const double xi_inf = get_xi_inf(model);
d95bdb20e22ba3dd43142e84ab4a6505|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|71|7|v|cpp
	tsm_fo.has_value()) {
eac349bfd1be80f13e60f265c3c6145e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|72|5|V|cpp
	    double tfo = tsm_fo.value();
eee6ede9cac721e91390f08f27ab56e9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|76|28|v|cpp
	xi_fo.value();
f678e4fa30166311f459d2398772b508|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|64|12|v|cpp
	void fcn(int *, double *, double *, double *, double *, int *)
b65448fc6711dfaa56d275d20a7eec9d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|16|1|V|cpp
	void DarkSun::boltzmann(double logx, const Vector<double> &y,
8807b0d7495520c0da89e0308a490822|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|16|25|v|cpp
	double logx, const Vector<double> &y,
a0e11c81fbbf55079f0a9df0b8fac39b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|17|24|V|cpp
	                        Vector<double> &dy) {
b2f5338d88ed6aa791e1f2e4ab877120|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|29|27|v|cpp
	!xi_fo.has_value()
3bc3bd65419b3d620ad0ad27b45fd31d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|108|1|V|cpp
	  //=========================================================================
	  //---- Functions for computing properities of eta and delta ---------------
	  //=========================================================================
442d9d2cb768d65b1db61c79e88f7fc6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|46|10|v|cpp
	Functions for computing properities of eta and delta ---------------
71613957b5d55af415dfd754ee5b0c09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|45|1|V|cpp
	  //=========================================================================
	  //---- Getter functions ---------------------------------------------------
	  //=========================================================================
	
	  // Model Parameters
	
	  // N in SU(N)
	  static size_t get_n(const double *model) { return model[N]; }
	  // confinement scale
	  static double get_lam(const double *model) { return model[Lam]; }
	  // suppression factor for 2eta->2del
	  static double get_c(const double *model) { return model[C]; }
	  // suppression factor for initial delta abundance
	  static double get_adel(const double *model) { return model[Adel]; }
	  // low-energy constant for 4pt eta interactions
	  static double get_lec1(const double *model) { return model[Lec1]; }
	  // low-energy constant for 6pt eta interactions
	  static double get_lec2(const double *model) { return model[Lec2]; }
	  // prefactor of eta mass: mu_eta * lam / sqrt(n)
	  static double get_mu_eta(const double *model) { return model[MuEta]; }
	  // prefactor of del mass: mu_del * lam * n
	  static double get_mu_del(const double *model) { return model[MuDel]; }
	  // initial ratio of dark to SM temperatures
	  static double get_xi_inf(const double *model) { return model[XiInf]; }
	
	  // Derived quantities
	
	  // xi when eta freezes
	  static double get_xi_fo(const double *model) { return model[XiFo]; }
	  // SM temp when eta freezes
	  static double get_tsm_fo(const double *model) { return model[TsmFo]; }
	  // xi at CMB
	  static double get_xi_cmb(const double *model) { return model[XiCmb]; }
	  // xi at BBN
	  static double get_xi_bbn(const double *model) { return model[XiBbn]; }
	  // eta relic density
	  static double get_rd_eta(const double *model) { return model[RdEta]; }
	  // delta relic density
	  static double get_rd_del(const double *model) { return model[RdDel]; }
	  // delta Neff at CMB
	  static double get_dneff_cmb(const double *model) { return model[DNeffCmb]; }
	  // delta Neff at BBN
	  static double get_dneff_bbn(const double *model) { return model[DNeffBbn]; }
	  // eta SI cross section today
	  static double get_eta_si_per_mass(const double *model) {
	    return model[EtaSiPerMass];
	  }
	  // delta SI cross section today
	  static double get_del_si_per_mass(const double *model) {
	    return model[DelSiPerMass];
	  }
	  // solution to boltzmann equation
	  static OdeSolution get_sol_boltz(const double *model);
73a32ddbf269a097182ef9e04fea743f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|150|37|v|cpp
	onst 
4907573ea489ab0b76a62585cfe4b8fb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|70|1|V|cpp
	  // get the spacing between logx's in solutions 
	  static double get_dx(const double *model) {return model[Dx];}
4c80a84ddbfd56e6aff638406cc78158|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|72|14|v|cpp
	spacing between logx's in solutions 
c4999459fd2f39020dc338762c1e447f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|70|1|V|cpp
	  // get the spacing between logx's in solutions
	  static double get_dx(const double *model) { return model[Dx]; }
	  // get the current value of logx
	  static double get_xout(const double *model) { return model[Xout]; }
c2b5ac62285e676a9a1c815eb20d4d29|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|102|10|v|cpp
	std::array<std::array<double, 3>, LEN_SOL>
18b76a03887a61930bcd2e468ba4fc5c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|107|1|V|cpp
	        model[N_PARS + 3 * i + 0],
7bd4288175805d04d5aa48524b7dfee0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|102|1|V|cpp
	  static auto get_sol_boltz(const double *model)
	      -> std::array<std::array<double, 3>, LEN_SOL> {
	    std::array<std::array<double, 3>, LEN_SOL> sol;
	    for (int i = 0; i < N_SOL; i++) {
	      sol[i] = {model[N_PARS + 3 * i + 0], model[N_PARS + 3 * i + 1],
	                model[N_PARS + 3 * i + 2]};
	    }
	    return sol;
	  }
32c6898bb2de086644ef6c4f112eb206|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|104|37|v|cpp
	, LEN_SOL> sol;
8d41f9960735a351150fba50ff240093|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|104|5|v|cpp
	std::array<
0abd4348b7552eaf93ea666d114bf70b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|105|5|V|cpp
	    for (int i = 0; i < N_SOL; i++) {
ac0c9c9fa6c0b1f1be943214a7fa241a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|105|5|v|cpp
	sol = 
08d45e8e795c357c966e3f7d53c326d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|107|5|V|cpp
	    return sol;
fae990c14fc629d97f00afc553db5447|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|102|48|v|cpp
	, int i
68a85e610b3397bec4ea81a961a92559|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|102|1|V|cpp
	  static auto get_sol_boltz(int i, const double *model)
	      -> std::array<std::array<double, 3>, LEN_SOL> {
	    std::array<double, 3> sol;
	    return {model[N_PARS + 3 * i + 0], model[N_PARS + 3 * i + 1],
	            model[N_PARS + 3 * i + 2]};
	  }
55827f059e1b5a45811868e7b11a04cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|179|1|V|cpp
	  static void set_sol_boltz(double *model);
0e948fe802d411006bf8c7ee6c1f4fdf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|180|7|V|cpp
	      -> std::array<std::array<double, 3>, LEN_SOL> {
5450c21aa060a47cea9d25c8e04781f6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|181|5|v|cpp
	return {
a10f53d193308da442e986328751828d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|181|30|v|cpp
	, model[N_PARS + 3 * i + 1],
	            model[N_PARS + 3 * i + 2]};
d258cdef9e36e966bd2449f018e46813|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|181|1|V|cpp
	    model[N_PARS + 3 * i + 0] = logx;
c5cadce10fe5896fdb43befb03967963|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|181|5|V|cpp
	    std::array<double, 3> sol;
5080f71a8df2154ffe81e89b5f623eff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|290|25|v|cpp
	double, const Vector<double> &, Vector<double> &);
a9424308b72078d2ee7eb26fa3677a87|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|293|29|v|cpp
	double, const Vector<double> &, Matrix<double> &);
3cfa9dc44a5ed30d1ba9ac6c4180f919|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|48|29|v|cpp
	double logx, const Vector<double> &y,
	                            Matrix<double> &df
c962ec1fd26d639003398c600c6f914a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|72|1|V|cpp
	  double *df[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i) {
	    df[i] = &dfy[i * *ldfy];
	  }
	
	  df[0][0] = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	  df[1][0] = 0.0;
	
	  df[0][1] = 2.0 * pfd * sigd * exp(2.0 * we);
	  df[1][1] = 0.0;
c02af2b4ff0ea288f36bc5f5a85b1c89|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|82|1|V|cpp
	  df(0, 0) = pfe * sige * exp(we) * (3.0 * exp(2 * we) - exp(2 * we_eq));
	  df(0, 1) = 0.0;
	  df(1, 0) = 2.0 * pfd * sigd * exp(2 * we);
	  df(1, 1) = 0.0;
b92edb93b7915bb91956f9421047c056|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|283|73|v|cpp
	, double *model
980424c929e6194243ac9e88d520a0c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|89|1|V|cpp
	  auto boltz = [this](double logx, const Vector<double> &y,
	                      Vector<double> &dy) { boltzmann(logx, y, dy); };
	  auto boltz_jac = [this](double logx, const Vector<double> &y,
	                          Matrix<double> &df) { boltzmann_jac(logx, y, df); };
9e68b2d2bdbd60e33f9745a0c844c2dc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|131|1|V|cpp
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-7;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	
	  rpar[0] = (log_xfinal - log_xstart) / double(num_sols);
	
	  // Extract the model parameters and put then in rpar and ipar
	  std::cout << "Running Radau5\n";
	  radau5(nd, boltz, log_xstart, y.data(), log_xfinal, 1e-6, rtol, atol,
	         boltz_jac, ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout,
	         work.data(), iwork.data(), rpar.data(), nullptr, &idid);
007b4a018cfd784e60a7bdb5e43e736c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|108|1|V|cpp
	  auto rad = Radau5(ndim, boltz, std::optional<OdeJac>(boltz_jac),
	                    std::optional<OdeMas>(), y, log_xstart, log_xfinal, dlogx,
	                    abstol, reltol, mljac, mujac, mlmas, mumas);
	  sol_boltz = rad.integrate();
26fd7b529d0e67ab74c4707b21ae5ef4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|103|1|V|cpp
	  int mljac = ndim;
	  int mujac = 0;
	  int mlmas = 0;
	  int mumas = 0;
0c4575a01a5b9bf530407ca28ca6b6a9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|131|50|v|cpp
	num_sols
d617fd18ecc897a9f8bd907f2dada316|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|136|10|v|cpp
	boltz_jac
c60ebd75fea8c6a1df63fc49add9f8cc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|137|37|v|cpp
	rpar.data()
a27ef2b7620e775b453ccb3e143b9308|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|87|1|V|cpp
	void solout(int *nr, double *xold, double *x, double *y, double *cont, int *lrc,
	            int *n, double *rpar, int *ipar, int *irtrn) {
aa3f9d2395ba51bddb9e7af35d906572|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|296|1|V|cpp
	  static void solout(int *nr, double *xold, double *x, double *y, double *cont,
	                     int *lrc, int *n, double *rpar, int *ipar, int *irtrn);
b7e9438cf38eaeba5cbbac9bb5b8681c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|87|1|V|cpp
	void solout(int *nr, double *xold, double *x, double *y, double *cont, int *lrc,
	            int *n, double *rpar, int *ipar, int *irtrn) {
	  double dx = rpar[0];
	  double d = rpar[1];
	  double yd[2];
	  if (*nr == 1) {
	    d = *xold;
	  }
	  while ((*xold <= d) && (*x >= d)) {
	    // int len = *ipar;
	    yd[0] = contr5(1, d, cont, lrc);
	    yd[1] = contr5(2, d, cont, lrc);
	    f_logxs.push_back(d);
	    f_wes.push_back(yd[0]);
	    f_yds.push_back(yd[1]);
	
	    d += dx;
	  }
	  rpar[1] = d;
	};
8bde0f11da8edd0e86a1b361d1db7fc4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|2|19|v|cpp
	diffeq.hpp"
a2be6123283c45da7867a852732a7e77|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|94|1|V|cpp
	    f_logxs.push_back(d);
	    f_wes.push_back(yd[0]);
	    f_yds.push_back(yd[1]);
b6acb6327938a2cf922b9925c339259d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|157|14|v|cpp
	&DarkSun::
24d0c72269ed15143f05a7624c2cb61c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|157|3|V|cpp
	  std::cout << "Running Radau5\n";
2dab28c6eb607f79cdcd3c3ff9742e0f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|161|7|v|cpp
	sol_boltz.value().code == Success) {
c30fedacb95cd28d444adc3d536032ec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|82|1|V|cpp
	//===========================================================================
	//---- solution output ------------------------------------------------------
	//===========================================================================
22565cbd36d536d9d690c91f0d38dab4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|107|8|v|cpp
	solution output ------------------------------------------------------
d48bff746fcd7fe2579a28115c597654|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|11|1|V|cpp
	// Set a global model so we can use it in Fortran routine
	static constexpr size_t n = 10;
	static constexpr double lam = 1e-3;
	DarkSun gmodel{n, lam};
	
	// Vector to store Fortran Solution
	std::vector<double> f_logxs;
	std::vector<double> f_wes;
	std::vector<double> f_yds;
	
	void boltz(int *, double *logx, double *y, double *dy, double *rpar,
	           int *ipar) {
	
	  const double x = exp(*logx);
	  const double meta = gmodel.m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = gmodel.compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = StandardModel::entropy_density(tsm);
	  double weq = gmodel.weq_eta(tsm, xi);
	
	  // Determine if the eta' has frozen out
	  if (we - weq > 0.1 && !gmodel.tsm_fo.has_value()) {
	    gmodel.xi_fo = xi;
	    gmodel.tsm_fo = tsm;
	  }
	
	  double xd = meta / td;
	  double sige = gmodel.thermal_cross_section_4eta_2eta(xd);
	  double sigd = gmodel.thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * gmodel.sqrt_gstar(tsm, xi);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * tsm / x;
	
	  dy[0] = pfe * sige * exp(we) * (exp(2.0 * we) - exp(2.0 * weq));
	  dy[1] = pfd * sigd * exp(2.0 * we);
	}
	
	void boltz_jac(int *n, double *logx, double *y, double *dfy, int *ldfy,
	               double *rpar, double *) {
	  const double x = exp(*logx);
	  const double meta = gmodel.m_eta();
	  const double tsm = meta / x;
	  const double we = y[0]; // log(Yeta)
	
	  double xi = gmodel.compute_xi_const_tsm(tsm);
	  double td = xi * tsm;
	  double s = StandardModel::entropy_density(tsm);
	  double weq = gmodel.weq_eta(tsm, xi);
	
	  double xd = meta / td;
	  double sige = gmodel.thermal_cross_section_4eta_2eta(xd);
	  double sigd = gmodel.thermal_cross_section_2eta_2del(xd);
	
	  double pf = sqrt(M_PI / 45) * M_PLANK * gmodel.sqrt_gstar(tsm, xi);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * tsm / x;
	
	  double *df[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i) {
	    df[i] = &dfy[i * *ldfy];
	  }
	
	  df[0][0] = pfe * sige * exp(we) * (3.0 * exp(2.0 * we) - exp(2.0 * weq));
	  df[1][0] = 0.0;
	
	  df[0][1] = 2.0 * pfd * sigd * exp(2.0 * we);
	  df[1][1] = 0.0;
	}
	
	void mm(int *n, double *am, int *lmas, int *rpar, int *ipar){};
	void solout(int *nr, double *xold, double *x, double *y, double *cont, int *lrc,
	            int *n, double *rpar, int *ipar, int *irtrn) {
	  double dx = rpar[0];
	  double d = rpar[1];
	  double yd[2];
	  if (*nr == 1) {
	    d = *xold;
	  }
	  while ((*xold <= d) && (*x >= d)) {
	    // int len = *ipar;
	    yd[0] = contr5(1, d, cont, lrc);
	    yd[1] = contr5(2, d, cont, lrc);
	    f_logxs.push_back(d);
	    f_wes.push_back(yd[0]);
	    f_yds.push_back(yd[1]);
	
	    d += dx;
	  }
	  rpar[1] = d;
	};
	
	void solve_boltzmann() {
	  size_t num_sols = 100;
	  f_logxs.reserve(num_sols);
	  f_wes.reserve(num_sols);
	  f_yds.reserve(num_sols);
	
	  gsl_set_error_handler_off(); // Turn off the gsl errors
	
	  double log_xstart;        // Log of initial x
	  double log_xfinal;        // Log of final x (end at CMB)
	  std::vector<double> y(2); // Storage for the solution
	  std::vector<double> rpar(2);
	
	  double meta = gmodel.m_eta();               // Mass of the eta
	  double td = gmodel.lam / 2.0;               // Start Td at confinement
	  double xi = gmodel.compute_xi_const_td(td); // Starting value of xi
	  double tsm = td / xi;                       // Initial SM temperature
	  log_xstart = log(meta / tsm);               // Log of initial x
	  log_xfinal = log(meta / T_CMB);             // Log of final x (end at CMB)
	
	  y[0] = gmodel.weq_eta(tsm, xi);
	  y[1] = gmodel.yeq_del(tsm, xi) * exp(-gmodel.adel * gmodel.n);
	
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-7;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	
	  rpar[0] = (log_xfinal - log_xstart) / double(num_sols);
	
	  // Extract the model parameters and put then in rpar and ipar
	  std::cout << "Running Radau5\n";
	  radau5(nd, boltz, log_xstart, y.data(), log_xfinal, 1e-6, rtol, atol,
	         boltz_jac, ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout,
	         work.data(), iwork.data(), rpar.data(), nullptr, &idid);
	}
820adb7be49d1945cd17fad10163f061|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|43|3|v|cpp
	std::array<double, LEN>
d346fbeca49304d24ae9321a1366fac3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|45|1|V|cpp
	    model[N] = double(n);
8260f4881ab8d87018659c03da407578|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|46|18|v|cpp
	double(n);
02639e26ad4f3bb6a988ee57376e7b38|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|46|1|V|cpp
	    model[Lam] = lam;
261ee6354812b6ab2e859b6388b2764f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|47|1|V|cpp
	    model[Adel] = 1.0;
2374447799f06b33e3f66e5617462c0b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|48|1|V|cpp
	    model[C] = 1.0;
ee6c5f2e54d95b45feba49210fef8601|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|49|1|V|cpp
	    model[Lec1] = 0.1;
c42b71ce783b070a1280f1ec17c105eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|50|1|V|cpp
	    model[Lec2] = 0.1;
a740a29f078bdc02d0a651e72762b539|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|51|20|v|cpp
	0.1;
7cde13826a2f3eeb02a785fb078d7185|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|51|1|V|cpp
	    model[MuEta] = 1.0;
cb019ee22cac629e9de575416f912b69|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|3|V|cpp
	  gmodel.solve_boltzmann(1e-7, 1e-7);
1021738e4e29378a5b4403bc35d262f2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|14|v|cpp
	gmodel.sol_boltz.value();
12a5e9afe820c0852ac04881b53c5dc2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|1|V|cpp
	  std::cout << "Reseting model\n";
	  gmodel.reset();
	
	  // Reset model and solve using Fortran radau
	  std::cout << "Solving with FORTRAN\n";
	  solve_boltzmann();
	  std::cout << std::endl;
	  std::cout << std::endl;
	  std::cout << std::endl;
	
	  for (size_t i = 0; i < f_logxs.size(); i++) {
	    fmt::print("logx = {}, we = {}, wd = {}\n", f_logxs[i], f_wes[i], f_yds[i]);
	  }
742d574c94b6c4b33fc7ed4e78bf0a90|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|88|15|v|cpp
	model[Dx];
45f95fa8a9f0b982457cb241b71d385a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|89|14|v|cpp
	model[Xout];
0004b0bb3650f9bfa564f005151d129a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|105|3|V|cpp
	  model[Xout] = d;
b3670fe44da4927d51374c0a17bb7fff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|106|1|V|cpp
	  std::cout << i << std::endl;
162d00ebf23a78228ae8f38d415b842d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|106|3|V|cpp
	  std::cout << get_xout(model) << std::endl;
bcb1563409212d6aeb0bdd5e13f2b2a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|114|27|v|cpp
	, 3>, NUM_SOLS>
f41f887744ae1065f9225078aa314a77|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|198|1|V|cpp
	    model[XiFo] = -1.0;
	    model[TsmFo] = -1.0;
	    model[XiCmb] = -1.0;
	    model[XiBbn] = -1.0;
	    model[RdEta] = -1.0;
	    model[RdDel] = -1.0;
	    model[DNeffCmb] = -1.0;
	    model[DNeffBbn] = -1.0;
	    model[EtaSiPerMass] = -1.0;
	    model[DelSiPerMass] = -1.0;
353ecda3162cdc0ee9241bea03111938|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|183|1|V|cpp
	    set_rd_eta(model, NAN);
	    set_rd_del(model, NAN);
	    set_xi_cmb(model, NAN);
	    set_xi_bbn(model, NAN);
	    set_dneff_bbn(model, NAN);
	    set_dneff_cmb(model, NAN);
	    set_eta_si_per_mass(model, NAN);
	    set_del_si_per_mass(model, NAN);
a89a615d149c55d0ed9af7900131787c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|32|65|v|cpp
	, NAN));
309623c2071d92afaca700f5f6fc7914|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|1|V|cpp
	  fmt::print("rd eta={}\n", DarkSun::get_rd_eta(model.data()));
	  fmt::print("rd del={}\n", DarkSun::get_rd_del(model.data()));
a1b5f128a538c88b49d36f5dfc8b4c28|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|15|v|cpp
	rd eta
38aa7ea85c09a1196e10f5dd4b851d61|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|25|15|v|cpp
	rd del
afa5041ee37ffa634b5f9379fad2656d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|14|40|v|cpp
	const Vector<double> &
87384a98793914c1f5411e0804aae37f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|14|50|v|cpp
	Vector<double> &
329c969dc63f5e49c96298d3b44fcde3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|16|56|v|cpp
	eps;
ed83ec7b4a6ca9c7d24a8a39ac8a0f56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|18|16|v|cpp
	std::optional(
bffc35b58838b85d0ad2a6bb0448fbd4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|19|10|v|cpp
	double x, const Vector<double> &y, Matrix<double> &df
8b62bc646ebe1e8ed8d955b172351e99|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|25|20|v|cpp
	(-2.0 * y[0] * y[1] - 1.0) / eps;
815a51cf190cb0bdbe1c306939f2798e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|23|1|V|cpp
	        dfy[2] = 1.0;
b7c3b46cecf777e804ea2e2d56762745|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|27|1|V|cpp
	        df(1, 1) = ((1 - y[0] * y[0])) / eps;
e411da69c47733b24100493755fd74c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|24|12|v|cpp
	(1, 1)
d3588a5f5bac52d539a47e6ec47cd0d4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|25|1|V|cpp
	        df(0, 0) = 0.0;
	        df(0, 1) = 1.0;
	        df(1, 0) = (-2.0 * y[0] * y[1] - 1.0) / eps;
	        df(1, 1) = ((1 - y[0] * y[0])) / eps;
27c2be257310227d8b05eba50a091fce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|27|14|v|cpp
	std::optional<OdeMas>();
81871cbba69a6f7a26bd30355a94ae22|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/fstiff.hpp|79|1|V|cpp
	    int n, void fcn(int *, double *, double *, double *, double *, int *),
	    double x, double *y, double xend, double h, double rtol, double atol,
	    void jac(int *, double *, double *, double *, int *, double *, int *),
	    int ijac, int mljac, int mujac,
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    int mlmas, int mumas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *),
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid);
a2cec742bdcad8255e87d10e82a3dc5b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|12|5|V|cpp
	    double x, double *y, double xend, double h, double rtol, double atol,
c0ed95b6020628a1550167901e1bf970|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|13|5|V|cpp
	    int ijac, int mljac, int mujac,
eb365acea5c709832964ccf97307e4cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|14|5|V|cpp
	    int mlmas, int mumas,
bcc46f377e26ff398e25973d47069932|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|16|5|V|cpp
	    int iout, double *work, int *iwork, double *rpar, int *ipar, int *idid);
6b09c54a1a19a52719923cb3c587f880|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|13|1|V|cpp
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *)
59697e59d5331c166c2ae297d151023a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|14|1|V|cpp
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *)
81505020dddad1841713b1e8bfa6faa5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|11|1|V|cpp
	    void fcn(int *, double *, double *, double *, double *, int *),
	    void jac(int *, double *, double *, double *, int *, double *, int *),
	    void mas(int *n, double *am, int *lmas, int *rpar, int *ipar), int imas,
	    void solout(int *, double *, double *, double *, double *, int *, int *,
	                double *, int *, int *)
ad3ea8187d2448483c493b95d942ce4f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|33|3|V|cpp
	  auto mas = [](int *n, double *, int *, double *, int *) {};
95681507155a3a8fe277c9246c8bed4b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|29|3|v|cpp
	auot
b3c29dd0539683edbb2a8e570e113fbe|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|86|1|V|cpp
	void DarkSun::solout(int *nr, double *xold, double *x, double *y, double *cont,
	                     int *lrc, int *n, double *model, int *ipar, int *irtrn) {
	  double dx = get_dx(model);
	  double d = get_xout(model);
	  double yd[2];
	  int i = *ipar;
	  if (*nr == 1) {
	    d = *xold;
	  }
	  while ((*xold <= d) && (*x >= d)) {
	    // int len = *ipar;
	    yd[0] = contra(1, d, cont, lrc);
	    yd[1] = contra(2, d, cont, lrc);
	    set_sol_boltz(i, d, yd[0], yd[1], model);
	
	    d += dx;
	    i += 1;
	  }
	  set_xout(model, d);
	  *ipar = i;
	};
ba6b13870772ddaad8aab0967c37a947|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|30|1|v|cpp
	(int *nr, double *xold, double *x, double *, double *, int *, int *,
	                   double *, int *, int *) {};
4ab93fd18d03762b9852c89fdca63bcc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|30|1|v|cpp
	void DarkSun::solout
a5be7f6c4c8358de409c38c5303608e7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|31|15|v|cpp
	get_dx(model);
0a030a71aeac7dafb61b4874cef3661c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|32|14|v|cpp
	get_xout(model);
ce1f5703c17baab657ec4edfd8b5dc0e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|32|3|V|cpp
	  double d = rpar[0]
914330eacc4595affc5f43b833bbbf75|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|42|5|V|cpp
	    set_sol_boltz(i, d, yd[0], yd[1], model);
13f015e997c3e4980fafaa0239d408a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|47|3|V|cpp
	  set_xout(model, d);
5aa603c6e3dc9643144a5b58dfb27bb4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|52|3|v|cpp
	Vector<double>
1bac909aef1a5e2cec63f7e04528126c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|52|11|v|cpp
	(n);
22c6a6111cde634ef64a23706bcfb6eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|167|1|V|cpp
	  radau(nd, boltzmann, log_xstart, y.data(), log_xfinal, h, rtol, atol,
	        boltzmann_jac, ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout,
	        work.data(), iwork.data(), model, &ipar, &idid);
28185d3ee5c962494ea79e473efde50f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|136|1|V|cpp
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-7;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	  int ipar = 0;
	
	  model[Dx] = (log_xfinal - log_xstart) / double(DarkSun::NUM_SOLS - 1);
	
	  // Extract the model parameters and put then in rpar and ipar
	  radau(nd, boltzmann, log_xstart, y.data(), log_xfinal, h, rtol, atol,
	        boltzmann_jac, ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout,
	        work.data(), iwork.data(), model, &ipar, &idid);
8b8401033ad6be374049288510c48491|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|51|1|V|cpp
	  int n = 2;
	  double y[2];
	  y[0] = 2.0;
	  y[1] = -0.66;
	  double x = 0.0;
	  double xend = 2.0;
	  double dx = 0.05;
	  int mljac = n;
	  int mujac = 0;
	  int mlmas = 0;
	  int mumas = 0;
	  double reltol = 1e-6;
	  double abstol = 1e-6;
	
	  auto rad = Radau5(n, vdpol, jvpol, mas, y, x, xend, dx, abstol, reltol, mljac,
	                    mujac, mlmas, mumas);
	  auto sol = rad.integrate();
4e0ea28d57afe5205fbeb85d88532d91|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|79|3|v|cpp
	model[Dx] = (log_xfinal - log_xstart) / double(DarkSun::NUM_SOLS - 1);
597851d5776655424eb1b1e5bafb8448|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|87|20|v|cpp
	log_xstart
41bf7318db1f7eea491f29f4bbac1d33|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|88|9|v|cpp
	boltzmann_jac
5f082a041ecd404925f137417d766688|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|4|1|V|cpp
	#include "darksun/diffeq.hpp"
c13e02ce18250a697a5b3604706e2f9f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|34|5|V|cpp
	    int i = *ipar;
f97fcbb3727f3b1619d011bae4abd24f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|46|5|V|cpp
	    *ipar = i;
561af2e9be90a3ee8bc60c26eb98134b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|44|3|V|cpp
	      i += 1;
835ff5c86125dc02de6d34b63fda2ce6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|12|3|V|cpp
	  double eps = 1e-6;
2e0cf4a12eb4cf1a2bd41cf98addcdb5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|39|7|V|cpp
	      fmt::print("x = {}, y = {}, yp = {}\n", d, yd[0], yd[1]);
973ad358d4e8428ede5073a87607c17c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|80|1|V|cpp
	  constexpr int num_xs = 40;
7eb2aa76f037990159a6d9fefc2628ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|80|1|V|cpp
	  constexpr int num_xs = 40;
	  double rpar[3 + 2 * num_xs];
	  rpar[0] = 1e-6;
	  rpar[1] = xstart;
	  rpar[2] = (xend - xstart) / double(num_xs);
28631a9de89e7ae4d7256e2c2df0bab9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|45|1|V|cpp
	      rpar[3 + i * num_xs + 0];
07c810d51098cab3b64ec22b721d34fc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|53|15|V|cpp
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-9;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	  int ipar = 0;
	
	  double xstart = 0.0;
	  double xend = 2.0;
	  double y[2];
	  y[0] = 2.0;
	  y[1] = -0.66;
18e1106918c27ef6cf1c2e1e4da21ff0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|52|1|V|cpp
	  //=========================================================================
1b892f6e2864313a5db95944d6763980|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|52|1|V|cpp
	  //=========================================================================
	  //---- Functions ----------------------------------------------------------
	  //=========================================================================
e93acb146e114b5dfa6ce2d12dcb96e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|93|10|v|cpp
	Functions
e47650e110e21a43367265c49c20b973|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|89|1|V|cpp
	      rpar[3 + i * num_xs + q];
3f2c8ece16ec10d2cdcaaf9d7f13c0e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|57|10|v|cpp
	Functions ----------------------------------------------------------
ff1b6e5368af3e0210ad0d165f80bcea|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|56|1|V|cpp
	  //=========================================================================
	  //---- Van Der Pol Equation -----------------------------------------------
	  //=========================================================================
aa8a105043d90127c760e67170853c2c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|67|22|v|cpp
	Equation
0fad43aec4929290e65bc8d65f9d9e09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|66|1|V|cpp
	  //=========================================================================
	  //---- Van Der Pol Jacobian -----------------------------------------------
	  //=========================================================================
4dd807997a2e695f629c35ac63133623|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|83|10|v|cpp
	Van Der Pol Jacobian -----------------------------------------------
a663c2d75a1976e30daf952ea42faf1c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|82|1|V|cpp
	  //=========================================================================
	  //---- Solution Output ----------------------------------------------------
	  //=========================================================================
823d29d46bfe642a49dcae3a9e7cdfbb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|80|10|v|cpp
	Solution Output ----------------------------------------------------
b4e3ee03e5070cd5479c2888956d176e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|113|1|V|cpp
	  //=========================================================================
	  //---- Solve --------------------------------------------------------------
	  //=========================================================================
652b2870d3b6b1ab60651f0dec2e07f8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|123|10|v|cpp
	Solve --------------------------------------------------------------
daec210a5acb4a14e591ab24280fecd0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|170|42|v|cpp
	rpar[3 + num_xs * i + 0]
4d88d4425df37e94b8d6e55254626f22|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|172|1|V|cpp
	        sol.ys[i](0), 
5af7fe1bcd72f494e38608cc7ccd385d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|173|1|V|cpp
	        sol.ys[i](1)
33fe0c7cfb9b501c4e5d471de8d67234|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|102|20|v|cpp
	num_xs
e2312274390edbb1990a9072df1a0035|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|102|1|V|cpp
	      rpar[3 + i * 3 + 0] = d;
	      rpar[3 + i * 3 + 1] = yd[0];
	      rpar[3 + i * 3 + 2] = yd[1];
2c39da651f6641f7a19d72ded4c4d7d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|72|1|V|cpp
	    double eps = rpar[0];
684f09a6eff1c39f838396bad5dd492e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|175|26|v|cpp
	mma.size()
9874fad9b95e8feab841777c9b357d43|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|51|37|v|cpp
	[3 + 3 * num_xs];
e306ae02babbd01437c1d5d2f16250d6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|75|8|v|cpp
	Weta
500c9536700495e7a3c03d2beecd72ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|75|1|V|cpp
	  // d f / d Weta
28ad9582a705119654e11fac4b0a05ee|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|75|1|V|cpp
	  // df / dWeta
7cbdb5f893104ac7b61b4109eb14d688|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|75|1|V|cpp
	  // df[0] / dWeta
1444173a18d1390b8ee51038cd836e41|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|80|12|v|cpp
	2.0 * pfd * sigd * exp(2.0 * we);
6cf6d19f4bcd7c5417e536cd0d0a6977|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|79|1|V|cpp
	  // df[0] / dYdel
82c61b48d103776f206b860f306b0c60|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|68|10|V|cpp
	  double *df[2];
	  int i;
	  /* set J to first elt. of each column */
	  for (i = 0; i < *n; ++i) {
	    df[i] = &dfy[i * *ldfy];
	  }
22efdbe132eabc102306bd7a334fb434|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|9|6|v|cpp
	Scan
4d4658dee28505d10cc285afbaaccda8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|21|1|V|cpp
	template<Type, 
5632220af4c029b7fd90f0ca37128057|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|23|1|V|cpp
	  std::array<
f0756e21b6c52b55146d252ac1f5a72a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|11|15|V|cpp
	enum VarName {
	  N,
	  Lam,
	  C,
	  Adel,
	  Lec1,
	  Lec2,
	  MuEta,
	  MuDel,
	  XiInf,
	};
	
	struct ScanVar {
	  VarName name;
	  std::vector<double> values;
	};
9a41f75d48513dc3e7178a2185ee8d7c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|17|11|v|cpp
	ScanVar var1, ScanVar var2
b63119da730344b345cdc8f62a4711e9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|17|42|v|cpp
	vars
932905f5dc6919dec28a4ac7deb74a23|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|19|3|v|cpp
	std::function<void(int, double *)>
0b45bb5cfb228a82e9bf4af96545afd1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|23|15|v|cpp
	std::make_shared<std::string>(
4ca6409f26351663ec77f9ea29764a65|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|23|7|V|cpp
	      : fname(std::make_shared<std::string>(t_fname)), set_model(&t_set_model) {
afa5b3df39f5a938ecbbb683857ec835|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|18|3|v|cpp
	std::shared_ptr<
175885dc97a873f0f88949a4b9a98695|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|4|1|V|cpp
	#include "darksun/model.hpp"
	#include <fstream>
	#include <functional>
	#include <memory>
	#include <string>
	#include <thread>
	#include <vector>
d9d5256127e1614d6b24112d7cb004a9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|4|1|V|cpp
	#include <fstream>
5cb44865f9fba91e77cb486d4605f965|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|18|3|V|cpp
	  // N
7470ea8c91fe597a23713a125a965070|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|17|3|V|cpp
	  const std::string fname;
a3da707b651c79ecc39a4986516180b2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|13|7|v|cpp
	fname
a59ee1cec5fbd6947bb7b56300e63989|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|13|13|v|cpp
	std::move(t_fname)
b477443a96f52a9720e9a1a1881a78ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|16|3|V|cpp
	  while
f2ed387c56fddfa655b60f41986ed809|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|18|9|v|cpp
	(!done){
9441b85aa6c75b10705f57e5c133d924|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|21|12|v|cpp
	set_model->operator()
d4636df943a812d95b3f202d8c290d28|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|26|32|v|cpp
	R"()";
ff6de9d00cefca91b5578ecd320d61e1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|20|10|v|cpp
	.open();
c322ee0edc3c04f426af57af45342fbb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|20|5|V|cpp
	    ofile;
aa2d10990b2a738a373d1fd7ae524fff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|17|3|v|cpp
	std::ofstream ofile;
b8d5ee77c4ba8eda4fce920f76c920b1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|13|7|v|cpp
	ofile
e1e18cb2159ae7aab37bf1f019cecef0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|13|13|v|cpp
	std::ofstream(
a3198b0a4e79a79d39a2402856bc3740|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|34|3|v|cpp
	// namespace darksun
e519a143228b4133ca92bc6015d17b8d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|20|1|V|cpp
	    std::ofstream ofile;
	    ofile.open(fname);
eda500c37d476e3407afc476525e77ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/scan.hpp|31|1|V|cpp
	  void output_data(std::ofstream &ofile, double *model);
6378fbd5974f1eab56de454be9db41cf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|17|1|V|cpp
	  ofile << model[DarkSunIdx::N] << ",";
c7b3a374560a6d71f930c238d6be4712|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|28|1|V|cpp
	  ofile << model[DarkSunIdx::XiFo] << ",";
db97aba52cfa95bf94a7c474360184cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|34|1|V|cpp
	  ofile << model[DarkSunIdx::DNeffCmb] << ",";
7faaffe0a6d5716679d2ae5c29105f0c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|35|30|v|cpp
	DNeffCmb
30870f45ee574a439a15340a1c50fb85|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|35|1|V|cpp
	  ofile << model[DarkSunIdx::DNeffBbn] << ",";
551d2ab8fe79cf3eda68629c0e064b77|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|36|30|v|cpp
	DNeffBbn
ee54a4f957038b8a81fbd7790c5ec62f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|15|1|V|cpp
	void output_data(std::ofstream &ofile, double *model) {
	  // Model parameters
	  ofile << model[DarkSunIdx::N] << ",";
	  ofile << model[DarkSunIdx::Lam] << ",";
	  ofile << model[DarkSunIdx::C] << ",";
	  ofile << model[DarkSunIdx::Adel] << ",";
	  ofile << model[DarkSunIdx::Lec1] << ",";
	  ofile << model[DarkSunIdx::Lec2] << ",";
	  ofile << model[DarkSunIdx::MuEta] << ",";
	  ofile << model[DarkSunIdx::MuDel] << ",";
	  ofile << model[DarkSunIdx::XiInf] << ",";
	  // Derived parameters
	  ofile << model[DarkSunIdx::XiFo] << ",";
	  ofile << model[DarkSunIdx::TsmFo] << ",";
	  ofile << model[DarkSunIdx::XiCmb] << ",";
	  ofile << model[DarkSunIdx::XiBbn] << ",";
	  ofile << model[DarkSunIdx::RdEta] << ",";
	  ofile << model[DarkSunIdx::RdDel] << ",";
	  ofile << model[DarkSunIdx::DNeffCmb] << ",";
	  ofile << model[DarkSunIdx::DNeffBbn] << ",";
	  ofile << model[DarkSunIdx::EtaSiPerMass] << ",";
	  ofile << model[DarkSunIdx::DelSiPerMass] << "\n";
	}
bdeb060589f1e4898c5e4de721d9fe49|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|64|47|v|cpp
	"\n";
440d2f3125595f1a520ea1bfaf5dcadd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|28|1|V|cmake
		mu_eta_scan.cpp
ffcee67b808867bbe2ebf2bb08ce9dd3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|29|1|V|cmake
		mu_del_scan.cpp
f58408c9821bd3e76e90720296d751cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|40|1|V|cmake
	add_executable(test_phase_space test_phase_space.cpp)
	target_link_libraries(test_phase_space PUBLIC gtest_main darksun)
	
	 set_target_properties(test_phase_space PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
242f660e2e747dbddaa7dab94b39b090|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|32|1|V|cmake
		add_executable(scanner 
666d771dd2c3b6dcc5e52118349c3afc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/adel_scan.cpp|1|1|V|cpp
	int main() {}
067ae4ea2333172289177acd3e24a18c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|7|1|V|cpp
	static constexpr N_MIN = 5;
479d555e3152a5d269cd1793250e345a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|6|1|V|cpp
	static constexpr size_t N_MIN = 5;
b7d84c2df58f95fd4ece1c9f3fb339e2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|7|1|V|cpp
	static constexpr size_t N_MAX = 100;
11fec33f8275e2f7d5141e63e84b225f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|6|1|V|cpp
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t N_STP = 1;
f60d48204b7f50d89581576c927b6ca8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|10|25|v|cpp
	N_LAM = 5;
5e8115238533c3a3f643261da339224c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|12|25|v|cpp
	N_STP
b52828b71bf86614ad17d9582e6eb7f3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|21|1|V|cpp
	    //i = j + k * (NUM_N - 1);
844a07ce24bb86904e6dc91fc26154c7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|22|28|v|cpp
	+ k * (NUM_N - 1);
ca3b7c7e2e988d0aa5500509e18cef18|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|22|9|v|cpp
	(NUM_N-1) * (NUM_LAM - 1 +1);
5bc70a953467551b48158031401184c6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|22|1|V|cpp
	    i = (NUM_N - 1) + k * NUM_N;
63b0549880983b614829ae82cc06f2bb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|22|v|cpp
	  + k * NUM_N
57612b60d8c7f89e075da3f8e566fc26|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|25|v|cpp
	-1+1
b8f5a0f05b8fd3ffd9e1d90bd9d74e9a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|21|1|V|cpp
	    //i = j + k * NUM_N;
	    i = (NUM_N - 1) + k * NUM_N;
	    i = NUM_N * NUM_LAM - 1;
	    int j = i % (NUM_N - 1);
	    int k = (i - j) / (NUM_N-1);
6505adcbddb8b45c0e7045d04901fd3b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|20|16|v|cpp
	- 1) + k * NUM_N;
5882d4dee4784d86d9d9ba44da8a3837|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|20|5|V|cpp
	    i = (NUM_N 
d75e3f0171e818ba267877b622bf00d9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|20|5|V|cpp
	    i = NUM_N * NUM_LAM - 1;
160438854285b923977e3bdff5096fbc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|20|1|V|cpp
	    int j = i % NUM_N;
	    int k = (i - j) / NUM_N;
d4a0cbc9816c4d1998c47fd231d81647|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|25|13|v|cpp
	i % NUM_N;
6a55ef3eacd026f4f76ae5b2f7a06db4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|26|20|v|cpp
	+ 2- j
a5b6135966b12a2f9da2615719272792|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|26|5|V|cpp
	    int k = (NUM_N ) / NUM_N;
573d3a0265c41f003dfb923d08318cf4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|25|1|V|cpp
	    int j = 2;
6b23aa201b5271aca4da90dcc5e02f62|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|24|1|V|cpp
	    i = NUM_N + 2;
018e0bfacc5aceefcf8c5814dc728e60|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|19|5|V|cpp
	    //i = j + k * NUM_N;
93b9e0af919ea6125c8544ebff0db706|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|22|1|V|cpp
	    size_t n = N_MIN + idx_n * N_STP;
d570cc68175b912a082aa3b7a76f88f7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|32|v|cpp
	idx_n
271d3c77c4271927a1487c95429ba990|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|25|5|V|cpp
	    model[DarkSunIdx::N] = 
051df3bff6cdaf6428757a72cc599a83|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|22|5|v|cpp
	size_t n =
2c830d392730c09735b82db331525bef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|5|v|cpp
	double lam =
67191c80d0f94bca5fb142d8ddcec9bf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|40|5|V|cpp
	    thread = std::thread(
ffc6e86b68e21edfe74a8c0f87e522ab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|39|7|v|cpp
	(auto&thread:threads){
b70df6a5d0160c1fa819be30c5c07118|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|46|15|v|cpp
	"~/Documents/research/DarkSun/code/rundata/c=
7594c8ce52d1f2b27f0b64340a05899b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|19|1|V|cpp
	  "~/Documents/research/DarkSun/code/rundata/c=0.5.dat"
0cf00dac8163a767378bd18cfb107d34|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|20|v|cpp
	<std::mutex>
72dff3b1b6e383411c99a8011284e56f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|21|v|cpp
	std::mutex
44498e635491ea87980d7305d655aff0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|37|v|cpp
	progress_mutex
b7500d9d553845e96e6ea5a92f882f3b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|5|V|cpp
	    std::lock_guard<progress_mutex>();
465ed9fb61dab6b8cc7faf70c653d785|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|6|v|cpp
	~/Documents/research/DarkSun/code/rundata/c=0.5.dat
a326f6d637cd24414469450b3c781e87|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|28|1|V|cpp
	static const path = std::filesystem::current_path();
a5a971864094b6a3b69be903c09fda09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|23|1|V|cpp
	    std::filesystem::current_path().append("../rundata/c=0.5.dat"),
9802ad89a738d781c70915b0b87d31dd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|24|1|V|cpp
	    "~/Documents/research/DarkSun/code/rundata/c=1.5.dat"};
a669d3f9690de67ed666760a6ce45167|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|35|49|V|cpp
	    fmt::print("i, idx_n, idx_lam = {},{},{}\n", i, idx_n, idx_lam);
c2f62fa14efcd41b3081e61a2bbfa1fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_LAM = 100;
	static constexpr double LOG_LAM_MIN = -7.0;
	static constexpr double LOG_LAM_MAX = 1.0;
	static constexpr double LOG_LAM_STP =
	    (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAM - 1);
	
	static constexpr std::array<double, 2> CS = {0.5, 1.5};
	static const std::array<std::string, 2> FNAMES = {
	    std::filesystem::current_path().append("../rundata/c=0.5.dat"),
	    std::filesystem::current_path().append("../rundata/c=1.5.dat")};
	
	static boost::progress_display progress(CS.size() * NUM_N * NUM_LAM);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double c) {
	  if (i < NUM_LAM * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_lam = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::Lam] = pow(10.0, LOG_LAM_MIN + idx_lam * LOG_LAM_STP);
	    model[DarkSunIdx::C] = c;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, CS.size()> threads;
	
	  for (size_t i = 0; i < CS.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, CS[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
ccb947ac53dc48f1d64ed954d2ace7b8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/lec1_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_LAM = 100;
	static constexpr double LOG_LAM_MIN = -7.0;
	static constexpr double LOG_LAM_MAX = 1.0;
	static constexpr double LOG_LAM_STP =
	    (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAM - 1);
	
	static constexpr std::array<double, 2> LEC1S = {0.01, 1.0};
	static const std::array<std::string, 2> FNAMES = {
	    std::filesystem::current_path().append("../rundata/lec1=0.01.dat"),
	    std::filesystem::current_path().append("../rundata/lec1=1.0.dat")};
	
	static boost::progress_display progress(LEC1S.size() * NUM_N * NUM_LAM);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double lec1) {
	  if (i < NUM_LAM * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_lam = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::Lam] = pow(10.0, LOG_LAM_MIN + idx_lam * LOG_LAM_STP);
	    model[DarkSunIdx::Lec1] = lec1;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, LEC1S.size()> threads;
	
	  for (size_t i = 0; i < LEC1S.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, LEC1S[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
a1167069c53dd6c6a2a7265856171c62|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/lec2_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_LAM = 100;
	static constexpr double LOG_LAM_MIN = -7.0;
	static constexpr double LOG_LAM_MAX = 1.0;
	static constexpr double LOG_LAM_STP =
	    (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAM - 1);
	
	static constexpr std::array<double, 2> LEC2S = {0.01, 1.0};
	static const std::array<std::string, 2> FNAMES = {
	    std::filesystem::current_path().append("../rundata/lec2=0.01.dat"),
	    std::filesystem::current_path().append("../rundata/lec2=1.0.dat")};
	
	static boost::progress_display progress(LEC2S.size() * NUM_N * NUM_LAM);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double lec2) {
	  if (i < NUM_LAM * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_lam = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::Lam] = pow(10.0, LOG_LAM_MIN + idx_lam * LOG_LAM_STP);
	    model[DarkSunIdx::Lec1] = lec2;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, LEC2S.size()> threads;
	
	  for (size_t i = 0; i < LEC2S.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, LEC2S[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
62da7d827ae47161de10b91c23a50101|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/mu_del_scan.cpp|22|40|v|cpp
	LEC2S
2e79dc20c7f96c1fced88310974be424|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/mu_del_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_LAM = 100;
	static constexpr double LOG_LAM_MIN = -7.0;
	static constexpr double LOG_LAM_MAX = 1.0;
	static constexpr double LOG_LAM_STP =
	    (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAM - 1);
	
	static constexpr std::array<double, 2> MU_DELS = {0.1, 10.0};
	static const std::array<std::string, 2> FNAMES = {
	    std::filesystem::current_path().append("../rundata/mu_del=0.1.dat"),
	    std::filesystem::current_path().append("../rundata/mu_del=10.0.dat")};
	
	static boost::progress_display progress(MU_DELS.size() * NUM_N * NUM_LAM);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double mu_del) {
	  if (i < NUM_LAM * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_lam = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::Lam] = pow(10.0, LOG_LAM_MIN + idx_lam * LOG_LAM_STP);
	    model[DarkSunIdx::MuDel] = mu_del;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, MU_DELS.size()> threads;
	
	  for (size_t i = 0; i < MU_DELS.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, MU_DELS[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
7d10425fd92adbd0e22c7fc9cbe5f010|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/mu_eta_scan.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_LAM = 100;
	static constexpr double LOG_LAM_MIN = -7.0;
	static constexpr double LOG_LAM_MAX = 1.0;
	static constexpr double LOG_LAM_STP =
	    (LOG_LAM_MAX - LOG_LAM_MIN) / double(NUM_LAM - 1);
	
	static constexpr std::array<double, 2> MU_ETAS = {0.1, 10.0};
	static const std::array<std::string, 2> FNAMES = {
	    std::filesystem::current_path().append("../rundata/mu_eta=0.1.dat"),
	    std::filesystem::current_path().append("../rundata/mu_eta=10.0.dat")};
	
	static boost::progress_display progress(MU_ETAS.size() * NUM_N * NUM_LAM);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double mu_eta) {
	  if (i < NUM_LAM * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_lam = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::Lam] = pow(10.0, LOG_LAM_MIN + idx_lam * LOG_LAM_STP);
	    model[DarkSunIdx::MuDel] = mu_eta;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, MU_ETAS.size()> threads;
	
	  for (size_t i = 0; i < MU_ETAS.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, MU_ETAS[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
454f1d72852b9e6b3402010d991a49e2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|22|40|v|cpp
	MU_ETAS
bac14a6f7fd6f37df89f2e33500cad9d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|22|55|v|cpp
	, 0.1
1d2128176c5832f2b6b23a416d555e78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|25|1|V|cpp
	    std::filesystem::current_path().append("../rundata/xi_inf=1e-1.dat")
803b157d416c052365e1bd2f1f283011|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|17|33|v|cpp
	LOG_LAM_MIN
4210640f74c31ba9ba86fe5e4223687c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|17|33|v|cpp
	-7.0;
04817efd11c15364a6ec239780038862|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|17|37|v|cpp
	0.01
257e05c250dde370a77a312d1b702773|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|22|48|v|cpp
	0.5, 1.5
19cc4de3b8e1978cb9751ffb2739eada|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|25|1|V|cpp
	    std::filesystem::current_path().append("../rundata/c=1.5.dat")
c30dfb9a6619740abfdad2a0b5479ddb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|1|1|v|cpp
	NUM_LAM
3384b428b4e613995f0509ff2c1401d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_vs_n.cpp|1|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/model.hpp>
	#include <darksun/scan.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <mutex>
	#include <thread>
	
	using namespace darksun;
	
	static constexpr size_t N_MIN = 5;
	static constexpr size_t N_MAX = 100;
	static constexpr size_t NUM_N = N_MAX - N_MIN + 1;
	static constexpr size_t N_STP = 1;
	
	static constexpr size_t NUM_CS = 100;
	static constexpr double LOG_C_MIN = -3.0;
	static constexpr double LOG_C_MAX = 1.0;
	static constexpr double LOG_C_STP =
	    (LOG_C_MAX - LOG_C_MIN) / double(NUM_CS - 1);
	
	static constexpr std::array<double, 5> LAMS = {1e-7, 1e-5, 1e-3, 1e-1, 10.0};
	static const std::array<std::string, LAMS.size()> FNAMES = {
	    std::filesystem::current_path().append("../rundata/c_vs_n_lam=1e-7.dat"),
	    std::filesystem::current_path().append("../rundata/c_vs_n_lam=1e-5.dat"),
	    std::filesystem::current_path().append("../rundata/c_vs_n_lam=1e-3.dat"),
	    std::filesystem::current_path().append("../rundata/c_vs_n_lam=1e-1.dat"),
	    std::filesystem::current_path().append("../rundata/c_vs_n_lam=10.0.dat")};
	
	static boost::progress_display progress(LAMS.size() * NUM_N * NUM_CS);
	static std::mutex progress_mutex;
	
	bool set_model(int i, double *model, double lam) {
	  if (i < NUM_CS * NUM_N) {
	    int idx_n = i % NUM_N;
	    int idx_c = (i - idx_n) / NUM_N;
	
	    model[DarkSunIdx::N] = N_MIN + idx_n * N_STP;
	    model[DarkSunIdx::C] = pow(10.0, LOG_C_MIN + idx_c * LOG_C_STP);
	    model[DarkSunIdx::Lam] = lam;
	
	    {
	      std::lock_guard<std::mutex> lock(progress_mutex);
	      ++progress;
	    }
	
	    return false;
	  } else {
	    return true;
	  }
	}
	
	int main() {
	
	  std::array<std::thread, LAMS.size()> threads;
	
	  for (size_t i = 0; i < LAMS.size(); i++) {
	    auto f = [i](int counter, double *model) {
	      return set_model(counter, model, LAMS[i]);
	    };
	    Scanner s(FNAMES[i], f);
	    threads[i] = std::thread(&Scanner::scan, s);
	  }
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
	}
5578f4085124ad2f66351ec8eca1b0fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|24|38|V|cpp
	static const std::array<std::string, 2> FNAMES = {
d070f7a3373c29c18a8369b52de0f8d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|23|55|V|cpp
	static constexpr std::array<double, 2> CS = {0.5, 1.5};
659426113a4d5744c6a4a8ab0d98d6a2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|25|41|v|cpp
	CS.size() * 
60f439b40e874ab9a485480bbaae0310|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|29|36|v|cpp
	, double c
b55a226b24978170fc444dcbbdb4b6e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|36|29|V|cpp
	    model[DarkSunIdx::C] = c;
a3d2230c4e219d8017fdaa21739c8e10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|50|1|V|cpp
	  std::array<std::thread, CS.size()> threads;
22c0c580c76afcde4767617205647137|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|51|1|V|cpp
	  for (size_t i = 0; i < CS.size(); i++) {
11e9ef3f857566741ae168ba728aaddb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|56|1|V|cpp
	  for (auto &thread : threads) {
	    if (thread.joinable()) {
	      thread.join();
	    }
	  }
97e79ae67471be0f27b288edcd06a608|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|55|1|V|cpp
	    threads[i] = std::thread(&Scanner::scan, s);
d51193122405ea6af02215255f5d2d99|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|51|1|V|cpp
	    auto f = (int counter, double *model) {
	      return set_model(counter, model, CS[i]);
	    };
6f5ecc16326242bb7f0a1930cf751a9b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|37|5|V|cpp
	    {
ef60b76a60516f8541f272ed45c4e66d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/bm.cpp|37|37|V|cpp
	      std::lock_guard<std::mutex> lock(progress_mutex);
ccfe3a07272d2e696817ce8276c3f1a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|20|17|v|cpp
	logx = 
9b49e21a1861fb505bcfd40a0748808f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|20|22|v|cpp
	we = 
754990deb3b5c4b130ab7a8039b88822|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|20|26|v|cpp
	wd = 
58d68f43c579bf9607775af6ba4d5c7a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|1|V|cpp
	  fmt::print("tsm fo={}\n", DarkSun::get_tsm_fo(model.data()));
ab77b86e9d01cd3e4c9d794501aaea08|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|25|28|v|cpp
	DarkSun::get_tsm_fo(model.data())
aba694cce7f33675711a01790c509407|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|5|1|V|cmake
	if(${CMAKE_BUILD_TYPE} STREQUAL Release)
		set(CMAKE_CXX_FLAGS "-Ofast -std=c++17")
	endif()
46edafc4c25848e49fcc1b7fda118603|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/rodas.f|858|1|v|fortran
	      WRITE(6,979)X   
0c367fe622877139240491de3895e2e0|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/rodas.f|858|1|v|fortran
	      WRITE(6,*) ' STEP SIZE T0O SMALL, H=',H
63cb68bfaa3a652b07269f16da4bdda8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|5|41|v|cmake
	-Ofast 
b24a6947191d6269b63e36a48d7d5a71|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|2|1|V|cpp
	#include <boost/math/interpolators/cardinal_cubic_b_spline.hpp>
2710d806b0f33880160b6d980771e173|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|2|1|V|cpp
	#include <boost/math/interpolators/cubic_b_spline.hpp>
2020f13305cfe028a57ab0540797c0b7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|25|1|V|cpp
	  static gsl_spline *geff_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
0e29186d580a3a9a6ce7b45bea0977ac|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|25|34|v|cpp
	= gsl_spline_alloc(gsl_interp_cspline, 341);
bbc91fc394e9261a1b8552caad6bc53c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|25|1|V|cpp
	  static gsl_spline *geff_spline;
aac0c7057152e956ba15eaac10c15639|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|27|22|v|cpp
	geff_spline
cd568e7b6294354326aa43c93b5dd1c2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|48|1|V|cpp
	gsl_spline *StandardModel::geff_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
b05bfc601a810755bf886348bbd95a58|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|23|16|v|cpp
	std::array<double, 341>
0f095d6d463a809d89c7099e3130887b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|48|1|V|cpp
	gsl_spline *StandardModel::geff_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
	gsl_spline *StandardModel::heff_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
	gsl_spline *StandardModel::sqrt_gstar_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
730ef5ab478ea1a07ec7099371901531|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|14|1|V|cpp
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    StandardModel::geff_spline(StandardModel::geff_data.begin(),
	                               StandardModel::geff_data.end(),
	                               StandardModel::LOG_TEMP_MIN,
	                               StandardModel::LOG_TEMP_STP);
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    StandardModel::heff_spline(StandardModel::heff_data.begin(),
	                               StandardModel::heff_data.end(),
	                               StandardModel::LOG_TEMP_MIN,
	                               StandardModel::LOG_TEMP_STP);
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    StandardModel::sqrt_gstar_spline(StandardModel::sqrt_gstar_data.begin(),
	                                     StandardModel::sqrt_gstar_data.end(),
	                                     StandardModel::LOG_TEMP_MIN,
	                                     StandardModel::LOG_TEMP_STP);
061cb27a8c0a0596fa77f720f4224788|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|5|13|v|cpp
	, 341>
12fdb22d6aa01e4bc6e50dcd207b9bda|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|21|1|V|cpp
	  static const double sqrt_gstar_data[341];
8ee5682dbe4be61b73d3583ecd71dc3d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|30|1|V|cpp
	  //  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	  //      geff_spline;
	  //  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	  //      heff_spline;
	  //  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	  //      sqrt_gstar_spline;
fe203bb80d409bf7058342b8a2f2b093|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|5|1|V|cpp
	const double StandardModel::sqrt_gstar_data[341] = {
d61d528cd99ea3855f97df8abe6c90a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|7|1|V|cpp
	gsl_spline *StandardModel::geff_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
	gsl_spline *StandardModel::heff_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
	gsl_spline *StandardModel::sqrt_gstar_spline =
	    gsl_spline_alloc(gsl_interp_cspline, 341);
	
3da5cdd870a1ef38d3a2a1cb949a3b26|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|26|1|V|cpp
	  static gsl_spline *geff_spline;
	  static gsl_spline *heff_spline;
	  static gsl_spline *sqrt_gstar_spline;
badf3ddf97b4140c7147b0125491fed4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|21|1|V|cpp
	  static const double temps[341];
	  static const double sqrt_gstar_data[341];
	  static const double heff_data[341];
	  static const double geff_data[341];
1ad8a205d621d0ef0c2b85515918112b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|34|1|V|cpp
	  static double geff(double tsm);
	  static double heff(double tsm);
	  static double sqrt_gstar(double tsm);
	  static double energy_density(double tsm);
	  static double entropy_density(double tsm);
1785a17144bc4f4309363275becaf0be|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|37|1|V|cpp
	  StandardModel() = delete;
cd7a83ea29e5b573050a6bc8978d8463|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|38|3|v|cpp
	StandardModel 
099af53f601532dbd31e0ea99ffdeb64|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|26|21|v|cpp
	delete
5764705b23dc1ef49223c994bad3275d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|12|13|v|cpp
	StandardModel
9cb44512963a340eb3633b66555c1396|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|12|1|V|cpp
	  gsl_spline_init(geff_spline, temps, sqrt_gstar_data, 341);
3cb9ba47b5491a73d9bf692a3aea8eda|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|8|3|v|cpp
	gsl_spline 
5f8df1ccf503eaaba5b8ac761c1fd0f4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|17|1|V|cpp
	gsl_interp_init(StandardModel::sqrt_gstar_spline, StandardModel::temps,
	                StandardModel::sqrt_gstar_data, 341);
c8a5788619077a3d5e3dfc140b44e6a6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|41|1|V|cpp
	  gsl_spline_ac
e8f98795593a5b0cb819f95b8ac976d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|41|1|V|cpp
	  gsl_interp_accel *acc_geff;
75d1ff17e6dcdd67451c74bc52f7c143|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|44|25|v|cpp
	geff
7ea9c363e6f01eabee44157e6438a740|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|42|1|V|cpp
	  gsl_interp_accel *acc_geff;
	  gsl_interp_accel *acc_heff;
	  gsl_interp_accel *acc_sqrt_gstar;
df9afec90fef0eaceb83f34edecbdc7e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|12|3|v|cpp
	gsl_interp_accel 
b1f1bf466909fa829f364cb0ffeac2db|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|17|44|v|cpp
	spline
519c517281da34e14c07e5e6eb383dae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|21|1|V|cpp
	//===========================================================================
	//---- Internal functions ---------------------------------------------------
	//===========================================================================
1857dab42b6b3d4eeadc74452fc3ef60|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|29|1|V|cpp
	  static StandardModel sm;
635b2981ca7a6a966d80ff66a96582bd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|39|3|V|cpp
	  gsl_spline *geff_spline;
	  gsl_spline *heff_spline;
	  gsl_spline *sqrt_gstar_spline;
	
	  gsl_interp_accel *acc_geff;
	  gsl_interp_accel *acc_heff;
	  gsl_interp_accel *acc_sqrt_gstar;
534d5211bf73574325967e9de4d08847|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|53|1|V|cpp
	  StandardModel &get_instance();
cf62bcae627301549273c0a08121a27d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|29|1|V|cpp
	double StandardModel::geff(double tsm) { return get_instance().i_geff(tsm); }
53f52636260f1c9f6dc15d811fda98b9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|17|27|v|cpp
	<< ", " << temps[1];
5e2e525cd3ed72094fb2eb6d7dcea4e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|8|5|v|cpp
	2.14115, 2.14115, 2.14116, 2.14121, 2.14129, 2.14211, 2.14313, 2.14788,
	    2.16075, 2.18016, 2.21693, 2.27367, 2.35457, 2.46145, 2.59387, 2.74915,
	    2.91932, 3.08264, 3.21977, 3.32439, 3.38107, 3.39252, 3.39207, 3.38331,
	    3.37016, 3.356,   3.34556, 3.33867, 3.32907, 3.32115, 3.31505, 3.31139,
	    3.30715, 3.30316, 3.2995,  3.29685, 3.29651, 3.29747, 3.29683, 3.29568,
	    3.29388, 3.29202, 3.29111, 3.29104, 3.29166, 3.29271, 3.29303, 3.29304,
	    3.29275, 3.29186, 3.29076, 3.29008, 3.29054, 3.29449, 3.3003,  3.30766,
	    3.32432, 3.34921, 3.39026, 3.45708, 3.54372, 3.63446, 3.7203,  3.7938,
	    3.8616,  3.92322, 3.97843, 4.00396, 4.02831, 4.05174, 4.07455, 4.0971,
	    4.11986, 4.14345, 4.16854, 4.19655, 4.23093, 4.27596, 4.33495, 4.40527,
	    4.48248, 4.56881, 4.67508, 4.7968,  5.00266, 5.41135, 5.9174,  6.47829,
	    7.17981, 7.85646, 8.35094, 8.56448, 8.5431,  8.41707, 8.29839, 8.23215,
	    8.21437, 8.22517, 8.24774, 8.27302, 8.29796, 8.32271, 8.34848, 8.37642,
	    8.40712, 8.44062, 8.47644, 8.51387, 8.55201, 8.58977, 8.62648, 8.66162,
	    8.6949,  8.72643, 8.75649, 8.78579, 8.81487, 8.84423, 8.87419, 8.90481,
	    8.93593, 8.9672,  8.99818, 9.02837, 9.05732, 9.08465, 9.11007, 9.13336,
	    9.15442, 9.17323, 9.18985, 9.20436, 9.21692, 9.22769, 9.23685, 9.24459,
	    9.25109, 9.25653, 9.26102, 9.26791, 9.2726,  9.27591, 9.27828, 9.28006,
	    9.28149, 9.28283, 9.28446, 9.28708, 9.29181, 9.30021, 9.31417, 9.32373,
	    9.33528, 9.34891, 9.3647,  9.38268, 9.40285, 9.42515, 9.44954, 9.47597,
	    9.50437, 9.53471, 9.56693, 9.60096, 9.63672, 9.67406, 9.7128,  9.75271,
	    9.79348, 9.83475, 9.8761,  9.91712, 9.95736, 9.99639, 10.0338, 10.0693,
	    10.1025, 10.1333, 10.1614, 10.1869, 10.2098, 10.23,   10.2477, 10.263,
	    10.2762, 10.2874, 10.2968, 10.3047, 10.3112, 10.3165, 10.3208, 10.3243,
	    10.327,  10.3292, 10.3309, 10.3322, 10.3332, 10.334,  10.3346, 10.335,
	    10.3353, 10.3355, 10.3357, 10.3358, 10.3358, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3358, 10.3358, 10.3358, 10.3358, 10.3358, 10.3358,
	    10.3358, 10.3358, 10.3358, 10.3358, 10.3358, 10.3358, 10.3358, 10.3358,
	    10.3358, 10.3358, 10.3358, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359, 10.3359,
	    10.3359, 10.3359, 10.3359
120d4be2638a9b1fa60f6075617ff77a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|11|5|v|cpp
	3.93872, 3.93872, 3.93872, 3.93873, 3.9388,  3.93903, 3.94002, 3.94193,
	    3.94971, 3.96568, 3.99719, 4.05392, 4.14742, 4.29041, 4.49612, 4.77665,
	    5.14242, 5.59394, 6.11588, 6.68405, 7.26618, 7.81519, 8.31058, 8.74618,
	    9.11984, 9.4338,  9.69405, 9.91217, 10.0914, 10.2369, 10.354,  10.4496,
	    10.5269, 10.5884, 10.6366, 10.6741, 10.704,  10.7302, 10.7524, 10.7702,
	    10.7838, 10.7933, 10.7997, 10.8047, 10.809,  10.8136, 10.8183, 10.8225,
	    10.8259, 10.8283, 10.8292, 10.8289, 10.8284, 10.8299, 10.8374, 10.8496,
	    10.8735, 10.9162, 10.9878, 11.1083, 11.3007, 11.5685, 11.9012, 12.2773,
	    12.6822, 13.1056, 13.5375, 13.754,  13.9696, 14.1839, 14.3963, 14.6066,
	    14.8152, 15.0223, 15.2291, 15.4369, 15.6488, 15.8705, 16.1102, 16.3763,
	    16.6736, 17.0063, 17.3825, 17.8167, 18.3309, 19.0466, 20.0941, 21.4912,
	    23.3641, 25.7839, 28.688,  31.8594, 35.0171, 37.9544, 40.5998, 42.9805,
	    45.1544, 47.1692, 49.053,  50.8196, 52.4762, 54.0287, 55.4844, 56.8521,
	    58.1415, 59.3625, 60.5243, 61.6347, 62.7001, 63.7252, 64.7128, 65.6649,
	    66.5825, 67.4663, 68.3173, 69.1369, 69.9273, 70.6913, 71.432,  72.1526,
	    72.8562, 73.5449, 74.2203, 74.8832, 75.5335, 76.1703, 76.7924, 77.3981,
	    77.9856, 78.5531, 79.0988, 79.6212, 80.1191, 80.5915, 81.0378, 81.4577,
	    81.8513, 82.2189, 82.5611, 83.1724, 83.6932, 84.133,  84.5016, 84.8091,
	    85.0646, 85.2765, 85.4531, 85.6026, 85.7348, 85.862,  85.9999, 86.0786,
	    86.1673, 86.2684, 86.3845, 86.518,  86.6712, 86.8461, 87.0444, 87.2678,
	    87.5177, 87.7953, 88.1015, 88.4372, 88.8032, 89.1998, 89.6273, 90.0855,
	    90.5738, 91.0912, 91.6359, 92.2058, 92.7982, 93.4096, 94.0364, 94.6744,
	    95.3191, 95.966,  96.6104, 97.2481, 97.8747, 98.4864, 99.0797, 99.6518,
	    100.2,   100.723, 101.218, 101.686, 102.125, 102.535, 102.918, 103.272,
	    103.6,   103.902, 104.18,  104.435, 104.667, 104.879, 105.072, 105.248,
	    105.407, 105.551, 105.681, 105.799, 105.905, 106.,    106.086, 106.164,
	    106.233, 106.296, 106.352, 106.402, 106.447, 106.488, 106.524, 106.556,
	    106.585, 106.611, 106.635, 106.655, 106.674, 106.691, 106.705, 106.719,
	    106.731, 106.741, 106.751, 106.759, 106.767, 106.773, 106.78,  106.785,
	    106.79,  106.794, 106.798, 106.801, 106.804, 106.807, 106.81,  106.812,
	    106.814, 106.816, 106.817, 106.818, 106.82,  106.821, 106.822, 106.823,
	    106.824, 106.824, 106.825, 106.825, 106.826, 106.826, 106.827, 106.827,
	    106.828, 106.828, 106.828, 106.828, 106.829, 106.829, 106.829, 106.829,
	    106.829, 106.829, 106.829, 106.83,  106.83,  106.83,  106.83,  106.83,
	    106.83,  106.83,  106.83
f98c698bd91e5588b6c18a7039e3a8c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/data.cpp|14|5|v|cpp
	3.38387, 3.38387, 3.38388, 3.38389, 3.38397, 3.38427, 3.38549, 3.3881,
	    3.39738, 3.41647, 3.45361, 3.51934, 3.62573, 3.78527, 4.0102,  4.3118,
	    4.69996, 5.17649, 5.72974, 6.33782, 6.96665, 7.56535, 8.11056, 8.59272,
	    9.00495, 9.34736, 9.6294,  9.86545, 10.0587, 10.2142, 10.3381, 10.4387,
	    10.5198, 10.5838, 10.6332, 10.6713, 10.7017, 10.7286, 10.7517, 10.7704,
	    10.7844, 10.7937, 10.7998, 10.8043, 10.8083, 10.8132, 10.8184, 10.8231,
	    10.827,  10.8296, 10.8304, 10.8296, 10.8287, 10.8303, 10.8395, 10.8543,
	    10.883,  10.9338, 11.0194, 11.1678, 11.4085, 11.7266, 12.0945, 12.5001,
	    12.9312, 13.3759, 13.8235, 14.0456, 14.2655, 14.4826, 14.6968, 14.908,
	    15.1166, 15.3235, 15.5298, 15.7377, 15.9508, 16.1761, 16.4233, 16.7028,
	    17.02,   17.3796, 17.7909, 18.2706, 18.8863, 19.8105, 21.0143, 22.6405,
	    24.8377, 27.678,  31.0595, 34.6881, 38.2034, 41.3583, 44.0896, 46.46,
	    48.5645, 50.4771, 52.2407, 53.877,  55.3974, 56.8108, 58.1272, 59.3581,
	    60.5156, 61.6115, 62.6563, 63.6585, 64.6247, 65.5589, 66.4632, 67.3386,
	    68.1849, 69.0022, 69.7905, 70.551,  71.2857, 71.9976, 72.69,   73.3664,
	    74.0297, 74.682,  75.3246, 75.9577, 76.5805, 77.1915, 77.7887, 78.3697,
	    78.9322, 79.4738, 79.9925, 80.4865, 80.9545, 81.3956, 81.8092, 82.1954,
	    82.5543, 82.8867, 83.1933, 83.7336, 84.1855, 84.5603, 84.8691, 85.1225,
	    85.33,   85.5002, 85.6411, 85.7609, 85.8698, 85.9812, 86.1122, 86.1913,
	    86.2833, 86.3907, 86.5163, 86.6626, 86.8318, 87.0258, 87.2464, 87.4949,
	    87.7727, 88.0806, 88.4194, 88.7899, 89.1925, 89.6273, 90.0944, 90.5931,
	    91.1226, 91.6813, 92.2669, 92.8769, 93.5077, 94.1554, 94.8155, 95.4832,
	    96.1536, 96.8214, 97.4818, 98.13,   98.7617, 99.373,  99.9605, 100.522,
	    101.054, 101.557, 102.028, 102.468, 102.877, 103.255, 103.603, 103.922,
	    104.214, 104.48,  104.721, 104.94,  105.138, 105.316, 105.477, 105.621,
	    105.751, 105.867, 105.971, 106.064, 106.147, 106.221, 106.287, 106.346,
	    106.399, 106.446, 106.488, 106.525, 106.558, 106.588, 106.614, 106.638,
	    106.659, 106.677, 106.694, 106.709, 106.722, 106.734, 106.744, 106.753,
	    106.762, 106.769, 106.776, 106.781, 106.787, 106.791, 106.795, 106.799,
	    106.803, 106.805, 106.808, 106.81,  106.813, 106.814, 106.816, 106.818,
	    106.819, 106.82,  106.821, 106.822, 106.823, 106.824, 106.825, 106.825,
	    106.826, 106.826, 106.827, 106.827, 106.827, 106.828, 106.828, 106.828,
	    106.828, 106.829, 106.829, 106.829, 106.829, 106.829, 106.829, 106.829,
	    106.83,  106.83,  106.83,  106.83,  106.83,  106.83,  106.83,  106.83,
	    106.83,  106.83,  106.83
53e5ea3567abf32d0053a830ea02e8b5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|16|1|V|cpp
	  for (size_t i = 0; i < 341; i++) {
	    std::cerr << temps[i] << "\n";
	  }
e91f881ee7ea7a14cb65a3490a0bf9cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|40|1|V|cpp
	  gsl_spline *spline_cs44;
c4d87a9661de0aa6ec05dba42eaabc7c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|40|1|V|cpp
	  gsl_spline *spline_cs44;
	  gsl_spline *spline_cs66;
	  gsl_spline *spline_cs46;
ef022ba8a358c74dfc88a4e08fe50c9d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|45|3|V|cpp
	  gsl_interp_accel *spline_cs66;
596d487b2f73f046b59e8391935f37ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|379|1|V|cpp
	  // Boost splines for cs44, cs66 and cs46
	  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	      log_eta_cs44_spline;
	  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	      log_eta_cs66_spline;
	  static const boost::math::interpolators::cardinal_cubic_b_spline<double>
	      log_eta_cs46_spline;
6d763aa2bf6e060a9bd657ceb3e69823|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|40|1|V|cpp
	  gsl_spline *spline_cs44;
	  gsl_spline *spline_cs66;
	  gsl_spline *spline_cs46;
	
	  gsl_interp_accel *acc_cs44;
	  gsl_interp_accel *acc_cs66;
	  gsl_interp_accel *acc_cs46;
8128568f19d7103ce434c8a3d19dc7dc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|3|1|V|cpp
	using namespace darksun;
1607c08e44038b7b334003e75e6deaf1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|6|13|v|cpp
	, 500>
c3c3c04850719d3548193af7c205df88|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|385|22|v|cpp
	, 500 
c3c3c04850719d3548193af7c205df88|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|385|22|v|cpp
	, 500 
c3c3c04850719d3548193af7c205df88|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|385|22|v|cpp
	, 500 
9eecc429c6d9ba3994c82a4715235363|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|176|7|v|cpp
	std::array<double, 
c390605866829cae76e4a99417588cb6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cs_data.cpp|176|7|v|cpp
	500> 
c24444e72ddbf39f8cb34e53eb7d9e2e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|6|7|v|cpp
	gsl_spline_alloc
e9a1c8fbdc28c8a1979221cba43f1b6c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|6|1|V|cpp
	      gsl_spline_alloc(gsl_interp_cspline, log_eta_zs, log_eta_cs44, 500);
7fa51d0c4619810aef6502567dc406e7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|11|23|v|cpp
	gsl_interp_cspline
23acbb6024abfd01812f93ed858536f4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|11|1|V|cpp
	      gsl_spline_init(spline_cs44, log_eta_zs, log_eta_cs44, 500);
96f927dbcf23dd3668740544c0fbedbe|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|6|44|v|cpp
	log_eta_zs, log_eta_cs44, 500);
cce450d7f8d6e7fc9da1da06bdb12dea|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|5|1|V|cpp
	  spline_cs44 = gsl_spline_alloc(gsl_interp_cspline, 500);
a2190cd6a7539d2c8d511db3514724a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|6|1|V|cpp
	  spline_cs66;
a78f903cc35f30928b2c4c6f54a6eddd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|7|1|V|cpp
	  spline_cs46;
467f07dca35ce18e5514564c8f05a140|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|13|1|V|cpp
	  acc_cs44 = gsl_interp_accel_alloc();
07cc65e4aac5cee901944eb34f2ba906|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|13|11|v|cpp
	 = gsl_interp_accel_alloc()
4dbd2ce50e6a3c076164da6046cc8c2d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|8|1|V|cpp
	//===========================================================================
	//---- Define the interpolators ---------------------------------------------
	//===========================================================================
	
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    DarkSun::log_eta_cs44_spline(DarkSun::log_eta_cs44.begin(),
	                                 DarkSun::log_eta_cs44.end(),
	                                 DarkSun::log_eta_z_min,
	                                 DarkSun::log_eta_z_step);
	
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    DarkSun::log_eta_cs66_spline(DarkSun::log_eta_cs66.begin(),
	                                 DarkSun::log_eta_cs66.end(),
	                                 DarkSun::log_eta_z_min,
	                                 DarkSun::log_eta_z_step);
	
	const boost::math::interpolators::cardinal_cubic_b_spline<double>
	    DarkSun::log_eta_cs46_spline(DarkSun::log_eta_cs46.begin(),
	                                 DarkSun::log_eta_cs46.end(),
	                                 DarkSun::log_eta_z_min,
	                                 DarkSun::log_eta_z_step);
1f942acbf3ddfa39c03f95619547b5a7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|16|1|V|cpp
	                    gsl_spline_eval(DarkSun::get_instance().spline_cs44, logz,
	                                    DarkSun::get_instance().acc_cs44)
0633f488a1fb11532e2b60b188d155c1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|30|1|v|cpp
	log_eta_cs66_spline(logz)
d94a87187e48a399d26bc32ae978bc01|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|29|1|V|cpp
	                    gsl_spline_eval(DarkSun::get_instance().spline_cs66, logz,
	                                    DarkSun::get_instance().acc_cs66)
6ba1e40e544b0d5629c34cc541abbacb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|43|1|v|cpp
	log_eta_cs46_spline(logz)
4f72611a179687060de9686a1c52f724|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|29|5|v|cpp
	gsl_spline_eval(DarkSun::get_instance().spline_cs66, logz,
	                    DarkSun::get_instance().acc_cs66)
a208cdf37d2ec10dc5bb9b3ed94950d5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|28|1|V|cpp
	    auto val = gsl_spline_eval(DarkSun::get_instance().spline_cs66, logz,
	                               DarkSun::get_instance().acc_cs66);
	    return std::pow(10.0, val);
de9cd6ce25919a47559e67134b825952|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|41|1|V|cpp
	    return std::pow(10.0, 
	                    gsl_spline_eval(DarkSun::get_instance().spline_cs46, logz,
	                                    DarkSun::get_instance().acc_cs46)
	);
00b7b09aa5b3e3068b6d60d5db4ed085|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|29|32|v|cpp
	DarkSun::get_instance()
24247ce8b266c471ffc358563392c4da|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|28|1|V|cpp
	    auto &inst = DarkSun::get_instance();
	    auto val = gsl_spline_eval(inst.spline_cs66, logz, inst.acc_cs66);
	    return std::pow(10.0, val);
d1e717d0d30167e178b332ac4b0887e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|41|1|V|cpp
	    auto val = gsl_spline_eval(DarkSun::get_instance().spline_cs46, logz,
	                               DarkSun::get_instance().acc_cs46);
	    return std::pow(10.0, val);
338e45f0cde714fd1da3827552e953ad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|15|1|V|cpp
	    return std::pow(10.0,
	                    gsl_spline_eval(DarkSun::get_instance().spline_cs44, logz,
	                                    DarkSun::get_instance().acc_cs44));
1375851c34b0c99bcd1a92e667f399fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|53|1|V|cpp
	  static StandardModel &get_instance();
057544526f6471765abf8669062a381b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|21|1|V|cpp
	StandardModel &get_instance(){
f8b3871f7e5224716b91f49208b36a97|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|21|3|V|cpp
	  return 
7913bf848757bd7c2306fa27a9d9e841|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/adel_scan.cpp|1|17|v|cpp
	progress.hpp>
b0908924c8c42c5390b9aca9ffbad061|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/standard_model.hpp|46|1|V|cpp
	  StandardModel();
50604b3345a9ea4e6a2501a50492e7c8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|48|1|V|cpp
	  DarkSun();
dabfd81449b6322940984b7e41974da1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|7|1|V|cpp
	StandardModel::StandardModel() {
	
	  geff_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
	  heff_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
	  sqrt_gstar_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
	
	  acc_geff = gsl_interp_accel_alloc();
	  acc_heff = gsl_interp_accel_alloc();
	  acc_sqrt_gstar = gsl_interp_accel_alloc();
	
	  gsl_spline_init(sqrt_gstar_spline, temps, sqrt_gstar_data, 341);
	  gsl_spline_init(heff_spline, temps, heff_data, 341);
	  gsl_spline_init(geff_spline, temps, geff_data, 341);
	}
3de2208afbbbd15abd63100a0abc361e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|24|1|V|cpp
	  gsl_spline_free(geff_spline);
cc4187fe1d1e79daa0bcce1c59fe884a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|28|1|V|cpp
	  geff_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
	  heff_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
	  sqrt_gstar_spline = gsl_spline_alloc(gsl_interp_cspline, 341);
2c4d3fcfe73b8528861e4abdb8adf604|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|33|1|V|cpp
	 gsl_spline_init(sqrt_gstar_spline, temps, sqrt_gstar_data, 341);
	  gsl_spline_init(heff_spline, temps, heff_data, 341);
	  gsl_spline_init(geff_spline, temps, geff_data, 341);
20563487b764577e11b627314c21d7dd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|28|1|V|cpp
	  gsl_interp_accel_free(acc_geff);
be9b29ed7c77963e91e656a422e1f77d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|33|1|V|cpp
	  acc_geff = gsl_interp_accel_alloc();
	  acc_heff = gsl_interp_accel_alloc();
	  acc_sqrt_gstar = gsl_interp_accel_alloc();
f04e52a97049cb763111dc4098c4323c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/standard_model/functions.cpp|23|1|V|cpp
	  gsl_spline_free(geff_spline);
	  gsl_spline_free(heff_spline);
	  gsl_spline_free(sqrt_gstar_spline);
	
	  gsl_interp_accel_free(acc_geff);
	  gsl_interp_accel_free(acc_heff);
	  gsl_interp_accel_free(acc_sqrt_gstar);
95b2f944744c936b39dbbbdfad9e63ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|4|1|V|cpp
	DarkSun::DarkSun() {
	  spline_cs44 = gsl_spline_alloc(gsl_interp_cspline, 500);
	  spline_cs66 = gsl_spline_alloc(gsl_interp_cspline, 500);
	  spline_cs46 = gsl_spline_alloc(gsl_interp_cspline, 500);
	
	  gsl_spline_init(spline_cs44, log_eta_zs, log_eta_cs44, 500);
	  gsl_spline_init(spline_cs66, log_eta_zs, log_eta_cs66, 500);
	  gsl_spline_init(spline_cs46, log_eta_zs, log_eta_cs46, 500);
	
	  acc_cs44 = gsl_interp_accel_alloc();
	  acc_cs66 = gsl_interp_accel_alloc();
	  acc_cs46 = gsl_interp_accel_alloc();
	}
899993800062447d2de7f4371c5699de|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|18|1|V|cpp
	  spline_cs44 = gsl_spline_alloc(gsl_interp_cspline, 500);
	  spline_cs66 = gsl_spline_alloc(gsl_interp_cspline, 500);
	  spline_cs46 = gsl_spline_alloc(gsl_interp_cspline, 500);
	
	  gsl_spline_init(spline_cs44, log_eta_zs, log_eta_cs44, 500);
	  gsl_spline_init(spline_cs66, log_eta_zs, log_eta_cs66, 500);
	  gsl_spline_init(spline_cs46, log_eta_zs, log_eta_cs46, 500);
	
	  acc_cs44 = gsl_interp_accel_alloc();
	  acc_cs66 = gsl_interp_accel_alloc();
	  acc_cs46 = gsl_interp_accel_alloc();
e134593792615c30aa2312a02e6cc2d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|20|19|v|cpp
	sqrt_gstar_spline
575343a9025a2d476120c63cc8db4473|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|22|25|v|cpp
	acc_geff
dda7efef7563017ce3ca65c1258e1616|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|23|25|v|cpp
	acc_heff
ff8d76ee2619e7e9753f1d64fe6446eb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|24|25|v|cpp
	acc_sqrt_gstar
3791c622333c94c47eebea1a30fcb9a3|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|11|1|V|cpp
	static constexpr double kHIGGS_VEV = 246.21965;
e593332a7fb9265dc38217efc7948092|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|33|1|V|cpp
	static constexpr double kW_BOSON_MASS = 80.379;
	static constexpr double kZ_BOSON_MASS = 91.1876;
	static constexpr double kHIGGS_MASS = 125.10;
ece6357a49403c9da1365ae8f63c0a72|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|14|1|V|cpp
	V = 246.21965;
5fffb51210ecd71ff8dab5c4f715cfec|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/include/lanre/constants.hpp|24|1|V|cpp
	static constexpr double kELECTRON_MASS = 0.5109989461e-3;
	static constexpr double kMUON_MASS = 105.6583745e-3;
	static constexpr double kTAU_MASS = 1776.86e-3;
2ca438fa2478e5e1440bb30f31cf7702|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|269|1|V|cpp
	  // Compute the thermal cross section for 2eta -> 4eta
	  static double thermal_cross_section_2eta_4eta(double x, const double *model);
	  // Compute the thermal cross section for 4eta -> 2eta
	  static double thermal_cross_section_4eta_2eta(double x, const double *model);
	  // Compute the thermal cross section for 2eta -> 2delta
	  static double thermal_cross_section_2eta_2del(double x, const double *model);
0e6184fc152677a54ae0f8f3cfa4ca0e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|62|69|v|cpp
	const double *model
3ce232d4244cd5b79b91b37baa984289|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|61|1|V|cpp
	  static double integrand_thermal_cross_section_2eta_4eta(double, double,
	                                                          void *);
	  static double integrand_thermal_cross_section_4eta_2eta(double, double x,
	                                                          void *);
	  static double integrand_thermal_cross_section_2eta_2del(double, double,
	                                                          void *);
18b356d84a14439c6c2299c1c1b9fd36|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|128|1|V|cpp
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
7202f9c3aed4f9d58ebc0ca03c57f440|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|131|1|V|cpp
	  const double meta = m_eta(model);
bdc82654e6f981af144c49b3d233c611|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|160|1|V|cpp
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
6c0143ed4372006254f83494307bae51|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|119|3|V|cpp
	  const double *model = (double *)params;
748f573e07d9fc8d4077044b064d9e0c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|119|1|V|cpp
	  struct ThermIntegrationParams *p = (ThermIntegrationParams *)params;
e43cd17f7634d78c77e49472e3ca675e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|120|1|V|cpp
	  const double meta = m_eta(p->model);
5570d3cb5e55c12128f65600cdc05820|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|204|1|V|cpp
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
7cb4010cf4dcd598dfcdc628b6afe842|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|107|1|V|cpp
	//===========================================================================
	//---- Thermally-averaged cross-sections ------------------------------------
	//===========================================================================
0eeaab658664d723a7dc29c98065c7a1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|152|3|V|cpp
	  using boost::math::quadrature::gauss_kronrod;
17fdc149cb30caff12a5de042deb1365|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|157|1|V|cpp
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 2.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
b2d5808b62e09d0bf96f7e1a5e2befcd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|128|67|v|cpp
	, double x
e76989deaa61cab93ff3d278e2fdeccf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|134|1|V|cpp
	  const double x = p->x;
f4952047c5de061f5d2605e8032b1a8e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|116|69|v|cpp
	double x,
99015b4ef852958fec0a9888160b9823|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|163|14|v|cpp
	&model;
1b49611e63772be145ad60f713df46e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|163|15|v|cpp
	ThermIntegrationParams{model,x};
2ea0f6379d131fe516c729b647763bdc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|161|32|v|cpp
	 = ThermIntegrationParams
1629dee48cc4e53161f9b2be8614e062|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|169|50|v|cpp
	workspace
09a25b22ff6165b826de7bee9c4d75f0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|157|1|V|cpp
	  static thread_local gsl_integration_workspace *w =
	      gsl_integration_workspace_alloc(1000);
4deb57a7a5df92eaf1471ff15d14256b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|162|3|V|cpp
	  double integral, error;
18a42e7d10d94de5411dbbbb1a90ce19|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|162|1|V|cpp
	  double integral, error;
	
	  ThermIntegrationParams params{model, x};
	  gsl_function F;
	  F.function = &DarkSun::integrand_thermal_cross_section_2eta_4eta;
	  F.params = &params;
	
	  gsl_integration_qagiu(&F, 4.0, 0.0, 1e-8, 1000, w, &integral, &error);
66178f655ec009558715c7c5fdee1502|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|185|1|V|cpp
	
	  auto f = [x, model, meta](double z) -> double {
	    const double z2 = z * z;
	    const double sig = cross_section_2eta_4eta(z * meta, model);
	    const double ker =
	        z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) * exp(-x * (z - 4.0));
	    return sig * ker;
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, 4.0, std::numeric_limits<double>::infinity(), 5, 1e-8);
7118fee809ca098df4eac038a83f8ee6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|184|1|V|cpp
	  double integral, error;
	
	  ThermIntegrationParams params{model, x};
	  gsl_function F;
	  F.function = &DarkSun::integrand_thermal_cross_section_4eta_2eta;
	  F.params = &params;
	
	  gsl_integration_qagiu(&F, 4.0, 0.0, 1e-8, 1000, w, &integral, &error);
ed5ee5249b2f6406ee0be7e78096de74|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|214|1|V|cpp
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
d15b9cbc68c437263ee453b4757202cf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|157|1|V|cpp
	  static thread_local std::shared_ptr<gsl_integration_workspace> w =
	      std::make_shared<gsl_integration_workspace>(
	          gsl_integration_workspace_alloc(1000));
214b31a96df24d2f1a1403a4f4783ffb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|178|1|V|cpp
	  static thread_local gsl_integration_workspace w =
	      *gsl_integration_workspace_alloc(1000);
90b1e21d38127abec79acecf0576535e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|192|52|v|cpp
	.get()
d0666b09e83ec99514858865c92077a1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|190|1|V|cpp
	  double integral, error;
	  gsl_integration_workspace *w = gsl_integration_workspace_alloc(1000);
75954f0fead0d6241dab05e45fd4814f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|49|3|V|cpp
	  gsl_integration_workspace *workspace;
39b0d9e2e6fbf10beb9884c081e467c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|17|3|V|cpp
	  workspace = gsl_integration_workspace_alloc(1000);
319d98f5389b9833bf1f28c4b1a7b810|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|27|1|V|cpp
	  gsl_integration_workspace_free(workspace);
136797ba49e0a9cd97016a2ae202ffd9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|58|1|V|cpp
	  // Thermal cross section integrands
	  static double integrand_thermal_cross_section_2eta_4eta(double, void *);
	  static double integrand_thermal_cross_section_4eta_2eta(double, void *);
	  static double integrand_thermal_cross_section_2eta_2del(double, void *);
b51be0edc4d529a7ad854c5f925ab2fc|file:///Users/loganmorrison/Downloads/blackhawk_v1.2/results/spec1/plot_spec.py|8|1|V|python
	energies=prim_spec[0,1:]
	spectrum=prim_spec[500,1:]
c425adc1e9bbc68bb9327f70d5418bf9|file:///Users/loganmorrison/Downloads/blackhawk_v1.2/results/spec1/plot_spec.py|8|52|v|python
	prim_spec[500,0]
e8b774561c36f801044ce3f793e86747|file:///Users/loganmorrison/Downloads/blackhawk_v1.2/results/spec1/plot_spec.py|19|17|v|python
	I don't know the units'
e05e89737d1a38b85a11cd575482be00|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|92|25|v|cpp
	/ (1.0 - vrel * vrel);         // CME^2/meta^2.
e1e437ea23111a30adb37746c6ea9163|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|91|3|V|cpp
	  const double vrel = 2.0 * sqrt(3.0 * Td_today / me); // 2 * vrms
2a71077542b55cc3e9711837365bd84c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|90|3|V|cpp
	  const double me = m_eta(model);
689d2369ea6bd38714713b47e80be0c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|85|36|V|cpp
	  // compute dark temperature today in order to compute eta velocity
	  const double Tsm_today = 2.7255 * 8.6173303e-14;
	  const double xi_today = compute_xi_const_tsm(Tsm_today, model);
	  const double Td_today = xi_today * Tsm_today;
	
744f9b824a1bed6341ea3a2986e420a2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|57|1|V|cmake
	# --------------------------------------------------------------------------
	# test_solve_boltzmann.cpp: Test solving the boltzmann equation
	# --------------------------------------------------------------------------
	
	add_executable(test_solve_boltzmann test_solve_boltzmann.cpp)
	target_link_libraries(test_solve_boltzmann PUBLIC gtest_main stiff darksun fmt::fmt)
	
	 set_target_properties(test_solve_boltzmann PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
062cde4fbd4f07956d0f217d2b8f2e42|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/CMakeLists.txt|37|24|v|cmake
	solving the boltzmann equation
78c1216a7c156190c4d3b223cb09d282|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|9|1|V|cpp
	  fmt::print("<sigma*v>(x=10) = {}",
	             DarkSun::thermal_cross_section_2eta_4eta(10, model.data()));
5a0fdb2e987b680a43d433b22c56955b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|36|1|V|cmake
		add_executable(${scanner} "apps/${scanner}.cpp")
		target_link_libraries(${scanner} PUBLIC darksun stiff fmt::fmt)
		set_target_properties(${scanner} PROPERTIES
	         RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
098a86499caddcab58114207cd93467a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|43|16|v|cmake
	${scanner} "apps/${scanner}.cpp"
5229a34b47d84547e6d3bc2c7905ca35|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|44|23|v|cmake
	${scanner}
43028527f85cf96af5481b7fd4d686ab|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|42|1|V|cmake
	#============================================================================
89b6f356aba60205c45f6f2cc04efadf|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|42|1|V|cmake
	#============================================================================
	#---- App for generating the 2eta->4eta, zero-temperature cross-section -----
	#============================================================================
73a2bb8fa9f4d450c3da2fadfbc53983|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|23|1|V|cmake
	# Build the applications
e727c5b7969a0924044ea82db6406337|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|24|16|v|cmake
	generating
c42927a93a41ea36700c0274b6f09ae9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|24|16|v|cmake
	 the 2eta->4eta, zero-temperature cross-section -----
1fb31c93be2c6a89c8469cdf167e29bb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|18|1|V|cpp
	double amp_4pt(const FourVector &, const FourVector &, const FourVector &,
	               const FourVector &, const FourVector &, const FourVector &);
	
	double amp_6pt(const FourVector &, const FourVector &, const FourVector &,
	               const FourVector &, const FourVector &, const FourVector &);
0f5a5b26c634620a4c7f7c07f14d5765|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|5|1|V|cpp
	double amp_4pt(const FourMomentum &, const FourMomentum &, const FourMomentum &,
	               const FourMomentum &, const FourMomentum &,
	               const FourMomentum &);
	
	double amp_6pt(const FourMomentum &, const FourMomentum &, const FourMomentum &,
	               const FourMomentum &, const FourMomentum &,
	               const FourMomentum &);
c1432b48a29c606d424ff3ba23181069|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|16|1|V|cpp
	//===========================================================================
	//---- Amplitude for 2eta->4eta using only 4pt interactions -----------------
	//===========================================================================
7345b70a2d45f15bd2a84a05ab68b88a|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|24|1|V|cpp
	std::tuple<double, double, double> scaled_cross_section(double, size_t);
8f4bada1f7f942c8d4a91f52eceec9da|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|78|1|V|cpp
	  return ((scalar_product(p2, p2) * scalar_product(p3, p5) -
	           scalar_product(p2, p5) *
	               (scalar_product(p3, p3) + 2 * scalar_product(p3, p5)) +
	           scalar_product(p2, p3) *
	               (2 * scalar_product(p2, p5) - 2 * scalar_product(p3, p5) -
	                scalar_product(p5, p5))) *
	          (scalar_product(p1, p6) *
	               (scalar_product(p2, p4) - scalar_product(p3, p4) -
	                scalar_product(p4, p5)) +
	           (scalar_product(p1, p2) - scalar_product(p1, p3) -
	            scalar_product(p1, p5)) *
	               scalar_product(p4, p6) +
	           scalar_product(p1, p4) *
	               (scalar_product(p2, p6) - scalar_product(p3, p6) -
	                scalar_product(p5, p6)))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p3) -
	              2 * scalar_product(p2, p5) + scalar_product(p3, p3) +
	              2 * scalar_product(p3, p5) + scalar_product(p5, p5)) +
	         ((scalar_product(p2, p2) * scalar_product(p4, p5) -
	           scalar_product(p2, p5) *
	               (scalar_product(p4, p4) + 2 * scalar_product(p4, p5)) +
	           scalar_product(p2, p4) *
	               (2 * scalar_product(p2, p5) - 2 * scalar_product(p4, p5) -
	                scalar_product(p5, p5))) *
	          (scalar_product(p1, p6) *
	               (scalar_product(p2, p3) - scalar_product(p3, p4) -
	                scalar_product(p3, p5)) +
	           (scalar_product(p1, p2) - scalar_product(p1, p4) -
	            scalar_product(p1, p5)) *
	               scalar_product(p3, p6) +
	           scalar_product(p1, p3) *
	               (scalar_product(p2, p6) - scalar_product(p4, p6) -
	                scalar_product(p5, p6)))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p4) -
	              2 * scalar_product(p2, p5) + scalar_product(p4, p4) +
	              2 * scalar_product(p4, p5) + scalar_product(p5, p5)) +
	         ((scalar_product(p3, p3) * scalar_product(p4, p5) +
	           scalar_product(p3, p5) *
	               (scalar_product(p4, p4) + 2 * scalar_product(p4, p5)) +
	           scalar_product(p3, p4) *
	               (2 * scalar_product(p3, p5) + 2 * scalar_product(p4, p5) +
	                scalar_product(p5, p5))) *
	          (scalar_product(p1, p6) *
	               (scalar_product(p2, p3) + scalar_product(p2, p4) +
	                scalar_product(p2, p5)) +
	           scalar_product(p1, p3) * scalar_product(p2, p6) +
	           scalar_product(p1, p4) * scalar_product(p2, p6) +
	           scalar_product(p1, p5) * scalar_product(p2, p6) +
	           scalar_product(p1, p2) * scalar_product(p3, p6) +
	           scalar_product(p1, p2) * scalar_product(p4, p6) +
	           scalar_product(p1, p2) * scalar_product(p5, p6))) /
	             (-1 + scalar_product(p3, p3) + 2 * scalar_product(p3, p4) +
	              2 * scalar_product(p3, p5) + scalar_product(p4, p4) +
	              2 * scalar_product(p4, p5) + scalar_product(p5, p5)) +
	         ((scalar_product(p2, p2) * scalar_product(p3, p4) -
	           scalar_product(p2, p4) *
	               (scalar_product(p3, p3) + 2 * scalar_product(p3, p4)) +
	           scalar_product(p2, p3) *
	               (2 * scalar_product(p2, p4) - 2 * scalar_product(p3, p4) -
	                scalar_product(p4, p4))) *
	          (scalar_product(p1, p6) *
	               (scalar_product(p2, p5) - scalar_product(p3, p5) -
	                scalar_product(p4, p5)) +
	           scalar_product(p1, p5) *
	               (scalar_product(p2, p6) - scalar_product(p3, p6) -
	                scalar_product(p4, p6)) +
	           (scalar_product(p1, p2) - scalar_product(p1, p3) -
	            scalar_product(p1, p4)) *
	               scalar_product(p5, p6))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p3) -
	              2 * scalar_product(p2, p4) + scalar_product(p3, p3) +
	              2 * scalar_product(p3, p4) + scalar_product(p4, p4)) +
	         (((scalar_product(p1, p2) - scalar_product(p1, p3) -
	            scalar_product(p1, p6)) *
	               scalar_product(p4, p5) +
	           scalar_product(p1, p5) *
	               (scalar_product(p2, p4) - scalar_product(p3, p4) -
	                scalar_product(p4, p6)) +
	           scalar_product(p1, p4) *
	               (scalar_product(p2, p5) - scalar_product(p3, p5) -
	                scalar_product(p5, p6))) *
	          (scalar_product(p2, p2) * scalar_product(p3, p6) -
	           scalar_product(p2, p6) *
	               (scalar_product(p3, p3) + 2 * scalar_product(p3, p6)) +
	           scalar_product(p2, p3) *
	               (2 * scalar_product(p2, p6) - 2 * scalar_product(p3, p6) -
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p3) -
	              2 * scalar_product(p2, p6) + scalar_product(p3, p3) +
	              2 * scalar_product(p3, p6) + scalar_product(p6, p6)) +
	         (((scalar_product(p1, p2) - scalar_product(p1, p4) -
	            scalar_product(p1, p6)) *
	               scalar_product(p3, p5) +
	           scalar_product(p1, p5) *
	               (scalar_product(p2, p3) - scalar_product(p3, p4) -
	                scalar_product(p3, p6)) +
	           scalar_product(p1, p3) *
	               (scalar_product(p2, p5) - scalar_product(p4, p5) -
	                scalar_product(p5, p6))) *
	          (scalar_product(p2, p2) * scalar_product(p4, p6) -
	           scalar_product(p2, p6) *
	               (scalar_product(p4, p4) + 2 * scalar_product(p4, p6)) +
	           scalar_product(p2, p4) *
	               (2 * scalar_product(p2, p6) - 2 * scalar_product(p4, p6) -
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p4) -
	              2 * scalar_product(p2, p6) + scalar_product(p4, p4) +
	              2 * scalar_product(p4, p6) + scalar_product(p6, p6)) +
	         (((scalar_product(p1, p2) - scalar_product(p1, p5) -
	            scalar_product(p1, p6)) *
	               scalar_product(p3, p4) +
	           scalar_product(p1, p4) *
	               (scalar_product(p2, p3) - scalar_product(p3, p5) -
	                scalar_product(p3, p6)) +
	           scalar_product(p1, p3) *
	               (scalar_product(p2, p4) - scalar_product(p4, p5) -
	                scalar_product(p4, p6))) *
	          (scalar_product(p2, p2) * scalar_product(p5, p6) -
	           scalar_product(p2, p6) *
	               (scalar_product(p5, p5) + 2 * scalar_product(p5, p6)) +
	           scalar_product(p2, p5) *
	               (2 * scalar_product(p2, p6) - 2 * scalar_product(p5, p6) -
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p2, p2) - 2 * scalar_product(p2, p5) -
	              2 * scalar_product(p2, p6) + scalar_product(p5, p5) +
	              2 * scalar_product(p5, p6) + scalar_product(p6, p6)) +
	         ((scalar_product(p1, p3) * scalar_product(p2, p5) +
	           scalar_product(p1, p4) * scalar_product(p2, p5) +
	           scalar_product(p1, p6) * scalar_product(p2, p5) +
	           scalar_product(p1, p5) *
	               (scalar_product(p2, p3) + scalar_product(p2, p4) +
	                scalar_product(p2, p6)) +
	           scalar_product(p1, p2) * scalar_product(p3, p5) +
	           scalar_product(p1, p2) * scalar_product(p4, p5) +
	           scalar_product(p1, p2) * scalar_product(p5, p6)) *
	          (scalar_product(p3, p3) * scalar_product(p4, p6) +
	           scalar_product(p3, p6) *
	               (scalar_product(p4, p4) + 2 * scalar_product(p4, p6)) +
	           scalar_product(p3, p4) *
	               (2 * scalar_product(p3, p6) + 2 * scalar_product(p4, p6) +
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p3, p3) + 2 * scalar_product(p3, p4) +
	              2 * scalar_product(p3, p6) + scalar_product(p4, p4) +
	              2 * scalar_product(p4, p6) + scalar_product(p6, p6)) +
	         ((scalar_product(p1, p3) * scalar_product(p2, p4) +
	           scalar_product(p1, p5) * scalar_product(p2, p4) +
	           scalar_product(p1, p6) * scalar_product(p2, p4) +
	           scalar_product(p1, p4) *
	               (scalar_product(p2, p3) + scalar_product(p2, p5) +
	                scalar_product(p2, p6)) +
	           scalar_product(p1, p2) * scalar_product(p3, p4) +
	           scalar_product(p1, p2) * scalar_product(p4, p5) +
	           scalar_product(p1, p2) * scalar_product(p4, p6)) *
	          (scalar_product(p3, p3) * scalar_product(p5, p6) +
	           scalar_product(p3, p6) *
	               (scalar_product(p5, p5) + 2 * scalar_product(p5, p6)) +
	           scalar_product(p3, p5) *
	               (2 * scalar_product(p3, p6) + 2 * scalar_product(p5, p6) +
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p3, p3) + 2 * scalar_product(p3, p5) +
	              2 * scalar_product(p3, p6) + scalar_product(p5, p5) +
	              2 * scalar_product(p5, p6) + scalar_product(p6, p6)) +
	         ((scalar_product(p1, p4) * scalar_product(p2, p3) +
	           scalar_product(p1, p5) * scalar_product(p2, p3) +
	           scalar_product(p1, p6) * scalar_product(p2, p3) +
	           scalar_product(p1, p3) * scalar_product(p2, p4) +
	           scalar_product(p1, p3) * scalar_product(p2, p5) +
	           scalar_product(p1, p3) * scalar_product(p2, p6) +
	           scalar_product(p1, p2) * scalar_product(p3, p4) +
	           scalar_product(p1, p2) * scalar_product(p3, p5) +
	           scalar_product(p1, p2) * scalar_product(p3, p6)) *
	          (scalar_product(p4, p4) * scalar_product(p5, p6) +
	           scalar_product(p4, p6) *
	               (scalar_product(p5, p5) + 2 * scalar_product(p5, p6)) +
	           scalar_product(p4, p5) *
	               (2 * scalar_product(p4, p6) + 2 * scalar_product(p5, p6) +
	                scalar_product(p6, p6)))) /
	             (-1 + scalar_product(p4, p4) + 2 * scalar_product(p4, p5) +
	              2 * scalar_product(p4, p6) + scalar_product(p5, p5) +
	              2 * scalar_product(p5, p6) + scalar_product(p6, p6));
8c7de79e3dbe82da9f1931a1dc999159|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|268|1|V|cpp
	  return scalar_product(p1, p4) * scalar_product(p2, p6) *
	             scalar_product(p3, p5) +
	         scalar_product(p1, p4) * scalar_product(p2, p5) *
	             scalar_product(p3, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p2) * scalar_product(p3, p6) *
	             scalar_product(p4, p5) +
	         scalar_product(p1, p6) *
	             (scalar_product(p2, p5) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p5) +
	              scalar_product(p2, p3) * scalar_product(p4, p5)) +
	         scalar_product(p1, p3) * scalar_product(p2, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p5) *
	             scalar_product(p4, p6) +
	         scalar_product(p1, p5) *
	             (scalar_product(p2, p6) * scalar_product(p3, p4) +
	              scalar_product(p2, p4) * scalar_product(p3, p6) +
	              scalar_product(p2, p3) * scalar_product(p4, p6)) +
	         scalar_product(p1, p4) * scalar_product(p2, p3) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p3) * scalar_product(p2, p4) *
	             scalar_product(p5, p6) +
	         scalar_product(p1, p2) * scalar_product(p3, p4) *
	             scalar_product(p5, p6);
751abc873913f608bbab0158a4ce74d0|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|302|1|V|cpp
	  if (z <= 4.0) {
	    return std::make_tuple(0.0, 0.0, 0.0);
	  }
	
	  // Incoming 4-momenta
	  const double p = sqrt(z * z / 4.0 - 1.0);
	  FourVector p1{z / 2.0, 0.0, 0.0, p};
	  FourVector p2{z / 2.0, 0.0, 0.0, -p};
	
	  auto msqrd44 = [&p1, &p2](const std::vector<FourVector> &fm) {
	    const FourVector p3 = fm[0];
	    const FourVector p4 = fm[1];
	    const FourVector p5 = fm[2];
	    const FourVector p6 = fm[3];
	
	    const double amp = amp_4pt(p1, p2, p3, p4, p5, p6);
	    return amp * amp;
	  };
	  auto msqrd66 = [&p1, &p2](const std::vector<FourVector> &fm) {
	    const FourVector p3 = fm[0];
	    const FourVector p4 = fm[1];
	    const FourVector p5 = fm[2];
	    const FourVector p6 = fm[3];
	
	    const double amp = amp_6pt(p1, p2, p3, p4, p5, p6);
	    return amp * amp;
	  };
	  auto msqrd46 = [&p1, &p2](const std::vector<FourVector> &fm) {
	    const FourVector p3 = fm[0];
	    const FourVector p4 = fm[1];
	    const FourVector p5 = fm[2];
	    const FourVector p6 = fm[3];
	
	    const double amp4 = amp_4pt(p1, p2, p3, p4, p5, p6);
	    const double amp6 = amp_6pt(p1, p2, p3, p4, p5, p6);
	
	    return amp4 * amp6;
	  };
	
	  std::vector<double> isp_masses = {1.0, 1.0};
	  std::vector<double> fsp_masses = {1.0, 1.0, 1.0, 1.0};
	
	  auto res44 = Rambo(isp_masses, fsp_masses, z, msqrd44)
	                   .compute_width_cross_section(nevents);
	  auto res66 = Rambo(isp_masses, fsp_masses, z, msqrd66)
	                   .compute_width_cross_section(nevents);
	  auto res46 = Rambo(isp_masses, fsp_masses, z, msqrd46)
	                   .compute_width_cross_section(nevents);
	  return std::make_tuple(res44.first, res66.first, res46.first);
9a75d005a3a0e07daceca07d0ac44d23|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|27|1|V|cpp
	  std::string fname_zs =
	      std::filesystem::current_path().append("../rundata/cs_data/zs.dat");
	  std::string fname_cs44 =
	      std::filesystem::current_path().append("../rundata/cs_data/cs44.dat");
	  std::string fname_cs66 =
	      std::filesystem::current_path().append("../rundata/cs_data/cs66.dat");
	  std::string fname_cs46 =
	      std::filesystem::current_path().append("../rundata/cs_data/cs46.dat");
e8e5e1f4e9856e0a0e5f844476b172ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|16|1|V|cpp
	  return 0; 
0e3865ed8ef229ef09dcc6050a8e1f3e|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|36|1|V|cpp
	  std::ofstream file_zs;
	  std::ofstream file_cs44;
	  std::ofstream file_cs66;
	  std::ofstream file_cs46;
	  file_zs.open(fname_zs);
	  file_cs44.open(fname_cs44);
	  file_cs66.open(fname_cs66);
	  file_cs46.open(fname_cs46);
	
	  const double logz_min = log10(4.0 + 1e-5);
	  const double logz_max = log10(100.0);
	  const size_t num_zs = 500;
	  const double logz_step = (logz_max - logz_min) / double(num_zs - 1);
	  boost::progress_display progress(num_zs);
	
	  for (size_t i = 0; i < num_zs; i++) {
	    const double logz = logz_min + i * logz_step;
	    const double z = pow(10.0, logz);
	    const auto res = scaled_cross_section(z, 1000000);
	    file_zs << z << "\n";
	    file_cs44 << std::get<0>(res) << "\n";
	    file_cs66 << std::get<1>(res) << "\n";
	    file_cs46 << std::get<2>(res) << "\n";
	    ++progress;
	  }
	
	  file_zs.close();
	  file_cs44.close();
	  file_cs66.close();
	  file_cs46.close();
	
	  return 0;
fd7081c184a74ab00354d168a3c9fcbb|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/apps/generate_cs_data.cpp|6|1|V|cpp
	#include <boost/progress.hpp>
	#include <darksun/phase_space.hpp>
	#include <filesystem>
	#include <fmt/core.h>
	#include <fstream>
	#include <iomanip>
	#include <iostream>
	#include <string>
	#include <tuple>
3c709b10a5d47ba33d85337dd9110917|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|1|17|v|cpp
	progress
0198702b8726b970011da4fc21d56a94|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|7|1|V|cpp
	TEST(TestModel, TestSigmav) {
	  auto model = DarkSun::new_vec(10, 0.1);
	  fmt::print("<sigma*v>_24(x=10) = {}\n",
	             DarkSun::thermal_cross_section_2eta_4eta(10, model.data()));
	  fmt::print("<sigma*v>_42(x=10) = {}\n",
	             DarkSun::thermal_cross_section_4eta_2eta(10, model.data()));
	}
6f8c15713c297e9ceb9cad56fcf270c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|11|23|v|cpp
	thermal_cross_section_2eta_4eta
2215df0f08dc8c734957fa8c41a8b4c3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|10|1|V|cpp
	  fmt::print("<sigma*v>_24(x=10) = {}\n",
	             DarkSun::cross_section_2eta_4eta(99.0, model.data()));
ce1345f09a1c44db6a2cdfdfaf9a3b39|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|12|1|V|cpp
	  fmt::print("<sigma*v>_42(x=10) = {}\n",
	             DarkSun::thermal_cross_section_4eta_2eta(10, model.data()));
695b1e4ea14a79745f55805749ce85e4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|13|47|v|cpp
	99.0
e6e9e32aaa78bf1bd40aad8f3872c74f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|11|15|v|cpp
	<sigma*v>
9de579009e3e8dee826c8fabcec2ad1b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|64|6|v|cpp
	Common prefactos of the cross section terms
14a1e4549b78ae960311672efa606585|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|16|v|cpp
	pref
12c04dbb9dec6a8b0afd488f3380d179|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|22|v|cpp
	pow<2>((256.0 * pow<4>(M_PI) / 9.0));
402247efb7243e254f8019ae6bc99927|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|1|V|cpp
	  const double c44 = 2770.75 * pow<7>(mu_eta) * pow<2>(lec1) / lam / pow(n,5.5); 
5dddd4d51d6480f57a69cbd3e48353e1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|66|24|v|cpp
	2770.75 * pow<7>(mu_eta) * pow<2>(lec1) / lam / pow(n,5.5); 
e058148d07ba0b1bca6a6df459811964|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|3|V|cpp
	  const double norm = pref * pow<14>(mu_eta) / (lam * lam * pow<11>(n));
6453e7d481b2c7427b88ab9de320c693|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|68|22|v|cpp
	norm * pow<4>(lec1) / 9.0;
8682f79c3c1183e074e16a7e0156fea0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|69|22|v|cpp
	norm * pow<2>(lec2) / 25.0;
9b541639f3918e4dcf1a22acc852ab8b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|70|29|v|cpp
	norm * lec2 * pow<2>(lec1) / 15.0;
b98a256e1a0c9e7bc35dee2eb6be796a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|17|v|cpp
	pow<7>(mu_eta)
c7f4f857ee7e83a7b9777305eb0fcd7a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|31|v|cpp
	/ lam / pow(n, 5.5)
75b0d8cb50688a6964bd6e6c3ba88958|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|39|v|cpp
	pow<7>(mu_eta) *
3fbfaa1ac70b77d74d349ee9b6a18b40|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|45|v|cpp
	/ lam / pow(n, 5.5);
8e094ecdd6580c50fac7fca94079b203|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|66|29|v|cpp
	2770.75
6c15822f9cd74d2a76ee43070b6e1d78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|29|v|cpp
	1662.45
31427698024bca96c949d4f0e06433bc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|68|27|v|cpp
	* 2770.74747830051
23519e578d1706d82f9b002503ba65d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|70|29|v|cpp
	1662.44848698031 * 
06a60ab89c3446e44617e97706d875a8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|66|28|v|cpp
	boost::math::
fc401c372dd27e060a32d736e22386ef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|29|v|cpp
	boost::math::pow<2>(
ce69e0fd615a74b295d6e8e832d33621|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|66|3|V|cpp
	  // 256 pi^4 / 9
7775fff5732a0a9e9773bed66eba250d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|3|V|cpp
	  // 256 pi^4 / 15
af1e8b3cf27a8e8c164aa14c6261a8ea|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|87|10|v|cpp
	(pow<2>(lec1) * pow<3>(M_PI) *
	          (376.0 - 576.0 * z2 + 396.0 * pow<2>(z2) - 136.0 * pow<3>(z2) +
	           21.0 * pow<4>(z2)) *
	          pow<6>(mu_eta)) /
	         (135.0 * pow<2>(lam) * pow<5>(n) * z2)
9603972fcc18b3a4779a3cbc22805f0d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|87|40|v|cpp
	,6.0
0ac0f90a022628d67feaeab7fe6e6b09|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|88|22|v|cpp
	 * lam 
c70c7376b200c0a40b3eac47556559a1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|85|3|V|cpp
	  const double z2 = 4.0;
89d354903b2b146a1f997f13d725646c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|22|v|cpp
	8312.2424349015413
1b229c69889864e68edf38c02ca6b326|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|60|v|cpp
	, 7.0
3d17263062543ecdc6f5900ee4c03d77|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|65|87|v|cpp
	, 5.5
c87a6f616cc752da654de66e5d3d552a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|66|23|v|cpp
	com * 
ef6b2ac580b90c926d2c359d57a9da06|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|70|28|v|cpp
	pre4 * pre4;
14198ad06ac6d8ab32b08c3622631a64|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|71|28|v|cpp
	pre6 * pre6;
b9f3624f7405b3d87846fe7111f44726|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|72|35|v|cpp
	pre4 * pre6;
e21ff4323b917096e7ef6ec4cb531a52|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|3|V|cpp
	  const double pre4 = lec1 * lec1;
133737230bb4d1e4be11ec1406d2cba9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|67|3|V|cpp
	  const double pre6 = lec2 / 5.0;
ea3dfa9323938363b69e582508298fc5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|42|1|V|cpp
	  file_zs << std::setprecision(17);
d96a0c56ac5bfec4cbe75fdec07992d8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/generate_cs_data.cpp|44|1|V|cpp
	  file_cs << std::setprecision(17);
63e79a5ed6484ad8395406baae1be2d9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|132|3|V|cpp
	  y[1] = 
2c64ac639ad3aaa167c7f60eb6c0b1be|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|130|1|V|cpp
	  y[1] = exp(-get_adel(model) * get_n(model)) * yeq_del(tsm, xi, model);
77eba2ba7525e4df45e2f38dd3f63a63|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|129|8|v|cpp
	SIMPLE_BOLTZ
041e697ae828f1d872dd270a2fedeba2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|178|1|V|cpp
	    set_rd_del(model, m_del(model) * y[1] * S_TODAY / RHO_CRIT);
d076516b19170d92b6f46ea3831abc78|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|1|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, model);
	  double pfe = -pf * tsm * s * s;
	  double pfd = pf * meta / (x * x);
	
	  dy[0] = pfe * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq));
	  dy[1] = pfd * sigd * exp(2 * we);
fa3bf598fb30dc472ce818e43c66450a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|39|21|v|cpp
	lx * 
37f55c2a59050d373bd6aa684c128614|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|1|V|cpp
	  double pfe = -pf * s * s;
	  double pfd = pf / x;
48539650239ed5a7a4f1e6802e46969a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|40|13|v|cpp
	 * sigd * exp(2 * we);
2943680be69f272c133240849f4fb6e9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|37|26|v|cpp
	 // log(Yeta)
e73529bfbec3db1094aa499bc7597aae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|25|1|V|cpp
	  double we_eq = weq_eta(tsm, xi, model);
29ae1f1ddfca96f0c04e78f1cfd3688e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|43|20|v|cpp
	- wd
f8a76c16b5085853623428d364d03d67|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|42|11|v|cpp
	pf * sigd * (
	      exp(2.0 * we - wd) - exp(2.0*we_eq + wd - 2.0 * wd_eq)
	  );
	
b7fbe07365e565506a9832c29e10a213|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|41|1|V|cpp
	  dy[0] =
	      -s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)) -
	      pf * sigd * (exp(2.0 * we - wd) - exp(2.0 * we_eq + wd - 2.0 * wd_eq));
	  dy[1] =
	      pf * sigd * (exp(2.0 * we - wd) - exp(2.0 * we_eq + wd - 2.0 * wd_eq));
25cf516253151eeccc2c68861f313118|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|39|3|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, model) * tsm;
e851b2d983a6363dad0d563e4eac381d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|49|3|V|cpp
	  double pf = sqrt(M_PI / 45) * M_PLANK * sqrt_gstar(tsm, xi, model);
3871aa29a65d6a49a9bb460be55509e2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|49|20|v|cpp
	* tsm 
289571d0bdab67b18a845683cbee2ef5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|76|19|v|cpp
	* meta
ba0dd9cb3c5cd2e0a1e4f339dbe283f8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|81|45|v|cpp
	- exp(2.0 * we_eq + wd - 2.0 * wd_eq)
8b5df6a69140c6960b9d46e5f44bf1d0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|7|v|cpp
	-s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq))
290e97a32f61e7131495ec5a1d881bb9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|7|1|V|cpp
	TEST(TestModel, TestSigma24) {
	  auto model = DarkSun::new_vec(10, 0.1);
	  fmt::print("sigma_24(cme=99) = {}\n",
	             DarkSun::cross_section_2eta_4eta(99.0, model.data()));
	  fmt::print("sigma_24(cme=101) = {}\n",
	             DarkSun::cross_section_2eta_4eta(101.0, model.data()));
	}
	
	TEST(TestModel, TestSigmav) {
	  auto model = DarkSun::new_vec(10, 0.1);
	  fmt::print("<sigma*v>_24(x=10) = {}\n",
	             DarkSun::thermal_cross_section_2eta_4eta(10, model.data()));
	  fmt::print("<sigma*v>_42(x=10) = {}\n",
	             DarkSun::thermal_cross_section_4eta_2eta(10, model.data()));
	}
5e16fafdbfb70ee89e58216d61c02ba2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|23|17|v|cpp
	TestSigma24
8ffb398ee6bee6533435199e68a9f38c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|24|1|V|cpp
	  auto model = DarkSun::new_vec(10, 0.1);
	  fmt::print("sigma_24(cme=99) = {}\n",
	             DarkSun::cross_section_2eta_4eta(99.0, model.data()));
	  fmt::print("sigma_24(cme=101) = {}\n",
	             DarkSun::cross_section_2eta_4eta(101.0, model.data()));
4272e4f53c62dad0b44541c63c34ea81|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|25|1|V|cpp
	
	TEST(TestModel, TestSigmav) {
	  auto model = DarkSun::new_vec(10, 0.1);
	  fmt::print("<sigma*v>_24(x=10) = {}\n",
	             DarkSun::thermal_cross_section_2eta_4eta(10, model.data()));
	  fmt::print("<sigma*v>_42(x=10) = {}\n",
	             DarkSun::thermal_cross_section_4eta_2eta(10, model.data()));
	}
2d8c02a72397eeb1a416d317e8f0bced|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|8|1|V|cpp
	  auto model = DarkSun::new_vec(10, 0.1);
00d985d12a2a4565362c56007e45e10b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|24|1|V|cpp
	#define FULL_BOLTZ
a49573e298cdfa1893721dfff3f35682|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|152|1|V|cpp
	#ifdef FULL_BOLTZ
c92ebc7b5a2794d0e3e6344976c95ff3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|12|2|v|cpp
	ifdef
5432bfba04b23a002ac1917694dbe5b1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|28|1|V|cpp
	  fmt::print("<sigma*v>_ed(x=10) = {}\n",
	             DarkSun::thermal_cross_section_2eta_2del(10, model.data()));
236ac95e81044e074e89bb5ed6015c56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|44|3|V|cpp
	  std::ceff << wd_eq
2a3976e1521d16169d54eb9e1de71364|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|45|3|V|cpp
	  fmt::print("wd_eq = {}\n", wd_eq);
f2f14e574bf0107273bbca7c207bfc57|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|45|3|V|cpp
	  fmt::print("wd_eq = {}\n", exp(wd_eq));
aa7eeca438121d27f9bc6532edefa53e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|51|15|v|cpp
	wd_eq
c3943c53080a5cd71e0a60d421b42667|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|51|37|v|cpp
	exp(wd_eq));
fc58e0f619ba42973e6c72f90824eccb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|48|52|v|cpp
	- we
fa80a5746847aa367a7c781668396b9c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|13|1|V|cpp
	  fmt::print("sigma_24(cme=101) = {}\n",
	             DarkSun::cross_section_2eta_4eta(101.0, model.data()));
742277d4ea0e23cd3bc83b996be9d465|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|11|1|V|cpp
	  fmt::print("sigma_24(cme=1GeV) = {}\n",
	             DarkSun::cross_section_2eta_4eta(1.0, model.data()));
4c20438ac54dfa603f1f9c79518c69ca|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun_eta.fr|96|1|V|
	    t3 = lec2*fac[3]*del[eta, mu1]*del[eta, mu1]*del[eta, mu2]*del[eta, mu2]*del[eta, mu3]*del[eta, mu3]*del[eta, mu4]*del[eta, mu4];
6ca86c2fb1c77d73019726bd011fdcf2|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun_eta.fr|96|12|v|
	 + t3
ddf4fdc321a8e32e48e1336c46978edc|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|51|6|v|
	,
	    lec3 == {
	        ParameterType -> External,
	        Description -> "Low energy constant 3",
	        TeX -> ComposedChar["L", "3"],
	        Value -> 0.0
	    }
	
c3ae973f72e44f8cec5650af0c52a45b|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|61|28|v|
	ComposedChar[
da6c33a995a2140f962c2d6d11578ab8|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|61|35|v|
	, Null, Null],
dc3ed5207a5b7018abb3390b03e153cc|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|62|35|v|
	, Null, Null]
eeec92718d0bdcde1d781ee05b0d151a|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|49|16|v|
	ComposedChar["L", "2"],
676250cfb310760557589290c0f9d967|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|42|16|v|
	ComposedChar["L", "1"],
d3962856a16643edda39a8c4147ba145|file:///Users/loganmorrison/Documents/git_hub/FeynTutorial/FeynRules/HiggsPortalDM/higgs_portal_dm.fr|61|1|V|
	M$InteractionOrderHierarchy = {
	  {QCD, 1},
	  {NP,  1},
	  {NPMIX,  1},
	  {QED, 2}
	};
	
	M$InteractionOrderLimit = {
	  {NP, 4},
	  {NPMIX, 4}
	}
0b1fcbbc594e5f193be98ef93fe1d2fd|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|24|3|V|
	  {NPMIX,  1},
32b81e6c09939269e773eed4e6cb5679|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|29|3|V|
	  {NPMIX, 4}
5bcf69f55c7be1feddc35f653ecd62d8|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|23|1|V|
	  {NP,  1},
30bdcde544603a8e258e438d15715fd5|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|29|1|V|
	  {NP, 4}
ea5ef82301855c4b1c1a97d980d65448|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|22|3|V|
	  {QCD, 1},
6bf02b6e1e604b97da048b9d9ec44673|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|24|3|V|
	  {QED, 2}
2bd540f0cae38d207d5e4a3a61438327|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|62|1|V|
		InteractionOrder->{NP,4}
55bc81bf055e8df853bd0151432d034c|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|23|3|V|
	  {NP2,  2}
f0fe781cf8c1724edfe2364add695a00|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|27|3|V|
	  {NP2, 4}
a76492abe4ebfa9796770d3c96fb2b08|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|1|1|V|
	(* ::Package:: *)
	
	(**********************************************************)
	(*                                                        *)
	(*  Model for Chiral perturbation Theory at lowest order  *)
	(*  Follows Scherer's conventions                         *)
	(*                                                        *)
	(**********************************************************)
f3576ef273d5ff7c0e41c098c70e8aa1|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|924|1|V|
	M$ModelName = "large_sun_eta";
	
	M$Information = {
	    Authors -> {"Logan Morrison"},
	    Date-> "8/15/2018",
	    Institutions -> {"UC Santa Cruz"},
	    Emails -> {"acoogan@ucsc.edu", "loanmorr@ucsc.edu"},
	    Version -> "1"
	};
	
	M$InteractionOrderHierarchy = {
	  {NP,  1}
	};
	
	M$InteractionOrderLimit = {
	  {NP, 6}
	}
a8482677bf98171be2fad8b2ae834b7a|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|21|1|V|
	M$ModelName = "Standard Model + Higgs-Portal DM";
f67b6f90644f1f80eb5289a31626800c|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|22|1|V|
	M$Information = {
	  Authors      -> {"Logan A. Morrison"},
	  Version      -> "1.0.0",
	  Date         -> "24. 01. 2020",
	  Institutions -> {"University of California, Santa Cruz"},
	  Emails       -> {"loanmorr@ucsc.edu"}
	};
d2feb513149e041b2d8f541848dae780|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|11|1|V|
	M$InteractionOrderHierarchy = {
	  {NP,  1}
	};
	
	M$InteractionOrderLimit = {
	  {NP, 6}
	}
8d2b07c13f9f4a39010b287c195488d9|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|928|1|V|
	    lam == {
	        ParameterType -> External,
	        Description -> "Confinement Scale",
	        TeX -> "\\Lambda",
	        Value -> 0.1
	    },
	
	    SUNN == {
	        ParameterType -> External,
	        Description -> "N in SU(N)",
	        TeX -> "N",
	        Value -> 10
	    },
	
	    lec1 == {
	        ParameterType -> External,
	        Description -> "Low energy constant 1",
	        TeX -> "\\lambda_{1}",
	        Value -> 0.1,
		InteractionOrder->{NP,2}
	    },
	
	    lec2 == {
	        ParameterType -> External,
	        Description -> "Low energy constant 2",
	        TeX -> "\\lambda_{2}",
	        Value -> 0.1,
		InteractionOrder->{NP,4}
	    }
1e9d5cfb41b67d75efb0910666527e60|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|785|1|V|
	    cmix == {
	        ParameterType    -> Internal,
	        Definitions      -> {cmix -> Sqrt[1 - smix^2]},
	        TeX              -> Cos[Subscript[\[Theta], mix]],
	        Description      -> "Cosine of higgs-scalar-mediator mixing angle"
	    },
	    c1 == {
	        ParameterType    -> Internal,
	        Definitions      -> {c1 -> ((MH - MSM) * (MH + MSM) * Sqrt[1 - smix^2] * smix) / vev},
	        InteractionOrder -> {NPMIX, 1},
	        TeX              -> Subscript[c, 1],
	        Description      -> "coupling of scalar-mediator to Higgs"
	    },
	    MSp == {
	        ParameterType -> Internal,
	        Definitions   -> {MSp -> (Sqrt[1 - smix^2] * Sqrt[-MH^2 + MSM^2 + (MH^2 + MSM^2)/(1 - 2*smix^2)])/Sqrt[1 + 1/(1 - 2*smix^2)]},
	        TeX           -> Subscript[c, 1],
	        Description   -> "coupling of scalar-mediator to Higgs"
	    }
1728507aa3720a84f69c99b24946c34b|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|935|1|V|
	(***** Parameter list. ALL UNITS ARE IN GeV! *****)
	M$Parameters = {
	
	    lam == {
	        ParameterType -> External,
	        Description -> "Confinement Scale",
	        TeX -> "\\Lambda",
	        Value -> 0.1
	    },
	
	    SUNN == {
	        ParameterType -> External,
	        Description -> "N in SU(N)",
	        TeX -> "N",
	        Value -> 10
	    },
	
	    lec1 == {
	        ParameterType -> External,
	        Description -> "Low energy constant 1",
	        TeX -> "\\lambda_{1}",
	        Value -> 0.1,
		InteractionOrder->{NP,2}
	    },
	
	    lec2 == {
	        ParameterType -> External,
	        Description -> "Low energy constant 2",
	        TeX -> "\\lambda_{2}",
	        Value -> 0.1,
		InteractionOrder->{NP,4}
	    }
	
	};
5a095c8e7fcc75d85b1ad423b66f3d1d|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|939|1|V|
	    S[1] == {
	        ClassName -> eta,
	        SelfConjugate -> True,
	        Mass -> meta,
	        TeXParticleName -> "eta",
	        PropagatorLabel -> "eta"
	    }
2908d0012f7ee09067431de0e60b7992|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|326|1|V|
	    S[4] == {
	        ClassName        -> sm,
	        SelfConjugate    -> True,
	        Mass             -> {MSM, 1000.0},
	        Width            -> {WSM,1.0},
	        PropagatorLabel  -> "S",
	        PropagatorType   -> D,
	        PropagatorArrow  -> None,
	        PDG              -> 54,
	        ParticleName     -> "S",
	        FullName         -> "S"
	    },
f60357a8d17e45793298323f1b372a74|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|325|8|v|
	Scalar
cf7f72fb2e3e5a9df104130ba81c194e|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|325|9|v|
	Mediator
f5206c429e2f85df97e6e10faf583a15|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|931|4|V|
	(***** Particle classes list ******)
	M$ClassesDescription = {
	    (* Goldstones *)
	    S[1] == {
	        ClassName -> eta,
	        SelfConjugate -> True,
	        Mass -> meta,
	        TeXParticleName -> "eta",
	        PropagatorLabel -> "eta"
	    }
	}
b738d84104a6544b424c06284541dc09|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|935|1|V|
	(*****************************************************************)
	(*****************************************************************)
	(*                        Lagrangian                             *)
	(*****************************************************************)
	(*****************************************************************)
	
	
	(*****************************************************************)
	(*                        Kinetic Terms                          *)
	(*****************************************************************)
a005c719c1621d0a15cf44e1ce3ac922|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|938|1|V|
	    1/2 del[eta, mu] del[eta, mu] - 1/2 meta eta^2
c4f71b14f621e78aeccf39732478d29c|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|952|1|V|
	(* Full Lagrangian *)
	L := LKinetic + LInt;
f51552bba49867abde7085b43c4783fa|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|936|1|V|
	(* DM *)
	LKinetic := Block[{mu},
	    1/2 del[eta, mu] del[eta, mu] - 1/2 meta eta^2
	];
56b039a8a0ef338a6530843bf90928e1|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|937|4|v|
	Mesons Kinetic Term
c9f4d94ec9fff5420925d0048a048faa|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|937|1|V|
	(* Eta *)
	LEta := Block[{kin,t1, t2, t3, mu1, mu2, mu3, mu4, fac},
	    fac[k_] := (16*Pi^2/(lam^4 * SUNN))^k / Factorial[2*(k+1)];
	    
	    kin = 1/2 del[eta, mu] del[eta, mu] - 1/2 meta eta^2
	
	    t1 = lec1*fac[1]*del[eta, mu1]*del[eta, mu1]*del[eta, mu2]*del[eta, mu2];
	    t2 = lec2*fac[2]*del[eta, mu1]*del[eta, mu1]*del[eta, mu2]*del[eta, mu2]*del[eta, mu3]*del[eta, mu3];
	    kin + t1 + t2
	];
9f250908d1d550380361242f68f90320|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|899|1|V|
	LDM := Block[{kin,mass,int,mu,ii},
	    kin = I * chibar.Ga[mu].del[chi, mu] + 1/2 * del[smp, mu] * del[smp, mu];
	    mass = -MDM * chibar.chi - 1/2 * MSp^2 * smp^2;
	    int = -gSXX * smp * chibar.chi - c1 * smp * Phibar[ii] * Phi[ii];
	
	    ExpandIndices[kin + mass + int, FlavorExpand->SU2D]/.feynmanGaugeRules
	];
b0db491ea0dfa5a7274c31495497f599|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|911|1|V|
	 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
1306e16b2e6466a86d43241567c1ff0d|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|785|1|V|
	    LamC == {
	        ParameterType -> External,
	        Description -> "Confinement Scale",
	        TeX -> "\\Lambda",
	        Value -> 0.1
	    },
942adae5684fef2af4c7034edba602b0|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|791|5|v|
	LamC
09e67c3196a9971cd530bd092ff12138|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|793|25|v|
	Confinement
85a7cd587d6142dbfc1a4de05af7b75d|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|793|26|v|
	Scale
a78be08b915add0d02359752497c60b9|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|437|43|v|
	+ cmix * 
e022b8997cb126389fcf40e2a1ad57ba|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|625|1|V|
	    smix == {
	        ParameterType    -> External,
	        BlockName        -> DMBLOCK,
	        OrderBlock       -> 1,
	        InteractionOrder -> {NPMIX, 1},
	        Value            -> 1.0*^-3,
	        TeX              -> Sin[Subscript[\[Theta], mix]],
	        Description      -> "Sine of higgs-scalar-mediator mixing angle"
	    },
79d974bfe149571d9de59d1b7c6f0e6a|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|625|1|V|
	    gSXX == {
	        ParameterType    -> External,
	        BlockName        -> DMBLOCK,
	        OrderBlock       -> 2,
	        InteractionOrder -> {NP, 1},
	        Value            -> 1.0,
	        TeX              -> Subscript[g, SXX],
	        Description      -> "coupling of DM to scalar-mediator"
	    },
97dbd8ff659f79a6409b8d41f884a26f|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|693|37|v|
	(1 - smix^2) * 
999a9b281d31e6b30718462552eebf95|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|693|43|v|
	+ (-1 + 1/(1 - smix^2)) * MSM^2
62c1236cb9857f528c72644cc86b2217|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|699|35|v|
	Sqrt[MH^2 + (-1 + 1/(1 - smix^2)) * MSM^2])
30916ac09d7efe198dc869867a66bd44|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|790|9|V|
	        TeX -> "\\lambda_{2}",
42b610033305f86e7988ccd0898729d6|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|783|9|V|
	        TeX -> "\\lambda_{1}",
8cdd1508b23d71acd97ac2c1c00c5422|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|777|9|V|
	        TeX -> "N",
f7d76c74da705d9a9517ac63b1d85be2|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|770|9|V|
	        TeX -> "\\mu_{\\eta}",
bf7403d567e97aba3d096bca2a547eb2|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|764|9|V|
	        TeX -> "\\Lambda",
cadacb4ccf6414a90adf9150b7ddcc35|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|734|9|V|
	        Definitions      -> {yd[i_?NumericQ, j_?NumericQ] :> 0 /; UnsameQ[i, j]},
29a02f39743e2a80bf8a64fe9fe9204f|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|733|1|V|
	        Indices       -> {Index[Generation], Index[Generation]},
7b79ec7cf16047d07b68b3028806581f|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|719|1|V|
	        Indices          -> {Index[Generation], Index[Generation]},
b258d9713e32c9622294a4d402fda8a2|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|11|1|V|
	FeynmanGauge = True;
4a38290b003134d7788e8d398dfa733b|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|12|1|V|
	M$vevs = { {Phi[2],vev} };
3b97385dec5510cf77b6c420e4996f3f|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|37|1|V|
	
	IndexRange[Index[SU2W      ]] = Unfold[Range[3]];
	IndexRange[Index[SU2D      ]] = Unfold[Range[2]];
	IndexRange[Index[Gluon     ]] = NoUnfold[Range[8]];
	IndexRange[Index[Colour    ]] = NoUnfold[Range[3]];
	IndexRange[Index[Generation]] = Range[3];
	
	IndexStyle[SU2W,       j];
	IndexStyle[SU2D,       k];
	IndexStyle[Gluon,      a];
	IndexStyle[Colour,     m];
	IndexStyle[Generation, f];
	
09d5d518702d90eacb9432877b6340d9|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|58|1|V|
	    (**** Physical Fields ****)
	
	    (* SM photon *)
	    V[1] == {
	        ClassName       -> A,
	        SelfConjugate   -> True,
	        Mass            -> 0,
	        Width           -> 0,
	        ParticleName    -> "a",
	        PDG             -> 22,
	        PropagatorLabel -> "a",
	        PropagatorType  -> W,
	        PropagatorArrow -> None,
	        FullName        -> "Photon"
	    },
	    (* Z-Boson *)
	    V[2] == {
	        ClassName       -> Z,
	        SelfConjugate   -> True,
	        Mass            -> {MZ, 91.1876},
	        Width           -> {WZ, 2.4952},
	        ParticleName    -> "Z",
	        PDG             -> 23,
	        PropagatorLabel -> "Z",
	        PropagatorType  -> Sine,
	        PropagatorArrow -> None,
	        FullName        -> "Z"
	    },
	    (* W-Boson *)
	    V[3] == {
	        ClassName        -> W,
	        SelfConjugate    -> False,
	        Mass             -> {MW, Internal},
	        Width            -> {WW, 2.085},
	        ParticleName     -> "W+",
	        AntiParticleName -> "W-",
	        QuantumNumbers   -> {Q -> 1},
	        PDG              -> 24,
	        PropagatorLabel  -> "W",
	        PropagatorType   -> Sine,
	        PropagatorArrow  -> Forward,
	        FullName         -> "W"
	    },
	    (* Gluon *)
	    V[4] == {
	        ClassName        -> G,
	        SelfConjugate    -> True,
	        Indices          -> {Index[Gluon]},
	        Mass             -> 0,
	        Width            -> 0,
	        ParticleName     -> "g",
	        PDG              -> 21,
	        PropagatorLabel  -> "G",
	        PropagatorType   -> C,
	        PropagatorArrow  -> None,
	        FullName         -> "G"
	    },
	    (* Photon ghost *)
	    U[1] == {
	        ClassName       -> ghA,
	        SelfConjugate   -> False,
	        Ghost           -> A,
	        QuantumNumbers  -> {GhostNumber -> 1},
	        Mass            -> 0,
	        Width	    -> 0,
	        PropagatorLabel -> "uA",
	        PropagatorType  -> GhostDash,
	        PropagatorArrow -> Forward
	    },
	    (* Z-boson ghost *)
	    U[2] == {
	        ClassName       -> ghZ,
	        SelfConjugate   -> False,
	        Ghost           -> Z,
	        QuantumNumbers  -> {GhostNumber -> 1},
	        Mass            -> {MZ,91.1876},
	        Width	    -> {WZ, 2.4952},
	        PropagatorLabel -> "uZ",
	        PropagatorType  -> GhostDash,
	        PropagatorArrow -> Forward
	    },
	    (* w+ ghost *)
	    U[31] == {
	        ClassName       -> ghWp,
	        SelfConjugate   -> False,
	        Ghost           -> W,
	        QuantumNumbers  -> {GhostNumber -> 1, Q -> 1},
	        Mass            -> {MW,Internal},
	        Width           -> {WW, 2.085},
	        PropagatorLabel -> "uWp",
	        PropagatorType  -> GhostDash,
	        PropagatorArrow -> Forward
	    },
	    (* w- ghost *)
	    U[32] == {
	        ClassName       -> ghWm,
	        SelfConjugate   -> False,
	        Ghost           -> Wbar,
	        QuantumNumbers  -> {GhostNumber -> 1, Q -> -1},
	        Mass            -> {MW,Internal},
	        Width           -> {WW, 2.085},
	        PropagatorLabel -> "uWm",
	        PropagatorType  -> GhostDash,
	        PropagatorArrow -> Forward
	    },
	    (* gluon ghost *)
	    U[4] == {
	        ClassName       -> ghG,
	        SelfConjugate   -> False,
	        Indices         -> {Index[Gluon]},
	        Ghost           -> G,
	        PDG             -> 82,
	        QuantumNumbers  ->{GhostNumber -> 1},
	        Mass            -> 0,
	        Width	    -> 0,
	        PropagatorLabel -> "uG",
	        PropagatorType  -> GhostDash,
	        PropagatorArrow -> Forward
	    },
	    (* Up-type leptons: Neutrinos *)
	    F[1] == {
	        ClassName        -> vl,
	        ClassMembers     -> {ve,vm,vt},
	        Indices          -> {Index[Generation]},
	        FlavorIndex      -> Generation,
	        SelfConjugate    -> False,
	        Mass             -> 0,
	        Width            -> 0,
	        QuantumNumbers   -> {LeptonNumber -> 1},
	        PropagatorLabel  -> {"v", "ve", "vm", "vt"} ,
	        PropagatorType   -> S,
	        PropagatorArrow  -> Forward,
	        PDG              -> {12,14,16},
	        ParticleName     -> {"ve","vm","vt"},
	        AntiParticleName -> {"ve~","vm~","vt~"},
	        FullName         -> {"Electron-neutrino", "Mu-neutrino", "Tau-neutrino"}
	    },
	    (* Down-type leptons: charged lepton *)
	    F[2] == {
	        ClassName        -> l,
	        ClassMembers     -> {e, mu, ta},
	        Indices          -> {Index[Generation]},
	        FlavorIndex      -> Generation,
	        SelfConjugate    -> False,
	        Mass             -> {Ml, {Me,5.11*^-4}, {MMU,0.10566}, {MTA,1.777}},
	        Width            -> 0,
	        QuantumNumbers   -> {Q -> -1, LeptonNumber -> 1},
	        PropagatorLabel  -> {"l", "e", "mu", "ta"},
	        PropagatorType   -> Straight,
	        PropagatorArrow  -> Forward,
	        PDG              -> {11, 13, 15},
	        ParticleName     -> {"e-", "mu-", "ta-"},
	        AntiParticleName -> {"e+", "mu+", "ta+"},
	        FullName         -> {"Electron", "Muon", "Tau"}
	    },
	    (* up-type quarks *)
	    F[3] == {
	        ClassName        -> uq,
	        ClassMembers     -> {u, c, t},
	        Indices          -> {Index[Generation], Index[Colour]},
	        FlavorIndex      -> Generation,
	        SelfConjugate    -> False,
	        Mass             -> {Mu, {MU, 2.55*^-3}, {MC,1.27}, {MT,172}},
	        Width            -> {0, 0, {WT,1.50833649}},
	        QuantumNumbers   -> {Q -> 2/3},
	        PropagatorLabel  -> {"uq", "u", "c", "t"},
	        PropagatorType   -> Straight,
	        PropagatorArrow  -> Forward,
	        PDG              -> {2, 4, 6},
	        ParticleName     -> {"u",  "c",  "t" },
	        AntiParticleName -> {"u~", "c~", "t~"},
	        FullName         -> {"u-quark", "c-quark", "t-quark"}
	    },
	    (* down-type quarks *)
	    F[4] == {
	        ClassName        -> dq,
	        ClassMembers     -> {d, s, b},
	        Indices          -> {Index[Generation], Index[Colour]},
	        FlavorIndex      -> Generation,
	        SelfConjugate    -> False,
	        Mass             -> {Md, {MD,5.04*^-3}, {MS,0.101}, {MB,4.7}},
	        Width            -> 0,
	        QuantumNumbers   -> {Q -> -1/3},
	        PropagatorLabel  -> {"dq", "d", "s", "b"},
	        PropagatorType   -> Straight,
	        PropagatorArrow  -> Forward,
	        PDG              -> {1,3,5},
	        ParticleName     -> {"d",  "s",  "b" },
	        AntiParticleName -> {"d~", "s~", "b~"},
	        FullName         -> {"d-quark", "s-quark", "b-quark"}
	    },
	
	    (* Higgs-boson *)
	    S[1] == {
	        ClassName       -> H,
	        SelfConjugate   -> True,
	        Mass            -> {MH,125},
	        Width           -> {WH,0.00407},
	        PropagatorLabel -> "H",
	        PropagatorType  -> D,
	        PropagatorArrow -> None,
	        PDG             -> 25,
	        ParticleName    -> "H",
	        FullName        -> "H"
	    },
	    (* Z-boson goldstone *)
	    S[2] == {
	        ClassName       -> G0,
	        SelfConjugate   -> True,
	        Goldstone       -> Z,
	        Mass            -> {MZ, 91.1876},
	        Width           -> {WZ, 2.4952},
	        PropagatorLabel -> "Go",
	        PropagatorType  -> D,
	        PropagatorArrow -> None,
	        PDG             -> 250,
	        ParticleName    -> "G0",
	        FullName        -> "G0"
	    },
	    (* W-boson goldstone *)
	    S[3] == {
	        ClassName        -> GP,
	        SelfConjugate    -> False,
	        Goldstone        -> W,
	        Mass             -> {MW, Internal},
	        QuantumNumbers   -> {Q -> 1},
	        Width            -> {WW, 2.085},
	        PropagatorLabel  -> "GP",
	        PropagatorType   -> D,
	        PropagatorArrow  -> None,
	        PDG              -> 251,
	        ParticleName     -> "G+",
	        AntiParticleName -> "G-",
	        FullName         -> "GP"
	    },
	    (* Eta *)
15b5d5a6420fb4f78378e3a775edbca2|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|65|6|v|
	,
	
	    (**** UNPHYSICAL FIELDS ****)
	
	
	    (* U(1)_Y hyper-charge gauge boson *)
	    V[11] == {
	        ClassName     -> B,
	        Unphysical    -> True,
	        SelfConjugate -> True,
	        Definitions   -> { B[mu_] -> -sw Z[mu]+cw A[mu]}
	    },
	    (* SU(2)_L weak gauge bosons *)
	    V[12] == {
	        ClassName     -> Wi,
	        Unphysical    -> True,
	        SelfConjugate -> True,
	        Indices       -> {Index[SU2W]},
	        FlavorIndex   -> SU2W,
	        Definitions   -> { Wi[mu_,1] -> (Wbar[mu]+W[mu])/Sqrt[2],
	                           Wi[mu_,2] -> (Wbar[mu]-W[mu])/(I*Sqrt[2]),
	                           Wi[mu_,3] -> cw Z[mu] + sw A[mu]}
	    },
	    (* U(1)_Y hyper-charge ghosts *)
	    U[11] == {
	        ClassName     -> ghB,
	        Unphysical    -> True,
	        SelfConjugate -> False,
	        Ghost         -> B,
	        Definitions   -> { ghB -> -sw ghZ + cw ghA}
	    },
	    (* SU(2)_L weak ghosts *)
	    U[12] == {
	        ClassName     -> ghWi,
	        Unphysical    -> True,
	        SelfConjugate -> False,
	        Ghost         -> Wi,
	        Indices       -> {Index[SU2W]},
	        FlavorIndex   -> SU2W,
	        Definitions   -> {ghWi[1] -> (ghWp+ghWm)/Sqrt[2],
	                          ghWi[2] -> (ghWm-ghWp)/(I*Sqrt[2]),
	                          ghWi[3] -> cw ghZ+sw ghA}
	    },
	    (* left-handed lepton doublet *)
	    F[11] == {
	        ClassName      -> LL,
	        Unphysical     -> True,
	        Indices        -> {Index[SU2D], Index[Generation]},
	        FlavorIndex    -> SU2D,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> -1/2},
	        Definitions    -> {LL[sp1_,1,ff_] :> Module[{sp2}, ProjM[sp1,sp2] vl[sp2,ff]],
	                           LL[sp1_,2,ff_] :> Module[{sp2}, ProjM[sp1,sp2] l[sp2,ff]]}
	    },
	    (* right-handed leptons *)
	    F[12] == {
	        ClassName      -> lR,
	        Unphysical     -> True,
	        Indices        -> {Index[Generation]},
	        FlavorIndex    -> Generation,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> -1},
	        Definitions    -> {lR[sp1_,ff_] :> Module[{sp2}, ProjP[sp1,sp2] l[sp2,ff]]}
	    },
	    (* left-handed quarks doublet *)
	    F[13] == {
	        ClassName      -> QL,
	        Unphysical     -> True,
	        Indices        -> {Index[SU2D], Index[Generation], Index[Colour]},
	        FlavorIndex    -> SU2D,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> 1/6},
	        Definitions    -> {QL[sp1_,1,ff_,cc_] :> Module[{sp2}, ProjM[sp1,sp2] uq[sp2,ff,cc]],
	                           QL[sp1_,2,ff_,cc_] :> Module[{sp2,ff2}, CKM[ff,ff2] ProjM[sp1,sp2] dq[sp2,ff2,cc]]}
	    },
	    (* right-handed up-type-quarks *)
	    F[14] == {
	        ClassName      -> uR,
	        Unphysical     -> True,
	        Indices        -> {Index[Generation], Index[Colour]},
	        FlavorIndex    -> Generation,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> 2/3},
	        Definitions    -> {uR[sp1_,ff_,cc_] :> Module[{sp2}, ProjP[sp1,sp2] uq[sp2,ff,cc]]}
	    },
	    (* right-handed down-type-quarks *)
	    F[15] == {
	        ClassName      -> dR,
	        Unphysical     -> True,
	        Indices        -> {Index[Generation], Index[Colour]},
	        FlavorIndex    -> Generation,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> -1/3},
	        Definitions    -> {dR[sp1_,ff_,cc_] :> Module[{sp2}, ProjP[sp1,sp2] dq[sp2,ff,cc]]}
	    },
	    (* Higgs-doublet  *)
	    S[11] == {
	        ClassName      -> Phi,
	        Unphysical     -> True,
	        Indices        -> {Index[SU2D]},
	        FlavorIndex    -> SU2D,
	        SelfConjugate  -> False,
	        QuantumNumbers -> {Y -> 1/2},
	        Definitions    -> {Phi[1] -> -I GP,
	                           Phi[2] -> (vev + H + I G0) / Sqrt[2]}
	    }
	
c24e76a05e1f2bb4b7226f73a689c01f|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|68|1|V|
	
	GaugeXi[ V[1]  ] = GaugeXi[A];
	GaugeXi[ V[2]  ] = GaugeXi[Z];
	GaugeXi[ V[3]  ] = GaugeXi[W];
	GaugeXi[ V[4]  ] = GaugeXi[G];
	GaugeXi[ S[1]  ] = 1;
	GaugeXi[ S[2]  ] = GaugeXi[Z];
	GaugeXi[ S[3]  ] = GaugeXi[W];
	GaugeXi[ U[1]  ] = GaugeXi[A];
	GaugeXi[ U[2]  ] = GaugeXi[Z];
	GaugeXi[ U[31] ] = GaugeXi[W];
	GaugeXi[ U[32] ] = GaugeXi[W];
	GaugeXi[ U[4]  ] = GaugeXi[G];
	
eebf2b33b970845b93d363f32107360e|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|70|1|V|
	    (* External parameters *)
	    aEWM1 == {
	        ParameterType    -> External,
	        BlockName        -> SMINPUTS,
	        OrderBlock       -> 1,
	        Value            -> 127.9,
	        InteractionOrder -> {QED,-2},
	        Description      -> "Inverse of the EW coupling constant at the Z pole"
	    },
	    Gf == {
	        ParameterType    -> External,
	        BlockName        -> SMINPUTS,
	        OrderBlock       -> 2,
	        Value            -> 1.16637*^-5,
	        InteractionOrder -> {QED,2},
	        TeX              -> Subscript[G,f],
	        Description      -> "Fermi constant"
	    },
	    aS    == {
	        ParameterType    -> External,
	        BlockName        -> SMINPUTS,
	        OrderBlock       -> 3,
	        Value            -> 0.1184,
	        InteractionOrder -> {QCD,2},
	        TeX              -> Subscript[\[Alpha],s],
	        Description      -> "Strong coupling constant at the Z pole"
	    },
	    ymdo == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 1,
	        Value         -> 5.04*^-3,
	        Description   -> "Down Yukawa mass"
	    },
	    ymup == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 2,
	        Value         -> 2.55*^-3,
	        Description   -> "Up Yukawa mass"
	    },
	    yms == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 3,
	        Value         -> 0.101,
	        Description   -> "Strange Yukawa mass"
	    },
	    ymc == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 4,
	        Value         -> 1.27,
	        Description   -> "Charm Yukawa mass"
	    },
	    ymb == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 5,
	        Value         -> 4.7,
	        Description   -> "Bottom Yukawa mass"
	    },
	    ymt == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 6,
	        Value         -> 172,
	        Description   -> "Top Yukawa mass"
	    },
	    yme == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 11,
	        Value         -> 5.11*^-4,
	        Description   -> "Electron Yukawa mass"
	    },
	    ymm == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 13,
	        Value         -> 0.10566,
	        Description   -> "Muon Yukawa mass"
	    },
	    ymtau == {
	        ParameterType -> External,
	        BlockName     -> YUKAWA,
	        OrderBlock    -> 15,
	        Value         -> 1.777,
	        Description   -> "Tau Yukawa mass"
	    },
	    (* CKM up-down-type-quark CKM *)
	    Vud == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 1,
	        Value         -> 0.974461,
	        TeX           -> Subscript[V, udR],
	        Description   -> "Magnitude of u-d CKM"
	    },
	    Vus == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 2,
	        Value         -> 0.224529,
	        TeX           -> Subscript[V, usR],
	        Description   -> "Magnitude of u-s CKM"
	    },
	    Vub == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 3,
	        Value         -> 0.00364284,
	        TeX           -> Subscript[V, ubR],
	        Description   -> "Magnitude of u-b CKM"
	    },
	
	    (* CKM charm-down-type-quark CKM *)
	    Vcd == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 4,
	        Value         -> 0.224379,
	        TeX           -> Subscript[V, cdR],
	        Description   -> "Magnitude of c-d CKM"
	    },
	    Vcs == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 5,
	        Value         -> 0.97359,
	        TeX           -> Subscript[V, csR],
	        Description   -> "Magnitude of c-s CKM"
	    },
	    Vcb == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 6,
	        Value         -> 0.0421456,
	        TeX           -> Subscript[V, cbR],
	        Description   -> "Magnitude of c-b CKM"
	    },
	
	    (* CKM top-down-type-quark CKM *)
	    Vtd == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 7,
	        Value         -> 0.00896391,
	        TeX           -> Subscript[V, tdR],
	        Description   -> "Magnitude of t-d CKM"
	    },
	    Vts == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 8,
	        Value         -> 0.0413421,
	        TeX           -> Subscript[V, tsR],
	        Description   -> "Magnitude of t-s CKM"
	    },
	    Vtb == {
	        ParameterType -> External,
	        BlockName     -> CKMBLOCK,
	        OrderBlock    -> 9,
	        Value         -> 0.999105,
	        TeX           -> Subscript[V, tbR],
	        Description   -> "Magnitude of t-b CKM"
	    },
	
	    (* Internal Parameters *)
	    aEW == {
	        ParameterType    -> Internal,
	        Value            -> 1 / aEWM1,
	        InteractionOrder -> {QED,2},
	        TeX              -> Subscript[\[Alpha], EW],
	        Description      -> "Electroweak coupling contant"
	    },
	    MW == {
	        ParameterType -> Internal,
	        Value         -> Sqrt[MZ^2 / 2 + Sqrt[MZ^4 / 4 - Pi / Sqrt[2] * aEW / Gf * MZ^2]],
	        TeX           -> Subscript[M,W],
	        Description   -> "W mass"
	    },
	    sw2 == {
	        ParameterType -> Internal,
	        Value         -> 1 - (MW / MZ)^2,
	        Description   -> "Squared Sin of the Weinberg angle"
	    },
	    ee == {
	        ParameterType    -> Internal,
	        Value            -> Sqrt[4 * Pi * aEW],
	        InteractionOrder -> {QED,1},
	        TeX              -> e,
	        Description      -> "Electric coupling constant"
	    },
	    cw == {
	        ParameterType -> Internal,
	        Value         -> Sqrt[1 - sw2],
	        TeX           -> Subscript[c,w],
	        Description   -> "Cosine of the Weinberg angle"
	    },
	    sw == {
	        ParameterType -> Internal,
	        Value         -> Sqrt[sw2],
	        TeX           -> Subscript[s,w],
	        Description   -> "Sine of the Weinberg angle"
	    },
	    gw == {
	        ParameterType    -> Internal,
	        Definitions      -> {gw -> ee / sw},
	        InteractionOrder -> {QED,1},
	        TeX              -> Subscript[g,w],
	        Description      -> "Weak coupling constant at the Z pole"
	    },
	    g1 == {
	        ParameterType    -> Internal,
	        Definitions      -> {g1 -> ee / cw},
	        InteractionOrder -> {QED,1},
	        TeX              -> Subscript[g,1],
	        Description      -> "U(1)Y coupling constant at the Z pole"
	    },
	    gs == {
	        ParameterType    -> Internal,
	        Value            -> Sqrt[4 * Pi * aS],
	        InteractionOrder -> {QCD,1},
	        TeX              -> Subscript[g,s],
	        ParameterName    -> G,
	        Description      -> "Strong coupling constant at the Z pole"
	    },
	    vev == {
	        ParameterType    -> Internal,
	        Value            -> 2 * MW * sw / ee,
	        InteractionOrder -> {QED,-1},
	        Description      -> "Higgs vacuum expectation value"
	    },
	    lam == {
	        ParameterType    -> Internal,
	        Definitions      -> {lam -> MH^2 / (2 * vev^2)},
	        InteractionOrder -> {QED, 2},
	        Description      -> "Higgs quartic coupling"
	    },
	    muH == {
	        ParameterType -> Internal,
	        Definitions   -> {muH -> MH/Sqrt[2]},
	        TeX           -> \[Mu],
	        Description   -> "Coefficient of the quadratic piece of the Higgs potential"
	    },
	    yl == {
	        ParameterType    -> Internal,
	        Indices       -> {Index[Generation], Index[Generation]},
	        Definitions      -> {yl[i_?NumericQ, j_?NumericQ] :> 0 /; UnsameQ[i, j]},
	        Value            -> {yl[1,1] -> Sqrt[2] * yme / vev,
	                             yl[2,2] -> Sqrt[2] * ymm / vev,
	                             yl[3,3] -> Sqrt[2] * ymtau / vev},
	        InteractionOrder -> {QED, 1},
	        ParameterName    -> {yl[1,1] -> ye,
	                             yl[2,2] -> ym,
	                             yl[3,3] -> ytau},
	        TeX              -> Superscript[y, l],
	        Description      -> "Lepton Yukawa couplings"
	    },
	    yu == {
	        ParameterType    -> Internal,
	        Indices       -> {Index[Generation], Index[Generation]},
	        Definitions      -> {yu[i_?NumericQ, j_?NumericQ] :> 0 /; UnsameQ[i, j]},
	        Value            -> {yu[1,1] -> Sqrt[2] * ymup / vev,
	                             yu[2,2] -> Sqrt[2] * ymc / vev,
	                             yu[3,3] -> Sqrt[2] * ymt / vev},
	        InteractionOrder -> {QED, 1},
	        ParameterName    -> {yu[1,1] -> yup,
	                             yu[2,2] -> yc,
	                             yu[3,3] -> yt},
	        TeX              -> Superscript[y, u],
	        Description      -> "Up-type Yukawa couplings"
	    },
	    yd == {
	        ParameterType    -> Internal,
	        Indices       -> {Index[Generation], Index[Generation]},
	        Definitions      -> {yd[i_?NumericQ, j_?NumericQ] :> 0 /; UnsameQ[i, j]},
	        Value            -> {yd[1,1] -> Sqrt[2] * ymdo / vev,
	                             yd[2,2] -> Sqrt[2] * yms / vev,
	                             yd[3,3] -> Sqrt[2] * ymb / vev},
	        InteractionOrder -> {QED, 1},
	        ParameterName    -> {yd[1,1] -> ydo,
	                             yd[2,2] -> ys,
	                             yd[3,3] -> yb},
	        TeX              -> Superscript[y, d],
	        Description      -> "Down-type Yukawa couplings"
	    },
	    CKM == {
	        ParameterType -> Internal,
	        Indices       -> {Index[Generation], Index[Generation]},
	        Unitary       -> True,
	        Value         -> {CKM[1,1] -> Vud, CKM[1,2] -> Vus, CKM[1,3] -> Vub,
	                          CKM[2,1] -> Vcd, CKM[2,2] -> Vcs, CKM[2,3] -> Vcb,
	                          CKM[3,1] -> Vtd, CKM[3,2] -> Vts, CKM[3,3] -> Vtb},
	        TeX           -> Superscript[V,CKM],
	        Description   -> "CKM-Matrix"
	    },
4bb49cf2442386b975df3466eea57409|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|70|5|V|
	    (* dark matter parameters *)
55fd839f42a92870cda0651f60988211|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|105|1|V|
	
	(**** LAGRANGIAN TOOLS****)
	
	repCKMUnitary = {
	    CKM[a_, b_] * Conjugate[CKM[a_, c_]] -> IndexDelta[b, c],
	    CKM[b_, a_] * Conjugate[CKM[c_, a_]] -> IndexDelta[b, c]
	};
	
	(* generators in real representation: see below 90 of arXiv:1101.4665 *)
	GenReal[1] = (gw/2) * {{0, 0, 0, -1}, {0, 0, 1, 0}, {0, -1, 0, 0}, {1, 0, 0, 0}};
	GenReal[2] = (gw/2) * {{0, 0, 1, 0}, {0, 0, 0, 1}, {-1, 0, 0, 0}, {0, -1, 0, 0}};
	GenReal[3] = (gw/2) * {{0, -1, 0, 0}, {1, 0, 0, 0}, {0, 0, 0, 1}, {0, 0, -1, 0}};
	GenReal[4] = (g1/2) * {{0, -1, 0, 0}, {1, 0, 0, 0}, {0, 0, 0, -1}, {0, 0, 1, 0}};
	
	(* Higgs field in 4-d vector *)
	phiv = {GP + GPbar, -I * (GP - GPbar), vev + H, G0} / Sqrt[2];
	phivb = {0, 0, vev, 0} / Sqrt[2];
	
	(* ghost fields in 4-d vector *)
	ghv = {ghWi[1], ghWi[2], ghWi[3], ghB};
	ghvbar = {ghWibar[1], ghWibar[2], ghWibar[3], ghBbar};
	
	feynmanGaugeRules := If[Not[FeynmanGauge], {G0|GP|GPbar ->0}, {}];
	
274620c59cd413d291388c1f28dfa4e9|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|109|1|V|
	
	
	LGauge := Block[{mu,nu,ii,aa,kinB,kinW,kinG},
	    kinB = -1/4 * FS[B,mu,nu] * FS[B,mu,nu];
	    kinW = -1/4 * FS[Wi,mu,nu,ii] * FS[Wi,mu,nu,ii];
	    kinG = -1/4 * FS[G,mu,nu,aa] * FS[G,mu,nu,aa];
	
	    ExpandIndices[kinB + kinW + kinG, FlavorExpand->SU2W]
	];
	
	LFermions := Block[{mu,kin},
	    kin = I * QLbar.Ga[mu].DC[QL, mu];
	    kin += I * LLbar.Ga[mu].DC[LL, mu];
	    kin += I * uRbar.Ga[mu].DC[uR, mu];
	    kin += I * dRbar.Ga[mu].DC[dR, mu];
	    kin += I * lRbar.Ga[mu].DC[lR, mu];
	
	    ExpandIndices[kin, FlavorExpand->{SU2W,SU2D}]/.repCKMUnitary
	];
	
	LHiggs := Block[{ii,mu,kin,pot},
	    (* Higgs kinetic term *)
	    kin = DC[Phibar[ii], mu] * DC[Phi[ii], mu];
	    (* Higgs potential *)
	    pot = -muH^2 * Phibar[ii] * Phi[ii] + lam * Phibar[ii] * Phi[ii] * Phibar[jj] * Phi[jj];
	    (* expand out adjoint and doublet indices *)
	    ExpandIndices[kin - pot, FlavorExpand->{SU2D,SU2W}]/.feynmanGaugeRules
	];
	
	LYukawa := Block[{sp,ii,jj,cc,ff1,ff2,ff3,yuk},
	    (* up-type-quark yukawa interactions *)
	    yuk = -yu[ff1, ff2] * QLbar[sp, ii, ff1, cc].uR[sp, ff2, cc] * Phibar[jj] * Eps[ii, jj];
	    (* down-type-quark yukawa interactions *)
	    yuk += -yd[ff2, ff3] * CKM[ff1, ff2] * QLbar[sp, ii, ff1, cc].dR[sp, ff3, cc] * Phi[ii];
	    (* down-type-lepton yukawa interactions *)
	    yuk += -yl[ff1, ff3] * LLbar[sp, ii, ff1].lR[sp, ff3] * Phi[ii];
	
	    (* expand doublet indices *)
	    yuk = ExpandIndices[yuk, FlavorExpand -> SU2D];
	    (* apply unitarity *)
	    yuk = yuk/.repCKMUnitary;
	    (* add hermitian conjugate *)
	    (yuk + HC[yuk])/.feynmanGaugeRules
	];
	
	LGhost := Block[{kin,mass,Mg,mu,ii},
	    (* kinetic terms *)
	    kin = -ghBbar.del[DC[ghB,mu],mu] - ghWibar[ii].del[DC[ghWi[ii],mu],mu];
	
	    (* ghost fields assembled into vector *)
	    ghv = {ghWi[1], ghWi[2], ghWi[3], ghB};
	    ghvbar = {ghWibar[1], ghWibar[2], ghWibar[3], ghBbar};
	
	    (* ghost mass + goldstone interaction matrix *)
	    Mg = Table[Dot[Dot[GenReal[a], phivb], Dot[GenReal[b], phiv]], {a, 1, 4}, {b, 1, 4}];
	    mass = - ghvbar.Mg.ghv;
	
	    (* sum over adjoint indices *)
	    ExpandIndices[kin + mass, FlavorExpand->SU2W]
	];
05c063aa341a25510723a3203f670674|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|121|1|V|
	LSM:= LGauge + LFermions + LHiggs + LYukawa + LGhost + LEta;
64df636ab845f8bb3fb3bcb5211bfb78|file:///Users/loganmorrison/Documents/research/DarkSun/mathematica/feynrules/large_sun.fr|12|1|V|
	M$GaugeGroups = {
	  U1Y  == {
	    Abelian          -> True,
	    CouplingConstant -> g1,
	    GaugeBoson       -> B,
	    Charge           -> Y
	  },
	  SU2L == {
	    Abelian           -> False,
	    CouplingConstant  -> gw,
	    GaugeBoson        -> Wi,
	    StructureConstant -> Eps,
	    Representations   -> {Ta,SU2D},
	    Definitions       -> {Ta[a_,b_,c_]->PauliSigma[a,b,c]/2, FSU2L[i_,j_,k_]:> I Eps[i,j,k]}
	  },
	  SU3C == {
	    Abelian          -> False,
	    CouplingConstant  -> gs,
	    GaugeBoson        -> G,
	    StructureConstant -> f,
	    Representations   -> {T,Colour},
	    SymmetricTensor   -> dSUN
	  }
	};
c7aa477d82615146a5c3f57c0a349d4b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|13|1|V|cpp
	  DarkSun::set_lec1(0.3);
f6e6268e27414732e2e211979fe1849c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|14|21|v|cpp
	0.3,
53e61336bb49ec978968786b07dea50b|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|720|23|v|tex
	results
de7791799c3ba3f7ac0bcf4dccf8c33c|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|723|1|V|tex
	\subsubsection{Coupled Boltzmann Equations}
23d41e0d72fae18fff97df5d53775928|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|723|16|v|tex
	Coupled Boltzmann Equations
c4314e7fc9db8cb976c7bf200995ea63|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|723|1|V|tex
	\subsubsection{$2\etap\to4\etap$ Cross-Section}
245cf810e6c63c6ffddf8855a8995fe2|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|724|16|v|tex
	$2\etap\to4\etap$ Cross-Section}
e21a5fa55949a4da5d389673d1bbee3f|file:///Users/loganmorrison/Documents/research/DarkSun/paper/main.tex|812|1|V|tex
	The Boltzmann equations for the $\eta'$ and $\Delta$ are given by:
	\begin{align}
	    \dfrac{dn_{\eta'}}{dt} + 3Hn_{\eta'} &=  -\langle\sigma_{\eta'\eta'\to\Delta\bar{\Delta}} v\rangle \left(n_{\eta'}^2- n^{2}_{\mathrm{eq},\eta'} \dfrac{n_{\Delta}^2}{n_{\mathrm{eq},\Delta}^2}\right)-\langle\sigma_{2\eta'\to4\eta'} v\rangle n_{\eta'}^2\left(\dfrac{n_{\eta'}^2}{n^{2}_{\mathrm{eq},\eta'}} - 1\right)\\
	    \dfrac{dn_{\Delta}}{dt} + 3Hn_{\Delta} &= \langle\sigma_{\eta'\eta'\to\Delta\bar{\Delta}} v\rangle \left(n_{\eta'}^2- n^{2}_{\mathrm{eq},\eta'} \dfrac{n_{\Delta}^2}{n_{\mathrm{eq},\Delta}^2}\right)
	\end{align}
8f70067797d85e36f2a39097ac944469|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|49|1|V|cpp
	  dy[1] =
	      pf * sigd * (exp(2.0 * we - wd) - exp(2.0 * we_eq + wd - 2.0 * wd_eq));
2740a84c4bf637642c1de00dba6ab8d4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|40|1|V|cpp
	  auto model = DarkSun::new_vec(5, 0.1);
f8fcde14ed78eb92625484ae2d19479c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|51|15|v|cpp
	dye, dyd
2c4cfe476e0f4e5a2e14c82e9c03427f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|51|29|v|cpp
	dy[0], dy[1]);
e999a306fc418d38d1dca7b21bfcce74|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|54|10|v|cpp
	-2.1585514147471714 - m / (tsm * xi) + log(g) -
	         log(StandardModel::heff(tsm)) + 2.0 * log(m) - 2 * log(tsm) + log(xi) +
	         log(gsl_sf_bessel_Kn_scaled(2, m / (tsm * xi)))
b0a6711eafd560913488357980744ca0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|55|11|v|cpp
	m/(tsm*xi)
3cb9b9e76f55acff3628902ca4add0e0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|57|20|v|cpp
	pow(tsm, 2)
c6c3e8b15842684e99460d0ac1e43a36|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|52|1|V|cpp
	  const double m = m_eta(model);
	  const double g = 1.0;
	  const double x = m / (tsm * xi);
	  return -x + log((0.11549230036519878 * g * m * m * xi *
	                   gsl_sf_bessel_Kn_scaled(2, x)) /
	                  (tsm * tsm * StandardModel::heff(tsm)));
7bcc0c0aa35126fdf99c7b0c597b1375|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|62|1|V|cpp
	  const double m = m_del(model);
	  const double g = g_del(model);
	  return -2.1585514147471714 - m / (tsm * xi) + log(g) -
	         log(StandardModel::heff(tsm)) + 2.0 * log(m) - 2 * log(tsm) + log(xi) +
	         log(gsl_sf_bessel_Kn_scaled(2, m / (tsm * xi)));
af6c6b37203a657dddb1ace75506ee2b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|1|V|cpp
	  double siged = thermal_cross_section_2eta_2del(xd, model);
fedb51f593d4bdd5f3f8af94632cc74a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|271|1|V|cpp
	  // Compute the thermal cross section for 2eta -> 2delta
	  static double thermal_cross_section_2eta_2del(double x, const double *model);
449155de62d84e44cca3cf331a89ca6c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|143|1|V|cpp
	double DarkSun::thermal_cross_section_2eta_2del(const double x,
	                                                const double *model) {
	  using boost::math::pow;
	  using boost::math::quadrature::gauss_kronrod;
	
	  const double meta = m_eta(model);
	  const double mdel = m_del(model);
	  const double c = get_c(model);
	  const double n = get_n(model);
	  const double lam = get_lam(model);
	
	  const double den = 2.0 * gsl_sf_bessel_Kn_scaled(2, x);
	  const double pre = x / (den * den);
	  const double zmin = 2.0 * mdel / meta;
	  const double sig = exp(-2.0 * c * n) / (64.0 * M_PI * n * n * lam * lam);
	
	  auto f = [x](double z) -> double {
	    const double z2 = z * z;
	    return z2 * (z2 - 4.0) * gsl_sf_bessel_K1_scaled(x * z) *
	           exp(-x * (z - 4.0));
	  };
	
	  const double integral = gauss_kronrod<double, 15>::integrate(
	      f, zmin, std::numeric_limits<double>::infinity(), 15, 1e-8);
	
	  return pre * sig * integral;
	}
3fb2715a9558eb9fbd0d0d872d1d3d79|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|50|24|v|cpp
	2.0 * we_eq 
188ad3f0cc1e9d71a53dc75703817e89|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|50|39|v|cpp
	 - 2.0 * wd_eq
5dd65a3dbf73704dd822c115f0d78639|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|50|58|v|cpp
	2.0 * we_eq + 
c88abeeff239abc922c7162840728710|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|50|3|V|cpp
	  fmt::print("sigd = {}\n", sigd);
df62d25cac69677c8f0f4a5debc32cb2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|38|1|V|cpp
	  double siged = thermal_cross_section_2eta_2del(xd, model);
	  double sigde = thermal_cross_section_2del_2eta(xd, model);
116f30c6c208cd4bc6f69f6130e50c81|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|52|3|V|cpp
	  double sigde = thermal_cross_section_2del_2eta(xd, model);
25dbe08c5ee3dadc9a30c27606ba237c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|41|3|V|cpp
	  DarkSun::set_adel(model.data(), 0.0);
7e1f8ce4736cf1b2d7b7ee96e8b901d4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|1|V|cpp
	  return (0.11549230036519878 * g * pow<2>(m) * xi *
	          gsl_sf_bessel_Kn_scaled(2, m / (tsm * xi))) /
	         (exp(m / (tsm * xi)) * StandardModel::heff(tsm) * pow<2>(tsm));
6cd8a3192ae2c378af8773d6f9097c21|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|33|v|cpp
	Power(m,2)
e7ed04d09fa9c551fa74fb67a1acbe85|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|1|V|cpp
	  return (0.11549230036519878*g*m*m*pow<3>(meta)*BesselK(2.,m/(T*xi)))/
	   (Power(T,5)*Power(xeta,3)*Power(xi,2)*h(T));
d61723c2971adc490998cf1ca969b375|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|40|v|cpp
	BesselK
3e976ff598e6e4ea9a9869fff2c9b1c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|73|v|cpp
	Power(T,2)
343eabc2083eac2440152f4f5df99f81|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|1|V|cpp
	  return (0.11549230036519878 * g * m * m * xi *
	          gsl_sf_bessel_Kn(2, m / (tsm * xi))) /
	         (tsm * tsm * StandardModel::heff(tsm));
0359051c8828bb6f3affc2b512f115df|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|157|1|V|cpp
	  y[1] = -get_adel(model) * get_n(model) + weq_del(tsm, xi, model);
c3feec59d27b5f2e3363e0164509ed08|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|163|3|v|cpp
	y[1] = 
1ba1097629fbc14b95d42d8f33d1ec40|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|162|1|V|cpp
	  std::cerr << -get_adel(model) * get_n(model) + weq_del(tsm, xi, model);
99f79e9b9536db91d730e16a4dd2076d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|159|10|v|cpp
	exp(-get_adel(model) * get_n(model)) * yeq_del(tsm, xi, model)
64d5cb3bd663d2ccbcec3d86440a2ed0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|163|16|v|cpp
	-get_adel(model) * get_n(model) + weq_del(tsm, xi, model)
7e5de89d97b9702e26a03d82387acf7f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|164|48|v|cpp
	+ log(yeq_del(tsm, xi, model))
631c002599e8b0a7bea5eda9d32a1a10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|164|16|v|cpp
	-get_adel(model) * get_n(model) 
8a560d796809347ce36e823c11ad348c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|42|1|V|cpp
	  const double wd = y[1];
	  const double wd_eq = weq_del(tsm, xi, model);
	  double siged = thermal_cross_section_2eta_2del(xd, model);
	  double sigde = thermal_cross_section_2del_2eta(xd, model);
	
	  dy[0] = -s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)) -
	          pf * siged * exp(we) + pf * sigde * exp(-we + 2.0 * wd);
	  dy[1] = pf * siged * exp(2.0 * we - wd) - pf * sigde * exp(wd);
e46e6f97a160ec9bbdb12170b751d0c0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|80|1|V|cpp
	  const double wd = y[1];
	  const double wd_eq = weq_eta(tsm, xi, model);
	
	  dfy[0] = -s * s * pf * sige * exp(we) * (3.0 * exp(2 * we) - exp(2 * we_eq)) -
	           pf * sigd * 2.0 * exp(2.0 * we - wd);
	  dfy[1] = pf * sigd * 2.0 * exp(2.0 * we - wd);
	
	  dfy[2] =
	      pf * sigd * (exp(2.0 * we - wd) + exp(2.0 * we_eq + wd - 2.0 * wd_eq));
	  dfy[3] =
	      -pf * sigd * (exp(2.0 * we - wd) + exp(2.0 * we_eq + wd - 2.0 * wd_eq));
b182a19f0dce31c41cc78c4ed9c1bf56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|85|1|V|cpp
	  dfy[0] = -s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)) -
	          pf * siged * exp(we) + pf * sigde * exp(-we + 2.0 * wd);
	  dfy[1] = pf * siged * exp(2.0 * we - wd) - pf * sigde * exp(wd);
6c53d02dbdcc89773f2ab6b2e700201b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|87|50|v|cpp
	- pf * sigde * exp(wd);
f33b65bd3aee7d5a24fde5f36548941d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|89|13|v|cpp
	-pf * siged * exp(we) + 
527c1131bb74667370fa54b468f98ba1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|185|3|V|cpp
	  const double zmin = 2.0 * mdel / meta;
95ae3c0ebde1421750e6db87bdf74801|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|194|10|v|cpp
	zmin
69e85bb57e5b772a9dfe060c8c1fafde|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|3|V|cpp
	  std::c
a9b467f7f240b8e8a2ee8ae8380114a9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|46|1|V|cpp
	  std::cout << siged * neq_eta(td, model) << "\n";
5dfb74cbe027e8e8847d6440f727ae0f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|46|3|V|cpp
	  std::cout << "siged " << siged * pow(neq_eta(td, model), 2) << "\n";
e915ec08002133782c589ceab719fc47|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|46|3|V|cpp
	  std::cout << "sigde " << sigde * pow(neq_del(td, model), 2) << "\n\n";
ddc7fef098c63ffb243f034e8f85919d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|161|1|V|cpp
	
	  std::cerr << -get_adel(model) * get_n(model) + weq_del(tsm, xi, model)
	            << "\n";
	  std::cerr << weq_del(tsm, xi, model) << "\n";
7cd92ccd4f06186cf6fa0fea03f76ce7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|82|1|V|cpp
	  double sigd = thermal_cross_section_2eta_2del(xd, model);
c18432a94b7973280b04314b23cd8b92|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|84|40|v|cpp
	sigde 
eead90951ee044232abe3581cc54d6cb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|47|34|v|cpp
	pf * sigde *
93967c79cff8b92307a8c2ad40bbcac7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|47|39|v|cpp
	-we + 2.0 * wd
44cc279d78becf49ffc1e7d599e24c45|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|1|1|v|cpp
	pf * sigd * (exp(2.0 * we - wd) -  exp(wd));
5d9ef944865f5e550fffa2e948340d17|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|1|1|V|cpp
	          pf * sigd * (exp(we) -  exp(2.0 * wd + 2.0 * we_eq - 2.0 * wd_eq - we));
9e7a1d6ab0f5f7fddb6dd37987726ec9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|46|1|V|cpp
	  dy[0] =
	      -s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)) -
	      pf * sigd * (exp(we) - exp(2.0 * wd + 2.0 * we_eq - 2.0 * wd_eq - we));
	  dy[1] =
	      pf * sigd * (exp(2.0 * we - wd) - exp(wd + 2.0 * we_eq - 2.0 * wd_eq));
2c1089047efafbe5cbc8d9153b8707c2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|85|1|V|cpp
	  dfy[0] = -s * s * pf * sige * exp(we) * (3.0 * exp(2 * we) - exp(2 * we_eq)) -
	           pf * sigd * (exp(we) - pf * *exp(-we + 2.0 * wd));
	  dfy[1] = 2.0 * pf * siged * exp(2.0 * we - wd);
	
	  dfy[2] = 2.0 * pf * sigde * exp(-we + 2.0 * wd);
	  dfy[3] = -pf * siged * exp(2.0 * we - wd) - pf * sigde * exp(wd);
b3872a2dcb9f72f660eed42d0fdc762f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|92|7|v|cpp
	- exp(wd + 2.0 * we_eq - 2.0 * wd_eq))
b2560082eca24d0c774055350d5e8492|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|92|7|V|cpp
	      -s * s * pf * sige * exp(we) * (exp(2 * we) - exp(2 * we_eq)) -
2982476286239e955ae9a50276e8f6e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|91|26|v|cpp
	exp(we)
94a4712a63d166cc4271821bbd099c0f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|46|1|V|cpp
	    fmt::print("{}, {}, {}\n", val[0], val[1], val[2]);
81f4d23dc895391b74143a601e1727ff|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|48|1|V|cpp
	  fmt::print("rd eta = {}\n", DarkSun::get_rd_eta(model.data()));
bc4b285cc679d3019e2ea52ef7b05ff7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|20|5|v|cpp
	Compute the scaled cross-section (
06195b68d3e2ba73265446b2ca3d7641|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|13|1|V|cpp
	/**
	 *  @breif Compute the scaled cross-section for 2eta->4eta using only 4pt
	 * interactions
	 *
	 *  @param  z  Center-of-mass energy divided by eta mass: z = cme/meta.
	 *  @return Scaled cross-section.
	 *
	 *  By 'scaled', we mean that all model parameters have been removed.
	 *  Specifically a factor of [256 pi^4 lec1^2 meta^7 / 9 lam^8 n^2]^2. The
	 *  cross-section is computed by interpolating between data generated using
	 *  the RAMBO phase-space generator. This function includes only the 4pt eta
	 *  interactions, i.e. the (d_mu eta)^4 term in the chiral Lagrangian.
	 */
9fd5a5568e8f3b2d72fa213b2eb8a664|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|13|1|V|cpp
	/**
	 *  @breif Compute the scaled cross-section for 2eta->4eta using only 4pt
	 * interactions
	 *
	 *  @param  z  Center-of-mass energy divided by eta mass: z = cme/meta.
	 *  @return Scaled cross-section.
	 *
	 *  By 'scaled', we mean that all model parameters have been removed.
	 *  Specifically a factor of [256 pi^4 lec1^2 meta^7 / 9 lam^8 n^2]^2. The
	 *  cross-section is computed by interpolating between data generated using
	 *  the RAMBO phase-space generator. This function includes only the 4pt eta
	 *  interactions, i.e. the (d_mu eta)^4 term in the chiral Lagrangian. For
	 *  energies beyond the interpolation range, we use a fit of the form
	 *  log10(cs) = m * log10(z) + b with m = 14 and b='eta_cs_intercept44'.
	 */
bbae61392e5bae62256d850e2cacb97f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|41|1|V|cpp
	/**
	 *  @breif Compute the scaled cross-section for 2eta->4eta using only 6pt
	 * interactions
	 *
	 *  @param  z  Center-of-mass energy divided by eta mass: z = cme/meta.
	 *  @return Scaled cross-section.
	 *
	 *  By 'scaled', we mean that all model parameters have been removed.
	 *  Specifically a factor of [256 pi^4 lec2 meta^7 / 15 lam^8 n^2]^2. The
	 *  cross-section is computed by interpolating between data generated using
	 *  the RAMBO phase-space generator. This function includes only the 6pt eta
	 *  interactions, i.e. the (d_mu eta)^6 term in the chiral Lagrangian. For
	 *  energies beyond the interpolation range, we use a fit of the form
	 *  log10(cs) = m * log10(z) + b with m = 14 and b='eta_cs_intercept66'.
	 */
85aa9c704a544e104741012bf72b6572|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|71|4|v|cpp
	interactions
579fe8571f2ee2236549c849e11251fa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|82|5|v|cpp
	interaction
3f83e7e64f92860056dc3a75063eb2b7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|82|43|v|cpp
	, i.e. the (d_mu eta)^6 term in the chiral Lagrangian. For
07527d4c7dfec6f24b8f9cad9675ed86|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|13|1|V|cpp
	/**
	 *  @breif Compute the scaled cross-section for 2eta->4eta using only 4pt
	 *  interactions
	 *
	 *  @param  z  Center-of-mass energy divided by eta mass: z = cme/meta.
	 *  @return Scaled cross-section.
	 *
	 *  By 'scaled', we mean that all model parameters have been removed.
	 *  Specifically a factor of [256 pi^4 lec1^2 meta^7 / 9 lam^8 n^2]^2. The
	 *  cross-section is computed by interpolating between data generated using
	 *  the RAMBO phase-space generator. This function includes only the 4pt eta
	 *  interactions, i.e. the (d_mu eta)^4 term in the chiral Lagrangian. For
	 *  energies beyond the interpolation range, we use a fit of the form
	 *  log10(cs) = m * log10(z) + b with m = 14 and b='eta_cs_intercept44'.
	 */
fbfacf91eb39656e1c68bd1494c4a77d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|105|24|v|cpp
	scaled 
bbec154fc8c9e13c8810516efc27d28c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|107|39|v|cpp
	 divided by eta mass: z = cme/meta.
7380ae6c5e1189eef50cfd0557d74e99|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|109|13|v|cpp
	Scaled
2dc875fc51b7bd7df4ac74703b6b2aaa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|111|1|V|cpp
	 *  By 'scaled', we mean that all model parameters have been removed.
	 *  Specifically a factor of [256 pi^4 lec1^2 meta^7 / 9 lam^8 n^2]^2. The
	 *  cross-section is computed by interpolating between data generated using
	 *  the RAMBO phase-space generator. This function includes only the 4pt eta
	 *  interactions, i.e. the (d_mu eta)^4 term in the chiral Lagrangian. For
	 *  energies beyond the interpolation range, we use a fit of the form
	 *  log10(cs) = m * log10(z) + b with m = 14 and b='eta_cs_intercept44'.
cc6feb9e14a232049810b5d54ba45738|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|86|17|v|cpp
	scaled_cs_eta_24
1944992e3dac4c1f888f85ef4d730f07|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|112|69|v|cpp
	prefactors
ec29e813d3e740b6e76c8c7381af0f89|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|103|1|V|cpp
	/**
	 *  @breif Compute the cross-section for 2eta->4eta.
	 *
	 *  @param  cme  Center-of-mass energy.
	 *  @param  model  Pointer to an array of doubles containing model parameters.
	 *  @return Cross-section.
	 *
	 *  To compute the cross-section for 2eta->4eta, we use the scaled
	 *  cross-sections (see 'DarkSun::scaled_cs_eta_24_xx') and add the model
	 *  dependent prefactors.
	 */
977d3fd1817f3b4423f452c1e76a580a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|143|1|V|cpp
	 *  To compute the cross-section for 2eta->4eta, we use the scaled
	 *  cross-sections (see 'DarkSun::scaled_cs_eta_24_xx') and add the model
	 *  dependent prefactors.
79a31014ef5b08abb06a10c891dcad58|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|136|1|V|cpp
	/**
	 *  @breif Compute the cross-section for 2eta->2eta at zero temperature.
	 *
	 *  @param  cme  Center-of-mass energy.
	 *  @param  model  Pointer to an array of doubles containing model parameters.
	 *  @return Cross-section.
	 *
	 *  The 2eta->2eta cross section is computed using the 4pt eta interaction
	 *  from the chiral Lagrangian. It is assumed that the eta's are
	 *  non-relativistic so that the energy of each eta is m_eta.
	 */
c9e33b7c4bbb3e568b6a2b3b67c274e3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|159|12|v|cpp
	Compute the cross-section for 2eta->2eta at zero temperature.
1007cd743d8ab0da78c3a7daf487f887|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|165|1|V|cpp
	 *  The 2eta->2eta cross section is computed using the 4pt eta interaction
	 *  from the chiral Lagrangian. It is assumed that the eta's are
	 *  non-relativistic so that the energy of each eta is m_eta.
bb6df5dd9c874a35b47e1a8afcc44275|file:///Users/loganmorrison/Documents/git_hub/Haliax/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.0)
	set(CMAKE_VERBOSE_MAKEFILE ON)
	project(Haliax)
9905de1568da9c34a83f08972d32ca10|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(
544b7d38721a34c41627f2385393ea07|file:///Users/loganmorrison/Documents/git_hub/Haliax/CMakeLists.txt|8|1|V|cmake
	find_package(Eigen3 REQUIRED)
c32c400fd3786a8fe69f9612cd4b1091|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|1|1|V|cmake
	set(CMAKE_CXX_STANDARD 11)
	
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
a40be2dc5f004e8d314c941af7f2707a|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|46|1|V|cmake
	add_executable(test_diffeq_stiff test_diffeq_stiff.cpp)
	target_link_libraries(test_diffeq_stiff PUBLIC
	        lanre
		GSL::gsl
		GSL::gslcblas
	        gtest_main
	        Eigen3::Eigen
	        ${Boost_LIBRARIES})
	
	set_target_properties(test_diffeq_stiff PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
d88b78bbe25fdba82d96f0e3e0ef9d39|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/CMakeLists.txt|40|2|v|cmake
	 --------------------------------------------------------------------------
c21e56d2b54f950921d930da080c81b8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/CMakeLists.txt|42|1|V|cmake
	# --------------------------------------------------------------------------
18acb898a2cb632bb7d5bad58a9602b4|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
	
	project("Lanre" VERSION 0.1.0
	        DESCRIPTION "Collection of numerical and high-energy physics routines for c++"
	        LANGUAGES CXX)
	
	find_package(Boost REQUIRED)
	find_package(GSL REQUIRED)
	
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	        ${Boost_INCLUDE_DIRS}
	)
	
	set(CMAKE_MACOSX_RPATH ON)
	
	add_subdirectory(include)
9053f582ccfbd61f72c4f31fb4174d36|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/CMakeLists.txt|17|1|V|cmake
	        ${Boost_INCLUDE_DIRS}
29f9ba8739093ccf9ba8932e7304a606|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/CMakeLists.txt|1|1|V|cmake
	cmake_minimum_required(VERSION 3.11)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../build)
	set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/build)
	
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib")
	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/../lib")
	
	project("Stiff" VERSION 0.1.0
		DESCRIPTION "Port of the FORTRAN stiff ODE solvers to c++"
	        LANGUAGES CXX)
	
	include_directories(
	        ${PROJECT_SOURCE_DIR}/include
	        ${PROJECT_BINARY_DIR}/include
	)
	
	set(CMAKE_MACOSX_RPATH ON)
	
	add_subdirectory(include)
	
93e76ba5ce4c1d0e32c9827ba7aabbf7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/CMakeLists.txt|2|1|V|cmake
	project(Lanre CXX)
4a38c27a550e3dbb058c3e578d32384d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/CMakeLists.txt|9|1|V|cmake
	project("Stiff" VERSION 0.1.0
		DESCRIPTION "Port of the FORTRAN stiff ODE solvers to c++"
	        LANGUAGES CXX)
cb4ac5e55b326d251e1ffc6cdf93a44c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|3|1|V|cmake
	project(Stiff)
bd1e333d1166f18893b2bbeba10229a3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/.gitignore|34|16|v|conf
	directories
3a470f0733ed09506ac394f071e977ac|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/stiff/vector_matrix.hpp|9|24|v|cpp
	=Eigen::Dynamic
ca3aa79e095b6ed7031e5287afe10de3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/stiff/vector_matrix.hpp|9|13|v|cpp
	<Type, Size>
6f6cb72d544962fa333e2e34ce64f719|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/stiff/vector_matrix.hpp|8|27|v|cpp
	Size
9d66c1d52ea0a478b7b64fbc535bff19|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/stiff/include/stiff/radau5.hpp|4|11|v|cpp
	stiff/
2f607df1467616699c3ac2c3138525a3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|19|25|v|cmake
	to adhere to https://github.com/mapbox/cpp/issues/37
eb616be204a9d4c09d116219996ab58f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|25|63|v|cmake
	-D_GLIBCXX_USE_CXX11_ABI=0
1f25c1cda51127e967dadeb7b0f903e9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|35|30|v|cmake
	_TARGET
c64970c3524d07461a4d51e6d4e998ad|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|38|25|v|cmake
	_TARGE
f2a8db9ab9ecbcde6f2e4ae4cdbb940b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|36|43|v|cmake
	_VISIBILITY
c0bf6abb0cc9d6324c184a07d5e9c636|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|36|28|v|cmake
	${STIFF_LIB} ${STIFF_VIZ}
221c5609ab773ee382417a9dbc8953d5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|37|28|v|cmake
	${} ${_VISIBILITY}
7db18e677a18a90c263c7308673a65b2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|36|54|v|cmake
	"${MASON_PACKAGE_${_PACKAGE}_INCLUDE_DIRS}")
37e1809addc555a8ea8bbe2273d2600f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|39|36|v|cmake
	${STIFF_VIZ} "${MASON_PACKAGE_${_PACKAGE}_LIBRARIES}")
e1dabb7ddf8b8c83b3ab5293e4b070ce|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|37|41|v|cmake
	${STIFF_VIZ}
653c87df8d3cf0fd2ed0e6b3b29cd869|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|35|1|V|cmake
	set(STIFF_VIZ INTERFACE)
3368eaab5699138aae76d0d6a821a5c2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|37|1|V|cmake
	#target_compile_definitions(${STIFF_LIB} ${STIFF_VIZ} "${MASON_PACKAGE_${_PACKAGE}_DEFINITIONS}")
681539785f61c66c1fa25561d8435a93|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|37|1|V|cmake
	#target_compile_options(${STIFF_LIB} ${STIFF_VIZ} "${MASON_PACKAGE_${_PACKAGE}_OPTIONS}")
8d9b701d6590c2de5dc6cb27256b718d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/CMakeLists.txt|3|1|V|cmake
	# Download and unpack googletest at configure time
	configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "CMake step for googletest failed: ${result}")
	endif ()
	execute_process(COMMAND ${CMAKE_COMMAND} --build .
	        RESULT_VARIABLE result
	        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download)
	if (result)
	    message(FATAL_ERROR "Build step for googletest failed: ${result}")
	endif ()
	
	# Prevent overriding the parent project's compiler/linker
	# settings on Windows
	set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
	
	# Add googletest directly to our build. This defines
	# the gtest and gtest_main targets.
	add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src
	        ${CMAKE_CURRENT_BINARY_DIR}/googletest-build
	        EXCLUDE_FROM_ALL)
	
	# The gtest/gtest_main targets carry header search path
	# dependencies automatically when using CMake 2.8.11 or
	# later. Otherwise we have to add them here ourselves.
	if (CMAKE_VERSION VERSION_LESS 2.8.11)
	    include_directories("${gtest_SOURCE_DIR}/include")
	endif ()
de678f41f01185a1b86e2a6da9284a61|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|43|1|V|cmake
	#============================================================================
	#---- GTEST stuff -----------------------------------------------------------
	#============================================================================
17ceab77d86b36d33f5543a107927b53|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|80|7|v|cmake
	GTEST stuff -----------------------------------------------------------
30c15ad97b1bf1e2d4d406a1ef913e6b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/CMakeLists.txt|44|1|V|cmake
	add_executable(test_radau5 test_radau5.cpp)
	target_link_libraries(test_radau5 PUBLIC
	        stiff
	        gtest_main
	        Eigen3::Eigen)
	
	set_target_properties(test_radau5 PROPERTIES
	        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}../../bin)
a8bf220c655fa2ce6daad529b622ec8a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|93|1|V|cmake
	# Add the tests
	add_subdirectory(test)
70516aac7554f4e17c346cefc4ee97f7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|87|17|v|cmake
	test_radau5
c74c1f42f141c011ca6bd8b1114fc3d0|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|38|7|v|cmake
	Build
f225946b8230fc1880c780f0faf3a94e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|41|1|V|cmake
	# Build the stiff library
6bb2ab7a0a9dd7c9d79b22ae7fbe6c5d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|15|3|V|cpp
	  const size_t n; // Dimension of system
de77220af568208f2fac7537ca14c227|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|10|1|V|cpp
	template <class Type, int N>
	using OdeFunc =
	    std::function<void(Type, const Vector<Type, N> &, Vector<Type, N>)>;
e1d146b7b234dac0f40d83ad1410e20e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|21|1|V|cpp
	  OdeFunc<Type, N> fcn;
e97c066a80e3a6793a3f787662256f00|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|18|11|v|cpp
	class Type, 
a1fa27779242b4902f7ae3bdd5c6d508|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|12|24|v|cpp
	Type
b07236b0e7eb7ebea6fc51d6dc86de14|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|20|11|v|cpp
	Type, 
d157d3f5278542716904176f66eba660|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|4|1|V|cpp
	#include "stiff/vector_matrix.hpp"
	#include <Eigen/Dense>
	#include <functional>
	
	namespace stiff {
	
	template <int N>
	using OdeFunc =
	    std::function<void(double, const Vector<double, N> &, Vector<double, N>)>;
	
	template <int N>
	using OdeJac =
	    std::function<void(double, const Vector<double, N> &, Matrix<double, N>)>;
	
e04c476b10cb5e346849abbdb5dc6eef|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|9|1|V|cpp
	template <int N>
	using OdeFunc =
	    std::function<void(double, const Vector<double, N> &, Vector<double, N>)>;
	
	template <int N>
	using OdeJac =
	    std::function<void(double, const Vector<double, N> &, Matrix<double, N>)>;
48a32f971f7b9dbd87ab2f13744c3d57|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|11|3|v|cpp
	virtual 
83ce24abb0c3b5c586d2e10112f74e59|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|12|19|v|cpp
	double, const vector<double, n> &, vector<double> &
d963704b4e35e3a21510ee5b77c20de3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|15|22|v|cpp
	doube,
6432b3cd15622def61dc4bccd232ad05|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|17|1|V|cpp
	  std::function<void(double, const Vector<double, N> &, Vector<double, N> &)> f;
9aacefd6e9264bb443b143b104fc8f0b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|18|1|V|cpp
	  std::function<void(double, const Vector<double, N> &, Vector<double, N> &)> dfdy;
ca9f4c5381ddeab24b857426b6b24bf1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|12|1|V|cpp
	  void operator()(double x, const Vector<double, N> &y, Vector<double, N> &dy) {
	    dydx(x, y, dy);
	  }
e64e0a0dbcc7322916df03d8d992c85d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|12|1|V|cpp
	  int ubw_jac;
b01e8354aed643d1e333674d5fa00ae2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|13|7|v|cpp
	lbw_jac
9abeb91c27e946a4b3f60bfe07bd65c8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|13|3|V|cpp
	  int ;
19f0fc4b66975039300012340b66ac7b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|13|1|V|cpp
	  int ubw_jac, lbw_jac;
d9045d97232e6a7e52daa5bb8f579a31|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|34|1|V|cpp
	  std::function<void(double, const Vector<double, N> &, Vector<double, N> &)>
	      dfdx;
b7aa4ca6e665276ead4186b762127634|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|21|3|V|cpp
	  Matrix<double, N, N> mas;
4b583376b2767b923c3e1da60d10de59|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|21|8|v|cpp
	operator
fd154ffe305c26b5004231ff709bd1b8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|21|8|v|cpp
	oper
aed133afedc1734285cb31dda6a195ec|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|25|1|V|cpp
	  void dfdy(double x, const Vector<double, N> &y, Matrix<double, N> &dy) {
	    if (m_dydx == nullptr) {
	    } else {
	      (*m_dydx)(x, y, dy);
	    }
	  }
63a1ea41cd2a98ec987b59b8ff2ce534|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|23|5|V|cpp
	    (*m_dydx)(x, y, dy);
c703cd0aa8de577318753b089ad36702|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|24|1|V|cpp
	    if (m_dfdy == nullptr) {
	    } else {
	      (*m_dfdy)(x, y, df);
	    }
	  }
634f5dfdca173068397de07d4f5b4d5f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|25|1|V|cpp
	    if (m_dfdx == nullptr) {
	    } else {
	      (*m_dfdx)(x, y, dy);
	    }
f31e54d74cbd67d08649641bae4f7de8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|29|1|V|cpp
	  std::function<void(double, const Vector<double, N> &, Vector<double, N> &)>
fdfd96acbb9ca4cb79b5344933655859|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|11|11|v|cpp
	FDydx 
19d8c0937c456cfed9234188f7bb5038|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|11|3|v|cpp
	typedef 
1508035ccf05d67406309493ac122422|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|13|7|V|cpp
	      F_dydx;
8bef531ef3d15c409edcd680b4f4f4f2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|11|1|V|cpp
	  using F_dydx = std::function<void(double, const Vector<double, N> &,
	                                    Vector<double, N> &)>;
b973095f75aa7184fedf71a45be3d32f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|35|3|v|cpp
	std::function<void(double, const Vector<double, N> &, Vector<double, N> &)>
ba29e86dc2df0e1772602db2fcb76d63|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|36|9|v|cpp
	unction<void(double, const Vector<double, N> &, Matrix<double, N> &)>
d359184f6bccc72a00fdd15ce5095fe7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|36|3|V|cpp
	  std::f
5b7707be7418925c82ce2bd2bef48b27|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|28|1|V|cpp
	  OdeSystem(F_dydx *t_dydx);
789ccbada9cdfebb7e484f4751a04b33|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|30|1|V|cpp
	  void dydx(double x, const Vector<double, N> &y, Vector<double, N> &dy);
	  void dfdy(double x, const Vector<double, N> &y, Matrix<double, N> &df);
	  void dfdx(double x, const Vector<double, N> &y, Matrix<double, N> &dy);
63be40a21cd22ebe8203f86f9e56f2b4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|52|1|V|cpp
	  if (m_dfdy == nullptr){
	
	  }else{
	    (*m_dfdy)(x, y, df);
	  }
e93c3a8be5dedc5797953f6ac73a9476|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/radau5.f|802|13|v|fortran
	MUJACP=MUJAC+1
	            MD=MIN(MBJAC,M2)
	            DO MM=1,M1/M2+1
	               DO K=1,MD
	                  J=K+(MM-1)*M2
	 12               F1(J)=Y(J)
	                  F2(J)=DSQRT(UROUND*MAX(1.D-5,ABS(Y(J))))
	                  Y(J)=Y(J)+F2(J)
	                  J=J+MD
	                  IF (J.LE.MM*M2) GOTO 12 
	                  CALL FCN(N,X,Y,CONT,RPAR,IPAR)
	                  J=K+(MM-1)*M2
	                  J1=K
	                  LBEG=MAX(1,J1-MUJAC)+M1
	 14               LEND=MIN(M2,J1+MLJAC)+M1
	                  Y(J)=F1(J)
	                  MUJACJ=MUJACP-J1-M1
	                  DO L=LBEG,LEND
	                     FJAC(L+MUJACJ,J)=(CONT(L)-Y0(L))/F2(J) 
	                  END DO
	                  J=J+MD
	                  J1=J1+MD
	                  LBEG=LEND+1
	                  IF (J.LE.MM*M2) GOTO 14
	               END DO
	            END DO
	         ELSE
	
36ee23b6136628fa8152f565e73d58df|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|66|11|v|cpp
	MUJACP
11ac41c528ea3258f863568b2f43f9cf|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|68|18|v|cpp
	MBJAC
12171e4fbb95abc03e2c81f36a8d255c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|67|1|v|cpp
	      int mujacp=ubw_jac+1
	      int md=min(m,M2);
	            DO MM=1,M1/M2+1
	               DO K=1,MD
	                  J=K+(MM-1)*M2
	 12               F1(J)=Y(J)
	                  F2(J)=DSQRT(UROUND*MAX(1.D-5,ABS(Y(J))))
	                  Y(J)=Y(J)+F2(J)
	                  J=J+MD
	                  IF (J.LE.MM*M2) GOTO 12 
	                  CALL FCN(N,X,Y,CONT,RPAR,IPAR)
	                  J=K+(MM-1)*M2
	                  J1=K
	                  LBEG=MAX(1,J1-MUJAC)+M1
	 14               LEND=MIN(M2,J1+MLJAC)+M1
	                  Y(J)=F1(J)
	                  MUJACJ=MUJACP-J1-M1
	                  DO L=LBEG,LEND
	                     FJAC(L+MUJACJ,J)=(CONT(L)-Y0(L))/F2(J) 
	                  END DO
	                  J=J+MD
	                  J1=J1+MD
	                  LBEG=LEND+1
	                  IF (J.LE.MM*M2) GOTO 14
	               END DO
	            END DO
	         ELSE
7efe377333b4aef02375a95348a92559|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|35|1|V|cpp
	      F_dydx *t_dydx
30a741b47dab0d44faa0ae7c3d85e40f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|36|1|V|cpp
	      F_dfdy *t_dfdy,
95df0d1281262d697095fb728177b05b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|39|1|V|cpp
	      int t_lbw_jac, int t_ubw_jac,
5c6060666c421c520b8c5198e2cafea2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|40|1|V|cpp
	      int t_lbw_mas, int t_ubw_mas,
b75c059e70661dead43b94aea7796d61|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|41|11|v|cpp
	t_lbw_mas
eeb201b773e5abc9dfcd23d0f8b8951b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|41|23|v|cpp
	ubw_mas
49cdbdcef817aeff6f9e920d7a7d6ed5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|41|1|V|cpp
	      int t_m1, int t_m2,
5c5069711259890e147755c994b1160c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|28|20|v|cpp
	 = N; 
949252202a4f295edfa0476cca45b227|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|32|15|v|cpp
	 = N;
134850e39e6cafb74734f97963ae80da|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|38|3|v|cpp
	OdeSystem(F_dydx *t_dydx, F_dfdy *t_dfdy, F_dfdx *t_dfdx,
	            Matrix<double, N, N> t_mas, int t_lbw_jac, int t_ubw_jac,
	            int t_lbw_mas, int t_ubw_mas, int t_m1, int t_m2, int t_idx1,
	            int t_idx2, int t_idx3);
5e5aad573aca1ddaeb059e5c5c10005e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|54|32|v|cpp
	OdeSystem(OdeSystem<N>::F_dydx *t_dydx)
e880c8f84d9d6ae7e56b3a6d3c99359b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|24|1|V|cpp
	  // Bandwidths of the jacobian
	  const int lbw_jac;
	  const int ubw_jac;
	  // Bandwidths of the mass matrix
	  const int lbw_mas;
	  const int ubw_mas;
	  //
	  const int m1;
	  const int m2;
	  // index varaible
	  const int idx1;
	  const int idx2;
	  const int idx3;
b0d94754a03c910877a7f003b554dd6b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|60|3|V|cpp
	  m_dydx = t_dydx;
a6fb5eb3af64bbb2a1f1f96f9790a462|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|44|3|V|cpp
	  bool 
2074ad2d2effdcdda86b210e78109384|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|53|3|V|cpp
	  const bool banded;
17dae5118a53e20dfc7c7e355c18acfb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|37|29|v|cpp
	 = Matrix<double, N, N>::Identity();
fa121ff22693659a927772775604ef72|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|54|3|V|cpp
	  const bool implicit;
ead6135899a1dc31a3caf9099004929a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|37|1|V|cpp
	  const Matrix<double, N, N> m_mas;
	  const bool m_implicit;
	  // Bandwidths of the jacobian
	  const int m_lbw_jac;
	  const int m_ubw_jac;
	  // Bandwidths of the mass matrix
	  const int m_lbw_mas;
	  const int m_ubw_mas;
	  const bool m_banded;
	  //
	  const int m_m1;
	  const int m_m2;
	  const int m_nm1;
	  // index varaible
	  const int m_idx1;
	  const int m_idx2;
	  const int m_idx3;
54d377f97067c91f2b7ac4afa11a66d9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|73|1|V|cpp
	  (*m_dydx)(x, y, dy);
a3ecf752f485c3e9188c671ee4cf666a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|72|1|V|cpp
	template <int N>
	void OdeSystem<N>::dydx(double x, const Vector<double, N> &y,
	                        Vector<double, N> &dy) {
	  (*m_dydx)(x, y, dy);
	}
80e25da3f642c1ec2919ca427ac3517b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|61|24|v|cpp
	(F_dydx *t_dydx, F_dfdy *t_dfdy, F_dfdx *t_dfdx,
	                        Matrix<double, N, N> t_mas, bool t_implicit,
	                        int t_lbw_jac, int t_ubw_jac, int t_lbw_mas,
	                        int t_ubw_mas, int t_m1, int t_m2, int t_idx1,
	                        int t_idx2, int t_idx3)
	    : m_dydx(t_dydx), m_dfdy(t_dfdy), m_dfdx(t_dfdx), mas(t_mas),
	      implicit(t_implicit), lbw_jac(t_lbw_jac), ubw_jac(t_ubw_jac),
	      banded(t_lbw_jac <= N - t_m1), lbw_mas(t_lbw_mas), ubw_mas(t_ubw_mas),
	      m1(t_m1), m2(t_m2), nm1(N - t_m1), idx1(t_idx1), idx2(t_idx2),
	      idx3(t_idx3) {}
	
3108f74ff4f66110aa9d01c533f4f65f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|66|1|V|cpp
	    : m_dydx(t_dydx), m_dfdy(t_dfdy), m_dfdx(t_dfdx), mas(t_mas),
	      implicit(t_implicit), lbw_jac(t_lbw_jac), ubw_jac(t_ubw_jac),
	      banded(t_lbw_jac <= N - t_m1), lbw_mas(t_lbw_mas), ubw_mas(t_ubw_mas),
	      m1(t_m1), m2(t_m2), nm1(N - t_m1), idx1(t_idx1), idx2(t_idx2),
	      idx3(t_idx3) {}
04b156636550031bf42422f31582df30|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|65|17|V|cpp
	template <int N>
	OdeSystem<N>::OdeSystem(F_dydx *t_dydx, F_dfdy *t_dfdy, F_dfdx *t_dfdx,
	                        Matrix<double, N, N> t_mas, bool t_implicit,
	                        int t_lbw_jac, int t_ubw_jac, int t_lbw_mas,
	                        int t_ubw_mas, int t_m1, int t_m2, int t_idx1,
	                        int t_idx2, int t_idx3)
	    : m_dydx(t_dydx), m_dfdy(t_dfdy), m_dfdx(t_dfdx), mas(t_mas),
	      implicit(t_implicit), lbw_jac(t_lbw_jac), ubw_jac(t_ubw_jac),
	      banded(t_lbw_jac <= N - t_m1), lbw_mas(t_lbw_mas), ubw_mas(t_ubw_mas),
	      m1(t_m1), m2(t_m2), nm1(N - t_m1), idx1(t_idx1), idx2(t_idx2),
	      idx3(t_idx3) {}
a1e44432ee0da4b8b556cd30d5525b2d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|69|1|V|cpp
	  if (m_dfdy == nullptr) {
	
	  } else {
	    (*m_dfdy)(x, y, df);
	  }
57811a6c8131e7915d6c1c3b22e1599b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|71|1|V|cpp
	template <int N>
	void OdeSystem<N>::dfdy(double x, const Vector<double, N> &y,
	                        Matrix<double, N> &df) {
	  if (m_dfdy == nullptr) {
	
	  } else {
	    (*m_dfdy)(x, y, df);
	  }
	}
a0cdab5bd525905c30871e15ee7026f5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|75|1|V|cpp
	  if (m_dfdx == nullptr) {
	    if (lbw_jac <= N - m1) {
	    }
	
	  } else {
	    (*m_dfdx)(x, y, df);
	  }
df164e6c6b20cd02ead94c513793b17e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|79|1|V|cpp
	template <int N>
	void OdeSystem<N>::dfdx(double x, const Vector<double, N> &y,
	                        Vector<double, N> &df) {
	  if (m_dfdx == nullptr) {
	    if (lbw_jac <= N - m1) {
	    }
	
	  } else {
	    (*m_dfdx)(x, y, df);
	  }
	}
5c9a33c3d50f051e020554dfa74b4f9d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|46|11|v|cpp
	lbw_jac <= N - m1) {
aca962fbe6dab6d45dfec62688bbc89e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|46|1|V|cpp
	      if (banded) {
	      }
04581e80b76a7c39f5b4363242827e30|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|11|1|V|cpp
	//===========================================================================
	//---- OdeSystem ------------------------------------------------------------
	//===========================================================================
4dd411faa7c9f3301cd48c1c9c070718|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|13|3|v|cpp
	OdeFunc<N> fcn;
7318a37f16c444260933caa8a9b53873|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|14|3|V|cpp
	  OdeJac<N> jac;
ee7810faa9b34f68d093c47216918d1b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|15|3|v|cpp
	ier = 0
	    ip(n) = 1
	    if (n == 1) go to 70
	    nm1 = n - 1
	    do k = 1, nm1
	        kp1 = k + 1
	        m = k
	        do i = kp1, n
	            if (dabs(a(i, k)) > dabs(a(m, k))) m = i
	        end do
	        ip(k) = m
	        t = a(m, k)
	        if (m == k) go to 20
	        ip(n) = -ip(n)
	        a(m, k) = a(k, k)
	        a(k, k) = t
	        20     continue
	        if (t == 0.d0) go to 80
	        t = 1.d0 / t
	        do i = kp1, n
	        a(i, k) = -a(i, k) * t
	        end do
	        do j = kp1, n
	            t = a(m, j)
	            a(m, j) = a(k, j)
	            a(k, j) = t
	            if (t == 0.d0) go to 45
	            do i = kp1, n
	            a(i, j) = a(i, j) + a(i, k) * t
	            end do
	            45       continue
	        end do
	    end do
	    70   k = n
	    if (a(n, n) == 0.d0) go to 80
	    return
	    80   ier = k
	    ip(n) = 0
	    return
	
184c9a6bd3c4fdabe4b7f1bd16867e78|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|14|8|v|cpp
	() {
	  IER = 0;
	  IP[N] = 1;
	  if (N == 1)
	    goto g70;
	  NM1 = N - 1;
	  for (K = 1; K <= NM1; K++) {
	    KP1 = K + 1;
	    M = K;
	    for (I = KP1; I <= N; I++) {
	      if (DABS(A[I, K]) > DABS(A[M, K]))
	        M = I;
	    }
	    IP[K] = M;
	    T = A[M, K];
	    if (M == K)
	      goto g20;
	    IP[N] = -IP[N];
	    A[M, K] = A[K, K];
	    A[K, K] = T;
	  g20:
	
	    if (T == 0.D0)
	      goto g80;
	    T = 1.D0 / T;
	    for (I = KP1; I <= N; I++) {
	      A[I, K] = -A[I, K] * T;
	    }
	    for (J = KP1; J <= N; J++) {
	      T = A[M, J];
	      A[M, J] = A[K, J];
	      A[K, J] = T;
	      if (T == 0.D0)
	        goto g45;
	      for (I = KP1; I <= N; I++) {
	        A[I, J] = A[I, J] + A[I, K] * T;
	      }
	    g45:
	    }
	  }
	g70:
	  K = N;
	  if (A[N, N] == 0.D0)
	    goto g80;
	  return;
	g80:
	  IER = K;
	  IP[N] = 0;
	  return;
	  // C---------------------- END OF SUBROUTINE DEC --------------------------
	}
	
0751d0748ee86e38eef594f033a23dd4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|14|14|v|cpp
	Ndim
34083247941ad9ade5dbb74e56a6ef4d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|16|3|V|cpp
	  int ier;
995b58c5c35a89a0bc5f07cc37412262|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|18|3|V|cpp
	  double a, t;
a586d47444c09580b797ce33d572b846|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|70|1|V|cpp
	      a(k, j) = t;
11473ce29a0cd5bd9248eaf0672ea953|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|21|1|V|cpp
	  // c  matrix triangularization by gaussian elimination.
bda932a68ca3a102487896e1c553f604|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|22|1|V|cpp
	  // DIMENSION a(ndim, n), ip(n)
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination.
	  // c  input..
	  // c     n = order of matrix.
	  // c     ndim = declared dimension of array  a .
	  // c     a = matrix to be triangularized.
	  // c  output..
	  // c     a(i,j), i.le.j = upper triangular factor, u .
	  // c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  sol  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
e423581b2228863c9f891298953f433f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|9|1|V|cpp
	/**
	 *  @breif  Matrix triangularization by gaussian elimination.
	 *
	 *  @param  a  Matrix to decompose
	 *  @param  ip  Vector to store pivots
	 *  @return  ier  Error code equal to zero if no error and k if matrix was
	 *  found to be singular at stage k.
	 */
	template <int ndim, int n>
ce2fed830de146375276cab83423f018|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|74|13|v|cpp
	Matrix triangularization by gaussian elimination.
05cfe908f4d3475a28e269bba3a88a80|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|76|23|v|cpp
	to decompose
2b826037f6618c35ca65849f9794c740|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|79|1|V|cpp
	 *  @return  ier  Error code equal to zero if no error and k if matrix was
	 *  found to be singular at stage k.
b099bfa9e6337073f99703c73b808e71|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|73|1|v|cpp
	/**
	 *  @breif  Solve the linear system Ax=b.
	 *
	 *  @param  a  Matrix on LHS of linear equation.
	 *  @param  b  Vector on RHS of linear equation. Stores solution on output.
	 *  @param  ip  Vector to store pivots
	 */
	template <int ndim, int n>
3af1069505bf2febda69d80002ea16ad|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|112|13|v|cpp
	Solve the linear system Ax=b.
5904bab5e90065bb2be738603b7fd614|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|114|11|v|cpp
	  a  Matrix on LHS of linear equation.
4763ff24a753bc461c9d85d20bd7d0bb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|115|11|v|cpp
	  b  Vector on RHS of linear equation. Stores solution on output.
6ec455d26fec6b10186319b88aad90c3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|116|11|v|cpp
	  ip  Vector to store pivots
6b08d1316a3139f6a8573e162ac4d1ad|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|113|1|V|cpp
	/**
	 *  @breif
	 *
	 *  @param
	 *  @param
	 *  @param
	 */
	template <int ndim, int n>
420d198d15863ec427b3aa08fe002f3a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|278|11|v|cpp
	Matrix<double,ndmi,n>&
0e579e5670069e5afff33540e6016e7c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|405|11|v|cpp
	const Matrix<double,ndim,n>&
4a407e348fac9ee6426002c2bd302d76|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|405|75|v|cpp
	Vector<double,n>&
4f005e4ddea3ff3c48ba99a6cb596f81|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1098|1|V|cpp
	  // c----------------------- end of subroutine solbc ------------------------
193cdd2762b25ee81b3c6830fb6792ac|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|471|5|v|cpp
	Matrix<double,ndim,n>&
89e33e23b0badca45309c439b2a04feb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|637|1|v|cpp
	      \n
3c87196a6c8cedd961966397fa590c76|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|726|5|V|cpp
	    \n {
2aa86f6078ba0f24c504451be120e9cf|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1014|3|V|cpp
	  // c----------------------- end of subroutine decbc ------------------------
d44ce72b21c0b8d60c5967f374b5a633|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1024|5|v|cpp
	const Matrix<double, ndim, n>&
773d57c46f42ea30c58bebca016c6b2d|file:///Users/loganmorrison/Documents/research/DarkSun/code/stiff/src/decsol.f|947|1|V|fortran
	C        interchanged in the reduction.
	C        only elements low through igh are used.
	C
	C     questions and comments should be directed to b. s. garbow,
	C     applied mathematics division, argonne national laboratory
	C
	C     ------------------------------------------------------------------
	C
	      la = igh - 1
	      kp1 = low + 1
	      if (la .lt. kp1) go to 200
	C
	      do 180 m = kp1, la
	       mm1 = m - 1
	       x = 0.0d0
	       i = m
	C
	       do 100 j = m, igh
	          if (dabs(a(j,mm1)) .le. dabs(x)) go to 100
	          x = a(j,mm1)
	          i = j
	  100   continue
	C
	       int(m) = i
	       if (i .eq. m) go to 130
	C    :::::::::: interchange rows and columns of a ::::::::::
	       do 110 j = mm1, n
	          y = a(i,j)
	          a(i,j) = a(m,j)
	          a(m,j) = y
	  110   continue
	C
	       do 120 j = 1, igh
	          y = a(j,i)
	          a(j,i) = a(j,m)
	          a(j,m) = y
	  120   continue
	C    :::::::::: end interchange ::::::::::
	  130   if (x .eq. 0.0d0) go to 180
	       mp1 = m + 1
	C
	       do 160 i = mp1, igh
	          y = a(i,mm1)
	          if (y .eq. 0.0d0) go to 160
	          y = y / x
	          a(i,mm1) = y
	C
	          do 140 j = m, n
	  140      a(i,j) = a(i,j) - y * a(m,j)
	C
	          do 150 j = 1, igh
	  150      a(j,m) = a(j,m) + y * a(j,i)
	C
	  160   continue
	C
	  180 continue
	C
	  200 return
	C    :::::::::: last card of elmhes ::::::::::
	      end
	
31faad198a3a08e8c5d9a92b777ab882|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1112|5|v|cpp
	nm, n, 
be5de871634572b04e582d33a1e35f6b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1112|46|v|cpp
	iint
d7b5c4e930e05104ffe2c540da920bae|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1112|14|v|cpp
	int igh,
8867451cbea77d16ee8460ad9f86423c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1115|3|V|cpp
	  double a(nm - 1, n - 1);
e3112fe9ba1f616ca372bbbc1b297a53|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1117|3|V|cpp
	  int int[igh];
cd47be7d7c8aab0105e876ce446ac117|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1116|3|V|cpp
	  double fabs;
1f81791e307d6e65f2bd53dffae7d299|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1207|7|V|cpp
	      // c
944ca777d03dea8e218412c55d50faa1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1208|5|V|cpp
	    // c
8d477a0d39315d1caf00539416f98f43|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1209|3|V|cpp
	  // c
cc0b1941bc1cd73f5a62db3507a69db4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1209|3|V|cpp
	  // c    :::::::::: last card of elmhes ::::::::::
52c1f97b7b7d2194252082f99873af2b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1104|1|v|cpp
	/**
	 *  @breif
	 *
	 *  @param
	 *  @param
	 *  @param
	 */
	template <int nm, int n, int igh> void elmhes(
	    int low,  Matrix<double,nm,n>&a, Vector<int,igh>&inter) {
	  // c
	  int i, j, m, la, kp1, mm1, mp1;
	  double x, y;
	  // c
	  // c     this subroutine is a translation of the algol procedure elmhes,
	  // c     num. math. 12, 349-368(1968) by martin and wilkinson.
	  // c     handbook for auto. comp., vol.ii-linear algebra, 339-358(1971).
	  // c
	  // c     given a real general matrix, this subroutine
	  // c     reduces a submatrix situated in rows and columns
	  // c     low through igh to upper hessenberg form by
	  // c     stabilized elementary similarity transformations.
	  // c
	  // c     on input:
	  // c
	  // c      nm must be set to the row dimension of two-dimensional
	  // c        array parameters as declared in the calling program
	  // c        dimension statement;
	  // c
	  // c      n is the order of the matrix;
	  // c
	  // c      low and igh are integers determined by the balancing
	  // c        subroutine  balanc.      if  balanc  has not been used,
	  // c        set low=1, igh=n;
	  // c
	  // c      a contains the input matrix.
	  // c
	  // c     on output:
	  // c
	  // c      a contains the hessenberg matrix.  the multipliers
	  // c        which were used in the reduction are stored in the
	  // c        remaining triangle under the hessenberg matrix;
	  // c
	  // c      int contains information on the rows and columns
	  // c        interchanged in the reduction.
	  // c        only elements low through igh are used.
	  // c
	  // c     questions and comments should be directed to b. s. garbow,
	  // c     applied mathematics division, argonne national laboratory
	  // c
	  // c     ------------------------------------------------------------------
	  // c
	  la = igh - 1;
	  kp1 = low + 1;
	  if (la < kp1)
	    goto g200;
	  // c
	  for (m = kp1; m <= la; m++) {
	    mm1 = m - 1;
	    x = 0.00;
	    i = m;
	    // c
	    for (j = m; j <= igh; j++) {
	      if (fabs(a(j - 1, mm1 - 1)) <= fabs(x))
	        goto g100;
	      x = a(j - 1, mm1 - 1);
	      i = j;
	    }
	    // c
	    inter[m] = i;
	    if (i == m)
	      goto g130;
	    // c    :::::::::: interchange rows and columns of a ::::::::::
	    for (j = mm1; j <= n; j++) {
	      y = a(i - 1, j - 1);
	      a(i - 1, j - 1) = a(m - 1, j - 1);
	      a(m - 1, j - 1) = y;
	    }
	    // c
	    for (j = 1; j <= igh; j++) {
	      y = a(j - 1, i - 1);
	      a(j - 1, i - 1) = a(j - 1, m - 1);
	      a(j - 1, m - 1) = y;
	    }
	    // c    :::::::::: end interchange ::::::::::
	  g130:
	    if (x == 0.00)
	      goto g180;
	    mp1 = m + 1;
	    for (i = mp1; i <= igh; i++) {
	      y = a(i - 1, mm1 - 1);
	      if (y == 0.00)
	        goto g160;
	      y = y / x;
	      a(i - 1, mm1 - 1) = y;
	      for (j = m; j <= n; j++) {
	        a(i - 1, j - 1) = a(i - 1, j - 1) - y * a(m - 1, j - 1);
	      }
	      for (j = 1; j <= igh; j++) {
	        a(j - 1, m - 1) = a(j - 1, m - 1) + y * a(j - 1, i - 1);
	      }
	    }
	  }
	g200:
	  return;
	};
	
05c617b5b13afe04857c4db054a1ceb7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|126|9|v|cpp
	matrix triangularization by gaussian elimination of a hessenberg
4d8862975b829e9ee93afc2fedfa30ca|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|126|1|V|cpp
	  // DIMENSION a(ndim, n), ip(n)
	  // c-----------------------------------------------------------------------
	  // c  matrix triangularization by gaussian elimination of a hessenberg
	  // c  matrix with lower bandwidth lb
	  // c  input..
	  // c     n = order of matrix a.
	  // c     ndim = declared dimension of array  a .
	  // c     a = matrix to be triangularized.
	  // c     lb = lower bandwidth of a (diagonal is not counted, lb.ge.1).
	  // c  output..
	  // c     a(i,j), i.le.j = upper triangular factor, u .
	  // c     a(i,j), i.gt.j = multipliers = lower triangular factor, i - l.
	  // c     ip(k), k.lt.n = index of k-th pivot row.
	  // c     ip(n) = (-1)**(number of interchanges) or o .
	  // c     ier = 0 if matrix a is nonsingular, or k if found to be
	  // c           singular at stage k.
	  // c  use  solh  to obtain solution of linear system.
	  // c  determ(a) = ip(n)*a(1,1)*a(2,2)*...*a(n,n).
	  // c  if ip(n)=o, a is singular, sol will divide by zero.
	  // c
	  // c  reference..
	  // c     this is a slight modification of
	  // c     c. b. moler, algorithm 423, linear equation solver,
	  // c     c.a.c.m. 15 (1972), p. 274.
	  // c-----------------------------------------------------------------------
e2b5837e1a833a457854bfafe4ea05fd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|190|1|V|cpp
	  // DIMENSION a(ndim, n), b(n), ip(n)
	  // c-----------------------------------------------------------------------
	  // c  solution of linear system, a*x = b .
	  // c  input..
	  // c    n = order of matrix a.
	  // c    ndim = declared dimension of array  a .
	  // c    a = triangularized matrix obtained from dech.
	  // c    lb = lower bandwidth of a.
	  // c    b = right hand side vector.
	  // c    ip = pivot vector obtained from dec.
	  // c  do not use if dech has set ier .ne. 0.
	  // c  output..
	  // c    b = solution vector, x .
	  // c-----------------------------------------------------------------------
3ca19d369567bc434a524126336fdb39|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|116|1|V|cpp
	 *  @param  a  Hessenberg matrix to decompose.
	 *  @param  lb  Lower bandwidth of a
	 *  @param  ip  Vector to store pivots
	 *  @return  ier  Error code.
ad3e8d846f40112300b145350f155f58|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|180|1|V|cpp
	 *  @param
	 *  @param
	 *  @param
196acdd2b749bee6db0f374fa90a797c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|183|2|V|cpp
	 *  @return  ier  Error code.
8e6a0a48ad8978d269868fd5cf63d9ea|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|8|1|V|cpp
	    Matrix<double, 4, 4> mat;
	    mat << 0.08823928550576365, 0.4366011322519572, 0.5757622339313386,
	        0.179505767165407, 0.36562973885367844, 0.321105147872627,
	        0.12186862579281454, 0.8441594970550272, 0.18586006125322818,
	        0.8118574391821631, 0.4318675992972878, 0.35344372941325,
	        0.646804707626244, 0.5022684089075349, 0.10875331495865792,
	        0.07588179485412039;
	    Vector<int, 4> ip;
	    Vector<double, 4> b;
	    b << 0.7238358433172154, 0.0936030851273697, 0.5932736770573785,
	        0.21736157039940096;
	
	    int ier = dec(mat, ip);
	    sol(mat, b, ip);
	
	    Vector<double, 4> mma_sol;
	    mma_sol << 0.033187565435580435, 0.1555058036297453, 1.1754306013433948,
	        -0.13233648654772068;
	
	    ASSERT_LE(abs(b(0) - mma_sol(0)) / mma_sol(0), 1e-5);
	    ASSERT_LE(abs(b(1) - mma_sol(1)) / mma_sol(1), 1e-5);
	    ASSERT_LE(abs(b(2) - mma_sol(2)) / mma_sol(2), 1e-5);
	    ASSERT_LE(abs(b(3) - mma_sol(3)) / mma_sol(3), 1e-5);
e0414f5cfd67273ff527b1f0460abd8f|file:///Users/loganmorrison/Documents/research/SUN_DM/cpp/darksun/test/test_decsol.cpp|60|1|V|cpp
	TEST(TestDecSol, TestComplex) {
	  Matrix<double, 4, 4> ar;
	  Matrix<double, 4, 4> ai;
	  ar << 0.1291187697346574, 0.5263424393544771, 0.6033308837455076,
	      0.3670062614030687, 0.9430977357532899, 0.762507230664045,
	      0.7145949345306861, 0.7770921057984113, 0.10575399094620042,
	      0.069697934573834, 0.19213265307498628, 0.38256428505406914,
	      0.9901354559781239, 0.1600746717092394, 0.6685239730157391,
	      0.6447162257110048;
	  ai << 0.5905073004715569, 0.16037802962072378, 0.2910694000563925,
	      0.4906556692388433, 0.2223786593267496, 0.20200807206507432,
	      0.8817873326905912, 0.6359933395908153, 0.7702649887998638,
	      0.8772791717741877, 0.1791398552079, 0.2291355909339532,
	      0.43150903046310596, 0.7360954415759553, 0.8697783388724507,
	      0.3125387012263443;
	  Vector<int, 4> ip;
	  Vector<double, 4> br;
	  Vector<double, 4> bi;
	  br << 0.3393423403452167, 0.20182665745670336, 0.8656865975802763,
	      0.4274080017635964;
	  bi << 0.9939971813595374, 0.029220142889758494, 0.5826103358333119,
	      0.4938184878288683;
	
	  int ier = decc(ar, ai, ip);
	  solc(ar, ai, br, bi, ip);
	
	  Vector<double, 4> mma_sol_r;
	  Vector<double, 4> mma_sol_i;
	  mma_sol_r << 0.9825944718704431, -0.1360222339605851, -0.05684072311075594,
	      0.2221481295313641;
	  mma_sol_i << -0.3247177137004772, -0.6248893625053191, 1.744544667583715,
	      -0.9225331073294023;
	
	  ASSERT_LE(abs(br(0) - mma_sol_r(0)) / mma_sol_r(0), 1e-5);
	  ASSERT_LE(abs(br(1) - mma_sol_r(1)) / mma_sol_r(1), 1e-5);
	  ASSERT_LE(abs(br(2) - mma_sol_r(2)) / mma_sol_r(2), 1e-5);
	  ASSERT_LE(abs(br(3) - mma_sol_r(3)) / mma_sol_r(3), 1e-5);
	
	  ASSERT_LE(abs(bi(0) - mma_sol_i(0)) / mma_sol_i(0), 1e-5);
	  ASSERT_LE(abs(bi(1) - mma_sol_i(1)) / mma_sol_i(1), 1e-5);
	  ASSERT_LE(abs(bi(2) - mma_sol_i(2)) / mma_sol_i(2), 1e-5);
	  ASSERT_LE(abs(bi(3) - mma_sol_i(3)) / mma_sol_i(3), 1e-5);
	}
54b53072540eeeb8f8e9343e71f28176|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|4|17|v|cpp
	system
b1b7700dbb13430b4c64b4e8360356a0|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|1|1|V|cpp
	#ifndef STIFF_RADAU5
	#define STIFF_RADAU5
	
	#include "stiff/decsol.hpp"
	#include "stiff/system.hpp"
	#include "stiff/vector_matrix.hpp"
	#include <Eigen/Dense>
	#include <functional>
	
	namespace stiff {
	
	template <int N> class Radau5 {
	public:
	  OdeSystem<N> system;
	
	  double x;            // Independent variable
	  Vector<double, N> y; // State of the system
	  double xend;
	  double h;
	  double reltol;
	  double abstol;
	
	  Radau5();
	
	private:
	};
	} // namespace stiff
	
	#endif // STIFF_RADAU5
82096b14ff810835b798f64484090c64|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1|1|V|cpp
	#ifndef STIFF_RADAU_HPP
	#define STIFF_RADAU_HPP
	
	#include "stiff/decsol.hpp"
	#include "stiff/system.hpp"
	#include "stiff/vector_matrix.hpp"
	#include <Eigen/Dense>
	#include <functional>
	
	namespace stiff {
	
	template <int N> class Radau {
	public:
	  OdeSystem<N> system;
	
	  double x;            // Independent variable
	  Vector<double, N> y; // State of the system
	  double xend;
	  double h;
	  double reltol;
	  double abstol;
	
	  Radau();
	
	private:
	};
	} // namespace stiff
	
	#endif // STIFF_RADAU_HPP
cf0db63647da954d5d727cf5206a1019|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/seulex.hpp|1|15|v|cpp
	RADAU_HPP
5a88004013a2410404d904035a9bfc95|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/seulex.hpp|1|1|V|cpp
	#ifndef STIFF_SEULEX_HPP
	#define STIFF_SEULEX_HPP
	
	#include "stiff/decsol.hpp"
	#include "stiff/system.hpp"
	#include "stiff/vector_matrix.hpp"
	#include <Eigen/Dense>
	#include <functional>
	
	namespace stiff {
	
	template <int N> class Seulex {
	public:
	  OdeSystem<N> system;
	
	  double x;            // Independent variable
	  Vector<double, N> y; // State of the system
	  double xend;
	  double h;
	  double reltol;
	  double abstol;
	
	  Seulex();
	
	private:
	};
	} // namespace stiff
	
	#endif // STIFF_SEULEX_HPP
018acc575928f521da81964792afa026|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/rodas.hpp|1|15|v|cpp
	SEULEX_HPP
febd7cf16c161a7ff5baa1676912496c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/rodas.hpp|12|24|v|cpp
	Seulex
d6c8094282a4e08a59dd1c63a67c61a1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/.gitignore|36|1|V|conf
	cmake_build_debug/**
6d252638332255edc78a943be90e5724|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|14|3|V|cpp
	  OdeSystem<N> system;
6013c7f65669607acd1535d7335b4d72|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|14|1|V|cpp
	  double x;            // Independent variable
	  Vector<double, N> y; // State of the system
	  double xend;
	  double h;
	  double reltol;
	  double abstol;
98ecb3e770ae41aa97457564ee02f7b0|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/system.hpp|16|1|V|cpp
	  using F_dydx = std::function<void(double, const Vector<double, N> &,
	                                    Vector<double, N> &)>;
	  using F_dfdy = std::function<void(double, const Vector<double, N> &,
	                                    Matrix<double, N> &)>;
	  using F_dfdx = std::function<void(double, const Vector<double, N> &,
	                                    Vector<double, N> &)>;
595e4f63ad1123a155bdd042119f936d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|12|1|V|cpp
	using F_dydx =
	    std::function<void(double, const Vector<double, N> &, Vector<double, N> &)>;
	using F_dfdy =
	    std::function<void(double, const Vector<double, N> &, Matrix<double, N> &)>;
	using F_dfdx =
	    std::function<void(double, const Vector<double, N> &, Vector<double, N> &)>;
dafa46edea897356254f57203b6698bd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|26|27|v|cpp
	xend, h, rtol, atol, itol, jac, ijac, mljac, mujac,
	            mas, imas, mlmas, mumas, solout, iout, work, lwork, iwork, liwork,
	            rpar, ipar, idid
41f397e16a9aef0d77f45a9d3007783b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|17|9|v|cpp
	F_dfdx
2b7ba9b6889575db8aa84282d5dd30f6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|17|1|V|cpp
	  using F_mas = std::function<void(double, const Vector<double, N> &,
	                                    Vector<double, N> &)>;
6d6dc49f0effa092931b17d436dff43b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|27|40|v|cpp
	, idid
df60e386b912aeea2a28439ece2727f0|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|13|1|V|cpp
	  using F_dydx = std::function<void(double, const Vector<double, N> &,
	                                    Vector<double, N> &)>;
	  using F_dfdy = std::function<void(double, const Vector<double, N> &,
	                                    Matrix<double, N> &)>;
	  using F_mas = std::function<void(double, const Vector<double, N> &,
	                                   Vector<double, N> &)>;
	  using F_solout = std::function<void(double, const Vector<double, N> &,
	                                      Vector<double, N> &)>;
2a3093d1eb9be69ab21672ab323cbc9d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|27|1|V|cpp
	  Radau5(F_dydx<N> dydx, double x, Vector<double, N> y, double xend, double h,
	         double *rtol, double *atol, int itol, F_dfdy<N> *jac, int ijac, int mljac,
	         int mujac, F_mas<N> *mas, int imas, int mlmas, int mumas,
	         F_solout<N> *solout, int iout, Vector<double> &work, int lwork,
	         Vector<int> *iwork, int liwork);
bcfd691997ac9f9ab681107333957403|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|417|1|V|cpp
	  nfcn = 0;
	  njac = 0;
	  nstep = 0;
	  naccpt = 0;
	  nrejct = 0;
	  ndec = 0;
	  nsol = 0;
	  arret = false;
	  // c -------- uround   smallest number satisfying 1.0d0+uround>1.0d0
	  if (work[1] == 0.0d0) {
	    uround = 1.0d - 16;
	  } else {
	    uround = work[1];
	    if (uround <= 1.0d - 19)
	      || (uround >= 1.0d0) {
	        printf(6, *) " coefficients have 20 digits, uround=", work[1];
	        arret = true;
	      }
	  }
	  // c -------- check and change the tolerances
	  expm = 2.0d0 / 3.0d0;
	  if (itol == 0) {
	    if (atol[1] <= 0.d0)
	      || (rtol[1] <= 10.d0 * uround) {
	        printf(6, *) " tolerances are too small";
	        arret = true;
	      }
	    else {
	      quot = atol[1] / rtol[1];
	      rtol[1] = 0.1d0 * rtol[1] * *expm;
	      atol[1] = rtol[1] * quot;
	    }
	  } else {
	    do
	      i = 1, n if (atol[i] <= 0.d0) || (rtol[i] <= 10.d0 * uround) {
	        printf(6, *) " tolerances(", i, ") are too small";
	        arret = true;
	      }
	    else {
	      quot = atol[i] / rtol[i];
	      rtol[i] = 0.1d0 * rtol[i] * *expm;
	      atol[i] = rtol[i] * quot;
	    }
	  }
	  do
	    ;
	}
	// c -------- nmax , the maximal number of steps -----
	if (iwork[2] == 0) {
	  nmax = 100000;
	} else {
	  nmax = iwork[2];
	  if (nmax <= 0) {
	    printf(6, *) " wrong input iwork[2]=", iwork[2];
	    arret = true;
	  }
	}
	// c -------- nit    maximal number of newton iterations
	if (iwork[3] == 0) {
	  nit = 7;
	} else {
	  nit = iwork[3];
	  if (nit <= 0) {
	    printf(6, *) " curious input iwork[3]=", iwork[3];
	    arret = true;
	  }
	}
	// c -------- startn  switch for starting values of newton iterations
	if (iwork[4] == 0) {
	  startn = false;
	} else {
	  startn = true;
	}
	// c -------- parameter for differential-algebraic components
	nind1 = iwork[5];
	nind2 = iwork[6];
	nind3 = iwork[7];
	if (nind1 == 0)
	  nind1 = n;
	if (nind1 + nind2 + nind3 != n) {
	  printf(6, *) " curious input for iwork[5,6,7]=", nind1, nind2, nind3;
	  arret = true;
	}
	// c -------- pred   step size control
	if (iwork[8] <= 1) {
	  pred = true;
	} else {
	  pred = false;
	}
	// c -------- parameter for second order equations
	m1 = iwork[9];
	m2 = iwork[10];
	nm1 = n - m1;
	if (m1 == 0)
	  m2 = n;
	if (m2 == 0)
	  m2 = m1;
	if (m1 < 0)
	  || (m2 < 0) || (m1 + m2 > n) {
	  printf(6, *) " curious input for iwork[9,10]=", m1, m2;
	  arret = true;
	  }
	// c --------- safe     safety factor in step size prediction
	if (work[2] == 0.0d0) {
	  safe = 0.9d0;
	} else {
	  safe = work[2];
	  if (safe <= 0.001d0)
	    || (safe >= 1.0d0) {
	      printf(6, *) " curious input for work[2]=", work[2];
	      arret = true;
	    }
	}
	// c ------ thet     decides whether the jacobian should be recomputed;
	if (work[3] == 0.d0) {
	  thet = 0.001d0;
	} else {
	  thet = work[3];
	  if (thet >= 1.0d0) {
	    printf(6, *) " curious input for work[3]=", work[3];
	    arret = true;
	  }
	}
	// c --- fnewt   stopping criterion for newton's method, usually chosen <1.
	tolst = rtol[1];
	if (work[4] == 0.d0) {
	  fnewt = max(10 * uround / tolst, min(0.03d0, tolst * *0.5d0));
	} else {
	  fnewt = work[4];
	  if (fnewt <= uround / tolst) {
	    printf(6, *) " curious input for work[4]=", work[4];
	    arret = true;
	  }
	}
	// c --- quot1 and quot2: if quot1 < hnew/hold < quot2, step size = const.
	if (work[5] == 0.d0) {
	  quot1 = 1.d0;
	} else {
	  quot1 = work[5];
	}
	if (work[6] == 0.d0) {
	  quot2 = 1.2d0;
	} else {
	  quot2 = work[6];
	}
	if (quot1 > 1.0d0)
	  || (quot2 < 1.0d0) {
	  printf(6, *) " curious input for work[5,6]=", quot1, quot2;
	  arret = true;
	  }
	// c -------- maximal step size
	if (work[7] == 0.d0) {
	  hmax = xend - x;
	} else {
	  hmax = work[7];
	}
	// c -------  facl,facr     parameters for step size selection
	if (work[8] == 0.d0) {
	  facl = 5.d0;
	} else {
	  facl = 1.d0 / work[8];
	}
	if (work[9] == 0.d0) {
	  facr = 1.d0 / 8.0d0;
	} else {
	  facr = 1.d0 / work[9];
	}
	if (facl < 1.0d0)
	  || (facr > 1.0d0) {
	  printf(6, *) " curious input work[8,9]=", work[8], work[9];
	  arret = true;
	  }
	// c *** *** *** *** *** *** *** *** *** *** *** *** ***
	// c         computation of array entries
	// c *** *** *** *** *** *** *** *** *** *** *** *** ***
	// c ---- implicit, banded or not ?
	implct = imas != 0;
	jband = mljac < nm1;
	// c -------- computation of the row-dimensions of the 2-arrays ---
	// c -- jacobian  and  matrices e1, e2
	if (jband) {
	  ldjac = mljac + mujac + 1;
	  lde1 = mljac + ldjac;
	} else {
	  mljac = nm1;
	  mujac = nm1;
	  ldjac = nm1;
	  lde1 = nm1;
	}
	// c -- mass matrix
	if (implct) {
	  if (mlmas != nm1) {
	    ldmas = mlmas + mumas + 1;
	    if (jband) {
	      ijob = 4;
	    } else {
	      ijob = 3;
	    }
	  } else {
	    mumas = nm1;
	    ldmas = nm1;
	    ijob = 5;
	  }
	  // c ------ bandwith of "mas" not smaller than bandwith of "jac"
	  if (mlmas > mljac)
	    || (mumas > mujac) {
	      printf(6, *) "bandwith of " mas " not smaller than bandwith of " jac "";
	      arret = true;
	    }
	} else {
	  ldmas = 0;
	  if (jband) {
	    ijob = 2;
	  } else {
	    ijob = 1;
	    if (n > 2)
	      &&(iwork[1] != 0) ijob = 7;
	  }
	}
	ldmas2 = max(1, ldmas);
	// c ------ hessenberg option only for explicit equ. with full jacobian
	if ((implct) || (jband))
	  &&(ijob == 7) {
	  printf(6, *) " hessenberg option only for explicit equations with full "
	               "jacobian";
	  arret = true;
	  }
	// c ------- prepare the entry-points for the arrays in work -----
	iez1 = 21;
	iez2 = iez1 + n;
	iez3 = iez2 + n;
	iey0 = iez3 + n;
	iescal = iey0 + n;
	ief1 = iescal + n;
	ief2 = ief1 + n;
	ief3 = ief2 + n;
	iecon = ief3 + n;
	iejac = iecon + 4 * n;
	iemas = iejac + n * ldjac;
	iee1 = iemas + nm1 * ldmas;
	iee2r = iee1 + nm1 * lde1;
	iee2i = iee2r + nm1 * lde1;
	// c ------ total storage requirement -----------
	istore = iee2i + nm1 * lde1 - 1;
	if (istore > lwork) {
	  printf(6, *) " insufficient storage for work, min. lwork=", istore;
	  arret = true;
	}
	// c ------- entry points for integer workspace -----
	ieip1 = 21;
	ieip2 = ieip1 + nm1;
	ieiph = ieip2 + nm1;
	// c --------- total requirement ---------------
	istore = ieiph + nm1 - 1;
	if (istore > liwork) {
	  printf(6, *) " insuff. storage for iwork, min. liwork=", istore;
	  arret = true;
	}
	// c ------ when a fail has occured, we return with idid=-1
	if (arret) {
	  idid = -1;
	  return;
	}
27acd99bebacdb38e2fd1655858116d3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|44|1|V|cpp
	  nfcn = 0;
	  njac = 0;
	  nstep = 0;
	  naccpt = 0;
	  nrejct = 0;
	  ndec = 0;
	  nsol = 0;
0ff391ea67c3d5f120c3588de8448e54|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|59|3|V|cpp
	  arret = false;
b5bc15ad2f23bb5a44895cac96266c24|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|32|10|v|cpp
	<int>
8294c98de0f6ef6861dc196715365d36|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|50|52|v|cpp
	Vector<int>
0874e518a5c77b0a63d78b33c743bdd6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|69|9|V|cpp
	        arret = true;
e99b73522c9c3b9bd8e8b714e109cf56|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|84|7|v|cpp
	i = 1, n 
991e1821e09ed639927fb8fa1c6f151d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|85|16|v|cpp
	6, *) 
6bd1c7269fe319aa514b549a42ec732c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|93|3|V|cpp
	  do
5ce970e6b69846e3ef7b705025d41f98|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|93|5|V|cpp
	    ;
d5a259d32910526aab3411c2ede2588f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|94|1|V|cpp
	// c -------- nmax , the maximal number of steps -----
bad5b43f0afd17331f883405ca09508d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|98|7|V|cpp
	      arret = true;
99ea7e8b0b39d36a384102ea98515bfc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|107|15|v|cpp
	, *)
920f01959d688e664ae95f84ac5d4321|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|126|5|V|cpp
	    arret = true;
60dace8b02f6177703f0aedbe32227cd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|170|70|v|cpp
	 * *0.50
3f9651ce6fe859eb3a1995a8abcc711a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|53|3|V|cpp
	  double qu
7d1826d8dfc7c4759db6d4be4071e536|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|253|17|v|cpp
	, *) 
0027853877679f65b5b0ffd551ae794d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|253|29|v|cpp
	"  "
1c11daafc860f5e5187b5e221908f2f9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|269|30|V|cpp
	  // c ------- prepare the entry-points for the arrays in work -----
	  iez1 = 21;
	  iez2 = iez1 + n;
	  iez3 = iez2 + n;
	  iey0 = iez3 + n;
	  iescal = iey0 + n;
	  ief1 = iescal + n;
	  ief2 = ief1 + n;
	  ief3 = ief2 + n;
	  iecon = ief3 + n;
	  iejac = iecon + 4 * n;
	  iemas = iejac + n * ldjac;
	  iee1 = iemas + nm1 * ldmas;
	  iee2r = iee1 + nm1 * lde1;
	  iee2i = iee2r + nm1 * lde1;
	  // c ------ total storage requirement -----------
	  istore = iee2i + nm1 * lde1 - 1;
	  if (istore > lwork) {
	    printf(6, *) " insufficient storage for work, min. lwork=", istore;
	    arret = true;
	  }
	  // c ------- entry points for integer workspace -----
	  ieip1 = 21;
	  ieip2 = ieip1 + nm1;
	  ieiph = ieip2 + nm1;
	  // c --------- total requirement ---------------
	  istore = ieiph + nm1 - 1;
	  if (istore > liwork) {
	    printf(6, *) " insuff. storage for iwork, min. liwork=", istore;
	    arret = true;
	  }
	  // c ------ when a fail has occured, we return with idid=-1
	  if (arret) {
	    idid = -1;
	    return;
	  }
ada4477be9433ff1280965ca60fe5752|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|42|1|V|cpp
	  double uround;
	  int nmax;
	  int nit;
	  bool startn;
	  int nind1, nind2, nind3;
	  bool pred;
	  int m1, m2, nm1;
	  double safe;
	  double thet;
	  double fnewt;
	  double quot1, quot2;
	  double hmax;
	  double facl, facr;
d664d8cdefd84eff3b69faeb407c9694|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|29|52|v|cpp
	, int itol
2b78b5f8845ad590aebc0cda038283df|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|78|35|v|cpp
	, int ijac
6511304265809a4516814b178e8b5dac|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|81|19|v|cpp
	int imas, 
f6d5e7be0e00e2e937374b02ffe3a63a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|42|1|V|cpp
	  int mljac, mujac;
73dc4158b573af9d3a607729b03ddb57|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|82|64|v|cpp
	, int iout,
ae414572a2d8af2d8f08fe5250960727|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|31|29|v|cpp
	, int iout
e9fffaf6da7d94d34e88a04bbf7f6fc4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|107|1|V|cpp
	  if (itol == 0) {
	    if ((atol[1] <= 0.0) || (rtol[1] <= 10.0 * uround)) {
	      printf(" tolerances are too small %e, %e", atol[1], rtol[1]);
	    } else {
	      double quot = atol[1] / rtol[1];
	      rtol[1] = 0.10 * pow(rtol[1], expm);
	      atol[1] = rtol[1] * quot;
	    }
	  } else {
a97db9f846b2e367a0cb34eb46663036|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|232|12|v|cpp
	imas != 0;
28d383f32c8a3bfc22e228ffef602f39|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|78|1|V|cpp
	  Vector<double,N> z1;
5a345c054b8c5b648a8e615a00e24709|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|81|1|V|cpp
	  Vector<double, N> f1;
1cc2eabdaa84a809d414dc397af5cde6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|85|1|V|cpp
	  Matrix<double> fmas;
372328d3d4e07588208835a9e88b4aa5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|88|1|V|cpp
	  Matrix<double> e2r;
1eab964d0430ae548a4f371c32f93571|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|18|22|v|cpp
	, ndim, n
40cd37bfcbeadfebf6c0bd5c6f42d7a8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|17|1|V|cpp
	template <int ndim, int n>
df347a373b8f92aa0ae3dd920a5ec2f6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|18|13|v|cpp
	rows
b686f79d268a806beb511505455b0491|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|18|1|V|cpp
	  int n = a.cols();
8ecabc98622f65a528dd403aea3dbdf5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|228|1|V|cpp
	  int n = ar.cols();
de7a27c3a2869a5f6e79273b2ab3f02b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|70|3|V|cpp
	  bool implct;
a285693f1ff3b89336038ac96d4aebcd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|70|3|V|cpp
	  bool jband;
3ce84c8546d00b88ecba5761171cb097|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|61|3|V|cpp
	  int m1, m2, nm1;
7110ece3adeb885e45257932025c5017|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|59|3|V|cpp
	  int nind1, nind2, nind3;
e68e9ebf0cdb66a00323519b6cb086e9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|67|3|V|cpp
	  int ijob;
ce30e0192a8e17b7437aa7636401c71b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|67|1|V|cpp
	  int ldjac;
	  int lde1;
	  int ldmas;
7a5f96a59c6d413fb66f92e703fb1a36|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|147|1|V|cpp
	  // c -------- parameter for differential-algebraic components
	  nind1 = iwork[5];
	  nind2 = iwork[6];
	  nind3 = iwork[7];
	  if (nind1 == 0)
	    nind1 = N;
	  if (nind1 + nind2 + nind3 != N) {
	    printf(" curious input for iwork[5,6,7]=%d,%d,%d", nind1, nind2, nind3);
	  }
fd76d505e15f3500976ea676352e0eb2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|153|1|V|cpp
	  // c -------- parameter for second order equations
	  m1 = iwork[9];
	  m2 = iwork[10];
	  nm1 = N - m1;
	  if (m1 == 0)
	    m2 = N;
	  if (m2 == 0)
	    m2 = m1;
	  if ((m1 < 0) || (m2 < 0) || (m1 + m2 > N)) {
	    printf(" curious input for iwork[9,10]=%d,%d", m1, m2);
	  }
1b81555b0cfd4d339d7c863d0110d22a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|215|1|V|cpp
	  // c *** *** *** *** *** *** *** *** *** *** *** *** ***
	  // c         computation of array entries
	  // c *** *** *** *** *** *** *** *** *** *** *** *** ***
	  // c ---- implicit, banded or not ?
	  implct = mas != nullptr;
	  jband = mljac < nm1;
	  // c -------- computation of the row-dimensions of the 2-arrays ---
	  // c -- jacobian  and  matrices e1, e2
	  if (jband) {
	    ldjac = mljac + mujac + 1;
	    lde1 = mljac + ldjac;
	  } else {
	    mljac = nm1;
	    mujac = nm1;
	    ldjac = nm1;
	    lde1 = nm1;
	  }
	  // c -- mass matrix
	  if (implct) {
	    if (mlmas != nm1) {
	      ldmas = mlmas + mumas + 1;
	      if (jband) {
	        ijob = 4;
	      } else {
	        ijob = 3;
	      }
	    } else {
	      mumas = nm1;
	      ldmas = nm1;
	      ijob = 5;
	    }
	    // c ------ bandwith of "mas" not smaller than bandwith of "jac"
	    if ((mlmas > mljac) || (mumas > mujac)) {
	      printf("bandwith of mass not smaller than bandwith of jac");
	    }
	  } else {
	    ldmas = 0;
	    if (jband) {
	      ijob = 2;
	    } else {
	      ijob = 1;
	      if ((N > 2) && (iwork[1] != 0))
	        ijob = 7;
	    }
	  }
	  int ldmas2 = std::max(1, ldmas);
	  // c ------ hessenberg option only for explicit equ. with full jacobian
	  if (((implct) || (jband)) && (ijob == 7)) {
	    printf(" hessenberg option only for explicit equations with full jacobian");
	  }
0e7060ac292e887b75570f7567ed0476|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|90|42|v|cpp
	double *work, int lwork, int *iwork,
	                  int liwork
522bb67523b23ecfff42a045f3cea46c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|89|47|v|cpp
	, int t_mlmas, int t_mumas
14bb820fb58afab3e46b0f596bc19e6e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|88|63|v|cpp
	int t_mljac
17d77cfebd05d80cb46d7dfaecd93c0a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|89|19|v|cpp
	int t_mujac, F_mas<N> *t_mas,
68fb292420b4a655bbbdbbaa689b8b1d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|89|19|v|cpp
	F_solout<N> *t_solout,)
1b357ec70fceaf88cc5b4bdc2976030d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|86|19|v|cpp
	F_dydx<N> t_dydx, double t_x, Vector<double, N> t_y,
	                  double t_xend, double t_h, Vector<double, N> t_rtol,
	                  Vector<double, N> t_atol, F_dfdy<N> *t_jac,
	                  int nmax, int nit, bool startn, bool pred, double safe,
	                  double thet, double fnewt, double quot1, double quot2,
	                  double hmax, double facl, double facr
444e934420241542228ec43ab3ab102b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|28|10|v|cpp
	F_dydx<N> dydx, double x, Vector<double, N> y, double xend, double h,
	         Vector<double, N> rtol, Vector<double, N> atol, F_dfdy<N> *jac,
	         int mljac, int mujac, F_mas<N> *mas, int mlmas, int mumas,
	         F_solout<N> *solout, double *work, int lwork, int *iwork, int liwork
429e86fade4f230284f12cd683b22cab|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|42|3|V|cpp
	  F_mas<N> *mas;
97231704c3b34acbd21914c4e3c79070|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|42|3|V|cpp
	  int mlmas, mumas;
31903f845dd2c2cb0cee4a260189c32a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|42|3|V|cpp
	  F_solout<N> *solout;
bb48521e0521043e5de5480163c6e7af|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|85|61|v|cpp
	, int t_nmax,
	                  int t_nit, bool t_startn, bool t_pred, double safe, double thet,
	                  double fnewt, double quot1, double quot2, double hmax,
	                  double facl, double facr
a9c0ac0dfb245d64243f10626254ba25|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|88|31|v|cpp
	, mljac(t_mljac), mujac(t_mujac), mas(t_mas),
	      mumas(t_mumas), mlmas(t_mlmas), solout(t_solout)
47c931c1abe48c76c35b9c0bf7d8e211|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|30|26|v|cpp
	, int nmax, int nit, bool startn, bool pred,
	         double safe, double thet, double fnewt, double quot1, double quot2,
	         double hmax, double facl, double facr
f4edab5404e39c868944fceca5592cfc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|97|1|V|cpp
	  // c -------- uround   smallest number satisfying 1.0d0+uround>1.0d0
	  if (work[1] == 0.00) {
	    uround = 1.0e-16;
	  } else {
	    uround = work[1];
	    if ((uround <= 1.0e-19) || (uround >= 1.0)) {
	      printf("coefficients have 20 digits, uround= %e", work[1]);
	    }
	  }
17983b3051d2530d0e36a721d2bf7aa3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|109|1|V|cpp
	  if (iwork[2] == 0) {
	    nmax = 100000;
	  } else {
	    nmax = iwork[2];
	    if (nmax <= 0) {
	      printf("wrong input iwork[2]=%d", iwork[2]);
	    }
	  }
e29b1054a04118a1a24f2a6fde8e3d67|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|109|1|V|cpp
	  // c -------- nit    maximal number of newton iterations
	  if (iwork[3] == 0) {
	    nit = 7;
	  } else {
	    nit = iwork[3];
	    if (nit <= 0) {
	      printf(" curious input iwork[3]=%d", iwork[3]);
	    }
	  }
7f120742af9e1d257cda779804742901|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|109|1|V|cpp
	  // c -------- startn  switch for starting values of newton iterations
	  if (iwork[4] == 0) {
	    startn = false;
	  } else {
	    startn = true;
	  }
	  // c -------- pred   step size control
	  if (iwork[8] <= 1) {
	    pred = true;
	  } else {
	    pred = false;
	  }
07d1db911ef417732f459e7ca674ca9e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|109|1|V|cpp
	  // c --------- safe     safety factor in step size prediction
	  if (work[2] == 0.00) {
	    safe = 0.90;
	  } else {
	    safe = work[2];
	    if ((safe <= 0.001) || (safe >= 1.0)) {
	      printf(" curious input for work[2]=%d", work[2]);
	    }
	  }
	  // c ------ thet     decides whether the jacobian should be recomputed;
	  if (work[3] == 0.0) {
	    thet = 0.0010;
	  } else {
	    thet = work[3];
	    if (thet >= 1.00) {
	      printf(" curious input for work[3]=%e", work[3]);
	    }
	  }
406e96c8b2c6d77bed2eb55d859016a4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|111|3|V|cpp
	  if (work[4] == 0.0) {
643e946c95d11fe7d988f1e0ee5dacd7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|112|1|V|cpp
	  } else {
	    fnewt = work[4];
	    if (fnewt <= uround / tolst) {
	      printf(" curious input for work[4]=%e", work[4]);
	    }
	  }
77970c6ca65684cf2a5916ce417e9280|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|112|1|V|cpp
	  // c --- quot1 and quot2: if quot1 < hnew/hold < quot2, step size = const.
	  if (work[5] == 0.0) {
	    quot1 = 1.0;
	  } else {
	    quot1 = work[5];
	  }
	  if (work[6] == 0.0) {
	    quot2 = 1.20;
	  } else {
	    quot2 = work[6];
	  }
	  if ((quot1 > 1.0) || (quot2 < 1.0)) {
	    printf(" curious input for work[5,6]=%e,%e", quot1, quot2);
	  }
	  // c -------- maximal step size
	  if (work[7] == 0.0) {
	    hmax = xend - x;
	  } else {
	    hmax = work[7];
	  }
	  // c -------  facl,facr     parameters for step size selection
	  if (work[8] == 0.0) {
	    facl = 5.0;
	  } else {
	    facl = 1.0 / work[8];
	  }
	  if (work[9] == 0.0) {
	    facr = 1.0 / 8.0;
	  } else {
	    facr = 1.0 / work[9];
	  }
	  if ((facl < 1.0) || (facr > 1.0)) {
	    printf(" curious input work[8,9]=%e,%e", work[8], work[9]);
	  }
52849d1081d52304a7daeca4958b6d10|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|118|1|V|cpp
	// c
	// c     end of subroutine radau5
	// c
	// c ***********************************************************
	// c
	// --------------------------------------------
8311f1365ba7b50f055f7e37e5f17a52|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|121|1|v|cpp
	void radcor(n, fcn, x, y, xend, hmax, h, rtol, atol, itol, jac, ijac, mljac,
	            mujac, mas, mlmas, mumas, solout, iout, idid, nmax, uround, safe,
	            thet, fnewt, quot1, quot2, nit, ijob, startn, nind1, nind2, nind3,
	            pred, facl, facr, m1, m2, nm1, implct, banded, ldjac, lde1, ldmas,
	            z1, z2, z3, y0, scal, f1, f2, f3, fjac, e1, e2r, e2i, fmas, ip1,
	            ip2, iphes, cont, nfcn, njac, nstep, naccpt, nrejct, ndec, nsol,
	            rpar, ipar)
8bb53d0f727e8e931de6ddf12f8c8908|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|122|1|V|cpp
	  // c ----------------------------------------------------------
	  // c     core integrator for radau5
	  // c     parameters same as in radau5 with workspace added
	  // c ----------------------------------------------------------
	  // c         declarations
	  // c ----------------------------------------------------------
	  // implicit double(a - h, o - z)
	  // DIMENSION y(n), z1(n), z2(n), z3(n), y0(n), scal(n), f1(n), f2(n), f3(n)
	  // DIMENSION fjac(ldjac, n), fmas(ldmas, nm1), cont(4*n)
	  // DIMENSION e1(lde1, nm1), e2r(lde1, nm1), e2i(lde1, nm1)
	  // DIMENSION atol(*), rtol(*), rpar(*), ipar(*)
	  int ip1[nm1], ip2[nm1], iphes[nm1];
4fc73cb1a1f1095a2774adf664bd668d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|122|1|V|cpp
	  // COMMON/conra5/nn, nn2, nn3, nn4, xsol, hsol, c2m1, c1m1
	  // COMMON/linal/mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag
768543da9ab4bf330554a5dc1eb7bc2d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|124|3|V|cpp
	  external fcn;
716dd262e40c69f6a920a4514523ab88|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|124|1|V|cpp
	  // c *** *** *** *** *** *** ***
	  // c  initialisations
	  // c *** *** *** *** *** *** ***
	  // c --------- duplify n for common block cont -----
27394a8b1714ba190991d4b0c7eccfc2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|128|1|V|cpp
	  // c -------- check the index of the problem -----
	  index1 = nind1 != 0;
	  index2 = nind2 != 0;
	  index3 = nind3 != 0;
ba8857db6786859606da719950d265b6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|128|3|V|cpp
	  // c ------- compute mass matrix for implicit case ----------
e4729abcf7c2c623171b907fba8e1813|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|128|1|V|cpp
	  if (implct)
	    call mas(nm1, fmas, ldmas, rpar, ipar);
f1a996b528b551a316d60e9fa13e3e9b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|132|3|v|cpp
	conra5
ed31799630f6398720f264d3c6c4a24d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|129|1|V|cpp
	  double sq6 = dsqrt(6.0);
	  double c1 = (4.0 - sq6) / 10.0;
	  double c2 = (4.0 + sq6) / 10.0;
	  double c1m1 = c1 - 1.0;
	  double c2m1 = c2 - 1.0;
	  double c1mc2 = c1 - c2;
	  dd1 = -(13.d0 + 7.d0 * sq6) / 3.d0;
	  dd2 = (-13.d0 + 7.d0 * sq6) / 3.d0;
	  dd3 = -1.d0 / 3.d0;
	  u1 = (6.d0 + 81.d0 * *(1.d0 / 3.d0) - 9.d0 * *(1.d0 / 3.d0)) / 30.d0;
	  alph = (12.d0 - 81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) / 60.d0;
	  beta = (81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) * dsqrt(3.d0) / 60.d0;
	  cno = alph * *2 + beta * *2;
	  u1 = 1.0d0 / u1;
	  alph = alph / cno;
	  beta = beta / cno;
	  t11 = 9.1232394870892942792d - 02;
	  t12 = -0.14125529502095420843d0;
	  t13 = -3.0029194105147424492d - 02;
	  t21 = 0.24171793270710701896d0;
	  t22 = 0.20412935229379993199d0;
	  t23 = 0.38294211275726193779d0;
	  t31 = 0.96604818261509293619d0;
	  ti11 = 4.3255798900631553510d0;
	  ti12 = 0.33919925181580986954d0;
	  ti13 = 0.54177053993587487119d0;
	  ti21 = -4.1787185915519047273d0;
	  ti22 = -0.32768282076106238708d0;
	  ti23 = 0.47662355450055045196d0;
	  ti31 = -0.50287263494578687595d0;
	  ti32 = 2.5719269498556054292d0;
	  ti33 = -0.59603920482822492497d0;
3d4a03717ae9e267c7a302d8b41b5dc6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|15|1|V|cpp
	  constexpr double sq6 = sqrt(6.0);
	  constexpr double c1 = (4.0 - sq6) / 10.0;
	  constexpr double c2 = (4.0 + sq6) / 10.0;
	  constexpr double c1m1 = c1 - 1.0;
	  constexpr double c2m1 = c2 - 1.0;
	  constexpr double c1mc2 = c1 - c2;
	  constexpr double dd1 = -(13.d0 + 7.d0 * sq6) / 3.d0;
	  constexpr double dd2 = (-13.d0 + 7.d0 * sq6) / 3.d0;
	  constexpr double dd3 = -1.d0 / 3.d0;
	  constexpr double u1 = (6.d0 + 81.d0 * *(1.d0 / 3.d0) - 9.d0 * *(1.d0 / 3.d0)) / 30.d0;
	  constexpr double alph = (12.d0 - 81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) / 60.d0;
	  constexpr double beta = (81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) * dsqrt(3.d0) / 60.d0;
	  constexpr double cno = alph * *2 + beta * *2;
	  constexpr double u1 = 1.0d0 / u1;
	  constexpr double alph = alph / cno;
	  constexpr double beta = beta / cno;
42a8de42bc7db178729cde8be4afb01e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|17|25|v|cpp
	(4.0 + sq6) / 10.0;
a3e842f033ebd373f103956534fd1cb6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|21|26|v|cpp
	-(13.d0 + 7.d0 * sq6) / 3.d0;
33c3176dc50372cac543a6368252e30e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|22|26|v|cpp
	(-13.d0 + 7.d0 * sq6) / 3.d0;
5f9241ed8982d887cdb687ea3f19d14f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|23|26|v|cpp
	-1.d0 / 3.d0;
fee01d4463a9a03e126286e498c82dc9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|24|25|v|cpp
	(6.d0 + 81.d0 * *(1.d0 / 3.d0) - 9.d0 * *(1.d0 / 3.d0)) / 30.d0;
67c0794d3c567872066d0c3c5ba929ea|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|25|27|v|cpp
	(12.d0 - 81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) / 60.d0;
f82adb786fb63fa22cf0eecd2a224055|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|26|27|v|cpp
	(81.d0 * *(1.d0 / 3.d0) + 9.d0 * *(1.d0 / 3.d0)) * dsqrt(3.d0) / 60.d0;
38ba28490e99b87110f8b9da003b5f5c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|27|26|v|cpp
	alph * *2 + beta * *2;
35477c2138ae7e04f3c26a43068d2570|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|28|3|V|cpp
	  constexpr double u1 = 1.0d0 / u1;
68b7e1d90b1a7f33945b67bbebd6980b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|28|3|V|cpp
	  constexpr double alph = alph / cno;
048edd4c1653180fa1b96557b13391b6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|28|3|V|cpp
	  constexpr double beta = beta / cno;
a657827eaef7683fd5548e665f1fc2b9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|15|3|V|cpp
	  constexpr double sq6 = sqrt(6.0);
f27410db8e80c3958d8c7dfd00e73446|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|23|1|V|cpp
	constexpr double alph = 2.6810828736277521;
f2e15696fe8091d8a41615ba961f59dc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|14|1|V|cpp
	constexpr double C1 = 0.15505102572168219;
	constexpr double C2 = 0.64494897427831781;
	constexpr double C1M1 = C1 - 1.0;
	constexpr double C2M1 = C2 - 1.0;
	constexpr double C1MC2 = C1 - C2;
	constexpr double DD1 = -10.048809399827416;
	constexpr double DD2 = 1.3821427331607489;
	constexpr double DD3 = -0.33333333333333333;
	constexpr double U1 = 3.6378342527444957;
	constexpr double ALPH = 2.6810828736277521;
	constexpr double BETA = 3.0504301992474106;
	constexpr double CNO = 0.060630570879074929;
	constexpr double T11 = 9.1232394870892942792e-2;
	constexpr double T12 = -0.14125529502095420843;
	constexpr double T13 = -3.0029194105147424492e-2;
	constexpr double T21 = 0.24171793270710701896;
	constexpr double T22 = 0.20412935229379993199;
	constexpr double T23 = 0.38294211275726193779;
	constexpr double T31 = 0.96604818261509293619;
	constexpr double TI11 = 4.3255798900631553510;
	constexpr double TI12 = 0.33919925181580986954;
	constexpr double TI13 = 0.54177053993587487119;
	constexpr double TI21 = -4.1787185915519047273;
	constexpr double TI22 = -0.32768282076106238708;
	constexpr double TI23 = 0.47662355450055045196;
	constexpr double TI31 = -0.50287263494578687595;
	constexpr double TI32 = 2.5719269498556054292;
	constexpr double TI33 = -0.59603920482822492497;
8b44871bc9f0ad096ad6c7acf60d485d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|157|1|V|cpp
	  if (m1 > 0)
	    ijob = ijob + 10;
39e28a3d0d29f968e0394d419efbe28e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|181|1|V|cpp
	  if (iout != 0) {
	    irtrn = 1;
	    nrsol = 1;
	    xosol = xold;
	    conra5.xsol = x;
	    do
	      i = 1, n cont[i] = y[i];
	  }
	  do
	    ;
7365fe2dde7b43b2509ec675f442da4e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|181|1|V|cpp
	  nsolu = n;
	  conra5.hsol = hold;
	  solout(nrsol, xosol, conra5.xsol, y, cont, lrc, nsolu, rpar, ipar, irtrn);
	  if (irtrn < 0)
	    goto g179;
	}
b09f2f717a09750e104746323f66ad0b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|181|1|V|cpp
	linal.mle = mljac;
	linal.mue = mujac;
	linal.mbjac = mljac + mujac + 1;
	linal.mbb = mlmas + mumas + 1;
	linal.mdiag = linal.mle + linal.mue + 1;
	linal.mdiff = linal.mle + linal.mue - mumas;
	linal.mbdiag = mumas + 1;
722216ca2ac136499464e6b0201a7754|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|181|1|V|cpp
	n2 = 2 * n;
	n3 = 3 * n;
cf195aa1239bcb61e3bb12226dd8c630|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|181|1|V|cpp
	if (itol == 0) {
	  do
	    i = 1, n scal[i] = atol[1] + rtol[1] * abs(y[i]);
	}
	do
	  ;
	} // namespace stiff
	else {
77ef745ed1241e0239d4657af3e1394a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|183|1|V|cpp
	}
	do
	  ;
	}
c0f505b87badcbf728487b1f53d73b1d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|183|5|V|cpp
	    i = 1, n scal[i] = atol[i] + rtol[i] * abs(y[i]);
c835608c0db8158d3c550e3a9e21b84d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|183|16|v|cpp
	, rpar, ipar
7d1758821a43c1543b59c061feec0424|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|194|1|V|cpp
	    if (banded) {
	      // c --- jacobian is banded
	      mujacp = mujac + 1;
	      md = min(linal.mbjac, m2);
	      do
	        mm = 1, m1 / m2 + 1 do k = 1, md j = k + (mm - 1) * m2;
	    g12:
	      f1[j] = y[j];
	      f2[j] = dsqrt(uround * max(1.d - 5, abs(y[j])));
	      y[j] = y[j] + f2[j];
	      j = j + md;
	      if (j <= mm * m2)
	        goto g12;
	      fcn(n, x, y, cont, rpar, ipar);
	      j = k + (mm - 1) * m2;
	      j1 = k;
	      lbeg = max(1, j1 - mujac) + m1;
	    g14:
	      lend = min(m2, j1 + mljac) + m1;
	      y[j] = f1[j];
	      mujacj = mujacp - j1 - m1;
	      do
	        l = lbeg, lend fjac[l + mujacj, j] = (cont[l] - y0[l]) / f2[j];
	    }
	    do
	      ;
11a35b9a4b2ac42d73b697714ff52682|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|232|1|V|cpp
	} // namespace stiff
d82fe6aaadfcc8280471466a2ff55f95|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|192|1|V|cpp
	  if (ijac == 0) {
	    // c --- compute jacobian matrix numerically
	    if (banded) {
	      // c --- jacobian is banded
	      mujacp = mujac + 1;
	      md = min(linal.mbjac, m2);
	      do
	        mm = 1, m1 / m2 + 1 do k = 1, md j = k + (mm - 1) * m2;
	    g12:
	      f1[j] = y[j];
	      f2[j] = dsqrt(uround * max(1.d - 5, abs(y[j])));
	      y[j] = y[j] + f2[j];
	      j = j + md;
	      if (j <= mm * m2)
	        goto g12;
	      fcn(n, x, y, cont, rpar, ipar);
	      j = k + (mm - 1) * m2;
	      j1 = k;
	      lbeg = max(1, j1 - mujac) + m1;
	    g14:
	      lend = min(m2, j1 + mljac) + m1;
	      y[j] = f1[j];
	      mujacj = mujacp - j1 - m1;
	      do
	        l = lbeg, lend fjac[l + mujacj, j] = (cont[l] - y0[l]) / f2[j];
	    }
	    do
	      ;
	
	    j = j + md;
	    j1 = j1 + md;
	    lbeg = lend + 1;
	    if (j <= mm * m2)
	      goto g14;
	  }
	  do
	    ;
	}
	do
	  ;
a1096d10331a6f75a14d6c3db0335cc9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|192|1|V|cpp
	else {
6c6acce41dbcf2abf252a27f0ba44201|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|200|2|V|cpp
	}
	do
	  ;
eac94f79e0e054f5e4ae4321186945e7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|149|1|V|cpp
	template <int N> Solution<N> Radau5<N>::integrate() {
	  bool reject, first, implct, banded, caljac, startn, calhes;
	  bool index1, index2, index3, last, pred;
	  // conra5.nn = n;
	  // conra5.nn2 = 2 * n;
	  // conra5.nn3 = 3 * n;
	  // lrc = 4 * n;
	  // c ---------- constants ---------
	  double posneg = std::copysign(1.0, xend - x);
	  double hmaxn = std::min(std::abs(hmax), std::abs(xend - x));
	  if (abs(h) <= 10.0 * uround)
	    h = 1.0e-6;
	  h = std::min(abs(h), hmaxn);
	  h = std::copysign(h, posneg);
	  double hold = h;
	  reject = false;
	  first = true;
	  last = false;
	  if ((x + h * 1.0001 - xend) * posneg >= 0.0) {
	    h = xend - x;
	    last = true;
	  }
	  double hopt = h;
	  double faccon = 1.0;
	  double cfac = safe * (1 + 2 * nit);
	  int nsing = 0;
	  double xold = x;
	
	  for (int i = 0; i < N; i++) {
	    cont[i] = y[i];
	    scal[i] = atol[i] + rtol[i] * std::abs(y[i]);
	  }
	
	  double hhfac = h;
	  dydx(x, y, y0);
	  nfcn = nfcn + 1;
	// c --- basic integration step
	g10:
	
	  // c *** *** *** *** *** *** ***
	  // c  computation of the jacobian
	  // c *** *** *** *** *** *** ***
	  njac = njac + 1;
	  // c --- jacobian is full
	  for (int i = 0; i < N; i++) {
	    double ysafe = y[i];
	    double delt = sqrt(uround * max(1.e-5, abs(ysafe)));
	    y[i] = ysafe + delt;
	    fcn(n, x, y, cont, rpar, ipar);
	    do
	      j = m1 + 1, n fjac[j - m1, i] = (cont[j] - y0[j]) / delt;
	
	    y[i] = ysafe;
	  }
	  do
	    ;
	}
	} // namespace stiff
	else {
	  // c --- compute jacobian matrix analytically
	  jac(n, x, y, fjac, ldjac, rpar, ipar);
	}
	caljac = true;
	calhes = true;
	g20 :
	
	    // c --- compute the matrices e1 and e2 and their decompositions
	    fac1 = u1 / h;
	alphn = alph / h;
	betan = beta / h;
	decomr(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, m1, m2, nm1, fac1, e1, lde1,
	       ip1, ier, ijob, calhes, iphes);
	if (ier != 0)
	  goto g78;
	decomc(n, fjac, ldjac, fmas, ldmas, mlmas, mumas, m1, m2, nm1, alphn, betan,
	       e2r, e2i, lde1, ip2, ier, ijob);
	if (ier != 0)
	  goto g78;
	ndec = ndec + 1;
	g30 :
	
	    nstep = nstep + 1;
	if (nstep > nmax)
	  goto g178;
	if (0.1d0 * abs(h) <= abs(x) * uround)
	  goto g177;
	if (index2) {
	  do
	    i = nind1 + 1, nind1 + nind2 scal[i] = scal[i] / hhfac;
	}
	do
	  ;
	}
	if (index3) {
	  do
	    i = nind1 + nind2 + 1,
	    nind1 + nind2 + nind3 scal[i] = scal[i] / (hhfac * hhfac);
	}
	do
	  ;
	}
	xph = x + h;
	// c *** *** *** *** *** *** ***
	// c  starting values for newton iteration
	// c *** *** *** *** *** *** ***
	if (first)
	  || (startn) {
	    do
	      i = 1, n z1[i] = 0.d0;
	    z2[i] = 0.d0;
	    z3[i] = 0.d0;
	    f1[i] = 0.d0;
	    f2[i] = 0.d0;
	    f3[i] = 0.d0;
	  }
	do
	  ;
	}
	else {
	  c3q = h / hold;
	  c1q = c1 * c3q;
	  c2q = c2 * c3q;
	  do
	    i = 1, n ak1 = cont[i + n];
	  ak2 = cont[i + n2];
	  ak3 = cont[i + n3];
	  z1i = c1q * (ak1 + (c1q - conra5.c2m1) * (ak2 + (c1q - conra5.c1m1) * ak3));
	  z2i = c2q * (ak1 + (c2q - conra5.c2m1) * (ak2 + (c2q - conra5.c1m1) * ak3));
	  z3i = c3q * (ak1 + (c3q - conra5.c2m1) * (ak2 + (c3q - conra5.c1m1) * ak3));
	  z1[i] = z1i;
	  z2[i] = z2i;
	  z3[i] = z3i;
	  f1[i] = ti11 * z1i + ti12 * z2i + ti13 * z3i;
	  f2[i] = ti21 * z1i + ti22 * z2i + ti23 * z3i;
	  f3[i] = ti31 * z1i + ti32 * z2i + ti33 * z3i;
	}
	do
	  ;
	}
	// c *** *** *** *** *** *** ***
	// c  loop for the simplified newton iteration
	// c *** *** *** *** *** *** ***
	newt = 0;
	faccon = max(faccon, uround) * *0.8d0;
	theta = abs(thet);
	g40 :
	
	    if (newt >= nit) goto g78;
	// c ---     compute the right-hand side
	do
	  i = 1, n cont[i] = y[i] + z1[i];
	}
	do
	  ;
	
	fcn(n, x + c1 * h, cont, z1, rpar, ipar);
	do
	  i = 1, n cont[i] = y[i] + z2[i];
	}
	do
	  ;
	
	fcn(n, x + c2 * h, cont, z2, rpar, ipar);
	do
	  i = 1, n cont[i] = y[i] + z3[i];
	}
	do
	  ;
	
	fcn(n, xph, cont, z3, rpar, ipar);
	nfcn = nfcn + 3;
	// c ---     solve the linear systems
	do
	  i = 1, n a1 = z1[i];
	a2 = z2[i];
	a3 = z3[i];
	z1[i] = ti11 * a1 + ti12 * a2 + ti13 * a3;
	z2[i] = ti21 * a1 + ti22 * a2 + ti23 * a3;
	z3[i] = ti31 * a1 + ti32 * a2 + ti33 * a3;
	}
	do
	  ;
	
	slvrad(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, m1, m2, nm1,
	       fac1, alphn, betan, e1, e2r, e2i, lde1, z1, z2, z3, f1, f2, f3, cont,
	       ip1, ip2, iphes, ier, ijob);
	nsol = nsol + 1;
	newt = newt + 1;
	dyno = 0.d0;
	do
	  i = 1, n denom = scal[i];
	dyno =
	    dyno + (z1[i] / denom) * *2 + (z2[i] / denom) * *2 + (z3[i] / denom) * *2;
	}
	do
	  ;
	
	dyno = dsqrt(dyno / n3);
	// c ---     bad convergence or number of iterations to large
	if (newt > 1)
	  &&(newt < nit) {
	    thq = dyno / dynold;
	    if (newt == 2) {
	      theta = thq;
	    } else {
	      theta = sqrt(thq * thqold);
	    }
	    thqold = thq;
	    if (theta < 0.99d0) {
	      faccon = theta / (1.0d0 - theta);
	      dyth = faccon * dyno * theta * *(nit - 1 - newt) / fnewt;
	      if (dyth >= 1.0d0) {
	        qnewt = dmax1(1.0d - 4, dmin1(20.0d0, dyth));
	        hhfac = .8d0 * qnewt * *(-1.0d0 / (4.0d0 + nit - 1 - newt));
	        h = hhfac * h;
	        reject = true;
	        last = false;
	        if (caljac)
	          goto g20;
	        goto g10;
	      }
	    } else {
	      goto g78;
	    }
	  }
	dynold = max(dyno, uround);
	do
	  i = 1, n f1i = f1[i] + z1[i];
	f2i = f2[i] + z2[i];
	f3i = f3[i] + z3[i];
	f1[i] = f1i;
	f2[i] = f2i;
	f3[i] = f3i;
	z1[i] = t11 * f1i + t12 * f2i + t13 * f3i;
	z2[i] = t21 * f1i + t22 * f2i + t23 * f3i;
	z3[i] = t31 * f1i + f2i;
	}
	do
	  ;
	
	if (faccon * dyno > fnewt)
	  goto g40;
	// c --- error estimation
	estrad(n, fjac, ldjac, mljac, mujac, fmas, ldmas, mlmas, mumas, h, dd1, dd2,
	       dd3, fcn, nfcn, y0, y, ijob, x, m1, m2, nm1, e1, lde1, z1, z2, z3, cont,
	       f1, f2, ip1, iphes, scal, err, first, reject, fac1, rpar, ipar);
	// c --- computation of hnew
	// c --- we require .2<=hnew/h<=8.
	fac = min(safe, cfac / (newt + 2 * nit));
	quot = max(facr, min(facl, err * * .25d0 / fac));
	hnew = h / quot;
	// c *** *** *** *** *** *** ***
	// c  is the error small enough ?
	// c *** *** *** *** *** *** ***
	if (err < 1.d0) {
	  // c --- step is accepted
	  first = false;
	  naccpt = naccpt + 1;
	  if (pred) {
	    // c       --- predictive controller of gustafsson
	    if (naccpt > 1) {
	      facgus = (hacc / h) * (err * *2 / erracc) * *0.25d0 / safe;
	      facgus = max(facr, min(facl, facgus));
	      quot = max(quot, facgus);
	      hnew = h / quot;
	    }
	    hacc = h;
	    erracc = max(1.0d - 2, err);
	  }
	  xold = x;
	  hold = h;
	  x = xph;
	  do
	    i = 1, n y[i] = y[i] + z3[i];
	  z2i = z2[i];
	  z1i = z1[i];
	  cont[i + n] = (z2i - z3[i]) / conra5.c2m1;
	  ak = (z1i - z2i) / c1mc2;
	  acont3 = z1i / c1;
	  acont3 = (ak - acont3) / c2;
	  cont[i + n2] = (ak - cont[i + n]) / conra5.c1m1;
	  cont[i + n3] = cont[i + n2] - acont3;
	}
	do
	  ;
	
	if (itol == 0) {
	  do
	    i = 1, n scal[i] = atol[1] + rtol[1] * abs(y[i]);
	}
	do
	  ;
	}
	else {
	  do
	    i = 1, n scal[i] = atol[i] + rtol[i] * abs(y[i]);
	}
	do
	  ;
	}
	if (iout != 0) {
	  nrsol = naccpt + 1;
	  conra5.xsol = x;
	  xosol = xold;
	  do
	    i = 1, n cont[i] = y[i];
	}
	do
	  ;
	
	nsolu = n;
	conra5.hsol = hold;
	solout(nrsol, xosol, conra5.xsol, y, cont, lrc, nsolu, rpar, ipar, irtrn);
	if (irtrn < 0)
	  goto g179;
	}
	caljac = false;
	if (last) {
	  h = hopt;
	  idid = 1;
	  return;
	}
	fcn(n, x, y, y0, rpar, ipar);
	nfcn = nfcn + 1;
	hnew = posneg * min(abs(hnew), hmaxn);
	hopt = hnew;
	hopt = min(h, hnew);
	if (reject)
	  hnew = posneg * min(abs(hnew), abs(h));
	reject = false;
	if ((x + hnew / quot1 - xend) * posneg >= 0.d0) {
	  h = xend - x;
	  last = true;
	} else {
	  qt = hnew / h;
	  hhfac = h;
	  if (theta <= thet)
	    &&(qt >= quot1) && (qt <= quot2) goto g30;
	  h = hnew;
	}
	hhfac = h;
	if (theta <= thet)
	  goto g20;
	goto g10;
	}
	else {
	  // c --- step is rejected
	  reject = true;
	  last = false;
	  if (first) {
	    h = h * 0.1d0;
	    hhfac = 0.1d0;
	  } else {
	    hhfac = hnew / h;
	    h = hnew;
	  }
	  if (naccpt >= 1)
	    nrejct = nrejct + 1;
	  if (caljac)
	    goto g20;
	  goto g10;
	}
	// c --- unexpected step-rejection
	g78 :
	
	    if (ier != 0) {
	  nsing = nsing + 1;
	  if (nsing >= 5)
	    goto g176;
	}
	h = h * 0.5d0;
	hhfac = 0.5d0;
	reject = true;
	last = false;
	if (caljac)
	  goto g20;
	goto g10;
	// c --- fail exit
	g176 :
	
	    printf(6, 979) x // format(" exit of radau5 at x=", e18.4);
	    printf(6, *) " matrix is repeatedly singular, ier=",
	    ier;
	idid = -4;
	return;
	g177 :
	
	    printf(6, 979) x // format(" exit of radau5 at x=", e18.4);
	    printf(6, *) " step size t0o small, h=",
	    h;
	idid = -3;
	return;
	g178 :
	
	    printf(6, 979) x // format(" exit of radau5 at x=", e18.4);
	    printf(6, *) " more than nmax =",
	    nmax,
	    "steps are needed";
	idid = -2;
	return;
	// c --- exit caused by solout
	g179 :
	
	    printf(6, 979) x // format(" exit of radau5 at x=", e18.4);
	
	    idid = 2;
	return;
	}
	;
	
	// c
	// c     end of subroutine radcor
	// c
	// c ***********************************************************
	// c
	// --------------------------------------------
	double unknown_retval contr5(i, x, cont, lrc);
	{
	  // c ----------------------------------------------------------
	  // c     this function can be used for coninuous output. it provides an
	  // c     approximation to the i-th component of the solution at x.
	  // c     it gives the value of the collocation polynomial, defined for
	  // c     the last successfully computed step (by radau5).
	  // c ----------------------------------------------------------
	  // implicit double(a - h, o - z)
	  // DIMENSION cont(lrc)
	  // COMMON/conra5/nn, nn2, nn3, nn4, xsol, hsol, c2m1, c1m1
	  s = (x - conra5.xsol) / conra5.hsol;
	  contr5 = cont[i] +
	           s * (cont[i + conra5.nn] +
	                (s - conra5.c2m1) * (cont[i + conra5.nn2] +
	                                     (s - conra5.c1m1) * cont[i + conra5.nn3]));
	  return;
	};
	
	// c
	// c     end of function contr5
	// c
	// c ***********************************************************
	
1c30ca0a43207d4480b29501a4d3d96d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|147|2|v|cpp
	 // namespace stiff
5f435b48a6bc4cb4832a7b98c2f7d99b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|161|1|V|cpp
	  int s_wsfe(cilist *), do_fio(int *, char *, ftnlen), e_wsfe(),
	      s_wsle(cilist *), do_lio(int *, int *, char *, ftnlen), e_wsle();
2349b86365fd0b90a01f84d6eebd4876|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|158|1|V|cpp
	  /* Builtin functions */
	  double sqrt(double), pow_dd(double *, double *), d_sign(double *, double *),
	      pow_di(double *, int *);
5e126f95c6137e85f7ee5da7d74fbb15|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|205|2|V|cpp
	  double dynold, posneg;
1bffa84a3bf32d9ba7611a2406459e6f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|196|1|V|cpp
	  bool reject;
	  double facgus;
	  int mujacp;
d55245766979c1b411f8a948e18552f1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|190|1|V|cpp
	  bool calhes;
	  double erracc;
	  int mujacj;
b7697efce2c796f58ed6ca70006a17c7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|249|18|V|cpp
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  e2i_dim1 = *lde1;
	  e2i_offset = 1 + e2i_dim1;
	  e2i -= e2i_offset;
	  e2r_dim1 = *lde1;
	  e2r_offset = 1 + e2r_dim1;
	  e2r -= e2r_offset;
	  e1_dim1 = *lde1;
	  e1_offset = 1 + e1_dim1;
	  e1 -= e1_offset;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  --rpar;
	  --ipar;
3a79319fc1cd78739078e80bea3ae6b1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|250|1|V|cpp
	  /* Function Body */
	  conra5_1.nn = *n;
	  conra5_1.nn2 = *n << 1;
	  conra5_1.nn3 = *n * 3;
	  lrc = *n << 2;
8e1f203e1569db2987b51d627bd6172e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|250|1|V|cpp
	  /* -------- CHECK THE INDEX OF THE PROBLEM ----- */
	  index1 = *nind1 != 0;
	  index2 = *nind2 != 0;
	  index3 = *nind3 != 0;
6f51a74fa263419a68d4218f28f1cc48|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|250|1|V|cpp
	  /* ------- COMPUTE MASS MATRIX FOR IMPLICIT CASE ---------- */
	  if (*implct) {
	    (*mas)(nm1, &fmas[fmas_offset], ldmas, &rpar[1], &ipar[1]);
	  }
6bf50f8d58a62a236078aac03b3fb3c7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|254|3|v|cpp
	conra5_1
357613f6c10db5dd9d8be63e35b1d1b7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|251|1|V|cpp
	  sq6 = sqrt(6.);
	  c1 = (4. - sq6) / 10.;
	  c2 = (sq6 + 4.) / 10.;
	  c1m1 = c1 - 1.;
	  c2m1 = c2 - 1.;
	  c1mc2 = c1 - c2;
	  dd1 = -(sq6 * 7. + 13.) / 3.;
	  dd2 = (sq6 * 7. - 13.) / 3.;
	  dd3 = -.33333333333333331;
	  u1 = (pow_dd(&c_b91, &c_b92) + 6. - pow_dd(&c_b93, &c_b92)) / 30.;
	  alph = (12. - pow_dd(&c_b91, &c_b92) + pow_dd(&c_b93, &c_b92)) / 60.;
	  beta = (pow_dd(&c_b91, &c_b92) + pow_dd(&c_b93, &c_b92)) * sqrt(3.) / 60.;
	  /* Computing 2nd power */
	  d__1 = alph;
	  /* Computing 2nd power */
	  d__2 = beta;
	  cno = d__1 * d__1 + d__2 * d__2;
	  u1 = 1. / u1;
	  alph /= cno;
	  beta /= cno;
	  t11 = .091232394870892942792;
	  t12 = -.14125529502095420843;
	  t13 = -.030029194105147424492;
	  t21 = .24171793270710701896;
	  t22 = .20412935229379993199;
	  t23 = .38294211275726193779;
	  t31 = .96604818261509293619;
	  ti11 = 4.325579890063155351;
	  ti12 = .33919925181580986954;
	  ti13 = .54177053993587487119;
	  ti21 = -4.1787185915519047273;
	  ti22 = -.32768282076106238708;
	  ti23 = .47662355450055045196;
	  ti31 = -.50287263494578687595;
	  ti32 = 2.5719269498556054292;
	  ti33 = -.59603920482822492497;
5923e4eed01cd95a4c82fb185a5333f9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|251|1|V|cpp
	  if (*m1 > 0) {
	    *ijob += 10;
	  }
1cfb4ff6a3b1ffc046218875fa86a9cd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|252|12|v|cpp
	d_sign
b58528ca95ac78c22d772cbf47615491|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|234|3|v|cpp
	--cont;
	  --f3;
	  --f2;
	  --f1;
	  --scal;
	  --y0;
	  --z3;
	  --z2;
	  --z1;
	  --y;
	  --rtol;
	  --atol;
	  --iphes;
	  --ip2;
	  --ip1;
	
c1ff6c52247ef1dd67736e88a04ab064|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|233|2|V|cpp
	  /* Parameter adjustments */
6c99f9f48f9e587c38e924790cbfe422|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|223|2|V|cpp
	  /* ---------------------------------------------------------- */
	  /*     CORE INTEGRATOR FOR RADAU5 */
	  /*     PARAMETERS SAME AS IN RADAU5 WITH WORKSPACE ADDED */
	  /* ---------------------------------------------------------- */
	  /*         DECLARATIONS */
	  /* ---------------------------------------------------------- */
	  /* *** *** *** *** *** *** *** */
	  /*  INITIALISATIONS */
	  /* *** *** *** *** *** *** *** */
	  /* --------- DUPLIFY N FOR COMMON BLOCK CONT ----- */
	  
4fb1a841fd4fc81b091d654ae4ffd6f5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|255|26|v|cpp
	i__1
c20551fd80d79ca9f213f22114c05027|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|255|1|V|cpp
	    for (int i = 0; i < N; i++) {
	      cont[i] = y[i];
	    }
e825a6622ec5265cd6ffa3a82364fda5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|252|1|V|cpp
	  if (iout != 0) {
	    irtrn = 1;
	    nrsol = 1;
	    xosol = xold;
	    conra5_1.xsol = *x;
	    i__1 = *n;
	    nsolu = *n;
	    conra5_1.hsol = hold;
	    (*solout)(&nrsol, &xosol, &conra5_1.xsol, &y[1], &cont[1], &lrc, &nsolu,
	              &rpar[1], &ipar[1], &irtrn);
	    if (irtrn < 0) {
	      goto L179;
	    }
	  }
dc0aea827b92f8b9be4d48f880e73844|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|252|1|V|cpp
	  linal_1.mle = *mljac;
	  linal_1.mue = *mujac;
	  linal_1.mbjac = *mljac + *mujac + 1;
	  linal_1.mbb = *mlmas + *mumas + 1;
	  linal_1.mdiag = linal_1.mle + linal_1.mue + 1;
	  linal_1.mdiff = linal_1.mle + linal_1.mue - *mumas;
	  linal_1.mbdiag = *mumas + 1;
aee4640c74da74ecafed4478394f9f79|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|261|1|V|cpp
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      scal[i__] = atol[i__] + rtol[i__] * (d__1 = y[i__], abs(d__1));
	    }
67ce937e406447efae04bebadbddd59a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|259|3|V|cpp
	  if (*itol == 0) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      scal[i__] = atol[1] + rtol[1] * (d__1 = y[i__], abs(d__1));
	    }
	  } else {
	    i__1 = *n;
	  }
aa4dc3f7acdfe05023d2a3c6270fe6f4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|261|3|v|cpp
	(*fcn)
a9ecb0678bbd409f7a8d8d9ecc93315f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|261|16|v|cpp
	, &rpar[1], &ipar[1]);
dcf1eccfd3e4ee8f67d98d75ee52e8cb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|269|7|v|cpp
	ijac
f4fb0aaec02a4f8ab3452d85a1769d5e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|271|2|v|cpp
	   if (*banded) {
	      /* --- JACOBIAN IS BANDED */
	      mujacp = *mujac + 1;
	      md = min(linal_1.mbjac, *m2);
	      i__1 = *m1 / *m2 + 1;
	      for (mm = 1; mm <= i__1; ++mm) {
	        i__2 = md;
	        for (k = 1; k <= i__2; ++k) {
	          j = k + (mm - 1) * *m2;
	        L12:
	          f1[j] = y[j];
	          /* Computing MAX */
	          d__2 = 1e-5, d__3 = (d__1 = y[j], abs(d__1));
	          f2[j] = sqrt(*uround * max(d__2, d__3));
	          y[j] += f2[j];
	          j += md;
	          if (j <= mm * *m2) {
	            goto L12;
	          }
	          (*fcn)(n, x, &y[1], &cont[1], &rpar[1], &ipar[1]);
	          j = k + (mm - 1) * *m2;
	          j1 = k;
	          /* Computing MAX */
	          i__3 = 1, i__4 = j1 - *mujac;
	          lbeg = max(i__3, i__4) + *m1;
	        L14:
	          /* Computing MIN */
	          i__3 = *m2, i__4 = j1 + *mljac;
	          lend = min(i__3, i__4) + *m1;
	          y[j] = f1[j];
	          mujacj = mujacp - j1 - *m1;
	          i__3 = lend;
	          for (l = lbeg; l <= i__3; ++l) {
	            fjac[l + mujacj + j * fjac_dim1] = (cont[l] - y0[l]) / f2[j];
	          }
	          j += md;
	          j1 += md;
	          lbeg = lend + 1;
	          if (j <= mm * *m2) {
	            goto L14;
	          }
	        }
	      }
	    }
ee4e50edc27ade5802d599f4ad25c1fd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|271|3|V|cpp
	  else {
d8c6793dd432ee77c85c3086538c9bca|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|271|5|V|cpp
	    /* --- JACOBIAN IS FULL */
a65b33324c1d08ebcdc5fe4c1f7a559a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|278|24|v|cpp
	&rpar[1], &ipar[1]);
059f302f38418b51e98547ecff14c258|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|280|17|v|cpp
	m1 + 
60fabf10aa4061303f5a388028c6686a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|280|23|v|cpp
	i__2
869722863908b2de0045421d78fdb9f3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|281|13|v|cpp
	[j - *m1 + i__ * fjac_dim1]
284960759e1eb2070b3261c4afd8c12d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|279|7|V|cpp
	      i__2 = *n;
37727948a9ad0a9788bb4a6895fe84a2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|271|5|V|cpp
	    i__1 = *n;
78449e54620def71d92d16249686ee3e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|285|5|v|cpp
	(*jac)
721704a1009c18f65f74eb1469fd4c55|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau5.hpp|285|23|v|cpp
	, ldjac, &rpar[1], &ipar[1]);
2fb416b1ead3778f599d1820a24c6b62|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|71|20|v|cpp
	U_fp
0bd0e2245b2a282f9e87606aae4ad4a3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|4|1|V|cpp
	using F_fcn =
	    std::function<void(int *, double *, double *, double *, double *, int *)>;
a9af132897b0c65a8a2cbc0b26954cce|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|6|1|V|cpp
	using F_jac = std::function<void(int *, double *, double *, double *, int *,
	                                 double *, int *)>;
044578c864b7860fd423cb116fe5f4ef|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|8|56|v|cpp
	, double *, int *
29c855053f7b2132211ca0e20d790879|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|8|1|V|cpp
	using F_mas = std::function<void(int *, double *, int *, double *, int *)>;
c1f3833a1a1705afbc6457090cc38195|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|9|34|v|cpp
	int *, double *, int *, double *, int *)>;
24aa105cad04236130c645fe925447a7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|84|1|V|cpp
	  /* Builtin functions */
	  int s_wsle(cilist *), do_lio(int *, int *, char *, ftnlen), e_wsle();
ea83a408fa0944b170b5c286ef935955|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|121|1|V|cpp
	  /* Fortran I/O blocks */
	  static cilist io___13 = {0, 6, 0, 0, 0};
	  static cilist io___15 = {0, 6, 0, 0, 0};
	  static cilist io___17 = {0, 6, 0, 0, 0};
	  static cilist io___22 = {0, 6, 0, 0, 0};
	  static cilist io___27 = {0, 6, 0, 0, 0};
	  static cilist io___29 = {0, 6, 0, 0, 0};
	  static cilist io___30 = {0, 6, 0, 0, 0};
	  static cilist io___32 = {0, 6, 0, 0, 0};
	  static cilist io___34 = {0, 6, 0, 0, 0};
	  static cilist io___36 = {0, 6, 0, 0, 0};
	  static cilist io___39 = {0, 6, 0, 0, 0};
	  static cilist io___43 = {0, 6, 0, 0, 0};
	  static cilist io___54 = {0, 6, 0, 0, 0};
	  static cilist io___56 = {0, 6, 0, 0, 0};
	  static cilist io___70 = {0, 6, 0, 0, 0};
	  static cilist io___74 = {0, 6, 0, 0, 0};
2082d048ef7fb809232fc7294aae00e6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|566|7|V|cpp
	      s_wsle(&io___13);
94671b1da19577622ad5ed82c2d98940|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|35|14|v|cmake
	Eigen3
6699a9dfafbb66208a05bd1322bd73b3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|3|10|v|cpp
	<fmt/core.h>
3bf3d7a34710e8ca41935258220e6a71|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|568|1|V|cpp
	      do_lio(&c__9, &c__1, " WRONG INPUT IWORK(13)=", (ftnlen)23);
	      do_lio(&c__3, &c__1, (char *)&iwork[13], (ftnlen)sizeof(int));
	      e_wsle();
ef2c60323579f856e61d8d20b30215aa|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|567|1|V|cpp
	      fmt::print("Wrong input: iwork(13) = {}\n", &iwork[13]);
a8d0ae802e7ad3848d630cff47cbb258|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|578|1|V|cpp
	      s_wsle(&io___15);
	      do_lio(&c__9, &c__1, " WRONG INPUT IWORK(2)=", (ftnlen)22);
	      do_lio(&c__3, &c__1, (char *)&iwork[2], (ftnlen)sizeof(int));
	      e_wsle();
8efb3540ca6d3bae65cb9e8202fa9d8b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|577|1|V|cpp
	      fmt::print("Wrong input: iwork(2) = {}\n", &iwork[2]);
e3fb91912e382b704493189bda904098|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|588|1|V|cpp
	      s_wsle(&io___17);
	      do_lio(&c__9, &c__1, " CURIOUS INPUT IWORK(3)=", (ftnlen)24);
	      do_lio(&c__3, &c__1, (char *)&iwork[3], (ftnlen)sizeof(int));
	      e_wsle();
b35e5a1e003084f6f4268ed1c8abceb5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|587|19|v|cpp
	Wrong
8a901646b4222494d18ddff36e847e96|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|587|1|V|cpp
	      fmt::print("Curious input: iwork(3) = {}\n", &iwork[3]);
6f939162ae7a9f8da551379e78bd7889|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|605|65|v|cpp
	iwork[3]);
90dc04bba541694fe968c181199c7c02|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|606|1|V|cpp
	    s_wsle(&io___22);
	    do_lio(&c__9, &c__1, " CURIOUS INPUT FOR IWORK(5,6,7)=", (ftnlen)32);
	    do_lio(&c__3, &c__1, (char *)&nind1, (ftnlen)sizeof(int));
	    do_lio(&c__3, &c__1, (char *)&nind2, (ftnlen)sizeof(int));
	    do_lio(&c__3, &c__1, (char *)&nind3, (ftnlen)sizeof(int));
	    e_wsle();
b1806a4acb6d596a6d3e6f6fb8bfcfed|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|605|1|V|cpp
	    fmt::print("Curious input: iwork(5,6,7) = {}, {}, {}\n", &nind1, &nind2,
	               &nind3);
e2db7079c538bb11264394e09eed9c1c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|626|58|v|cpp
	nind1
3710cb9113288cbc6ad8351e1005406a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|626|63|v|cpp
	nind2
31605f966d7a97f0bdc059befc9b7a8a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|627|16|V|cpp
	               &nind3);
beda65f31b11219cb9275cf7da8911a7|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|627|1|V|cpp
	    s_wsle(&io___27);
	    do_lio(&c__9, &c__1, " CURIOUS INPUT FOR IWORK(9,10)=", (ftnlen)31);
	    do_lio(&c__3, &c__1, (char *)&m1, (ftnlen)sizeof(int));
	    do_lio(&c__3, &c__1, (char *)&m2, (ftnlen)sizeof(int));
	    e_wsle();
ec59a3d5a217e986c55e8a2ff14298cc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|626|1|V|cpp
	    fmt::print("Curious input: iwork(9,10) = {}, {}\n", &m1, &m2);
18d3b44ea53cc050ad6ba5eaedfc52c5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|635|19|v|cpp
	Curious input: iwork(9,10)
4a056865f2200b1c75033ec3212d2b95|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|635|65|v|cpp
	m1, &m2);
a6f70ba098a62e118c78ddaa629ec4b8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|636|1|V|cpp
	      s_wsle(&io___29);
	      do_lio(&c__9, &c__1, " COEFFICIENTS HAVE 20 DIGITS, UROUND=", (ftnlen)37);
	      do_lio(&c__5, &c__1, (char *)&work[1], (ftnlen)sizeof(double));
	      e_wsle();
5f59916c3a58a9445279df16e295d671|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|635|1|V|cpp
	      fmt::print("Coefficients have 20 digits, uround = {}\n", &work[1]);
a15d39460e9bb5bd5def661305a8cc82|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|642|19|v|cpp
	Coefficients have 20 digits, uround = {}
125ce8514d05cf803b4b73f9771f8e2b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|642|46|v|cpp
	, &work[1]);
b3a197dd43570a8ed65fce6ccb052721|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|643|1|V|cpp
	      s_wsle(&io___30);
	      do_lio(&c__9, &c__1, " TOLERANCES ARE TOO SMALL", (ftnlen)25);
	      e_wsle();
326aa7090958c6415ce127159ad8c1c3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|642|1|V|cpp
	      fmt::print("Tolerances are too small\n");
33271f170f950c1f2dcfdd4823e9b0cd|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|651|1|V|cpp
	        do_lio(&c__9, &c__1, " TOLERANCES(", (ftnlen)12);
	        do_lio(&c__3, &c__1, (char *)&i__, (ftnlen)sizeof(int));
	        do_lio(&c__9, &c__1, ") ARE TOO SMALL", (ftnlen)15);
	        e_wsle();
d0c9a8fab1ba276cfa7798dc7cbb14ac|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|650|9|V|cpp
	        s_wsle(&io___32);
a55f73ff390488d39d0d3d18deadce78|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|649|1|V|cpp
	        fmt::print("Tolerances({}) are too small\n", i);
51d1044788a7c292d4e74c50bfc81c8d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|660|19|v|cpp
	Tolerances({}) are too small\n", i);
85eb11865df76b79c2d0086ce6fc32d8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|661|1|V|cpp
	      s_wsle(&io___34);
	      do_lio(&c__9, &c__1, " CURIOUS INPUT FOR WORK(2)=", (ftnlen)27);
	      do_lio(&c__5, &c__1, (char *)&work[2], (ftnlen)sizeof(double));
	      e_wsle();
c14b358f40787bb076cfccdcc0613348|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|660|1|V|cpp
	      fmt::print("Curious input for work(2) = {}", &work[2]);
0fc8b6aaeda0e59826899026f8f57d00|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|671|1|V|cpp
	      s_wsle(&io___36);
	      do_lio(&c__9, &c__1, " CURIOUS INPUT FOR WORK(3)=", (ftnlen)27);
	      do_lio(&c__5, &c__1, (char *)&work[3], (ftnlen)sizeof(double));
	      e_wsle();
ccc9506d33166bbc24c5ef1999e27995|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|670|1|V|cpp
	      fmt::print("Curious input for work(3) = {}", &work[3]);
4a8788d07c12cf81510afcf24b5819d4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|686|58|v|cpp
	&work[5]
3032e143b3c4885b2dc9fc56fad38460|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|687|1|V|cpp
	    s_wsle(&io___39);
	    do_lio(&c__9, &c__1, " CURIOUS INPUT FOR WORK(5,6)=", (ftnlen)29);
	    do_lio(&c__5, &c__1, (char *)&quot1, (ftnlen)sizeof(double));
	    do_lio(&c__5, &c__1, (char *)&quot2, (ftnlen)sizeof(double));
	    e_wsle();
84c280d4f5c09a0552490fe276fccd0e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|686|1|V|cpp
	    fmt::print("Curious input for work(5,6) = {}, {}", &work[5], &work[6]);
1403e31999115d7591a7f515d2e9af79|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|708|1|V|cpp
	    s_wsle(&io___43);
	    do_lio(&c__9, &c__1, " CURIOUS INPUT WORK(8,9)=", (ftnlen)25);
	    do_lio(&c__5, &c__1, (char *)&work[8], (ftnlen)sizeof(double));
	    do_lio(&c__5, &c__1, (char *)&work[9], (ftnlen)sizeof(double));
	    e_wsle();
641c916c736cbe9f1ccfdc82c6659160|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|707|1|V|cpp
	    fmt::print("Curious input for work(8,9) = {}, {}", &work[8], &work[9]);
6d2261167a5053111036f87a6717480e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|763|17|v|cpp
	Curious input for work(8,9) = {}, {}", &work[8], &work[9]);
83b3bc443d5e293b0a9dd08a373f922d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|764|1|V|cpp
	      s_wsle(&io___54);
	      do_lio(&c__9, &c__1, "BANDWITH OF \"MAS\" NOT SMALLER THAN BANDW\
	ITH OF \"JAC\"",
	             (ftnlen)52);
	      e_wsle();
99668c91250248576dd6fc6d272ff329|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|763|1|V|cpp
	      fmt::print("Bandwidth of mass not smaller than bandwidth of jac\n");
5aaa1ca5d468f90968a9bbdd1ca23e3b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|780|19|v|cpp
	Bandwidth of mass not smaller than bandwidth of jac\n");
a02ae21c671ed465f48e874b3e3dd2a1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|781|1|V|cpp
	    s_wsle(&io___56);
	    do_lio(&c__9, &c__1, " HESSENBERG OPTION ONLY FOR EXPLICIT EQUATIONS\
	 WITH FULL JACOBIAN",
	           (ftnlen)65);
	    e_wsle();
04c990931968d44fb94ad8b41ff25d4e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|780|1|V|cpp
	    fmt::print(
	        "Hessenberg option only for explicit equations with full jacobian\n");
7a9e991c55bc2c20e4b69c7a2f889d82|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|801|10|v|cpp
	Hessenberg option only for explicit equations with full jacobian\n");
8c791a742a9ca8c7606226ee045bdf82|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|802|1|V|cpp
	    s_wsle(&io___70);
	    do_lio(&c__9, &c__1,
	           " INSUFFICIENT STORAGE FOR WORK, MIN. LWORK=", (ftnlen)43);
	    do_lio(&c__3, &c__1, (char *)&istore, (ftnlen)sizeof(int));
	    e_wsle();
202bb2d44932b41a3ebdd54e0f8d4839|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|800|1|V|cpp
	    fmt::print("Insufficient storage for work, min, lwork = {}\n", &istore);
f6f0e2884208cc843dd163c965c404df|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|811|1|V|cpp
	    s_wsle(&io___74);
	    do_lio(&c__9, &c__1,
	           " INSUFF. STORAGE FOR IWORK, MIN. LIWORK=", (ftnlen)40);
	    do_lio(&c__3, &c__1, (char *)&istore, (ftnlen)sizeof(int));
	    e_wsle();
897ba41971af94bad38b568e92ac9d74|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|819|14|v|cpp
	(U_fp)
2828728297fd89fbbc5f3bdf462fadfa|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|844|21|v|cpp
	S_fp
d6c1f5606eccff7ee39ca5074aaaa5ce|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|867|1|V|cpp
	  /* Builtin functions */
	  double sqrt(double), d_sign(double *, double *), pow_dd(double *, double *),
	      pow_di(double *, int *);
	  int s_wsfe(cilist *), do_fio(int *, char *, ftnlen), e_wsfe(),
	      s_wsle(cilist *), do_lio(int *, int *, char *, ftnlen), e_wsle();
7ae6fa73526e380c60b1a3bd29c9e3df|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|943|1|V|cpp
	  /* Fortran I/O blocks */
	  static cilist io___195 = {0, 6, 0, fmt_979, 0};
	  static cilist io___196 = {0, 6, 0, 0, 0};
	  static cilist io___197 = {0, 6, 0, fmt_979, 0};
	  static cilist io___198 = {0, 6, 0, 0, 0};
	  static cilist io___199 = {0, 6, 0, fmt_979, 0};
	  static cilist io___200 = {0, 6, 0, 0, 0};
	  static cilist io___201 = {0, 6, 0, fmt_979, 0};
546ade640b6edfbc8a086ef31347e768|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|1173|36|v|cpp
	float
9db8912f3bfa09ceb21800e1afbb6058|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|1173|35|v|cpp
	(float).5;
54a2c773a6df5ea20901bb0866e339b2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|1173|35|v|cpp
	(float)
7e6eb5a05b9b93ca2941483461c85a8b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|1430|57|v|cpp
	(S_fp)
adc699fd121424f1ea8b49da7b4a316c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2224|21|V|cpp
	  s_wsfe(&io___195);
	  do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(double));
	  e_wsfe();
	  s_wsle(&io___196);
751174c6064a3604dd472e32faddfbee|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2225|1|V|cpp
	  do_lio(&c__9, &c__1, " MATRIX IS REPEATEDLY SINGULAR, IER=", (ftnlen)36);
	  do_lio(&c__3, &c__1, (char *)&ier, (ftnlen)sizeof(int));
	  e_wsle();
4e0f04f759e592329b94a2d7639a4bd4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2224|1|V|cpp
	  fmt::print("Matrix is repeatedly singular, ier = {}", &ier);
82b71a757678e58f7177785df940859b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2228|15|v|cpp
	Matrix is repeatedly singular, ier
a0cd10cc531f407dc889685a4d6dbb13|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2229|1|V|cpp
	  s_wsfe(&io___197);
	  do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(double));
	  e_wsfe();
	  s_wsle(&io___198);
	  do_lio(&c__9, &c__1, " STEP SIZE T0O SMALL, H=", (ftnlen)24);
	  do_lio(&c__5, &c__1, (char *)&(*h__), (ftnlen)sizeof(double));
	  e_wsle();
d342ccf833dc7cdba40304d482295c63|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2228|1|V|cpp
	  fmt::print("Step-size too small, h = {}", *h__);
2c7932a840d4ea0c97b53f6ac7ab15d8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2233|1|V|cpp
	  s_wsfe(&io___199);
	  do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(double));
	  e_wsfe();
	  s_wsle(&io___200);
5097dae69dd2d6049d297b2897cee614|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2232|15|v|cpp
	Step-size too small, h = {}
ae6b0017510c2de30c289534682847ab|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2233|1|V|cpp
	  do_lio(&c__9, &c__1, " MORE THAN NMAX =", (ftnlen)17);
	  do_lio(&c__3, &c__1, (char *)&(*nmax), (ftnlen)sizeof(int));
	  do_lio(&c__9, &c__1, "STEPS ARE NEEDED", (ftnlen)16);
	  e_wsle();
209264e90f8344352c44225b9c6efb9b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2232|1|V|cpp
	  fmt::print("More than {} steps are needed", *nmax);
0e99a7872aab8e7c05caaadb04c1acac|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|2237|1|V|cpp
	  s_wsfe(&io___201);
	  do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(double));
	  e_wsfe();
4ae50176ae53d5153f89f5ace10122c6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|69|1|V|cpp
	static int c__9 = 9;
	static int c__1 = 1;
	static int c__3 = 3;
	static int c__5 = 5;
41e0fb59523fe17f1decf9a1f2afd5da|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.cpp|103|1|V|cpp
	  extern int radcov(
	      int *, F_fcn *, double *, double *, double *, double *, double *,
	      double *, double *, int *, int *, F_jac *, int *, int *, int *, F_mas *,
	      int *, int *, F_sol *, int *, int *, int *, double *, double *, double *,
	      double *, double *, int *, int *, bool *, int *, int *, int *, bool *,
	      double *, double *, int *, int *, int *, int *, int *, int *, int *,
	      int *, bool *, bool *, int *, int *, int *, double *, double *, double *,
	      double *, double *, double *, double *, double *, double *, int *, int *,
	      int *, double *, double *, double *, double *, int *, int *, int *, int *,
	      int *, int *, int *, double *, int *);
e05dab063dccde49ef68d64ed6c72924|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|824|2|v|cpp
	 /* radau_ */
54590c3e383de871935f5e0a6c1408b6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|822|1|V|cpp
	  /* ----------- RETURN ----------- */
376bd81fdc1a73dc7017f62a3b97e42e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|162|47|V|cpp
	  extern int slvrai_(int *, double *, int *, int *, int *, double *, int *,
	                     int *, int *, int *, int *, int *, double *, double *,
	                     double *, double *, int *, double *, double *, double *,
	                     double *, double *, int *, int *, int *, int *),
	      coertv_(int *),
	      estrav_(int *, double *, int *, int *, int *, double *, int *, int *,
	              int *, double *, double *, F_fcn *, int *, double *, double *,
	              int *, double *, int *, int *, int *, int *, int *, double *,
	              int *, double *, double *, double *, int *, int *, double *,
	              double *, bool *, bool *, double *, double *, int *),
	      slvrar_(int *, double *, int *, int *, int *, double *, int *, int *,
	              int *, int *, int *, int *, double *, double *, int *, double *,
	              double *, int *, int *, int *, int *);
558ca798cadbf82fb7ca81e8bd348eb3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|156|3|V|cpp
	  extern int slvrad_(int *, double *, int *, int *, int *, double *, int *,
	                     int *, int *, int *, int *, int *, double *, double *,
	                     double *, double *, double *, double *, int *, double *,
	                     double *, double *, double *, double *, double *, double *,
	                     int *, int *, int *, int *, int *);
6b35b383a3b714a4a5b1866f2d95d463|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|148|45|V|cpp
	  extern int coercv_(int *, double *, double *, double *, double *, double *),
	      estrad_(int *, double *, int *, int *, int *, double *, int *, int *,
	              int *, double *, double *, double *, double *, F_fcn *, int *,
	              double *, double *, int *, double *, int *, int *, int *,
	              double *, int *, double *, double *, double *, double *, double *,
	              double *, int *, int *, double *, double *, bool *, bool *,
	              double *, double *, int *);
679c94d8f2319f53cd5f2653c3ce070e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|142|3|V|cpp
	  extern int decomr_(int *, double *, int *, double *, int *, int *, int *,
	                     int *, int *, int *, double *, double *, int *, int *,
	                     int *, int *, bool *, int *);
6f929d1030cbe10a6c48aa14fbd20dee|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|135|3|V|cpp
	  extern int decomc_(int *, double *, int *, double *, int *, int *, int *,
	                     int *, int *, int *, double *, double *, double *,
	                     double *, int *, int *, int *, int *);
48aad5fcd27380df041fe40ba5c3e34d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.cpp|19|11|V|cpp
	/* ****************************************** */
	/*     VERSION OF SEPTEMBER 18, 1995 */
	/* ****************************************** */
	
54e85fb6fe92947f53a4bdf0542e10a3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.cpp|319|1|V|cpp
	/*     END OF SUBROUTINE DECOMR */
	
	/* *********************************************************** */
a8a5f1a3daeaba9f64ff0f9f164f2038|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.cpp|1396|1|V|cpp
	/*     END OF SUBROUTINE SLVRAI */
	
	/* *********************************************************** */
0f2793ecca896e2163328d7a67d13819|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.cpp|1852|1|V|cpp
	/*     END OF SUBROUTINE SLVRAD */
	
	/* *********************************************************** */
81a0493e3da53cf851febc2ae334bc8c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.cpp|2369|1|V|cpp
	/*     END OF SUBROUTINE ESTRAD */
	
	/* *********************************************************** */
711245691e602a7d7d12426b3185d5cb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|1|1|V|cpp
	#ifndef
582b6c842bcfdad2c449a121133efb30|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|6|1|V|cpp
	using F_fcn =
	    std::function<void(int *, double *, double *, double *, double *, int *)>;
	using F_jac = std::function<void(int *, double *, double *, double *, int *,
	                                 double *, int *)>;
	using F_mas = std::function<void(int *, double *, int *, double *, int *)>;
	using F_sol = std::function<void(int *, double *, double *, double *, double *,
	                                 int *, int *, double *, int *, int *)>;
c255aa41cd1673f6c666e0f1af655525|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|10|1|V|cpp
	using OdeFun = std::function<void(double, Vector<double>
920d9ee06e88826eab0bbc313b848a28|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|6|1|V|cpp
	int dec(int *n, int *ndim, double *a, int *ip, int *ier);
	
	int sol(int *n, int *ndim, double *a, double *b, int *ip);
	int dech(int *n, int *ndim, double *a, int *lb, int *ip, int *ier);
	int solh(int *n, int *ndim, double *a, int *lb, double *b, int *ip);
	int decc(int *n, int *ndim, double *ar, double *ai, int *ip, int *ier);
	int solc(int *n, int *ndim, double *ar, double *ai, double *br, double *bi,
	         int *ip);
	int dechc(int *n, int *ndim, double *ar, double *ai, int *lb, int *ip,
	          int *ier);
	int solhc(int *n, int *ndim, double *ar, double *ai, int *lb, double *br,
	          double *bi, int *ip);
	int decb(int *n, int *ndim, double *a, int *ml, int *mu, int *ip, int *ier);
	int solb(int *n, int *ndim, double *a, int *ml, int *mu, double *b, int *ip);
	int decbc(int *n, int *ndim, double *ar, double *ai, int *ml, int *mu, int *ip,
	          int *ier);
	int solbc(int *n, int *ndim, double *ar, double *ai, int *ml, int *mu,
	          double *br, double *bi, int *ip);
	int elmhes(int *nm, int *n, int *low, int *igh, double *a, int *int__);
4580d3f9a04e71fe8f6fdff4297be66b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1438|28|V|cpp
	/*     END OF SUBROUTINE RADCOV */
	
	/* *********************************************************** */
	
54393be61d7a4b2b0596e15a1a33ca3e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1438|1|V|cpp
	int coertv_(int *nsmax) {
	  /* --- */
	  coe3_1.t311 = .09123239487089294279155;
	  coe3_1.t312 = -.141255295020954208428;
	  coe3_1.t313 = -.03002919410514742449186;
	  coe3_1.t321 = .2417179327071070189575;
	  coe3_1.t322 = .204129352293799931996;
	  coe3_1.t323 = .3829421127572619377954;
	  coe3_1.t331 = .9660481826150929361906;
	  coe3_1.ti311 = 4.325579890063155351024;
	  coe3_1.ti312 = .3391992518158098695428;
	  coe3_1.ti313 = .5417705399358748711865;
	  coe3_1.ti321 = -4.178718591551904727346;
	  coe3_1.ti322 = -.3276828207610623870825;
	  coe3_1.ti323 = .4766235545005504519601;
	  coe3_1.ti331 = -.5028726349457868759512;
	  coe3_1.ti332 = 2.571926949855605429187;
	  coe3_1.ti333 = -.5960392048282249249688;
	  if (*nsmax <= 3) {
	    return 0;
	  }
	  coe5_1.t511 = -.01251758622050104589014;
	  coe5_1.t512 = -.01024204781790882707009;
	  coe5_1.t513 = .04767387729029572386318;
	  coe5_1.t514 = -.01147851525522951470794;
	  coe5_1.t515 = -.01401985889287541028108;
	  coe5_1.t521 = -.001491670151895382429004;
	  coe5_1.t522 = .05017286451737105816299;
	  coe5_1.t523 = -.09433181918161143698066;
	  coe5_1.t524 = -.007668830749180162885157;
	  coe5_1.t525 = .02470857842651852681253;
	  coe5_1.t531 = -.07298187638808714862266;
	  coe5_1.t532 = -.2305395340434179467214;
	  coe5_1.t533 = .1027030453801258997922;
	  coe5_1.t534 = .01939846399882895091122;
	  coe5_1.t535 = .08180035370375117083639;
	  coe5_1.t541 = -.3800914400035681041264;
	  coe5_1.t542 = .3778939022488612495439;
	  coe5_1.t543 = .4667441303324943592896;
	  coe5_1.t544 = .4076011712801990666217;
	  coe5_1.t545 = .1996824278868025259365;
	  coe5_1.t551 = -.9219789736812104884883;
	  coe5_1.ti511 = -30.04156772154440162771;
	  coe5_1.ti512 = -13.86510785627141316518;
	  coe5_1.ti513 = -3.480002774795185561828;
	  coe5_1.ti514 = 1.032008797825263422771;
	  coe5_1.ti515 = -.8043030450739899174753;
	  coe5_1.ti521 = 5.344186437834911598895;
	  coe5_1.ti522 = 4.593615567759161004454;
	  coe5_1.ti523 = -3.036360323459424298646;
	  coe5_1.ti524 = 1.05066019023145886386;
	  coe5_1.ti525 = -.2727786118642962705386;
	  coe5_1.ti531 = 3.748059807439804860051;
	  coe5_1.ti532 = -3.984965736343884667252;
	  coe5_1.ti533 = -1.044415641608018792942;
	  coe5_1.ti534 = 1.184098568137948487231;
	  coe5_1.ti535 = -.4499177701567803688988;
	  coe5_1.ti541 = -33.04188021351900000806;
	  coe5_1.ti542 = -17.37695347906356701945;
	  coe5_1.ti543 = -.1721290632540055611515;
	  coe5_1.ti544 = -.09916977798254264258817;
	  coe5_1.ti545 = .5312281158383066671849;
	  coe5_1.ti551 = -8.6114439798752919777;
	  coe5_1.ti552 = 9.699991409528808231336;
	  coe5_1.ti553 = 1.914728639696874284851;
	  coe5_1.ti554 = 2.418692006084940026427;
	  coe5_1.ti555 = -1.047463487935337418694;
	  if (*nsmax <= 5) {
	    return 0;
	  }
	  coe7_1.t711 = -.002153754627310526422828;
	  coe7_1.t712 = .02156755135132077338691;
	  coe7_1.t713 = .008783567925144144407326;
	  coe7_1.t714 = -.004055161452331023898198;
	  coe7_1.t715 = .004427232753268285479678;
	  coe7_1.t716 = -.001238646187952874056377;
	  coe7_1.t717 = -.002760617480543852499548;
	  coe7_1.t721 = .001600025077880428526831;
	  coe7_1.t722 = -.03813164813441154669442;
	  coe7_1.t723 = -.02152556059400687552385;
	  coe7_1.t724 = .008415568276559589237177;
	  coe7_1.t725 = -.004031949570224549492304;
	  coe7_1.t726 = -6.666635339396338181761e-5;
	  coe7_1.t727 = .003185474825166209848748;
	  coe7_1.t731 = -.00405910730194768309165;
	  coe7_1.t732 = .05739650893938171539757;
	  coe7_1.t733 = .05885052920842679105612;
	  coe7_1.t734 = -.008560431061603432060177;
	  coe7_1.t735 = -.006923212665023908924141;
	  coe7_1.t736 = -.002352180982943338340535;
	  coe7_1.t737 = 4.169077725297562691409e-4;
	  coe7_1.t741 = -.01575048807937684420346;
	  coe7_1.t742 = -.03821469359696835048464;
	  coe7_1.t743 = -.1657368112729438512412;
	  coe7_1.t744 = -.03737124230238445741907;
	  coe7_1.t745 = .008239007298507719404499;
	  coe7_1.t746 = .003115071152346175252726;
	  coe7_1.t747 = .02511660491343882192836;
	  coe7_1.t751 = -.1129776610242208076086;
	  coe7_1.t752 = -.2491742124652636863308;
	  coe7_1.t753 = .2735633057986623212132;
	  coe7_1.t754 = .005366761379181770094279;
	  coe7_1.t755 = .1932111161012620144312;
	  coe7_1.t756 = .1017177324817151468081;
	  coe7_1.t757 = .09504502035604622821039;
	  coe7_1.t761 = -.4583810431839315010281;
	  coe7_1.t762 = .5315846490836284292051;
	  coe7_1.t763 = .4863228366175728940567;
	  coe7_1.t764 = .5265742264584492629141;
	  coe7_1.t765 = .2755343949896258141929;
	  coe7_1.t766 = .5217519452747652852946;
	  coe7_1.t767 = .1280719446355438944141;
	  coe7_1.t771 = -.8813915783538183763135;
	  coe7_1.ti711 = -258.1319263199822292761;
	  coe7_1.ti712 = -189.073763081398508952;
	  coe7_1.ti713 = -49.08731481793013119445;
	  coe7_1.ti714 = -4.110647469661428418112;
	  coe7_1.ti715 = -4.053447889315563304175;
	  coe7_1.ti716 = 3.112755366607346076554;
	  coe7_1.ti717 = -1.646774913558444650169;
	  coe7_1.ti721 = -3.007390169451292131731;
	  coe7_1.ti722 = -11.01586607876577132911;
	  coe7_1.ti723 = 1.487799456131656281486;
	  coe7_1.ti724 = 2.130388159559282459432;
	  coe7_1.ti725 = -1.816141086817565624822;
	  coe7_1.ti726 = 1.134325587895161100083;
	  coe7_1.ti727 = -.414699045943303531993;
	  coe7_1.ti731 = -8.441963188321084681757;
	  coe7_1.ti732 = -.6505252740575150028169;
	  coe7_1.ti733 = 6.940670730369876478804;
	  coe7_1.ti734 = -3.205047525597898431565;
	  coe7_1.ti735 = 1.071280943546478589783;
	  coe7_1.ti736 = -.354850749121622187973;
	  coe7_1.ti737 = .09198549132786554154409;
	  coe7_1.ti741 = 74.67833223502269977153;
	  coe7_1.ti742 = 87.40858897990081640204;
	  coe7_1.ti743 = 4.024158737379997877014;
	  coe7_1.ti744 = -3.714806315158364186639;
	  coe7_1.ti745 = -3.430093985982317350741;
	  coe7_1.ti746 = 2.696604809765312378853;
	  coe7_1.ti747 = -.9386927436075461933568;
	  coe7_1.ti751 = 58.35652885190657724237;
	  coe7_1.ti752 = -10.06877395780018096325;
	  coe7_1.ti753 = -30.36638884256667120811;
	  coe7_1.ti754 = -1.020020865184865985027;
	  coe7_1.ti755 = -.1124175003784249621267;
	  coe7_1.ti756 = 1.8906408310003776228;
	  coe7_1.ti757 = -.9716486393831482282172;
	  coe7_1.ti761 = -299.1862480282520966786;
	  coe7_1.ti762 = -243.0407453687447911819;
	  coe7_1.ti763 = -48.77710407803786921219;
	  coe7_1.ti764 = -2.03867190574193440528;
	  coe7_1.ti765 = 1.673560239861084944268;
	  coe7_1.ti766 = -1.087374032057106164456;
	  coe7_1.ti767 = .9019382492960993738427;
	  coe7_1.ti771 = -93.07650289743530591157;
	  coe7_1.ti772 = 23.88163105628114427703;
	  coe7_1.ti773 = 39.2788807308138438271;
	  coe7_1.ti774 = 14.38891568549108006988;
	  coe7_1.ti775 = -3.510438399399361221087;
	  coe7_1.ti776 = 4.863284885566180701215;
	  coe7_1.ti777 = -2.2464827295912399164;
	  return 0;
	} /* coertv_ */
de6d6657681a7861f849591a8bc5e6ad|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1603|15|V|cpp
	/*     END OF SUBROUTINE COERTV */
	
	/* *********************************************************** */
	
f41aa368a0ed64a60a73899b1527da63|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1603|1|V|cpp
	int coercv(int *ns, double *c__, double *dd, double *u1, double *alph,
	            double *beta) {
	  /* System generated locals */
	  double d__1, d__2;
	
	  /* Builtin functions */
	  double sqrt(double), pow_dd(double *, double *);
	
	  /* Local variables */
	  double sq6, st9, bet, alp, cno;
	
	  /* Parameter adjustments */
	  --beta;
	  --alph;
	  --dd;
	
	  /* Function Body */
	  c__[0] = 0.;
	  c__[*ns] = 1.;
	  switch (*ns) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L11;
	  case 3:
	    goto L3;
	  case 4:
	    goto L11;
	  case 5:
	    goto L5;
	  case 6:
	    goto L11;
	  case 7:
	    goto L7;
	  }
	L11:
	  return 0;
	L1:
	  c__[1] = 1.;
	  *u1 = 1.;
	  dd[1] = -1.;
	  return 0;
	L3:
	  sq6 = sqrt(6.);
	  c__[1] = (4. - sq6) / 10.;
	  c__[2] = (sq6 + 4.) / 10.;
	  st9 = pow_dd(&c_b140, &c_b141);
	  *u1 = (st9 * (st9 - 1) + 6.) / 30.;
	  alp = (12. - st9 * (st9 - 1)) / 60.;
	  bet = st9 * (st9 + 1) * sqrt(3.) / 60.;
	  /* Computing 2nd power */
	  d__1 = alp;
	  /* Computing 2nd power */
	  d__2 = bet;
	  cno = d__1 * d__1 + d__2 * d__2;
	  *u1 = 1. / *u1;
	  alph[1] = alp / cno;
	  beta[1] = bet / cno;
	  return 0;
	L5:
	  c__[1] = .05710419611451768219312;
	  c__[2] = .27684301363812382768;
	  c__[3] = .5835904323689168200567;
	  c__[4] = .8602401356562194478479;
	  dd[1] = -27.78093394406463730479;
	  dd[2] = 3.641478498049213152712;
	  dd[3] = -1.252547721169118720491;
	  dd[4] = .5920031671845428725662;
	  dd[5] = -.2;
	  *u1 = 6.286704751729276645173;
	  alph[1] = 3.655694325463572258243;
	  beta[1] = 6.543736899360077294021;
	  alph[2] = 5.70095329867178941917;
	  beta[2] = 3.210265600308549888425;
	  return 0;
	L7:
	  c__[1] = .02931642715978489197205;
	  c__[2] = .14807859966848429185;
	  c__[3] = .3369846902811542990971;
	  c__[4] = .5586715187715501320814;
	  c__[5] = .7692338620300545009169;
	  c__[6] = .9269456713197411148519;
	  dd[1] = -54.37443689412861451458;
	  dd[2] = 7.000024004259186512041;
	  dd[3] = -2.355661091987557192256;
	  dd[4] = 1.132289066106134386384;
	  dd[5] = -.6468913267673587118673;
	  dd[6] = .3875333853753523774248;
	  dd[7] = -.1428571428571428571429;
	  *u1 = 8.936832788405216337302;
	  alph[1] = 4.378693561506806002523;
	  beta[1] = 10.16969328379501162732;
	  alph[2] = 7.141055219187640105775;
	  beta[2] = 6.623045922639275970621;
	  alph[3] = 8.511834825102945723051;
	  beta[3] = 3.281013624325058830036;
	  return 0;
	} /* coercv_ */
	
	/*     END OF SUBROUTINE COERCV */
	
	/* *********************************************************** */
	
	double contra(int *i__, double *x, double *cont, int *lrc) {
	  /* System generated locals */
	  double ret_val;
	
	  /* Local variables */
	  int k;
	  double s;
	
	  /* ---------------------------------------------------------- */
	  /*     THIS FUNCTION CAN BE USED FOR CONINUOUS OUTPUT. IT PROVIDES AN */
	  /*     APPROXIMATION TO THE I-TH COMPONENT OF THE SOLUTION AT X. */
	  /*     IT GIVES THE VALUE OF THE COLLOCATION POLYNOMIAL, DEFINED FOR */
	  /*     THE LAST SUCCESSFULLY COMPUTED STEP (BY RADAU). */
	  /* ---------------------------------------------------------- */
	  /* Parameter adjustments */
	  --cont;
	
	  /* Function Body */
	  s = (*x - weight_2.xsol) / weight_2.hsol + 1.;
	  ret_val = cont[*i__ + weight_2.ns * weight_2.nn];
	  for (k = weight_2.ns - 1; k >= 0; --k) {
	    ret_val = cont[*i__ + k * weight_2.nn] +
	              (s - weight_2.c__[weight_2.ns - k]) * ret_val;
	  }
	  return ret_val;
	} /* contra_ */
8b5e3cc3ee9877629e485b77d13cfda3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|233|3|v|cpp
	/* coertv_ */
adfebbfbd851f12abe67757aafb896db|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|26|1|V|cpp
	struct {
	  int mle, mue, mbjac, mbb, mdiag, mdiff, mbdiag;
	} linal_;
d9c224bd1ceac953910a6087771dbd2a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_decsol.cpp|19|3|v|cpp
	int ier = 
bdefd3be4ff564848514a7f7598c2174|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_decsol.cpp|20|7|v|cpp
	4, 4
bdabd1b3f713b8312e22f31e684e4a7a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_decsol.cpp|20|7|v|cpp
	&n, &ndim
ebbfaec3a19de243d283d5f4ae5c4a4c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_decsol.cpp|18|3|v|cpp
	int ier;
	  int n = 4, ndim = 4;
b6be9a90905844bf70d9edd366bf3340|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_decsol.cpp|59|8|v|cpp
	&n, &ndim, 
7523c228f2fb5572590ea59ead4110c8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.hpp|1865|1|V|cpp
	  /* Builtin functions */
	  double sqrt(double);
1c0c1c89fe7314f39e22fadced2cbf38|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|236|1|V|cpp
	  /* Builtin functions */
	  double sqrt(double), pow_dd(double *, double *);
8fe3fbb75656ee79e31fa32b4b549e34|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1726|1|v|cpp
	int radau(int *n, F_fcn *fcn, double *x, double *y, double *xend, double *h__,
	          double *rtol, double *atol, int *itol, F_jac *jac, int *ijac,
	          int *mljac, int *mujac, F_mas *mas, int *imas, int *mlmas, int *mumas,
	          F_sol *solout, int *iout, double *work, int *lwork, int *iwork,
	          int *liwork, double *rpar, int *ipar, int *idid)
8d779b01c4d4c371db70be2b633b93de|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|62|1|V|cpp
	    double eps = rpar[0];
	    dy[0] = y[1];
	    dy[1] = ((1 - y[0] * y[0]) * y[1] - y[0]) / eps;
c1f4c8ca392381a49467ec5f2ee694bb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|71|1|V|cpp
	  auto jvpol = [](int *n, double *x, double *y, double *dfy, int *ldfy,
	                  double *rpar, int *ipar) {
	    double eps = rpar[0];
	    dfy[0] = 0.0;
	    dfy[1] = (-2.0 * y[0] * y[1] - 1.0) / eps;
	    dfy[2] = 1.0;
	    dfy[3] = ((1 - y[0] * y[0])) / eps;
	  };
03b44da95df23e756b3975b4bea39900|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|84|1|V|cpp
	  auto mas = [](int *n, double *am, int *lmas, int *rpar, int *ipar) {};
e4f0aec45dfc271c230a103a9d7eee46|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|90|1|V|cpp
	  auto solout = [](int *nr, double *xold, double *x, double *y, double *cont,
	                   int *lrc, int *n, double *rpar, int *ipar, int *irtrn) {
	    double d = rpar[1];
	    double dx = rpar[2];
	    int i = *ipar;
	    double yd[2];
	    if (*nr == 1) {
	      d = *xold;
	    }
	    while ((*xold <= d) && (*x >= d)) {
	      // int len = *ipar;
	      yd[0] = contra(1, d, cont, lrc);
	      yd[1] = contra(2, d, cont, lrc);
	      rpar[3 + i * 3 + 0] = d;
	      rpar[3 + i * 3 + 1] = yd[0];
	      rpar[3 + i * 3 + 2] = yd[1];
	
	      d += dx;
	      i += 1;
	    }
	    rpar[1] = d;
	    *ipar = i;
	  };
d1d95ed51710c2156f342166670974b4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|331|1|V|cpp
	double contra(int *i__, double *x, double *cont, int *lrc) {
3ba0acfd64a95b484219693f9705b0ce|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|50|3|V|cpp
	  double contra(int *i__, double *x, double *cont, int *lrc) {
8a5db0165c66e4d59d76eb2e589f1ff8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|16|1|V|cpp
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
5961835e224eeec99d6583fb59a2bc0b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|8|1|V|cpp
	  int n = 2;
a956aeaa06ea171876e88d676c039959|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|26|1|V|cpp
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
0424792bacea01c9a00c068a3f67c7db|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|25|1|V|cpp
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-9;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	  int ipar = 0;
	
	  double xstart = 0.0;
	  double xend = 2.0;
	  double y[2];
	  y[0] = 2.0;
	  y[1] = -0.66;
	
	  constexpr int num_xs = 41;
	  std::array<double, 3 + 3 * num_xs> rpar;
	  rpar[0] = 1e-6;
	  rpar[1] = xstart;
	  rpar[2] = (xend - xstart) / double(num_xs - 1);
653ab248b6204fbab6a23b9609863788|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|119|1|V|cpp
	  radau(nd, vdpol, xstart, y, xend, h, rtol, atol, jvpol, ijac, mljac, mujac,
	        mas, imas, mlmas, mumas, solout, iout, work.data(), iwork.data(),
	        rpar.data(), &ipar, &idid);
bb59df1183565cbbf2aa50c5b11e93a6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|89|1|V|cpp
	  int radau(int *n, F_fcn *fcn, double *x, double *y, double *xend, double *h__,
	            double *rtol, double *atol, int *itol, F_jac *jac, int *ijac,
	            int *mljac, int *mujac, F_mas *mas, int *imas, int *mlmas,
	            int *mumas, F_sol *solout, int *iout, double *work, int *lwork,
	            int *iwork, int *liwork, double *rpar, int *ipar, int *idid);
0cb90ad58b0bfb0d41434b60cff4e1e3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1726|1|V|cpp
	int radau(int *n, F_fcn *fcn, double *x, double *y, double *xend, double *h__,
	          double *rtol, double *atol, int *itol, F_jac *jac, int *ijac,
	          int *mljac, int *mujac, F_mas *mas, int *imas, int *mlmas, int *mumas,
	          F_sol *solout, int *iout, double *work, int *lwork, int *iwork,
	          int *liwork, double *rpar, int *ipar, int *idid) {
81080df1f6a69e7ef5dc78558212af4f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|474|5|v|cpp
	(*mas)
19bcbb8ff561d4276bc4da5f339f7f95|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|124|1|V|cpp
	  rpar[3 + (num_xs - 1) * 3 + 0] = xend;
	  rpar[3 + (num_xs - 1) * 3 + 1] = y[0];
	  rpar[3 + (num_xs - 1) * 3 + 2] = y[1];
42b3b4423e3f2e5f7b77e3f7b45f7f3f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|123|1|V|cpp
	  // Save final solution
9a85c2fb1fece1be22c7dfa5db3acb6a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|175|1|V|cpp
	  for (size_t i = 0; i < num_xs; i++) {
	    fmt::print("x = {}, y = ({}, {})\n", rpar[3 + 3 * i + 0],
	               rpar[3 + 3 * i + 1], rpar[3 + 3 * i + 2]);
	    //    if (mma[i][0] != 0.0) {
	    //      ASSERT_LE(abs((mma[i][0] - sol.xs[i]) / mma[i][0]), 1e-5);
	    //    }
	    //    ASSERT_LE(abs((mma[i][1] - sol.ys[i](0)) / mma[i][1]), 1e-4);
	    //    ASSERT_LE(abs((mma[i][2] - sol.ys[i](1)) / mma[i][2]), 1e-4);
	  }
246f17f30cdad8aacd03bdfc0e69c973|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|107|1|V|cpp
	  // int radau(int *n, F_fcn *fcn, double *x, double *y, double *xend, double
	  // *h__,
	  //          double *rtol, double *atol, int *itol, F_jac *jac, int *ijac,
	  //          int *mljac, int *mujac, F_mas *mas, int *imas, int *mlmas, int
	  //          *mumas, F_sol *solout, int *iout, double *work, int *lwork, int
	  //          *iwork, int *liwork, double *rpar, int *ipar, int *idid) {
468e5b183252004c60e9699bada83bd8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|132|1|V|cpp
	  std::vector<std::vector<double>> mma{
	      {0., 2., -0.66},
	      {0.05, 1.9661892484754215, -0.6860638715110897},
	      {0.1, 1.9313610478721095, -0.7074178507553899},
	      {0.15000000000000002, 1.8954088384677206, -0.7310918015640505},
	      {0.2, 1.8582056276363659, -0.7575455973910044},
	      {0.25, 1.8195979561669557, -0.7873851758826808},
	      {0.30000000000000004, 1.7793974167757798, -0.8214160097192423},
	      {0.35000000000000003, 1.7373683162108742, -0.8607441151327514},
	      {0.4, 1.6932090256578511, -0.9069350923615699},
	      {0.45, 1.6465226506589787, -0.9622955673428706},
	      {0.5, 1.5967684573030676, -1.0303919311654355},
	      {0.55, 1.543175413976293, -1.117116105141874},
	      {0.6000000000000001, 1.4845750932363537, -1.2330713461728815},
	      {0.65, 1.4190350204854123, -1.399907588330944},
	      {0.7000000000000001, 1.342890898941202, -1.6715916588912154},
	      {0.75, 1.2472019295857966, -2.2451024277919465},
	      {0.8, 1.0839201216017382, -6.195465640457782},
	      {0.8500000000000001, -1.971118662159346, 0.6831570250070442},
	      {0.9, -1.936443129338714, 0.7042090923029367},
	      {0.9500000000000001, -1.9006600748947884, 0.7275230893444639},
	      {1., -1.8636457734095244, 0.7535434289873758},
	      {1.05, -1.8252510347857684, 0.7828513484575084},
	      {1.1, -1.7852931284223588, 0.8162189064954589},
	      {1.1500000000000001, -1.7435441383035513, 0.8547008616567286},
	      {1.2000000000000002, -1.6997134197726316, 0.8997826986496342},
	      {1.25, -1.6534202018998279, 0.9536402719476197},
	      {1.3, -1.6041486131673408, 1.0196113464070558},
	      {1.35, -1.5511684254192748, 1.1031511437264612},
	      {1.4000000000000001, -1.4933841570646318, 1.2139377356322454},
	      {1.4500000000000002, -1.4290107372008636, 1.3713136172955742},
	      {1.5, -1.3547447410455409, 1.6217935234704024},
	      {1.55, -1.2629136764948916, 2.122693038582543},
	      {1.6, -1.1208100241551344, 4.373902091600681},
	      {1.6500000000000001, 1.976027273175076, -0.6802900790098091},
	      {1.7000000000000002, 1.9415022557335877, -0.7010472435573056},
	      {1.75, 1.9058857983366582, -0.7240101812979894},
	      {1.8, 1.8690573261425005, -0.7496089960511384},
	      {1.85, 1.8308717492878046, -0.7784013725146435},
	      {1.9000000000000001, 1.791151777035892, -0.8111271853438429},
	      {1.9500000000000002, 1.7496769138953059, -0.8487931530970122},
	      {2., 1.706166942293804, -0.8928105392359631}};
c8ac01ab565397f29d458a3f0952ebc5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_radau.cpp|128|1|V|cpp
	  //=========================================================================
	  //---- Mathematica Solution -----------------------------------------------
	  //=========================================================================
ec0bc77c90978c02498939d3cc86473d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|146|42|v|cpp
	rpar[3 + 3 * i + 0]
ec63119f100d16ca94c7d60060478d0d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|148|16|v|cpp
	rpar[3 + 3 * i + 1]
2579acdb2deb6265e97bb4c8887af98d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|146|1|V|cpp
	    double y = rpar[3 + 3 * i + 1];
b64119a65daaef6b905d0cac1aae7962|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|148|42|v|cpp
	rpar[3 + 3 * i + 0],
ed952c57a05b69316be92f30a6db0410|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|149|16|V|cpp
	               rpar[3 + 3 * i + 1], rpar[3 + 3 * i + 2]);
0b1ec7b88152af1070d2d98f7a75899f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|153|32|v|cpp
	sol.ys[i](1)
21645daa6780e2793534b98a0391a9e2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|63|39|v|cpp
	lmas
c434a40267391f8744f55a4e006d4e0a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|65|67|v|cpp
	irtrn
0dd180f642a883b46273ac53c65a2760|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1730|24|v|cpp
	double *rpar, int *ipar, 
6c40f72fbbf3f25db4de64cfcdf5d439|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1773|1|V|cpp
	  --rpar;
	  --ipar;
739df46b2abcafe0a59c1d652c3b9c07|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|2078|42|v|cpp
	&rpar[1], &ipar[1]
2385af184ee0a8e5193d739aac6422fa|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|471|39|v|cpp
	, &rpar[1], &ipar[1]
7dddcb345a6963008ea46864a2fc6f22|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/function.hpp|12|34|v|cpp
	double *, int *
1b04ff1f5384a5250d50e3bbf2092855|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|542|12|v|cpp
	&rpar[1], &ipar[1], 
1126db7d15623ebfaf1cbf43c9d06f26|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1131|80|v|cpp
	,
	             &rpar[1], &ipar[1]
4bd494021e15bf360fb120a7072f1f75|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/radau.hpp|1257|49|v|cpp
	 &rpar[1], &ipar[1]
f9df4fbfe9a4a7adff4fd38f34b0b62f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.hpp|2373|24|v|cpp
	, double *rpar, int *ipar
f820466d90a487927b384f7191709f10|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/dc_decsol.hpp|1858|78|v|cpp
	,
	           double *rpar, int *ipar
bbf96a2e053457f58657a11894179206|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|48|3|v|cpp
	rpar[2]
ace48be5c22da9ce9e935cd403dd45e8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|66|5|V|cpp
	    double dx = rpar[2];
f587569991171b083e895e87d3fb1a59|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|66|5|V|cpp
	    double d = rpar[1];
5f10fe5ab8f39b5f20991fadfbb9e83f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|83|5|V|cpp
	    rpar[1] = d;
58304e07f1d8036bf32d54b4faf956be|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|44|22|v|cpp
	3 + 
17e9335845923b6c9cf2dd709731e6cf|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|46|1|V|cpp
	  rpar[0] = 1e-6;
	  rpar[1] = xstart;
2e30869fbda9f5f94059d6111c19d08a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|85|38|v|cpp
	, rpar.data(), &ipar
de1ad37ccf52b2d779a8c6f976dc11cb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|53|68|v|cpp
	, double *,
	                     int *
6838c2862df9d49666abf95adf0a8497|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|51|3|V|cpp
	  std::array<double, 3 * num_xs> sol;
30c41898d21e7247636c9df0dedc81f6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|78|14|v|cpp
	 * 3 + 0
1a3725eedabcd369901a50d9ca670902|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|79|15|v|cpp
	* 3 + 1
93e75489c318b1b5686ff85d5cb44ba2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|80|14|v|cpp
	 * 3 + 2
2e9aeba59e36d51f76a2eed118de349e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/test/test_radau5.cpp|92|21|v|cpp
	 * 3 + 1
40e565c287917419ef603d481d6cdb26|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|10|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION. */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*     A = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U . */
	  /*     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N). */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], abs(d__1)) >
	          (d__2 = a[m + k * a_dim1], abs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    t = a[m + k * a_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[k + k * a_dim1];
	    a[k + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      t = a[m + j * a_dim1];
	      a[m + j * a_dim1] = a[k + j * a_dim1];
	      a[k + j * a_dim1] = t;
	      if (t == 0.) {
	        goto L45;
	      }
	      i__3 = *n;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        /* L40: */
	        a[i__ + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if (a[*n + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DEC ------------------------- */
	} /* dec_ */
0dfc5e92d28648c37bade5353628d87a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|12|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, km1, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*    A = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    B = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L10: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    b[k] /= a[k + k * a_dim1];
	    t = -b[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L30: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[a_dim1 + 1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOL ------------------------- */
	} /* sol_ */
fe888f6ca46ee21b34c9b26b7f40fe69|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|14|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int na, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION OF A HESSENBERG */
	  /*  MATRIX WITH LOWER BANDWIDTH LB */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX A. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*     A = MATRIX TO BE TRIANGULARIZED. */
	  /*     LB = LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED, LB.GE.1). */
	  /*  OUTPUT.. */
	  /*     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U . */
	  /*     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOLH  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N). */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A SLIGHT MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    /* Computing MIN */
	    i__2 = *n, i__3 = *lb + k;
	    na = std::min(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], abs(d__1)) >
	          (d__2 = a[m + k * a_dim1], abs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    t = a[m + k * a_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[k + k * a_dim1];
	    a[k + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      t = a[m + j * a_dim1];
	      a[m + j * a_dim1] = a[k + j * a_dim1];
	      a[k + j * a_dim1] = t;
	      if (t == 0.) {
	        goto L45;
	      }
	      i__3 = na;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        /* L40: */
	        a[i__ + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if (a[*n + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECH ------------------------ */
	} /* dech_ */
8515783ef70b2654903238ba9fbb3a58|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|16|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, na, km1, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX A. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*    A = TRIANGULARIZED MATRIX OBTAINED FROM DECH. */
	  /*    LB = LOWER BANDWIDTH OF A. */
	  /*    B = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DECH HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    /* Computing MIN */
	    i__2 = *n, i__3 = *lb + k;
	    na = std::min(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      /* L10: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    b[k] /= a[k + k * a_dim1];
	    t = -b[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L30: */
	      b[i__] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[a_dim1 + 1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLH ------------------------ */
	} /* solh_ */
e6b935a498cdd2cd69c9e8cae59e93ec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|18|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double ti, tr;
	  int nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION */
	  /*  ------ MODIFICATION FOR COMPLEX MATRICES -------- */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI . */
	  /*     (AR, AI) = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     AR(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; REAL PART. */
	  /*     AI(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; IMAGINARY PART. */
	  /*     AR(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    REAL PART. */
	  /*     AI(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    IMAGINARY PART. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], abs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], abs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], abs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], abs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[k + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[k + k * ai_dim1];
	    ar[k + k * ar_dim1] = tr;
	    ai[k + k * ai_dim1] = ti;
	  L20:
	    if (abs(tr) + abs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      ar[m + j * ar_dim1] = ar[k + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[k + j * ai_dim1];
	      ar[k + j * ar_dim1] = tr;
	      ai[k + j * ai_dim1] = ti;
	      if (abs(tr) + abs(ti) == 0.) {
	        goto L48;
	      }
	      if (ti == 0.) {
	        i__3 = *n;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = *n;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = *n;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[i__ + j * ar_dim1] += prodr;
	        ai[i__ + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[*n + *n * ar_dim1], abs(d__1)) +
	          (d__2 = ai[*n + *n * ai_dim1], abs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECC ------------------------ */
	} /* decc_ */
7c2620b7b7ee6e9210d465e66900a168|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|21|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2;
	
	  /* Local variables */
	  int i__, k, m, kb;
	  double ti, tr;
	  int km1, nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI. */
	  /*    (AR,AI) = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    (BR,BI) = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    (BR,BI) = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    i__2 = *n;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    den = ar[k + k * ar_dim1] * ar[k + k * ar_dim1] +
	          ai[k + k * ai_dim1] * ai[k + k * ai_dim1];
	    prodr = br[k] * ar[k + k * ar_dim1] + bi[k] * ai[k + k * ai_dim1];
	    prodi = bi[k] * ar[k + k * ar_dim1] - br[k] * ai[k + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	L50:
	  den = ar[ar_dim1 + 1] * ar[ar_dim1 + 1] + ai[ai_dim1 + 1] * ai[ai_dim1 + 1];
	  prodr = br[1] * ar[ar_dim1 + 1] + bi[1] * ai[ai_dim1 + 1];
	  prodi = bi[1] * ar[ar_dim1 + 1] - br[1] * ai[ai_dim1 + 1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLC ------------------------ */
	} /* solc_ */
30ef2382fa0395ae10dae74dd5572ad8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|24|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m, na;
	  double ti, tr;
	  int nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION */
	  /*  ------ MODIFICATION FOR COMPLEX MATRICES -------- */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI . */
	  /*     (AR, AI) = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     AR(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; REAL PART. */
	  /*     AI(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; IMAGINARY PART. */
	  /*     AR(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    REAL PART. */
	  /*     AI(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    IMAGINARY PART. */
	  /*     LB = LOWER BANDWIDTH OF A (DIAGONAL NOT COUNTED), LB.GE.1. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  if (*lb == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  nm1 = *n - 1;
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    /* Computing MIN */
	    i__2 = *n, i__3 = *lb + k;
	    na = std::min(i__2, i__3);
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], abs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], abs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], abs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], abs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == k) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[k + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[k + k * ai_dim1];
	    ar[k + k * ar_dim1] = tr;
	    ai[k + k * ai_dim1] = ti;
	  L20:
	    if (abs(tr) + abs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__2 = na;
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    i__2 = *n;
	    for (j = kp1; j <= i__2; ++j) {
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      ar[m + j * ar_dim1] = ar[k + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[k + j * ai_dim1];
	      ar[k + j * ar_dim1] = tr;
	      ai[k + j * ai_dim1] = ti;
	      if (abs(tr) + abs(ti) == 0.) {
	        goto L48;
	      }
	      if (ti == 0.) {
	        i__3 = na;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = na;
	        for (i__ = kp1; i__ <= i__3; ++i__) {
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[i__ + j * ar_dim1] += prodr;
	          ai[i__ + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = na;
	      for (i__ = kp1; i__ <= i__3; ++i__) {
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[i__ + j * ar_dim1] += prodr;
	        ai[i__ + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[*n + *n * ar_dim1], abs(d__1)) +
	          (d__2 = ai[*n + *n * ai_dim1], abs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECHC ----------------------- */
	} /* dechc_ */
c289954a01c170a827bbb01269aa9844|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|27|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3, i__4;
	
	  /* Local variables */
	  int i__, k, m, kb;
	  double ti, tr;
	  int km1, nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI. */
	  /*    (AR,AI) = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    (BR,BI) = RIGHT HAND SIDE VECTOR. */
	  /*    LB = LOWER BANDWIDTH OF A. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    (BR,BI) = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  if (*n == 1) {
	    goto L50;
	  }
	  nm1 = *n - 1;
	  if (*lb == 0) {
	    goto L25;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    /* Computing MIN */
	    i__3 = *n, i__4 = *lb + k;
	    i__2 = std::min(i__3, i__4);
	    for (i__ = kp1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    km1 = *n - kb;
	    k = km1 + 1;
	    den = ar[k + k * ar_dim1] * ar[k + k * ar_dim1] +
	          ai[k + k * ai_dim1] * ai[k + k * ai_dim1];
	    prodr = br[k] * ar[k + k * ar_dim1] + bi[k] * ai[k + k * ai_dim1];
	    prodi = bi[k] * ar[k + k * ar_dim1] - br[k] * ai[k + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    i__2 = km1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[i__] += prodr;
	      bi[i__] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	L50:
	  den = ar[ar_dim1 + 1] * ar[ar_dim1 + 1] + ai[ai_dim1 + 1] * ai[ai_dim1 + 1];
	  prodr = br[1] * ar[ar_dim1 + 1] + bi[1] * ai[ai_dim1 + 1];
	  prodi = bi[1] * ar[ar_dim1 + 1] - br[1] * ai[ai_dim1 + 1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLHC ----------------------- */
	} /* solhc_ */
ef575d0e0034a239a79b97c47ec177da|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|29|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3, i__4;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, m;
	  double t;
	  int md, jk, mm, ju, md1, nm1, kp1, mdl, ijk;
	
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION OF A BANDED */
	  /*  MATRIX WITH LOWER BANDWIDTH ML AND UPPER BANDWIDTH MU */
	  /*  INPUT.. */
	  /*     N       ORDER OF THE ORIGINAL MATRIX A. */
	  /*     NDIM    DECLARED DIMENSION OF ARRAY  A. */
	  /*     A       CONTAINS THE MATRIX IN BAND STORAGE.   THE COLUMNS */
	  /*                OF THE MATRIX ARE STORED IN THE COLUMNS OF  A  AND */
	  /*                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS */
	  /*                ML+1 THROUGH 2*ML+MU+1 OF  A. */
	  /*     ML      LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*     MU      UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*  OUTPUT.. */
	  /*     A       AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
	  /*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
	  /*     IP      INDEX VECTOR OF PIVOT INDICES. */
	  /*     IP(N)   (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER     = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE */
	  /*                SINGULAR AT STAGE K. */
	  /*  USE  SOLB  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(MD,1)*A(MD,2)*...*A(MD,N)  WITH MD=ML+MU+1. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOLB WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  ju = 0;
	  if (*ml == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  if (*n < *mu + 2) {
	    goto L7;
	  }
	  i__1 = *n;
	  for (j = *mu + 2; j <= i__1; ++j) {
	    i__2 = *ml;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      /* L5: */
	      a[i__ + j * a_dim1] = 0.;
	    }
	  }
	L7:
	  nm1 = *n - 1;
	  i__2 = nm1;
	  for (k = 1; k <= i__2; ++k) {
	    kp1 = k + 1;
	    m = md;
	    /* Computing MIN */
	    i__1 = *ml, i__3 = *n - k;
	    mdl = std::min(i__1, i__3) + md;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      if ((d__1 = a[i__ + k * a_dim1], abs(d__1)) >
	          (d__2 = a[m + k * a_dim1], abs(d__2))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m + k - md;
	    t = a[m + k * a_dim1];
	    if (m == md) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    a[m + k * a_dim1] = a[md + k * a_dim1];
	    a[md + k * a_dim1] = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1. / t;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      /* L30: */
	      a[i__ + k * a_dim1] = -a[i__ + k * a_dim1] * t;
	    }
	    /* Computing MIN */
	    /* Computing MAX */
	    i__3 = ju, i__4 = *mu + ip[k];
	    i__1 = std::max(i__3, i__4);
	    ju = std::min(i__1, *n);
	    mm = md;
	    if (ju < kp1) {
	      goto L55;
	    }
	    i__1 = ju;
	    for (j = kp1; j <= i__1; ++j) {
	      --m;
	      --mm;
	      t = a[m + j * a_dim1];
	      if (m == mm) {
	        goto L35;
	      }
	      a[m + j * a_dim1] = a[mm + j * a_dim1];
	      a[mm + j * a_dim1] = t;
	    L35:
	      if (t == 0.) {
	        goto L45;
	      }
	      jk = j - k;
	      i__3 = mdl;
	      for (i__ = md1; i__ <= i__3; ++i__) {
	        ijk = i__ - jk;
	        /* L40: */
	        a[ijk + j * a_dim1] += a[i__ + k * a_dim1] * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	  L55:
	      /* L60: */
	      ;
	  }
	L70:
	  k = *n;
	  if (a[md + *n * a_dim1] == 0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECB ------------------------ */
	} /* decb_ */
94767c1e1602df40ec6182a69ad17357|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|31|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m;
	  double t;
	  int kb, md, lm, md1, nm1, imd, kmd, mdl, mdm;
	
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N      ORDER OF MATRIX A. */
	  /*    NDIM   DECLARED DIMENSION OF ARRAY  A . */
	  /*    A      TRIANGULARIZED MATRIX OBTAINED FROM DECB. */
	  /*    ML     LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    MU     UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    B      RIGHT HAND SIDE VECTOR. */
	  /*    IP     PIVOT VECTOR OBTAINED FROM DECB. */
	  /*  DO NOT USE IF DECB HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B      SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	
	  /* Function Body */
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  mdm = md - 1;
	  nm1 = *n - 1;
	  if (*ml == 0) {
	    goto L25;
	  }
	  if (*n == 1) {
	    goto L50;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    /* Computing MIN */
	    i__2 = *ml, i__3 = *n - k;
	    mdl = std::min(i__2, i__3) + md;
	    i__2 = mdl;
	    for (i__ = md1; i__ <= i__2; ++i__) {
	      imd = i__ + k - md;
	      /* L10: */
	      b[imd] += a[i__ + k * a_dim1] * t;
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    k = *n + 1 - kb;
	    b[k] /= a[md + k * a_dim1];
	    t = -b[k];
	    kmd = md - k;
	    /* Computing MAX */
	    i__2 = 1, i__3 = kmd + 1;
	    lm = std::max(i__2, i__3);
	    i__2 = mdm;
	    for (i__ = lm; i__ <= i__2; ++i__) {
	      imd = i__ - kmd;
	      /* L30: */
	      b[imd] += a[i__ + k * a_dim1] * t;
	    }
	    /* L40: */
	  }
	L50:
	  b[1] /= a[md + a_dim1];
	  return 0;
	  /* ----------------------- END OF SUBROUTINE SOLB ------------------------ */
	} /* solb_ */
78cde765650f38fe201397ed6484ae6a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|34|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3, i__4;
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i__, j, k, m, md, jk, mm;
	  double ti;
	  int ju;
	  double tr;
	  int md1, nm1, kp1;
	  double den;
	  int mdl, ijk;
	  double prodi, prodr;
	
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION OF A BANDED COMPLEX */
	  /*  MATRIX WITH LOWER BANDWIDTH ML AND UPPER BANDWIDTH MU */
	  /*  INPUT.. */
	  /*     N       ORDER OF THE ORIGINAL MATRIX A. */
	  /*     NDIM    DECLARED DIMENSION OF ARRAY  A. */
	  /*     AR, AI     CONTAINS THE MATRIX IN BAND STORAGE.   THE COLUMNS */
	  /*                OF THE MATRIX ARE STORED IN THE COLUMNS OF  AR (REAL */
	  /*                PART) AND AI (IMAGINARY PART)  AND */
	  /*                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS */
	  /*                ML+1 THROUGH 2*ML+MU+1 OF  AR AND AI. */
	  /*     ML      LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*     MU      UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*  OUTPUT.. */
	  /*     AR, AI  AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
	  /*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
	  /*     IP      INDEX VECTOR OF PIVOT INDICES. */
	  /*     IP(N)   (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER     = 0 IF MATRIX A IS NONSINGULAR, OR  = K IF FOUND TO BE */
	  /*                SINGULAR AT STAGE K. */
	  /*  USE  SOLBC  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(MD,1)*A(MD,2)*...*A(MD,N)  WITH MD=ML+MU+1. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOLBC WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     THIS IS A MODIFICATION OF */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  *ier = 0;
	  ip[*n] = 1;
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  ju = 0;
	  if (*ml == 0) {
	    goto L70;
	  }
	  if (*n == 1) {
	    goto L70;
	  }
	  if (*n < *mu + 2) {
	    goto L7;
	  }
	  i__1 = *n;
	  for (j = *mu + 2; j <= i__1; ++j) {
	    i__2 = *ml;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      ar[i__ + j * ar_dim1] = 0.;
	      ai[i__ + j * ai_dim1] = 0.;
	      /* L5: */
	    }
	  }
	L7:
	  nm1 = *n - 1;
	  i__2 = nm1;
	  for (k = 1; k <= i__2; ++k) {
	    kp1 = k + 1;
	    m = md;
	    /* Computing MIN */
	    i__1 = *ml, i__3 = *n - k;
	    mdl = std::min(i__1, i__3) + md;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      if ((d__1 = ar[i__ + k * ar_dim1], abs(d__1)) +
	              (d__2 = ai[i__ + k * ai_dim1], abs(d__2)) >
	          (d__3 = ar[m + k * ar_dim1], abs(d__3)) +
	              (d__4 = ai[m + k * ai_dim1], abs(d__4))) {
	        m = i__;
	      }
	      /* L10: */
	    }
	    ip[k] = m + k - md;
	    tr = ar[m + k * ar_dim1];
	    ti = ai[m + k * ai_dim1];
	    if (m == md) {
	      goto L20;
	    }
	    ip[*n] = -ip[*n];
	    ar[m + k * ar_dim1] = ar[md + k * ar_dim1];
	    ai[m + k * ai_dim1] = ai[md + k * ai_dim1];
	    ar[md + k * ar_dim1] = tr;
	    ai[md + k * ai_dim1] = ti;
	  L20:
	    if (abs(tr) + abs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    i__1 = mdl;
	    for (i__ = md1; i__ <= i__1; ++i__) {
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      ar[i__ + k * ar_dim1] = -prodr;
	      ai[i__ + k * ai_dim1] = -prodi;
	      /* L30: */
	    }
	    /* Computing MIN */
	    /* Computing MAX */
	    i__3 = ju, i__4 = *mu + ip[k];
	    i__1 = std::max(i__3, i__4);
	    ju = std::min(i__1, *n);
	    mm = md;
	    if (ju < kp1) {
	      goto L55;
	    }
	    i__1 = ju;
	    for (j = kp1; j <= i__1; ++j) {
	      --m;
	      --mm;
	      tr = ar[m + j * ar_dim1];
	      ti = ai[m + j * ai_dim1];
	      if (m == mm) {
	        goto L35;
	      }
	      ar[m + j * ar_dim1] = ar[mm + j * ar_dim1];
	      ai[m + j * ai_dim1] = ai[mm + j * ai_dim1];
	      ar[mm + j * ar_dim1] = tr;
	      ai[mm + j * ai_dim1] = ti;
	    L35:
	      if (abs(tr) + abs(ti) == 0.) {
	        goto L48;
	      }
	      jk = j - k;
	      if (ti == 0.) {
	        i__3 = mdl;
	        for (i__ = md1; i__ <= i__3; ++i__) {
	          ijk = i__ - jk;
	          prodr = ar[i__ + k * ar_dim1] * tr;
	          prodi = ai[i__ + k * ai_dim1] * tr;
	          ar[ijk + j * ar_dim1] += prodr;
	          ai[ijk + j * ai_dim1] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        i__3 = mdl;
	        for (i__ = md1; i__ <= i__3; ++i__) {
	          ijk = i__ - jk;
	          prodr = -ai[i__ + k * ai_dim1] * ti;
	          prodi = ar[i__ + k * ar_dim1] * ti;
	          ar[ijk + j * ar_dim1] += prodr;
	          ai[ijk + j * ai_dim1] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      i__3 = mdl;
	      for (i__ = md1; i__ <= i__3; ++i__) {
	        ijk = i__ - jk;
	        prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	        prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	        ar[ijk + j * ar_dim1] += prodr;
	        ai[ijk + j * ai_dim1] += prodi;
	        /* L47: */
	      }
	    L48:
	        /* L50: */
	        ;
	    }
	  L55:
	      /* L60: */
	      ;
	  }
	L70:
	  k = *n;
	  if ((d__1 = ar[md + *n * ar_dim1], abs(d__1)) +
	          (d__2 = ai[md + *n * ai_dim1], abs(d__2)) ==
	      0.) {
	    goto L80;
	  }
	  return 0;
	L80:
	  *ier = k;
	  ip[*n] = 0;
	  return 0;
	  /* ----------------------- END OF SUBROUTINE DECBC ------------------------ */
	} /* decbc_ */
c7d76e43571f825b096f5cc33d12d654|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|37|1|V|cpp
	{
	  /* System generated locals */
	  int ar_dim1, ar_offset, ai_dim1, ai_offset, i__1, i__2, i__3;
	
	  /* Local variables */
	  int i__, k, m, kb, md, lm;
	  double ti, tr;
	  int md1, nm1;
	  double den;
	  int imd, kmd, mdl, mdm;
	  double prodi, prodr;
	
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B , */
	  /*                  VERSION BANDED AND COMPLEX-DOUBLE PRECISION. */
	  /*  INPUT.. */
	  /*    N      ORDER OF MATRIX A. */
	  /*    NDIM   DECLARED DIMENSION OF ARRAY  A . */
	  /*    AR, AI TRIANGULARIZED MATRIX OBTAINED FROM DECB (REAL AND IMAG. PART).
	   */
	  /*    ML     LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    MU     UPPER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED). */
	  /*    BR, BI RIGHT HAND SIDE VECTOR (REAL AND IMAG. PART). */
	  /*    IP     PIVOT VECTOR OBTAINED FROM DECBC. */
	  /*  DO NOT USE IF DECB HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    BR, BI SOLUTION VECTOR, X (REAL AND IMAG. PART). */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
	
	  /* Function Body */
	  md = *ml + *mu + 1;
	  md1 = md + 1;
	  mdm = md - 1;
	  nm1 = *n - 1;
	  if (*ml == 0) {
	    goto L25;
	  }
	  if (*n == 1) {
	    goto L50;
	  }
	  i__1 = nm1;
	  for (k = 1; k <= i__1; ++k) {
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    /* Computing MIN */
	    i__2 = *ml, i__3 = *n - k;
	    mdl = std::min(i__2, i__3) + md;
	    i__2 = mdl;
	    for (i__ = md1; i__ <= i__2; ++i__) {
	      imd = i__ + k - md;
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[imd] += prodr;
	      bi[imd] += prodi;
	      /* L10: */
	    }
	    /* L20: */
	  }
	L25:
	  i__1 = nm1;
	  for (kb = 1; kb <= i__1; ++kb) {
	    k = *n + 1 - kb;
	    den = ar[md + k * ar_dim1] * ar[md + k * ar_dim1] +
	          ai[md + k * ai_dim1] * ai[md + k * ai_dim1];
	    prodr = br[k] * ar[md + k * ar_dim1] + bi[k] * ai[md + k * ai_dim1];
	    prodi = bi[k] * ar[md + k * ar_dim1] - br[k] * ai[md + k * ai_dim1];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    kmd = md - k;
	    /* Computing MAX */
	    i__2 = 1, i__3 = kmd + 1;
	    lm = std::max(i__2, i__3);
	    i__2 = mdm;
	    for (i__ = lm; i__ <= i__2; ++i__) {
	      imd = i__ - kmd;
	      prodr = ar[i__ + k * ar_dim1] * tr - ai[i__ + k * ai_dim1] * ti;
	      prodi = ai[i__ + k * ai_dim1] * tr + ar[i__ + k * ar_dim1] * ti;
	      br[imd] += prodr;
	      bi[imd] += prodi;
	      /* L30: */
	    }
	    /* L40: */
	  }
	  den =
	      ar[md + ar_dim1] * ar[md + ar_dim1] + ai[md + ai_dim1] * ai[md + ai_dim1];
	  prodr = br[1] * ar[md + ar_dim1] + bi[1] * ai[md + ai_dim1];
	  prodi = bi[1] * ar[md + ar_dim1] - br[1] * ai[md + ai_dim1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	L50:
	  return 0;
	  /* ----------------------- END OF SUBROUTINE  ------------------------ */
	} /* solbc_ */
71c6caa92b0e7e2de509a17c177c7a07|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|39|1|V|cpp
	{
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2, i__3;
	  double d__1;
	
	  /* Local variables */
	  int i__, j, m;
	  double x, y;
	  int la, mm1, kp1, mp1;
	
	  /*     this subroutine is a translation of the algol procedure elmhes, */
	  /*     num. math. 12, 349-368(1968) by martin and wilkinson. */
	  /*     handbook for auto. comp., vol.ii-linear algebra, 339-358(1971). */
	
	  /*     given a real general matrix, this subroutine */
	  /*     reduces a submatrix situated in rows and columns */
	  /*     low through igh to upper hessenberg form by */
	  /*     stabilized elementary similarity transformations. */
	
	  /*     on input: */
	
	  /*      nm must be set to the row dimension of two-dimensional */
	  /*        array parameters as declared in the calling program */
	  /*        dimension statement; */
	
	  /*      n is the order of the matrix; */
	
	  /*      low and igh are integers determined by the balancing */
	  /*        subroutine  balanc.      if  balanc  has not been used, */
	  /*        set low=1, igh=n; */
	
	  /*      a contains the input matrix. */
	
	  /*     on output: */
	
	  /*      a contains the hessenberg matrix.  the multipliers */
	  /*        which were used in the reduction are stored in the */
	  /*        remaining triangle under the hessenberg matrix; */
	
	  /*      int contains information on the rows and columns */
	  /*        interchanged in the reduction. */
	  /*        only elements low through igh are used. */
	
	  /*     questions and comments should be directed to b. s. garbow, */
	  /*     applied mathematics division, argonne national laboratory */
	
	  /*     ------------------------------------------------------------------ */
	
	  /* Parameter adjustments */
	  a_dim1 = *nm;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
	  --int__;
	
	  /* Function Body */
	  la = *igh - 1;
	  kp1 = *low + 1;
	  if (la < kp1) {
	    goto L200;
	  }
	
	  i__1 = la;
	  for (m = kp1; m <= i__1; ++m) {
	    mm1 = m - 1;
	    x = 0.;
	    i__ = m;
	
	    i__2 = *igh;
	    for (j = m; j <= i__2; ++j) {
	      if ((d__1 = a[j + mm1 * a_dim1], abs(d__1)) <= abs(x)) {
	        goto L100;
	      }
	      x = a[j + mm1 * a_dim1];
	      i__ = j;
	    L100:;
	    }
	
	    int__[m] = i__;
	    if (i__ == m) {
	      goto L130;
	    }
	    /*    :::::::::: interchange rows and columns of a :::::::::: */
	    i__2 = *n;
	    for (j = mm1; j <= i__2; ++j) {
	      y = a[i__ + j * a_dim1];
	      a[i__ + j * a_dim1] = a[m + j * a_dim1];
	      a[m + j * a_dim1] = y;
	      /* L110: */
	    }
	
	    i__2 = *igh;
	    for (j = 1; j <= i__2; ++j) {
	      y = a[j + i__ * a_dim1];
	      a[j + i__ * a_dim1] = a[j + m * a_dim1];
	      a[j + m * a_dim1] = y;
	      /* L120: */
	    }
	  /*    :::::::::: end interchange :::::::::: */
	  L130:
	    if (x == 0.) {
	      goto L180;
	    }
	    mp1 = m + 1;
	
	    i__2 = *igh;
	    for (i__ = mp1; i__ <= i__2; ++i__) {
	      y = a[i__ + mm1 * a_dim1];
	      if (y == 0.) {
	        goto L160;
	      }
	      y /= x;
	      a[i__ + mm1 * a_dim1] = y;
	
	      i__3 = *n;
	      for (j = m; j <= i__3; ++j) {
	        /* L140: */
	        a[i__ + j * a_dim1] -= y * a[m + j * a_dim1];
	      }
	
	      i__3 = *igh;
	      for (j = 1; j <= i__3; ++j) {
	        /* L150: */
	        a[j + m * a_dim1] += y * a[j + i__ * a_dim1];
	      }
	
	    L160:;
	    }
	
	  L180:;
	  }
	
	L200:
	  return 0;
	  /*    :::::::::: last card of elmhes :::::::::: */
	} /* elmhes_ */
3333f2a47a275a7d07a830eea454b547|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|24|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e1_dim1, e1_offset, i__1,
	      i__2, i__3, i__4, i__5, i__6;
	
	  /* Local variables */
	  int i__, j, k, j1, ib, mm, jm1;
	  double sum;
	
	  /* Parameter adjustments */
	  --iphes;
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip1;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e1_dim1 = *lde1;
	  e1_offset = 1 + e1_dim1;
	  e1 -= e1_offset;
	
	  /* Function Body */
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L3;
	  case 4:
	    goto L4;
	  case 5:
	    goto L5;
	  case 6:
	    goto L6;
	  case 7:
	    goto L7;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L13;
	  case 14:
	    goto L14;
	  case 15:
	    goto L15;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e1[i__ + j * e1_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    e1[j + j * e1_dim1] += *fac1;
	  }
	  dec(n, lde1, &e1[e1_offset], &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = *nm1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e1[i__ + j * e1_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	    }
	    e1[j + j * e1_dim1] += *fac1;
	  }
	L45:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *nm1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      sum = 0.;
	      i__3 = mm - 1;
	      for (k = 0; k <= i__3; ++k) {
	        sum = (sum + fjac[i__ + (j + k * *m2) * fjac_dim1]) / *fac1;
	      }
	      e1[i__ + j * e1_dim1] -= sum;
	    }
	  }
	  dec(nm1, lde1, &e1[e1_offset], &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e1[i__ + linal_1.mle + j * e1_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    e1[linal_1.mdiag + j * e1_dim1] += *fac1;
	  }
	  decb(n, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e1[i__ + linal_1.mle + j * e1_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	    }
	    e1[linal_1.mdiag + j * e1_dim1] += *fac1;
	  }
	L46:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      sum = 0.;
	      i__3 = mm - 1;
	      for (k = 0; k <= i__3; ++k) {
	        sum = (sum + fjac[i__ + (j + k * *m2) * fjac_dim1]) / *fac1;
	      }
	      e1[i__ + linal_1.mle + j * e1_dim1] -= sum;
	    }
	  }
	  decb(nm1, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L3:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e1[i__ + j * e1_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    /* Computing MAX */
	    i__2 = 1, i__3 = j - *mumas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = j + *mlmas;
	    i__4 = std::min(i__5, i__6);
	    for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	      e1[i__ + j * e1_dim1] +=
	          *fac1 * fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	    }
	  }
	  dec(n, lde1, &e1[e1_offset], &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L13:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__4 = *nm1;
	    for (i__ = 1; i__ <= i__4; ++i__) {
	      e1[i__ + j * e1_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	    }
	    /* Computing MAX */
	    i__4 = 1, i__2 = j - *mumas;
	    /* Computing MIN */
	    i__5 = *nm1, i__6 = j + *mlmas;
	    i__3 = std::min(i__5, i__6);
	    for (i__ = std::max(i__4, i__2); i__ <= i__3; ++i__) {
	      e1[i__ + j * e1_dim1] +=
	          *fac1 * fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	    }
	  }
	  goto L45;
	
	  /* ----------------------------------------------------------- */
	
	L4:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__3 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      e1[i__ + linal_1.mle + j * e1_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    i__3 = linal_1.mbb;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      ib = i__ + linal_1.mdiff;
	      e1[ib + j * e1_dim1] += *fac1 * fmas[i__ + j * fmas_dim1];
	    }
	  }
	  decb(n, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L14:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__3 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      e1[i__ + linal_1.mle + j * e1_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	    }
	    i__3 = linal_1.mbb;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      ib = i__ + linal_1.mdiff;
	      e1[ib + j * e1_dim1] += *fac1 * fmas[i__ + j * fmas_dim1];
	    }
	  }
	  goto L46;
	
	  /* ----------------------------------------------------------- */
	
	L5:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__3 = *n;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      e1[i__ + j * e1_dim1] =
	          fmas[i__ + j * fmas_dim1] * *fac1 - fjac[i__ + j * fjac_dim1];
	    }
	  }
	  dec(n, lde1, &e1[e1_offset], &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L15:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__3 = *nm1;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      e1[i__ + j * e1_dim1] =
	          fmas[i__ + j * fmas_dim1] * *fac1 - fjac[i__ + jm1 * fjac_dim1];
	    }
	  }
	  goto L45;
	
	  /* ----------------------------------------------------------- */
	
	L6:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A BANDED MATRIX */
	  /* ---  THIS OPTION IS NOT PROVIDED */
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L7:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, HESSENBERG-OPTION */
	  if (*calhes) {
	    elmhes(ldjac, n, &c__1, n, &fjac[fjac_offset], &iphes[1]);
	  }
	  *calhes = false;
	  i__1 = *n - 1;
	  for (j = 1; j <= i__1; ++j) {
	    j1 = j + 1;
	    e1[j1 + j * e1_dim1] = -fjac[j1 + j * fjac_dim1];
	  }
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__3 = j;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      e1[i__ + j * e1_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    e1[j + j * e1_dim1] += *fac1;
	  }
	  dech(n, lde1, &e1[e1_offset], &c__1, &ip1[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* decomr_ */
bd8acc716b7c6641d24802cefa5e9157|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|29|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e2r_dim1, e2r_offset,
	      e2i_dim1, e2i_offset, i__1, i__2, i__3, i__4, i__5, i__6;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k, j1;
	  double bb;
	  int ib, mm, jm1;
	  double bet, alp;
	  double ffma, abno;
	  int imle;
	  double sumi, sumr, sums;
	
	  /* Parameter adjustments */
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip2;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e2i_dim1 = *lde1;
	  e2i_offset = 1 + e2i_dim1;
	  e2i -= e2i_offset;
	  e2r_dim1 = *lde1;
	  e2r_offset = 1 + e2r_dim1;
	  e2r -= e2r_offset;
	
	  /* Function Body */
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L3;
	  case 4:
	    goto L4;
	  case 5:
	    goto L5;
	  case 6:
	    goto L6;
	  case 7:
	    goto L7;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L13;
	  case 14:
	    goto L14;
	  case 15:
	    goto L15;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + j * e2r_dim1] = -fjac[i__ + j * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = 0.;
	    }
	    e2r[j + j * e2r_dim1] += *alphn;
	    e2i[j + j * e2i_dim1] = *betan;
	  }
	  decc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = *nm1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + j * e2r_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = 0.;
	    }
	    e2r[j + j * e2r_dim1] += *alphn;
	    e2i[j + j * e2i_dim1] = *betan;
	  }
	L45:
	  mm = *m1 / *m2;
	  /* Computing 2nd power */
	  d__1 = *alphn;
	  /* Computing 2nd power */
	  d__2 = *betan;
	  abno = d__1 * d__1 + d__2 * d__2;
	  alp = *alphn / abno;
	  bet = *betan / abno;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *nm1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      sumr = 0.;
	      sumi = 0.;
	      i__3 = mm - 1;
	      for (k = 0; k <= i__3; ++k) {
	        sums = sumr + fjac[i__ + (j + k * *m2) * fjac_dim1];
	        sumr = sums * alp + sumi * bet;
	        sumi = sumi * alp - sums * bet;
	      }
	      e2r[i__ + j * e2r_dim1] -= sumr;
	      e2i[i__ + j * e2i_dim1] -= sumi;
	    }
	  }
	  decc(nm1, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      imle = i__ + linal_1.mle;
	      e2r[imle + j * e2r_dim1] = -fjac[i__ + j * fjac_dim1];
	      e2i[imle + j * e2i_dim1] = 0.;
	    }
	    e2r[linal_1.mdiag + j * e2r_dim1] += *alphn;
	    e2i[linal_1.mdiag + j * e2i_dim1] = *betan;
	  }
	  decbc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle, &linal_1.mue,
	        &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + linal_1.mle + j * e2r_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	      e2i[i__ + linal_1.mle + j * e2i_dim1] = 0.;
	    }
	    e2r[linal_1.mdiag + j * e2r_dim1] += *alphn;
	    e2i[linal_1.mdiag + j * e2i_dim1] += *betan;
	  }
	L46:
	  mm = *m1 / *m2;
	  /* Computing 2nd power */
	  d__1 = *alphn;
	  /* Computing 2nd power */
	  d__2 = *betan;
	  abno = d__1 * d__1 + d__2 * d__2;
	  alp = *alphn / abno;
	  bet = *betan / abno;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      sumr = 0.;
	      sumi = 0.;
	      i__3 = mm - 1;
	      for (k = 0; k <= i__3; ++k) {
	        sums = sumr + fjac[i__ + (j + k * *m2) * fjac_dim1];
	        sumr = sums * alp + sumi * bet;
	        sumi = sumi * alp - sums * bet;
	      }
	      imle = i__ + linal_1.mle;
	      e2r[imle + j * e2r_dim1] -= sumr;
	      e2i[imle + j * e2i_dim1] -= sumi;
	    }
	  }
	  decbc(nm1, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle,
	        &linal_1.mue, &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L3:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + j * e2r_dim1] = -fjac[i__ + j * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = 0.;
	    }
	  }
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    /* Computing MAX */
	    i__2 = 1, i__3 = j - *mumas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = j + *mlmas;
	    i__4 = std::min(i__5, i__6);
	    for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	      bb = fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	      e2r[i__ + j * e2r_dim1] += *alphn * bb;
	      e2i[i__ + j * e2i_dim1] = *betan * bb;
	    }
	  }
	  decc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L13:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__4 = *nm1;
	    for (i__ = 1; i__ <= i__4; ++i__) {
	      e2r[i__ + j * e2r_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = 0.;
	    }
	    /* Computing MAX */
	    i__4 = 1, i__2 = j - *mumas;
	    /* Computing MIN */
	    i__5 = *nm1, i__6 = j + *mlmas;
	    i__3 = std::min(i__5, i__6);
	    for (i__ = std::max(i__4, i__2); i__ <= i__3; ++i__) {
	      ffma = fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	      e2r[i__ + j * e2r_dim1] += *alphn * ffma;
	      e2i[i__ + j * e2i_dim1] += *betan * ffma;
	    }
	  }
	  goto L45;
	
	  /* ----------------------------------------------------------- */
	
	L4:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__3 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__3; ++i__) {
	      imle = i__ + linal_1.mle;
	      e2r[imle + j * e2r_dim1] = -fjac[i__ + j * fjac_dim1];
	      e2i[imle + j * e2i_dim1] = 0.;
	    }
	    /* Computing MAX */
	    i__3 = 1, i__4 = *mumas + 2 - j;
	    /* Computing MIN */
	    i__5 = linal_1.mbb, i__6 = *mumas + 1 - j + *n;
	    i__2 = std::min(i__5, i__6);
	    for (i__ = std::max(i__3, i__4); i__ <= i__2; ++i__) {
	      ib = i__ + linal_1.mdiff;
	      bb = fmas[i__ + j * fmas_dim1];
	      e2r[ib + j * e2r_dim1] += *alphn * bb;
	      e2i[ib + j * e2i_dim1] = *betan * bb;
	    }
	  }
	  decbc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle, &linal_1.mue,
	        &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L14:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = linal_1.mbjac;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + linal_1.mle + j * e2r_dim1] = -fjac[i__ + jm1 * fjac_dim1];
	      e2i[i__ + linal_1.mle + j * e2i_dim1] = 0.;
	    }
	    i__2 = linal_1.mbb;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      ib = i__ + linal_1.mdiff;
	      ffma = fmas[i__ + j * fmas_dim1];
	      e2r[ib + j * e2r_dim1] += *alphn * ffma;
	      e2i[ib + j * e2i_dim1] += *betan * ffma;
	    }
	  }
	  goto L46;
	
	  /* ----------------------------------------------------------- */
	
	L5:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      bb = fmas[i__ + j * fmas_dim1];
	      e2r[i__ + j * e2r_dim1] = bb * *alphn - fjac[i__ + j * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = bb * *betan;
	    }
	  }
	  decc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L15:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *nm1;
	  for (j = 1; j <= i__1; ++j) {
	    jm1 = j + *m1;
	    i__2 = *nm1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2r[i__ + j * e2r_dim1] =
	          *alphn * fmas[i__ + j * fmas_dim1] - fjac[i__ + jm1 * fjac_dim1];
	      e2i[i__ + j * e2i_dim1] = *betan * fmas[i__ + j * fmas_dim1];
	    }
	  }
	  goto L45;
	
	  /* ----------------------------------------------------------- */
	
	L6:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A BANDED MATRIX */
	  /* ---  THIS OPTION IS NOT PROVIDED */
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L7:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, HESSENBERG-OPTION */
	  i__1 = *n - 1;
	  for (j = 1; j <= i__1; ++j) {
	    j1 = j + 1;
	    e2r[j1 + j * e2r_dim1] = -fjac[j1 + j * fjac_dim1];
	    e2i[j1 + j * e2i_dim1] = 0.;
	  }
	  i__1 = *n;
	  for (j = 1; j <= i__1; ++j) {
	    i__2 = j;
	    for (i__ = 1; i__ <= i__2; ++i__) {
	      e2i[i__ + j * e2i_dim1] = 0.;
	      e2r[i__ + j * e2r_dim1] = -fjac[i__ + j * fjac_dim1];
	    }
	    e2r[j + j * e2r_dim1] += *alphn;
	    e2i[j + j * e2i_dim1] = *betan;
	  }
	  dechc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &c__1, &ip2[1], ier);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* decomc_ */
ed6fae7654ae6bd4015ad76d93797587|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|30|1|V|cpp
	/*     END OF SUBROUTINE DECOMC */
	
	/* *********************************************************** */
8c1a63d8d0121915df2c53ec72e43d7b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|34|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e1_dim1, e1_offset, i__1,
	      i__2, i__3, i__4, i__5, i__6;
	
	  /* Local variables */
	  int i__, j, k;
	  double s1;
	  int mm, mp, im1, mp1, jkm;
	  double sum1;
	  double zsafe;
	
	  /* Parameter adjustments */
	  --iphes;
	  --f1;
	  --z1;
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip1;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e1_dim1 = *lde1;
	  e1_offset = 1 + e1_dim1;
	  e1 -= e1_offset;
	
	  /* Function Body */
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L3;
	  case 4:
	    goto L4;
	  case 5:
	    goto L5;
	  case 6:
	    goto L6;
	  case 7:
	    goto L7;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L13;
	  case 14:
	    goto L13;
	  case 15:
	    goto L15;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	  sol(n, lde1, &e1[e1_offset], &z1[1], &ip1[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	L48:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum1 = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum1 = (z1[jkm] + sum1) / *fac1;
	      i__2 = *nm1;
	      for (i__ = 1; i__ <= i__2; ++i__) {
	        im1 = i__ + *m1;
	        z1[im1] += fjac[i__ + jkm * fjac_dim1] * sum1;
	      }
	    }
	  }
	  sol(nm1, lde1, &e1[e1_offset], &z1[*m1 + 1], &ip1[1]);
	L49:
	  for (i__ = *m1; i__ >= 1; --i__) {
	    z1[i__] = (z1[i__] + z1[*m2 + i__]) / *fac1;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	  solb(n, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &z1[1], &ip1[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	L45:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum1 = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum1 = (z1[jkm] + sum1) / *fac1;
	      /* Computing MAX */
	      i__2 = 1, i__3 = j - *mujac;
	      /* Computing MIN */
	      i__5 = *nm1, i__6 = j + *mljac;
	      i__4 = std::min(i__5, i__6);
	      for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	        im1 = i__ + *m1;
	        z1[im1] += fjac[i__ + *mujac + 1 - j + jkm * fjac_dim1] * sum1;
	      }
	    }
	  }
	  solb(nm1, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &z1[*m1 + 1],
	       &ip1[1]);
	  goto L49;
	
	  /* ----------------------------------------------------------- */
	
	L3:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s1 = 0.;
	    /* Computing MAX */
	    i__4 = 1, i__2 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = i__ + *mumas;
	    i__3 = std::min(i__5, i__6);
	    for (j = std::max(i__4, i__2); j <= i__3; ++j) {
	      s1 -= fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * f1[j];
	    }
	    z1[i__] += s1 * *fac1;
	  }
	  sol(n, lde1, &e1[e1_offset], &z1[1], &ip1[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L13:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *m1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	  i__1 = *nm1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    im1 = i__ + *m1;
	    s1 = 0.;
	    /* Computing MAX */
	    i__3 = 1, i__4 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *nm1, i__6 = i__ + *mumas;
	    i__2 = std::min(i__5, i__6);
	    for (j = std::max(i__3, i__4); j <= i__2; ++j) {
	      s1 -= fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * f1[j + *m1];
	    }
	    z1[im1] += s1 * *fac1;
	  }
	  if (*ijob == 14) {
	    goto L45;
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L4:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s1 = 0.;
	    /* Computing MAX */
	    i__2 = 1, i__3 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = i__ + *mumas;
	    i__4 = std::min(i__5, i__6);
	    for (j = std::max(i__2, i__3); j <= i__4; ++j) {
	      s1 -= fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * f1[j];
	    }
	    z1[i__] += s1 * *fac1;
	  }
	  solb(n, lde1, &e1[e1_offset], &linal_1.mle, &linal_1.mue, &z1[1], &ip1[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L5:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s1 = 0.;
	    i__4 = *n;
	    for (j = 1; j <= i__4; ++j) {
	      s1 -= fmas[i__ + j * fmas_dim1] * f1[j];
	    }
	    z1[i__] += s1 * *fac1;
	  }
	  sol(n, lde1, &e1[e1_offset], &z1[1], &ip1[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L15:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *m1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	  i__1 = *nm1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    im1 = i__ + *m1;
	    s1 = 0.;
	    i__4 = *nm1;
	    for (j = 1; j <= i__4; ++j) {
	      s1 -= fmas[i__ + j * fmas_dim1] * f1[j + *m1];
	    }
	    z1[im1] += s1 * *fac1;
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L6:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A BANDED MATRIX */
	  /* ---  THIS OPTION IS NOT PROVIDED */
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L7:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, HESSENBERG-OPTION */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    z1[i__] -= f1[i__] * *fac1;
	  }
	  for (mm = *n - 2; mm >= 1; --mm) {
	    mp = *n - mm;
	    mp1 = mp - 1;
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L746;
	    }
	    zsafe = z1[mp];
	    z1[mp] = z1[i__];
	    z1[i__] = zsafe;
	  L746:
	    i__1 = *n;
	    for (i__ = mp + 1; i__ <= i__1; ++i__) {
	      z1[i__] -= fjac[i__ + mp1 * fjac_dim1] * z1[mp];
	    }
	  }
	  solh(n, lde1, &e1[e1_offset], &c__1, &z1[1], &ip1[1]);
	  i__1 = *n - 2;
	  for (mm = 1; mm <= i__1; ++mm) {
	    mp = *n - mm;
	    mp1 = mp - 1;
	    i__4 = *n;
	    for (i__ = mp + 1; i__ <= i__4; ++i__) {
	      z1[i__] += fjac[i__ + mp1 * fjac_dim1] * z1[mp];
	    }
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L750;
	    }
	    zsafe = z1[mp];
	    z1[mp] = z1[i__];
	    z1[i__] = zsafe;
	  L750:;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* slvrar_ */
742c162796d31b226864ce757e60b9d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|35|1|V|cpp
	/*     END OF SUBROUTINE SLVRAR */
	
	/* *********************************************************** */
c911080d02ed49f242bd1f41c2e411a1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|40|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e2r_dim1, e2r_offset,
	      e2i_dim1, e2i_offset, i__1, i__2, i__3, i__4, i__5, i__6;
	  double d__1, d__2;
	
	  /* Local variables */
	  int i__, j, k;
	  double s2, s3, bb;
	  int mm, mp, im1, jm1, mp1;
	  double z2i, z3i;
	  int jkm, mpi;
	  double sum2, sum3, abno;
	  int iimu;
	  double sumh, e1imp;
	  double zsafe;
	
	  /* Parameter adjustments */
	  --iphes;
	  --f3;
	  --f2;
	  --z3;
	  --z2;
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip2;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e2i_dim1 = *lde1;
	  e2i_offset = 1 + e2i_dim1;
	  e2i -= e2i_offset;
	  e2r_dim1 = *lde1;
	  e2r_offset = 1 + e2r_dim1;
	  e2r -= e2r_offset;
	
	  /* Function Body */
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L3;
	  case 4:
	    goto L4;
	  case 5:
	    goto L5;
	  case 6:
	    goto L6;
	  case 7:
	    goto L7;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L13;
	  case 14:
	    goto L13;
	  case 15:
	    goto L15;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  solc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &z2[1], &z3[1], &ip2[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	L48:
	  /* Computing 2nd power */
	  d__1 = *alphn;
	  /* Computing 2nd power */
	  d__2 = *betan;
	  abno = d__1 * d__1 + d__2 * d__2;
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum2 = 0.;
	    sum3 = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sumh = (z2[jkm] + sum2) / abno;
	      sum3 = (z3[jkm] + sum3) / abno;
	      sum2 = sumh * *alphn + sum3 * *betan;
	      sum3 = sum3 * *alphn - sumh * *betan;
	      i__2 = *nm1;
	      for (i__ = 1; i__ <= i__2; ++i__) {
	        im1 = i__ + *m1;
	        z2[im1] += fjac[i__ + jkm * fjac_dim1] * sum2;
	        z3[im1] += fjac[i__ + jkm * fjac_dim1] * sum3;
	      }
	    }
	  }
	  solc(nm1, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &z2[*m1 + 1],
	       &z3[*m1 + 1], &ip2[1]);
	L49:
	  for (i__ = *m1; i__ >= 1; --i__) {
	    mpi = *m2 + i__;
	    z2i = z2[i__] + z2[mpi];
	    z3i = z3[i__] + z3[mpi];
	    z3[i__] = (z3i * *alphn - z2i * *betan) / abno;
	    z2[i__] = (z2i * *alphn + z3i * *betan) / abno;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  solbc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle, &linal_1.mue,
	        &z2[1], &z3[1], &ip2[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	L45:
	  /* Computing 2nd power */
	  d__1 = *alphn;
	  /* Computing 2nd power */
	  d__2 = *betan;
	  abno = d__1 * d__1 + d__2 * d__2;
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum2 = 0.;
	    sum3 = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sumh = (z2[jkm] + sum2) / abno;
	      sum3 = (z3[jkm] + sum3) / abno;
	      sum2 = sumh * *alphn + sum3 * *betan;
	      sum3 = sum3 * *alphn - sumh * *betan;
	      /* Computing MAX */
	      i__2 = 1, i__3 = j - *mujac;
	      /* Computing MIN */
	      i__5 = *nm1, i__6 = j + *mljac;
	      i__4 = std::min(i__5, i__6);
	      for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	        im1 = i__ + *m1;
	        iimu = i__ + *mujac + 1 - j;
	        z2[im1] += fjac[iimu + jkm * fjac_dim1] * sum2;
	        z3[im1] += fjac[iimu + jkm * fjac_dim1] * sum3;
	      }
	    }
	  }
	  solbc(nm1, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle,
	        &linal_1.mue, &z2[*m1 + 1], &z3[*m1 + 1], &ip2[1]);
	  goto L49;
	
	  /* ----------------------------------------------------------- */
	
	L3:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = 0.;
	    s3 = 0.;
	    /* Computing MAX */
	    i__4 = 1, i__2 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = i__ + *mumas;
	    i__3 = std::min(i__5, i__6);
	    for (j = std::max(i__4, i__2); j <= i__3; ++j) {
	      bb = fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	      s2 -= bb * f2[j];
	      s3 -= bb * f3[j];
	    }
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  solc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &z2[1], &z3[1], &ip2[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L13:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *m1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  i__1 = *nm1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    im1 = i__ + *m1;
	    s2 = 0.;
	    s3 = 0.;
	    /* Computing MAX */
	    i__3 = 1, i__4 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *nm1, i__6 = i__ + *mumas;
	    i__2 = std::min(i__5, i__6);
	    for (j = std::max(i__3, i__4); j <= i__2; ++j) {
	      jm1 = j + *m1;
	      bb = fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	      s2 -= bb * f2[jm1];
	      s3 -= bb * f3[jm1];
	    }
	    z2[im1] = z2[im1] + s2 * *alphn - s3 * *betan;
	    z3[im1] = z3[im1] + s3 * *alphn + s2 * *betan;
	  }
	  if (*ijob == 14) {
	    goto L45;
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L4:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = 0.;
	    s3 = 0.;
	    /* Computing MAX */
	    i__2 = 1, i__3 = i__ - *mlmas;
	    /* Computing MIN */
	    i__5 = *n, i__6 = i__ + *mumas;
	    i__4 = std::min(i__5, i__6);
	    for (j = std::max(i__2, i__3); j <= i__4; ++j) {
	      bb = fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1];
	      s2 -= bb * f2[j];
	      s3 -= bb * f3[j];
	    }
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  solbc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &linal_1.mle, &linal_1.mue,
	        &z2[1], &z3[1], &ip2[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L5:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = 0.;
	    s3 = 0.;
	    i__4 = *n;
	    for (j = 1; j <= i__4; ++j) {
	      bb = fmas[i__ + j * fmas_dim1];
	      s2 -= bb * f2[j];
	      s3 -= bb * f3[j];
	    }
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  solc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &z2[1], &z3[1], &ip2[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L15:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  i__1 = *m1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  i__1 = *nm1;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    im1 = i__ + *m1;
	    s2 = 0.;
	    s3 = 0.;
	    i__4 = *nm1;
	    for (j = 1; j <= i__4; ++j) {
	      jm1 = j + *m1;
	      bb = fmas[i__ + j * fmas_dim1];
	      s2 -= bb * f2[jm1];
	      s3 -= bb * f3[jm1];
	    }
	    z2[im1] = z2[im1] + s2 * *alphn - s3 * *betan;
	    z3[im1] = z3[im1] + s3 * *alphn + s2 * *betan;
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L6:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A BANDED MATRIX */
	  /* ---  THIS OPTION IS NOT PROVIDED */
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L7:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, HESSENBERG-OPTION */
	  i__1 = *n;
	  for (i__ = 1; i__ <= i__1; ++i__) {
	    s2 = -f2[i__];
	    s3 = -f3[i__];
	    z2[i__] = z2[i__] + s2 * *alphn - s3 * *betan;
	    z3[i__] = z3[i__] + s3 * *alphn + s2 * *betan;
	  }
	  for (mm = *n - 2; mm >= 1; --mm) {
	    mp = *n - mm;
	    mp1 = mp - 1;
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L746;
	    }
	    zsafe = z2[mp];
	    z2[mp] = z2[i__];
	    z2[i__] = zsafe;
	    zsafe = z3[mp];
	    z3[mp] = z3[i__];
	    z3[i__] = zsafe;
	  L746:
	    i__1 = *n;
	    for (i__ = mp + 1; i__ <= i__1; ++i__) {
	      e1imp = fjac[i__ + mp1 * fjac_dim1];
	      z2[i__] -= e1imp * z2[mp];
	      z3[i__] -= e1imp * z3[mp];
	    }
	  }
	  solhc(n, lde1, &e2r[e2r_offset], &e2i[e2i_offset], &c__1, &z2[1], &z3[1],
	        &ip2[1]);
	  i__1 = *n - 2;
	  for (mm = 1; mm <= i__1; ++mm) {
	    mp = *n - mm;
	    mp1 = mp - 1;
	    i__4 = *n;
	    for (i__ = mp + 1; i__ <= i__4; ++i__) {
	      e1imp = fjac[i__ + mp1 * fjac_dim1];
	      z2[i__] += e1imp * z2[mp];
	      z3[i__] += e1imp * z3[mp];
	    }
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L750;
	    }
	    zsafe = z2[mp];
	    z2[mp] = z2[i__];
	    z2[i__] = zsafe;
	    zsafe = z3[mp];
	    z3[mp] = z3[i__];
	    z3[i__] = zsafe;
	  L750:;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* slvrai_ */
40ce07724832d76fd68ede9bb679f24c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|64|1|V|cpp
	/*     END OF SUBROUTINE ESTRAV */
	
	/* *********************************************************** */
dc3f214fc6068ec30b778e2561637f22|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|70|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e_dim1, e_offset, i__1,
	      i__2, i__3, i__4, i__5, i__6;
	
	  /* Local variables */
	  int i__, j, k, mm, im1, jkm;
	  double sum;
	
	  /* Parameter adjustments */
	  --ynew;
	  --fx;
	  --ak;
	  --dy;
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e_dim1 = *lde;
	  e_offset = 1 + e_dim1;
	  e -= e_offset;
	
	  /* Function Body */
	  if (*hd == 0.) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] = dy[i__];
	    }
	  } else {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] = dy[i__] + *hd * fx[i__];
	    }
	  }
	
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L3;
	  case 4:
	    goto L4;
	  case 5:
	    goto L5;
	  case 6:
	    goto L6;
	  case 7:
	    goto L55;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L13;
	  case 14:
	    goto L13;
	  case 15:
	    goto L15;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	  }
	  sol(n, lde, &e[e_offset], &ak[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	  }
	L48:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum = (ak[jkm] + sum) / *fac1;
	      i__2 = *nm1;
	      for (i__ = 1; i__ <= i__2; ++i__) {
	        im1 = i__ + *m1;
	        ak[im1] += fjac[i__ + jkm * fjac_dim1] * sum;
	      }
	    }
	  }
	  sol(nm1, lde, &e[e_offset], &ak[*m1 + 1], &ip[1]);
	  for (i__ = *m1; i__ >= 1; --i__) {
	    ak[i__] = (ak[i__] + ak[*m2 + i__]) / *fac1;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	  }
	  solb(n, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &ak[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	  }
	L45:
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum = (ak[jkm] + sum) / *fac1;
	      /* Computing MAX */
	      i__2 = 1, i__3 = j - *mujac;
	      /* Computing MIN */
	      i__5 = *nm1, i__6 = j + *mljac;
	      i__4 = std::min(i__5, i__6);
	      for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	        im1 = i__ + *m1;
	        ak[im1] += fjac[i__ + *mujac + 1 - j + jkm * fjac_dim1] * sum;
	      }
	    }
	  }
	  solb(nm1, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &ak[*m1 + 1],
	       &ip[1]);
	  for (i__ = *m1; i__ >= 1; --i__) {
	    ak[i__] = (ak[i__] + ak[*m2 + i__]) / *fac1;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L3:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      /* Computing MAX */
	      i__4 = 1, i__2 = i__ - *mlmas;
	      /* Computing MIN */
	      i__5 = *n, i__6 = i__ + *mumas;
	      i__3 = std::min(i__5, i__6);
	      for (j = std::max(i__4, i__2); j <= i__3; ++j) {
	        sum += fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * ynew[j];
	      }
	      ak[i__] += sum;
	    }
	  }
	  sol(n, lde, &e[e_offset], &ak[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L13:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  if (*stage1) {
	    i__1 = *m1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	    i__1 = *nm1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      /* Computing MAX */
	      i__3 = 1, i__4 = i__ - *mlmas;
	      /* Computing MIN */
	      i__5 = *nm1, i__6 = i__ + *mumas;
	      i__2 = std::min(i__5, i__6);
	      for (j = std::max(i__3, i__4); j <= i__2; ++j) {
	        sum += fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * ynew[j + *m1];
	      }
	      im1 = i__ + *m1;
	      ak[im1] += sum;
	    }
	  }
	  if (*ijob == 14) {
	    goto L45;
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L4:
	  /* ---  B IS A BANDED MATRIX, JACOBIAN A BANDED MATRIX */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      /* Computing MAX */
	      i__2 = 1, i__3 = i__ - *mlmas;
	      /* Computing MIN */
	      i__5 = *n, i__6 = i__ + *mumas;
	      i__4 = std::min(i__5, i__6);
	      for (j = std::max(i__2, i__3); j <= i__4; ++j) {
	        sum += fmas[i__ - j + linal_1.mbdiag + j * fmas_dim1] * ynew[j];
	      }
	      ak[i__] += sum;
	    }
	  }
	  solb(n, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &ak[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L5:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      i__4 = *n;
	      for (j = 1; j <= i__4; ++j) {
	        sum += fmas[i__ + j * fmas_dim1] * ynew[j];
	      }
	      ak[i__] += sum;
	    }
	  }
	  sol(n, lde, &e[e_offset], &ak[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L15:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  if (*stage1) {
	    i__1 = *m1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      ak[i__] += ynew[i__];
	    }
	    i__1 = *nm1;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      i__4 = *nm1;
	      for (j = 1; j <= i__4; ++j) {
	        sum += fmas[i__ + j * fmas_dim1] * ynew[j + *m1];
	      }
	      im1 = i__ + *m1;
	      ak[im1] += sum;
	    }
	  }
	  goto L48;
	
	  /* ----------------------------------------------------------- */
	
	L6:
	  /* ---  B IS A FULL MATRIX, JACOBIAN A BANDED MATRIX */
	  /* ---  THIS OPTION IS NOT PROVIDED */
	  if (*stage1) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      sum = 0.;
	      i__4 = *n;
	      for (j = 1; j <= i__4; ++j) {
	        /* L623: */
	        sum += fmas[i__ + j * fmas_dim1] * ynew[j];
	      }
	      /* L624: */
	      ak[i__] += sum;
	    }
	    solb(n, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &ak[1], &ip[1]);
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* slvrod_ */
2b1477999008756294d34bbd02c61598|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|71|1|V|cpp
	/*     END OF SUBROUTINE SLVROD */
2e11b5995fb5a0dc70480964ca377a56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|71|1|V|cpp
	
	/* *********************************************************** */
64d0b4b672d8de0ce23ddb9f137454ce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/dc_decsol.hpp|76|1|V|cpp
	{
	  /* System generated locals */
	  int fjac_dim1, fjac_offset, fmas_dim1, fmas_offset, e_dim1, e_offset, i__1,
	      i__2, i__3, i__4, i__5, i__6;
	
	  /* Local variables */
	  int i__, j, k, mm, mp, im1, mp1, jkm, mmm;
	  double sum;
	  double zsafe;
	
	  /* Parameter adjustments */
	  --del;
	  --iphes;
	  fjac_dim1 = *ldjac;
	  fjac_offset = 1 + fjac_dim1;
	  fjac -= fjac_offset;
	  --ip;
	  fmas_dim1 = *ldmas;
	  fmas_offset = 1 + fmas_dim1;
	  fmas -= fmas_offset;
	  e_dim1 = *lde;
	  e_offset = 1 + e_dim1;
	  e -= e_offset;
	
	  /* Function Body */
	  switch (*ijob) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L2;
	  case 3:
	    goto L1;
	  case 4:
	    goto L2;
	  case 5:
	    goto L1;
	  case 6:
	    goto L55;
	  case 7:
	    goto L7;
	  case 8:
	    goto L55;
	  case 9:
	    goto L55;
	  case 10:
	    goto L55;
	  case 11:
	    goto L11;
	  case 12:
	    goto L12;
	  case 13:
	    goto L11;
	  case 14:
	    goto L12;
	  case 15:
	    goto L11;
	  }
	
	  /* ----------------------------------------------------------- */
	
	L1:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX */
	  sol(n, lde, &e[e_offset], &del[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L11:
	  /* ---  B=IDENTITY, JACOBIAN A FULL MATRIX, SECOND ORDER */
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum = (del[jkm] + sum) / *fac1;
	      i__2 = *nm1;
	      for (i__ = 1; i__ <= i__2; ++i__) {
	        im1 = i__ + *m1;
	        del[im1] += fjac[i__ + jkm * fjac_dim1] * sum;
	      }
	    }
	  }
	  sol(nm1, lde, &e[e_offset], &del[*m1 + 1], &ip[1]);
	  for (i__ = *m1; i__ >= 1; --i__) {
	    del[i__] = (del[i__] + del[*m2 + i__]) / *fac1;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L2:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX */
	  solb(n, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &del[1], &ip[1]);
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L12:
	  /* ---  B=IDENTITY, JACOBIAN A BANDED MATRIX, SECOND ORDER */
	  mm = *m1 / *m2;
	  i__1 = *m2;
	  for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
	    for (k = mm - 1; k >= 0; --k) {
	      jkm = j + k * *m2;
	      sum = (del[jkm] + sum) / *fac1;
	      /* Computing MAX */
	      i__2 = 1, i__3 = j - *mujac;
	      /* Computing MIN */
	      i__5 = *nm1, i__6 = j + *mljac;
	      i__4 = std::min(i__5, i__6);
	      for (i__ = std::max(i__2, i__3); i__ <= i__4; ++i__) {
	        im1 = i__ + *m1;
	        del[im1] += fjac[i__ + *mujac + 1 - j + jkm * fjac_dim1] * sum;
	      }
	    }
	  }
	  solb(nm1, lde, &e[e_offset], &linal_1.mle, &linal_1.mue, &del[*m1 + 1],
	       &ip[1]);
	  for (i__ = *m1; i__ >= 1; --i__) {
	    del[i__] = (del[i__] + del[*m2 + i__]) / *fac1;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L7:
	  /* ---  HESSENBERG OPTION */
	  for (mmm = *n - 2; mmm >= 1; --mmm) {
	    mp = *n - mmm;
	    mp1 = mp - 1;
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L110;
	    }
	    zsafe = del[mp];
	    del[mp] = del[i__];
	    del[i__] = zsafe;
	  L110:
	    i__1 = *n;
	    for (i__ = mp + 1; i__ <= i__1; ++i__) {
	      del[i__] -= fjac[i__ + mp1 * fjac_dim1] * del[mp];
	    }
	  }
	  solh(n, lde, &e[e_offset], &c__1, &del[1], &ip[1]);
	  i__1 = *n - 2;
	  for (mmm = 1; mmm <= i__1; ++mmm) {
	    mp = *n - mmm;
	    mp1 = mp - 1;
	    i__4 = *n;
	    for (i__ = mp + 1; i__ <= i__4; ++i__) {
	      del[i__] += fjac[i__ + mp1 * fjac_dim1] * del[mp];
	    }
	    i__ = iphes[mp];
	    if (i__ == mp) {
	      goto L240;
	    }
	    zsafe = del[mp];
	    del[mp] = del[i__];
	    del[i__] = zsafe;
	  L240:;
	  }
	  return 0;
	
	  /* ----------------------------------------------------------- */
	
	L55:
	  return 0;
	} /* slvseu_ */
4b4d615879ce1044dd092f39f5018a10|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/function.hpp|4|1|V|cpp
	#include "stiff/vector_matrix.hpp"
10f7e809b19fd2b64a9697aeeccaedec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|233|1|V|cpp
	{
	  /* System generated locals */
	  double d__1, d__2;
	
	  /* Local variables */
	  double sq6, st9, bet, alp, cno;
	
	  /* Parameter adjustments */
	  --beta;
	  --alph;
	  --dd;
	
	  /* Function Body */
	  c__[0] = 0.;
	  c__[*ns] = 1.;
	  switch (*ns) {
	  case 1:
	    goto L1;
	  case 2:
	    goto L11;
	  case 3:
	    goto L3;
	  case 4:
	    goto L11;
	  case 5:
	    goto L5;
	  case 6:
	    goto L11;
	  case 7:
	    goto L7;
	  }
	L11:
	  return 0;
	L1:
	  c__[1] = 1.;
	  *u1 = 1.;
	  dd[1] = -1.;
	  return 0;
	L3:
	  sq6 = sqrt(6.);
	  c__[1] = (4. - sq6) / 10.;
	  c__[2] = (sq6 + 4.) / 10.;
	  st9 = pow(c_b140, c_b141);
	  *u1 = (st9 * (st9 - 1) + 6.) / 30.;
	  alp = (12. - st9 * (st9 - 1)) / 60.;
	  bet = st9 * (st9 + 1) * sqrt(3.0) / 60.;
	  /* Computing 2nd power */
	  d__1 = alp;
	  /* Computing 2nd power */
	  d__2 = bet;
	  cno = d__1 * d__1 + d__2 * d__2;
	  *u1 = 1. / *u1;
	  alph[1] = alp / cno;
	  beta[1] = bet / cno;
	  return 0;
	L5:
	  c__[1] = .05710419611451768219312;
	  c__[2] = .27684301363812382768;
	  c__[3] = .5835904323689168200567;
	  c__[4] = .8602401356562194478479;
	  dd[1] = -27.78093394406463730479;
	  dd[2] = 3.641478498049213152712;
	  dd[3] = -1.252547721169118720491;
	  dd[4] = .5920031671845428725662;
	  dd[5] = -.2;
	  *u1 = 6.286704751729276645173;
	  alph[1] = 3.655694325463572258243;
	  beta[1] = 6.543736899360077294021;
	  alph[2] = 5.70095329867178941917;
	  beta[2] = 3.210265600308549888425;
	  return 0;
	L7:
	  c__[1] = .02931642715978489197205;
	  c__[2] = .14807859966848429185;
	  c__[3] = .3369846902811542990971;
	  c__[4] = .5586715187715501320814;
	  c__[5] = .7692338620300545009169;
	  c__[6] = .9269456713197411148519;
	  dd[1] = -54.37443689412861451458;
	  dd[2] = 7.000024004259186512041;
	  dd[3] = -2.355661091987557192256;
	  dd[4] = 1.132289066106134386384;
	  dd[5] = -.6468913267673587118673;
	  dd[6] = .3875333853753523774248;
	  dd[7] = -.1428571428571428571429;
	  *u1 = 8.936832788405216337302;
	  alph[1] = 4.378693561506806002523;
	  beta[1] = 10.16969328379501162732;
	  alph[2] = 7.141055219187640105775;
	  beta[2] = 6.623045922639275970621;
	  alph[3] = 8.511834825102945723051;
	  beta[3] = 3.281013624325058830036;
	  return 0;
	} /* coercv_ */
9ba956fbd443922256978170abb6206b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|234|1|V|cpp
	/*     END OF SUBROUTINE COERCV */
	
	/* *********************************************************** */
bfbc142658990b436dbbc492b95981f9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|236|1|V|cpp
	{
	  /* System generated locals */
	  double ret_val;
	
	  /* Local variables */
	  int k;
	  double s;
	
	  /* ---------------------------------------------------------- */
	  /*     THIS FUNCTION CAN BE USED FOR CONINUOUS OUTPUT. IT PROVIDES AN */
	  /*     APPROXIMATION TO THE I-TH COMPONENT OF THE SOLUTION AT X. */
	  /*     IT GIVES THE VALUE OF THE COLLOCATION POLYNOMIAL, DEFINED FOR */
	  /*     THE LAST SUCCESSFULLY COMPUTED STEP (BY RADAU). */
	  /* ---------------------------------------------------------- */
	  /* Parameter adjustments */
	  --cont;
	
	  /* Function Body */
	  s = (*x - weight_2.xsol) / weight_2.hsol + 1.;
	  ret_val = cont[*i__ + weight_2.ns * weight_2.nn];
	  for (k = weight_2.ns - 1; k >= 0; --k) {
	    ret_val = cont[*i__ + k * weight_2.nn] +
	              (s - weight_2.c__[weight_2.ns - k]) * ret_val;
	  }
	  return ret_val;
	} /* contra_ */
4e7a7153309809cb21bb4fe019a2e9db|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|237|1|V|cpp
	/*     END OF SUBROUTINE RADAU */
	
	/* *********************************************************** */
f9811fc0f6fa04948cacc1f678e4b3e0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|258|1|V|cpp
	{
	  /* System generated locals */
	  int i__1;
	
	  /* Local variables */
	  int i__, m1, m2, ns, nm1, iee, nit, nns, iee1, lde1, iey0;
	  double facl;
	  int ndec, njac;
	  double facr;
	  int ieff;
	  double safe, hhod;
	  int ijob, nfcn, nmee;
	  bool pred;
	  double hmax;
	  int nmax;
	  double thet, vitd, hhou;
	  int nsol, iezz;
	  double vitu;
	  int nsus, ieip1, ieip2, nind1, nind2, nind3, nm1ns;
	  double quot1, quot2;
	  int iejac, ldjac;
	  bool jband;
	  int iecon, iemas, ldmas, ieiph;
	  bool arret;
	  int nsmin, nsmax, nstep, ldmas2, iescal, naccpt;
	  int nrejct;
	  bool implct;
	  int istore;
	  bool startn;
	  double uround;
	
	  /* *** *** *** *** *** *** *** *** *** *** *** *** *** */
	  /*          DECLARATIONS */
	  /* *** *** *** *** *** *** *** *** *** *** *** *** *** */
	  /* *** *** *** *** *** *** *** */
	  /*        SETTING THE PARAMETERS */
	  /* *** *** *** *** *** *** *** */
	  /* Parameter adjustments */
	  --y;
	  --rtol;
	  --atol;
	  --work;
	  --iwork;
	
	  /* Function Body */
	  nfcn = 0;
	  njac = 0;
	  nstep = 0;
	  naccpt = 0;
	  nrejct = 0;
	  ndec = 0;
	  nsol = 0;
	  arret = false;
	  /* -------- NUMBER MAXIMAL AND MINIMAL OF STAGES  NS */
	  if (iwork[11] == 0) {
	    nsmin = 3;
	  } else {
	    nsmin = std::max(1, iwork[11]);
	    if (iwork[11] >= 2) {
	      nsmin = std::max(3, iwork[11]);
	    }
	    if (iwork[11] >= 4) {
	      nsmin = std::max(5, iwork[11]);
	    }
	    if (iwork[11] >= 6) {
	      nsmin = 7;
	    }
	  }
	  if (iwork[12] == 0) {
	    nsmax = 7;
	  } else {
	    nsmax = std::min(7, iwork[12]);
	    if (iwork[12] <= 6) {
	      nsmax = std::min(5, iwork[12]);
	    }
	    if (iwork[12] <= 4) {
	      nsmax = std::min(3, iwork[12]);
	    }
	    if (iwork[12] <= 2) {
	      nsmax = 1;
	    }
	  }
	  ns = nsmax;
	  if (iwork[13] == 0) {
	    nsus = nsmin;
	  } else {
	    nsus = iwork[13];
	    if (nsus <= 0 || ns >= 8 || ns == 2 || ns == 4 || ns == 6) {
	      fmt::print("Wrong input: iwork(13) = {}\n", iwork[13]);
	      arret = true;
	    }
	  }
	  /* -------- NMAX , THE MAXIMAL NUMBER OF STEPS ----- */
	  if (iwork[2] == 0) {
	    nmax = 100000;
	  } else {
	    nmax = iwork[2];
	    if (nmax <= 0) {
	      fmt::print("Wrong input: iwork(2) = {}\n", iwork[2]);
	      arret = true;
	    }
	  }
	  /* -------- NIT    MAXIMAL NUMBER OF NEWTON ITERATIONS */
	  if (iwork[3] == 0) {
	    nit = 7;
	  } else {
	    nit = iwork[3];
	    if (nit <= 0 || nit > 50) {
	      fmt::print("Curious input: iwork(3) = {}\n", iwork[3]);
	      arret = true;
	    }
	  }
	  /* -------- STARTN  SWITCH FOR STARTING VALUES OF NEWTON ITERATIONS */
	  if (iwork[4] == 0) {
	    startn = false;
	  } else {
	    startn = true;
	  }
	  /* -------- PARAMETER FOR DIFFERENTIAL-ALGEBRAIC COMPONENTS */
	  nind1 = iwork[5];
	  nind2 = iwork[6];
	  nind3 = iwork[7];
	  if (nind1 == 0) {
	    nind1 = *n;
	  }
	  if (nind1 + nind2 + nind3 != *n) {
	    fmt::print("Curious input: iwork(5,6,7) = {}, {}, {}\n", nind1, nind2,
	               nind3);
	    arret = true;
	  }
	  /* -------- PRED   STEP SIZE CONTROL */
	  if (iwork[8] <= 1) {
	    pred = true;
	  } else {
	    pred = false;
	  }
	  /* -------- PARAMETER FOR SECOND ORDER EQUATIONS */
	  m1 = iwork[9];
	  m2 = iwork[10];
	  nm1 = *n - m1;
	  if (m1 == 0) {
	    m2 = *n;
	  }
	  if (m2 == 0) {
	    m2 = m1;
	  }
	  if (m1 < 0 || m2 < 0 || m1 + m2 > *n) {
	    fmt::print("Curious input: iwork(9,10) = {}, {}\n", m1, m2);
	    arret = true;
	  }
	  /* -------- UROUND   SMALLEST NUMBER SATISFYING 1.0D0+UROUND>1.0D0 */
	  if (work[1] == 0.) {
	    uround = 1e-16;
	  } else {
	    uround = work[1];
	    if (uround <= 1e-19 || uround >= 1.) {
	      fmt::print("Coefficients have 20 digits, uround = {}\n", work[1]);
	      arret = true;
	    }
	  }
	  /* --------- CHECK IF TOLERANCES ARE O.K. */
	  if (*itol == 0) {
	    if (atol[1] <= 0. || rtol[1] <= uround * 10.) {
	      fmt::print("Tolerances are too small\n");
	      arret = true;
	    }
	  } else {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
	      if (atol[i__] <= 0. || rtol[i__] <= uround * 10.) {
	        fmt::print("Tolerances({}) are too small\n", i__);
	        arret = true;
	      }
	    }
	  }
	  /* --------- SAFE     SAFETY FACTOR IN STEP SIZE PREDICTION */
	  if (work[2] == 0.) {
	    safe = .9;
	  } else {
	    safe = work[2];
	    if (safe <= .001 || safe >= 1.) {
	      fmt::print("Curious input for work(2) = {}", work[2]);
	      arret = true;
	    }
	  }
	  /* ------ THET     DECIDES WHETHER THE JACOBIAN SHOULD BE RECOMPUTED; */
	  if (work[3] == 0.) {
	    thet = .001;
	  } else {
	    thet = work[3];
	    if (thet >= 1.) {
	      fmt::print("Curious input for work(3) = {}", work[3]);
	      arret = true;
	    }
	  }
	  /* --- QUOT1 AND QUOT2: IF QUOT1 < HNEW/HOLD < QUOT2, STEP SIZE = CONST. */
	  if (work[5] == 0.) {
	    quot1 = 1.;
	  } else {
	    quot1 = work[5];
	  }
	  if (work[6] == 0.) {
	    quot2 = 1.2;
	  } else {
	    quot2 = work[6];
	  }
	  if (quot1 > 1. || quot2 < 1.) {
	    fmt::print("Curious input for work(5,6) = {}, {}", work[5], work[6]);
	    arret = true;
	  }
	  /* -------- MAXIMAL STEP SIZE */
	  if (work[7] == 0.) {
	    hmax = *xend - *x;
	  } else {
	    hmax = work[7];
	  }
	  /* -------  FACL,FACR     PARAMETERS FOR STEP SIZE SELECTION */
	  if (work[8] == 0.) {
	    facl = 5.;
	  } else {
	    facl = 1. / work[8];
	  }
	  if (work[9] == 0.) {
	    facr = .125;
	  } else {
	    facr = 1. / work[9];
	  }
	  if (facl < 1. || facr > 1.) {
	    fmt::print("Curious input for work(8,9) = {}, {}", work[8], work[9]);
	    arret = true;
	  }
	  /* -------- PARAMETERS FOR ORDER SELECTION STRATEGY */
	  if (work[10] == 0.) {
	    vitu = .002;
	  } else {
	    vitu = work[10];
	  }
	  if (work[11] == 0.) {
	    vitd = .8;
	  } else {
	    vitd = work[11];
	  }
	  if (work[12] == 0.) {
	    hhou = 1.2;
	  } else {
	    hhou = work[12];
	  }
	  if (work[13] == 0.) {
	    hhod = .8;
	  } else {
	    hhod = work[13];
	  }
	  /* *** *** *** *** *** *** *** *** *** *** *** *** *** */
	  /*         COMPUTATION OF ARRAY ENTRIES */
	  /* *** *** *** *** *** *** *** *** *** *** *** *** *** */
	  /* ---- IMPLICIT, BANDED OR NOT ? */
	  implct = *imas != 0;
	  jband = *mljac < nm1;
	  /* -------- COMPUTATION OF THE ROW-DIMENSIONS OF THE 2-ARRAYS --- */
	  /* -- JACOBIAN  AND  MATRICES E1, E2 */
	  if (jband) {
	    ldjac = *mljac + *mujac + 1;
	    lde1 = *mljac + ldjac;
	  } else {
	    *mljac = nm1;
	    *mujac = nm1;
	    ldjac = nm1;
	    lde1 = nm1;
	  }
	  /* -- MASS MATRIX */
	  if (implct) {
	    if (*mlmas != nm1) {
	      ldmas = *mlmas + *mumas + 1;
	      if (jband) {
	        ijob = 4;
	      } else {
	        ijob = 3;
	      }
	    } else {
	      ldmas = nm1;
	      ijob = 5;
	    }
	    /* ------ BANDWITH OF "MAS" NOT SMALLER THAN BANDWITH OF "JAC" */
	    if (*mlmas > *mljac || *mumas > *mujac) {
	      fmt::print("Bandwidth of mass not smaller than bandwidth of jac\n");
	      arret = true;
	    }
	  } else {
	    ldmas = 0;
	    if (jband) {
	      ijob = 2;
	    } else {
	      ijob = 1;
	      if (*n > 2 && iwork[1] != 0) {
	        ijob = 7;
	      }
	    }
	  }
	  ldmas2 = std::max(1, ldmas);
	  /* ------ HESSENBERG OPTION ONLY FOR EXPLICIT EQU. WITH FULL JACOBIAN */
	  if ((implct || jband) && ijob == 7) {
	    fmt::print(
	        "Hessenberg option only for explicit equations with full jacobian\n");
	    arret = true;
	  }
	  /* ------- PREPARE THE ENTRY-POINTS FOR THE ARRAYS IN WORK ----- */
	  nns = ns * *n;
	  nm1ns = ns * nm1;
	  nmee = (ns - 1) * nm1;
	  iezz = 21;
	  iey0 = iezz + nns;
	  iescal = iey0 + *n;
	  ieff = iescal + *n;
	  iecon = ieff + nns;
	  iejac = iecon + nns + *n;
	  iemas = iejac + *n * ldjac;
	  iee1 = iemas + nm1 * ldmas;
	  iee = iee1 + nm1 * lde1;
	  /* ------ TOTAL STORAGE REQUIREMENT ----------- */
	  istore = iee + nmee * lde1 - 1;
	  if (istore > *lwork) {
	    fmt::print("Insufficient storage for work, min, lwork = {}\n", istore);
	    arret = true;
	  }
	  /* ------- ENTRY POINTS FOR INTEGER WORKSPACE ----- */
	  ieip1 = 21;
	  ieip2 = ieip1 + nm1;
	  ieiph = ieip2 + nm1 * (ns - 1) / 2;
	  /* --------- TOTAL REQUIREMENT --------------- */
	  istore = ieiph + nm1 - 1;
	  if (istore > *liwork) {
	    fmt::print("Insufficient storage for iwork, min, liwork = {}\n", istore);
	    arret = true;
	  }
	  /* ------ WHEN A FAIL HAS OCCURED, WE RETURN WITH IDID=-1 */
	  if (arret) {
	    *idid = -1;
	    return 0;
	  }
	  /* -------- CALL TO CORE INTEGRATOR ------------ */
	  radcov(n, fcn, x, &y[1], xend, &hmax, h__, &rtol[1], &atol[1], itol, &nsus,
	         jac, ijac, mljac, mujac, mas, mlmas, mumas, solout, iout, idid, &nmax,
	         &uround, &safe, &thet, &quot1, &quot2, &nit, &ijob, &startn, &nind1,
	         &nind2, &nind3, &pred, &facl, &facr, &m1, &m2, &nm1, &nsmin, &ns, &nns,
	         &nm1ns, &nmee, &implct, &jband, &ldjac, &lde1, &ldmas2, &work[iezz],
	         &work[iey0], &work[iescal], &work[ieff], &work[iejac], &work[iee1],
	         &work[iee], &work[iemas], &work[iecon], &iwork[ieip1], &iwork[ieip2],
	         &iwork[ieiph], &vitu, &vitd, &hhou, &hhod, &nfcn, &njac, &nstep,
	         &naccpt, &nrejct, &ndec, &nsol);
	  iwork[13] = nsus;
	  iwork[14] = nfcn;
	  iwork[15] = njac;
	  iwork[16] = nstep;
	  iwork[17] = naccpt;
	  iwork[18] = nrejct;
	  iwork[19] = ndec;
	  iwork[20] = nsol;
	  return 0;
	}
0657250ac0951891fe5422ff21d24fc8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/radau.hpp|67|1|V|cpp
	{
	  /* --- */
	  coe3_1.t311 = .09123239487089294279155;
	  coe3_1.t312 = -.141255295020954208428;
	  coe3_1.t313 = -.03002919410514742449186;
	  coe3_1.t321 = .2417179327071070189575;
	  coe3_1.t322 = .204129352293799931996;
	  coe3_1.t323 = .3829421127572619377954;
	  coe3_1.t331 = .9660481826150929361906;
	  coe3_1.ti311 = 4.325579890063155351024;
	  coe3_1.ti312 = .3391992518158098695428;
	  coe3_1.ti313 = .5417705399358748711865;
	  coe3_1.ti321 = -4.178718591551904727346;
	  coe3_1.ti322 = -.3276828207610623870825;
	  coe3_1.ti323 = .4766235545005504519601;
	  coe3_1.ti331 = -.5028726349457868759512;
	  coe3_1.ti332 = 2.571926949855605429187;
	  coe3_1.ti333 = -.5960392048282249249688;
	  if (*nsmax <= 3) {
	    return 0;
	  }
	  coe5_1.t511 = -.01251758622050104589014;
	  coe5_1.t512 = -.01024204781790882707009;
	  coe5_1.t513 = .04767387729029572386318;
	  coe5_1.t514 = -.01147851525522951470794;
	  coe5_1.t515 = -.01401985889287541028108;
	  coe5_1.t521 = -.001491670151895382429004;
	  coe5_1.t522 = .05017286451737105816299;
	  coe5_1.t523 = -.09433181918161143698066;
	  coe5_1.t524 = -.007668830749180162885157;
	  coe5_1.t525 = .02470857842651852681253;
	  coe5_1.t531 = -.07298187638808714862266;
	  coe5_1.t532 = -.2305395340434179467214;
	  coe5_1.t533 = .1027030453801258997922;
	  coe5_1.t534 = .01939846399882895091122;
	  coe5_1.t535 = .08180035370375117083639;
	  coe5_1.t541 = -.3800914400035681041264;
	  coe5_1.t542 = .3778939022488612495439;
	  coe5_1.t543 = .4667441303324943592896;
	  coe5_1.t544 = .4076011712801990666217;
	  coe5_1.t545 = .1996824278868025259365;
	  coe5_1.t551 = -.9219789736812104884883;
	  coe5_1.ti511 = -30.04156772154440162771;
	  coe5_1.ti512 = -13.86510785627141316518;
	  coe5_1.ti513 = -3.480002774795185561828;
	  coe5_1.ti514 = 1.032008797825263422771;
	  coe5_1.ti515 = -.8043030450739899174753;
	  coe5_1.ti521 = 5.344186437834911598895;
	  coe5_1.ti522 = 4.593615567759161004454;
	  coe5_1.ti523 = -3.036360323459424298646;
	  coe5_1.ti524 = 1.05066019023145886386;
	  coe5_1.ti525 = -.2727786118642962705386;
	  coe5_1.ti531 = 3.748059807439804860051;
	  coe5_1.ti532 = -3.984965736343884667252;
	  coe5_1.ti533 = -1.044415641608018792942;
	  coe5_1.ti534 = 1.184098568137948487231;
	  coe5_1.ti535 = -.4499177701567803688988;
	  coe5_1.ti541 = -33.04188021351900000806;
	  coe5_1.ti542 = -17.37695347906356701945;
	  coe5_1.ti543 = -.1721290632540055611515;
	  coe5_1.ti544 = -.09916977798254264258817;
	  coe5_1.ti545 = .5312281158383066671849;
	  coe5_1.ti551 = -8.6114439798752919777;
	  coe5_1.ti552 = 9.699991409528808231336;
	  coe5_1.ti553 = 1.914728639696874284851;
	  coe5_1.ti554 = 2.418692006084940026427;
	  coe5_1.ti555 = -1.047463487935337418694;
	  if (*nsmax <= 5) {
	    return 0;
	  }
	  coe7_1.t711 = -.002153754627310526422828;
	  coe7_1.t712 = .02156755135132077338691;
	  coe7_1.t713 = .008783567925144144407326;
	  coe7_1.t714 = -.004055161452331023898198;
	  coe7_1.t715 = .004427232753268285479678;
	  coe7_1.t716 = -.001238646187952874056377;
	  coe7_1.t717 = -.002760617480543852499548;
	  coe7_1.t721 = .001600025077880428526831;
	  coe7_1.t722 = -.03813164813441154669442;
	  coe7_1.t723 = -.02152556059400687552385;
	  coe7_1.t724 = .008415568276559589237177;
	  coe7_1.t725 = -.004031949570224549492304;
	  coe7_1.t726 = -6.666635339396338181761e-5;
	  coe7_1.t727 = .003185474825166209848748;
	  coe7_1.t731 = -.00405910730194768309165;
	  coe7_1.t732 = .05739650893938171539757;
	  coe7_1.t733 = .05885052920842679105612;
	  coe7_1.t734 = -.008560431061603432060177;
	  coe7_1.t735 = -.006923212665023908924141;
	  coe7_1.t736 = -.002352180982943338340535;
	  coe7_1.t737 = 4.169077725297562691409e-4;
	  coe7_1.t741 = -.01575048807937684420346;
	  coe7_1.t742 = -.03821469359696835048464;
	  coe7_1.t743 = -.1657368112729438512412;
	  coe7_1.t744 = -.03737124230238445741907;
	  coe7_1.t745 = .008239007298507719404499;
	  coe7_1.t746 = .003115071152346175252726;
	  coe7_1.t747 = .02511660491343882192836;
	  coe7_1.t751 = -.1129776610242208076086;
	  coe7_1.t752 = -.2491742124652636863308;
	  coe7_1.t753 = .2735633057986623212132;
	  coe7_1.t754 = .005366761379181770094279;
	  coe7_1.t755 = .1932111161012620144312;
	  coe7_1.t756 = .1017177324817151468081;
	  coe7_1.t757 = .09504502035604622821039;
	  coe7_1.t761 = -.4583810431839315010281;
	  coe7_1.t762 = .5315846490836284292051;
	  coe7_1.t763 = .4863228366175728940567;
	  coe7_1.t764 = .5265742264584492629141;
	  coe7_1.t765 = .2755343949896258141929;
	  coe7_1.t766 = .5217519452747652852946;
	  coe7_1.t767 = .1280719446355438944141;
	  coe7_1.t771 = -.8813915783538183763135;
	  coe7_1.ti711 = -258.1319263199822292761;
	  coe7_1.ti712 = -189.073763081398508952;
	  coe7_1.ti713 = -49.08731481793013119445;
	  coe7_1.ti714 = -4.110647469661428418112;
	  coe7_1.ti715 = -4.053447889315563304175;
	  coe7_1.ti716 = 3.112755366607346076554;
	  coe7_1.ti717 = -1.646774913558444650169;
	  coe7_1.ti721 = -3.007390169451292131731;
	  coe7_1.ti722 = -11.01586607876577132911;
	  coe7_1.ti723 = 1.487799456131656281486;
	  coe7_1.ti724 = 2.130388159559282459432;
	  coe7_1.ti725 = -1.816141086817565624822;
	  coe7_1.ti726 = 1.134325587895161100083;
	  coe7_1.ti727 = -.414699045943303531993;
	  coe7_1.ti731 = -8.441963188321084681757;
	  coe7_1.ti732 = -.6505252740575150028169;
	  coe7_1.ti733 = 6.940670730369876478804;
	  coe7_1.ti734 = -3.205047525597898431565;
	  coe7_1.ti735 = 1.071280943546478589783;
	  coe7_1.ti736 = -.354850749121622187973;
	  coe7_1.ti737 = .09198549132786554154409;
	  coe7_1.ti741 = 74.67833223502269977153;
	  coe7_1.ti742 = 87.40858897990081640204;
	  coe7_1.ti743 = 4.024158737379997877014;
	  coe7_1.ti744 = -3.714806315158364186639;
	  coe7_1.ti745 = -3.430093985982317350741;
	  coe7_1.ti746 = 2.696604809765312378853;
	  coe7_1.ti747 = -.9386927436075461933568;
	  coe7_1.ti751 = 58.35652885190657724237;
	  coe7_1.ti752 = -10.06877395780018096325;
	  coe7_1.ti753 = -30.36638884256667120811;
	  coe7_1.ti754 = -1.020020865184865985027;
	  coe7_1.ti755 = -.1124175003784249621267;
	  coe7_1.ti756 = 1.8906408310003776228;
	  coe7_1.ti757 = -.9716486393831482282172;
	  coe7_1.ti761 = -299.1862480282520966786;
	  coe7_1.ti762 = -243.0407453687447911819;
	  coe7_1.ti763 = -48.77710407803786921219;
	  coe7_1.ti764 = -2.03867190574193440528;
	  coe7_1.ti765 = 1.673560239861084944268;
	  coe7_1.ti766 = -1.087374032057106164456;
	  coe7_1.ti767 = .9019382492960993738427;
	  coe7_1.ti771 = -93.07650289743530591157;
	  coe7_1.ti772 = 23.88163105628114427703;
	  coe7_1.ti773 = 39.2788807308138438271;
	  coe7_1.ti774 = 14.38891568549108006988;
	  coe7_1.ti775 = -3.510438399399361221087;
	  coe7_1.ti776 = 4.863284885566180701215;
	  coe7_1.ti777 = -2.2464827295912399164;
	  return 0;
	}
9c1725f04e04909da3b91e8cd9317920|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|142|1|V|cpp
	void DarkSun::solve_boltzmann(double *model, double reltol, double abstol) {
	  gsl_set_error_handler_off();
	
	  // Initial conditions
	  double meta = m_eta(model);
	  double td = get_lam(model) / 2.0;           // Start Td at confinement
	  double xi = compute_xi_const_td(td, model); // Starting value of xi
	  double tsm = td / xi;                       // Initial SM temperature
	  double log_xstart = log(meta / tsm);        // Log of initial x
	  double log_xfinal = log(meta / T_CMB);      // Log of final x (end at CMB)
	
	  constexpr int ndim = 2;
	  double y[ndim];
	  y[0] = weq_eta(tsm, xi, model); // log(Y_eta)
	#ifdef FULL_BOLTZ
	  // In the case of FULL_BOLTZ, we will use w_del instead of y_del
	  y[1] = -get_adel(model) * get_n(model) + weq_del(tsm, xi, model);
	#else
	  y[1] = exp(-get_adel(model) * get_n(model)) * yeq_del(tsm, xi, model);
	#endif
	
	  double dlogx = (log_xfinal - log_xstart) / 100.0;
	
	  constexpr int nd = 2;     // dimension of the system
	  constexpr int ns = 7;     // maximum number of allowed stages
	  constexpr int ijac = 1;   // analytic jacobian
	  constexpr int mljac = nd; // full jacaobian
	  constexpr int mujac = 0;  // full jacaobian
	  constexpr int imas = 0;   // no mass matrix
	  constexpr int mlmas = 0;  // no mass matrix
	  constexpr int mumas = 0;  // no mass matrix
	
	  // Length of `work`
	  constexpr int lwork = (ns + 1) * nd * nd + (3 * ns + 3) * nd + 20;
	  // Length of `iwork`
	  constexpr int liwork = (2 + (ns - 1) / 2) * nd + 20;
	  std::vector<double> work(lwork); // Workspace of doubles needed for radau
	  std::vector<int> iwork(liwork);  // Workspace of ints needed for radau
	  for (int i = 0; i < 20; i++) {   // Set all radau params to defaults
	    iwork[i] = 0;
	    work[i] = 0.0;
	  }
	
	  int idid;                 // Flag for radau return code
	  double rtol = 1.0e-7;     // Relative tolerance for radau
	  double atol = 1.0 * rtol; // Absolute tolerance for radau
	  int itol = 0;             // Flag telling radau we are using scalar tols
	  double h = 1.0e-6;        // Initial step size
	  int iout = 1;             // Have radau call `solout`
	  int ipar = 0;
	
	  model[Dx] = (log_xfinal - log_xstart) / double(DarkSun::NUM_SOLS - 1);
	
	  // Extract the model parameters and put then in rpar and ipar
	  radau(nd, boltzmann, log_xstart, y, log_xfinal, h, rtol, atol, boltzmann_jac,
	        ijac, mljac, mujac, mm, imas, mlmas, mumas, solout, iout, work.data(),
	        iwork.data(), model, &ipar, &idid);
	  // Save last state
	  set_sol_boltz(DarkSun::NUM_SOLS - 1, log_xfinal, y[0], y[1], model);
	
	  if (idid > 0) {
	    set_rd_eta(model, m_eta(model) * exp(y[0]) * S_TODAY / RHO_CRIT);
	#ifdef FULL_BOLTZ
	    set_rd_del(model, m_del(model) * exp(y[1]) * S_TODAY / RHO_CRIT);
	#else
	    set_rd_del(model, m_del(model) * y[1] * S_TODAY / RHO_CRIT);
	#endif
	    set_xi_cmb(model, compute_xi_const_tsm(T_CMB, model));
	    set_xi_bbn(model, compute_xi_const_tsm(T_BBN, model));
	    set_dneff_bbn(model, compute_dneff_bbn(model));
	    set_dneff_cmb(model, compute_dneff_cmb(model));
	    set_eta_si_per_mass(model, cross_section_2eta_2eta(model) / m_eta(model));
	    set_del_si_per_mass(model, cross_section_2del_2del(model) / m_del(model));
	  } else {
	    set_rd_eta(model, NAN);
	    set_rd_del(model, NAN);
	    set_xi_cmb(model, NAN);
	    set_xi_bbn(model, NAN);
	    set_dneff_bbn(model, NAN);
	    set_dneff_cmb(model, NAN);
	    set_eta_si_per_mass(model, NAN);
	    set_del_si_per_mass(model, NAN);
	  }
	}
405222e834faf537bda988cf48490de5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|325|1|V|cpp
	  static void solve_boltzmann(double *model, double reltol, double abstol);
293ed16cdd3c365c9787078fef2a09fb|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|333|1|V|cpp
	  static void boltzmann(int *n, double *x, double *y, double *dy, double *model,
	                        int *ipar);
eedf02300e602d011391d0719bce826e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|336|25|v|cpp
	int *ipar
1bfa762895c11f8e7217f6de4e196f53|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|337|1|V|cpp
	  static void boltzmann_jac(int *n, double *x, double *y, double *df, int *ldy,
	                            double *model, int *ipar);
fa4575ddf9b3a65bbd100ac520d81e36|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|339|79|v|cpp
	,
	                            double *model, int *ipar
469d70b939263d15a514fadb2dc268d2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|344|1|V|cpp
	  static void solout(int *nr, double *xold, double *x, double *y, double *cont,
	                     int *lrc, int *n, int *irtrn);
129f8b308a94138aeeb9099d01508450|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|339|1|V|cpp
	  static void boltzmann_jac(int *n, double *x, double *y, double *df, int *ldy);
465e2a6098a2dfcc120841473185f133|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|335|1|V|cpp
	  static void boltzmann(int *n, double *x, double *y, double *dy);
a79cfd1c4c49765a3f72b657162f794f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|279|1|V|cpp
	  auto boltz = [](){};
b5874e014741aa7ca75aab293bcc9ed4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|295|28|v|cpp
	, &ipar, &idid
4037ca0d02072f2c32d922fbc2375801|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|12|1|V|cpp
	  auto model = DarkSun::new_vec(30, 2e-3);
	  DarkSun::set_lec1(model.data(), 0.1);
	  DarkSun::set_lec2(model.data(), 1.0);
	
	  DarkSun::solve_boltzmann(model.data(), 1e-7, 1e-7);
	
	  // Solve the model using c++ Radau
	  auto sol = DarkSun::get_sol_boltz(model.data());
	
	  for (size_t i = 0; i < sol.size(); i++) {
	    fmt::print("[{}, {}, {}],\n", sol[i][0], sol[i][1], sol[i][2]);
	  }
	
	  fmt::print("xi fo={}\n", DarkSun::get_xi_fo(model.data()));
	  fmt::print("tsm fo={}\n", DarkSun::get_tsm_fo(model.data()));
	  fmt::print("xd fo={}\n",
	             DarkSun::m_eta(model.data()) / (DarkSun::get_tsm_fo(model.data()) *
	                                             DarkSun::get_xi_fo(model.data())));
	  fmt::print("rd eta={}\n", DarkSun::get_rd_eta(model.data()));
	  fmt::print("rd del={}\n", DarkSun::get_rd_del(model.data()));
	  fmt::print("xi cmb={}\n", DarkSun::get_xi_cmb(model.data()));
	  fmt::print("xi bbn={}\n", DarkSun::get_xi_bbn(model.data()));
	  fmt::print("dneff bbn={}\n", DarkSun::get_dneff_bbn(model.data()));
	  fmt::print("dneff cmb={}\n", DarkSun::get_dneff_cmb(model.data()));
	  fmt::print("eta si/meta={}\n", DarkSun::get_eta_si_per_mass(model.data()));
	  fmt::print("del si/mdel={}\n", DarkSun::get_del_si_per_mass(model.data()));
8c35213edbedb8effc72b068408733c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|43|1|V|cpp
	  timer.stop();
ef399b2d446bb37b7c32ad2cc1b6045b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|48|9|v|cpp
	stop
b0415db73113e529f5a1d8ebfc46478d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|43|1|V|cpp
	  timer.stop();
	  std::cout << timer.format() << "\n";
c1ab7baa935f42947cf8bca9d8357dad|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|45|3|V|cpp
	  std::cout << timer.format() << "\n";
32e57be4bdad23fa8ea5b77051c838c7|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|43|1|V|cpp
	  std::cout << timer.format() << "\n";
	  timer.stop();
6ef25661b63af50fada6d71e7bfb2b5c|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|39|1|V|cmake
	include_directories(${Boost_INCLUDE_DIRS})
75d4d5f40f93999f1b2378d78f0f5925|file:///Users/loganmorrison/Documents/git_hub/Haliax/lanre/test/CMakeLists.txt|35|1|V|cmake
	find_package(Boost REQUIRED)
efa11247d254bdef054870edae150fa9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|5|1|V|cpp
	#include <boost/timer/timer.hpp>
93546bee6e942d9fdd20de2ab8f2939a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|12|1|V|cpp
	  boost::timer::cpu_timer timer;
f29c42fca030f8d5cc68d4ce83a3ef2c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|13|1|V|cpp
	  auto start1 = std::chrono::high_resolution_clock::now();
368096b6864b055eebc12fb33ae636ae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|42|8|v|cpp
	start1
ebfb5110c011e38042f2f500b75933a6|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|44|16|v|cpp
	timer.format() << "\n";
f12083af766654e3cba4a158695778d1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|51|1|V|cpp
	  timer.resume();
f89b6bed96a3443ec9e37bdcc376e81b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|42|1|V|cpp
	  auto end1 = std::chrono::high_resolution_clock::now();
03239c122b1c4a315751e613da13b718|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|44|1|V|cpp
	  std::cout << std::chrono::duration_cast<std::chrono::nanoseconds>(end1 -
	                                                                    start1)
	                   .count()
	            << "\n";
092070dba8c01560ba67cdb9ae01ae46|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|44|56|v|cpp
	nanoseconds
c50c3b1ca82ba7b7ab55afdf66a2f6c9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|81|56|v|cpp
	milliseconds
841b50ca5a8a7b121faa3e21db32f4ef|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|11|1|V|cpp
	enum DarkSunIdx {
	  N,
	  Lam,
	  C,
	  Adel,
	  Lec1,
	  Lec2,
	  MuEta,
	  MuDel,
	  XiInf,
	  Dx,
	  Xout,
	  XiFo,
	  TsmFo,
	  XiCmb,
	  XiBbn,
	  RdEta,
	  RdDel,
	  DNeffCmb,
	  DNeffBbn,
	  EtaSiPerMass,
	  DelSiPerMass,
	};
e3a2dd461ae8757d5e1cab58fdba5144|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|28|1|V|cpp
	  // Static DarkSun instance
	  static DarkSun dsun;
b97b671952cfac255847fede6b58b702|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|29|1|V|cpp
	  // Get the instance
	  static DarkSun &get_instance() { return dsun; }
25915687b293cdfab26f2d096fc24081|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|25|3|V|cpp
	  ~DarkSun();
8d676679db5061bf5fcdf23a2f8bcf6e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|26|3|V|cpp
	  DarkSun(const DarkSun &) = delete;
742b9250743b0d622ff7114c81704627|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|28|1|V|cpp
	  // Generate a vector containing the parameters
	  static std::array<double, LEN> new_vec(size_t n, double lam) {
	    std::array<double, LEN> model;
	    model[N] = double(n);
	    model[Lam] = lam;
	    model[Adel] = 1.0;
	    model[C] = 1.0;
	    model[Lec1] = 0.1;
	    model[Lec2] = 0.1;
	    model[MuEta] = 1.0;
	    model[MuDel] = 1.0;
	    model[XiInf] = 1e-2;
	    // Set derived quantities to be negative => not set
	    model[XiFo] = -1.0;
	    model[TsmFo] = -1.0;
	    model[XiCmb] = -1.0;
	    model[XiBbn] = -1.0;
	    model[RdEta] = -1.0;
	    model[RdDel] = -1.0;
	    model[DNeffCmb] = -1.0;
	    model[DNeffBbn] = -1.0;
	    model[EtaSiPerMass] = -1.0;
	    model[DelSiPerMass] = -1.0;
	    return model;
	  }
658f95cd7a3b2b9ea5ed329155e759b9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|44|1|V|cpp
	  double eta_si_per_mass;
13a65968c08410806f130c30160d6645|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|49|1|V|cpp
	  //=========================================================================
	  //---- Getter functions ---------------------------------------------------
	  //=========================================================================
	
	  // Model Parameters
	
	  // N in SU(N)
	  static size_t get_n(const double *model) { return model[N]; }
	  // confinement scale
	  static double get_lam(const double *model) { return model[Lam]; }
	  // suppression factor for 2eta->2del
	  static double get_c(const double *model) { return model[C]; }
	  // suppression factor for initial delta abundance
	  static double get_adel(const double *model) { return model[Adel]; }
	  // low-energy constant for 4pt eta interactions
	  static double get_lec1(const double *model) { return model[Lec1]; }
	  // low-energy constant for 6pt eta interactions
	  static double get_lec2(const double *model) { return model[Lec2]; }
	  // prefactor of eta mass: mu_eta * lam / sqrt(n)
	  static double get_mu_eta(const double *model) { return model[MuEta]; }
	  // prefactor of del mass: mu_del * lam * n
	  static double get_mu_del(const double *model) { return model[MuDel]; }
	  // initial ratio of dark to SM temperatures
	  static double get_xi_inf(const double *model) { return model[XiInf]; }
	  // get the spacing between logx's in solutions
	  static double get_dx(const double *model) { return model[Dx]; }
	  // get the current value of logx
	  static double get_xout(const double *model) { return model[Xout]; }
	
	  // Derived quantities
	
	  // xi when eta freezes
	  static double get_xi_fo(const double *model) { return model[XiFo]; }
	  // SM temp when eta freezes
	  static double get_tsm_fo(const double *model) { return model[TsmFo]; }
	  // xi at CMB
	  static double get_xi_cmb(const double *model) { return model[XiCmb]; }
	  // xi at BBN
	  static double get_xi_bbn(const double *model) { return model[XiBbn]; }
	  // eta relic density
	  static double get_rd_eta(const double *model) { return model[RdEta]; }
	  // delta relic density
	  static double get_rd_del(const double *model) { return model[RdDel]; }
	  // delta Neff at CMB
	  static double get_dneff_cmb(const double *model) { return model[DNeffCmb]; }
	  // delta Neff at BBN
	  static double get_dneff_bbn(const double *model) { return model[DNeffBbn]; }
	  // eta SI cross section today
	  static double get_eta_si_per_mass(const double *model) {
	    return model[EtaSiPerMass];
	  }
	  // delta SI cross section today
	  static double get_del_si_per_mass(const double *model) {
	    return model[DelSiPerMass];
	  }
	  // solution to boltzmann equation
	  static auto get_sol_boltz(int i, const double *model)
	      -> std::array<double, 3> {
	    return {model[NUM_PARS + 3 * i + 0], model[NUM_PARS + 3 * i + 1],
	            model[NUM_PARS + 3 * i + 2]};
	  }
	
	  static auto get_sol_boltz(const double *model)
	      -> std::array<std::array<double, 3>, NUM_SOLS> {
	    std::array<std::array<double, 3>, NUM_SOLS> sol;
	    for (int i = 0; i < NUM_SOLS; i++) {
	      sol[i] = {model[NUM_PARS + 3 * i + 0], model[NUM_PARS + 3 * i + 1],
	                model[NUM_PARS + 3 * i + 2]};
	    }
	    return sol;
	  }
	
	  //=========================================================================
	  //---- Setter functions ---------------------------------------------------
	  //=========================================================================
	
	  // Model Parameters
	
	  // N in SU(N)
	  static void set_n(double *model, double val) { model[N] = val; }
	  // confinement scale
	  static void set_lam(double *model, double val) { model[Lam] = val; }
	  // suppression factor for 2eta->2del
	  static void set_c(double *model, double val) { model[C] = val; }
	  // suppression factor for initial delta abundance
	  static void set_adel(double *model, double val) { model[Adel] = val; }
	  // low-energy constant for 4pt eta interactions
	  static void set_lec1(double *model, double val) { model[Lec1] = val; }
	  // low-energy constant for 6pt eta interactions
	  static void set_lec2(double *model, double val) { model[Lec2] = val; }
	  // prefactor of eta mass: mu_eta * lam / sqrt(n)
	  static void set_mu_eta(double *model, double val) { model[MuEta] = val; }
	  // prefactor of del mass: mu_del * lam * n
	  static void set_mu_del(double *model, double val) { model[MuDel] = val; }
	  // initial ratio of dark to SM temperatures
	  static void set_xi_inf(double *model, double val) { model[XiInf] = val; }
	  // set the spacing between logx's in solutions
	  static void set_dx(double *model, double val) { model[Dx] = val; }
	  // set the current value of logx
	  static void set_xout(double *model, double val) { model[Xout] = val; }
	
	  // Derived quantities
	
	  // xi when eta freezes
	  static void set_xi_fo(double *model, double val) { model[XiFo] = val; }
	  // SM temp when eta freezes
	  static void set_tsm_fo(double *model, double val) { model[TsmFo] = val; }
	  // xi at CMB
	  static void set_xi_cmb(double *model, double val) { model[XiCmb] = val; }
	  // xi at BBN
	  static void set_xi_bbn(double *model, double val) { model[XiBbn] = val; }
	  // eta relic density
	  static void set_rd_eta(double *model, double val) { model[RdEta] = val; }
	  // delta relic density
	  static void set_rd_del(double *model, double val) { model[RdDel] = val; }
	  // delta Neff at CMB
	  static void set_dneff_cmb(double *model, double val) {
	    model[DNeffCmb] = val;
	  }
	  // delta Neff at BBN
	  static void set_dneff_bbn(double *model, double val) {
	    model[DNeffBbn] = val;
	  }
	  // eta SI cross section today
	  static void set_eta_si_per_mass(double *model, double val) {
	    model[EtaSiPerMass] = val;
	  }
	  // delta SI cross section today
	  static void set_del_si_per_mass(double *model, double val) {
	    model[DelSiPerMass] = val;
	  }
	  // solution to boltzmann equation
	  static void set_sol_boltz(int i, double logx, double eta, double del,
	                            double *model) {
	    model[NUM_PARS + 3 * i + 0] = logx;
	    model[NUM_PARS + 3 * i + 1] = eta;
	    model[NUM_PARS + 3 * i + 2] = del;
	  }
817b75587da7c58ca82365ec3546ff58|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|37|1|V|cpp
	  std::optional<double> xi_fo{};
	  std::optional<double> tsm_fo{};
	  std::optional<double> xi_cmb{};
	  std::optional<double> xi_bbn{};
	  std::optional<double> rd_eta{};
	  std::optional<double> rd_del{};
	  std::optional<double> dneff_cmb{};
	  std::optional<double> dneff_bbn{};
	  std::optional<double> eta_si_per_mass{};
	  std::optional<double> del_si_per_mass{};
97d9ffbf72030cc93be4c6d9f093bf7e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|51|14|v|cpp
	double *model
7ccd5c9cff2e939fab6aafb7eb050c53|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|70|12|v|cpp
	model[MuEta]
70e9477bf5551d39def64e542d181a37|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|70|21|v|cpp
	model[Lam]
4cfff480ea87be7a947ff42ffd4c63c4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|72|12|v|cpp
	model[MuDel]
21918e374f606861d79ca8472fc43ac2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|120|5|V|cpp
	    const double n = get_n(model);
4f528d459460a25304916a870cad6783|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|129|59|v|cpp
	,
	                                                       const double *model
f9f3258ddb4946721f64a5891073bbfc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|126|57|v|cpp
	,
	                                                      const double *model
ddca4bd9ae1325d3006b20351091eb6c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|141|3|V|cpp
	  static void solve_boltzmann2(double *model, double reltol, double abstol);
ee91504e1a79eeebee9e9862443a1a83|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|140|24|v|cpp
	double *model, 
babb7145569ee7b2557053021a38c4a4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|147|58|v|cpp
	, double *model,
2557172c9a5ce5d3a49c9ec507dbc537|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|150|22|v|cpp
	double *model, int *ipar
628182f63287480b9fc024b317a37e94|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|13|3|v|cpp
	static constexpr size_t NUM_PARS = 21;
	  static constexpr size_t NUM_SOLS = 100;
	  static constexpr size_t LEN_SOLS = 3 * NUM_SOLS;
	  static constexpr size_t LEN = LEN_SOLS + NUM_PARS;
cccd7fe8c7252039daf5ec82a62b21c0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|44|3|V|cpp
	  std::optional<std::
e5f3609eff0f4407b0c014f716234e26|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|52|19|v|cpp
	// Solution to Boltzmann equation
f0e77677c5249f852a2b4dff034a6cf2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|54|1|V|cpp
	  DarkSun(size_t n, double lam);
05c6aa9665b6906338fb1af42d7dc884|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|55|11|v|cpp
	(size_t n, double lam);
5d64ac29e8cdea357b2ebfaee97e751d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/init.cpp|27|1|V|cpp
	DarkSun DarkSun::dsun = DarkSun();
d7220073c51a7959e3f4ef94504cf04f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|31|5|V|cpp
	    auto &inst = DarkSun::get_instance();
183224d27b72b647391e179fa311b891|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|31|32|v|cpp
	inst
b45f93f7fb0c4bf7c8f1a94a1476495b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|213|39|v|cpp
	 const;
24458e9ed0ccc728487261c81581a861|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|141|3|V|cpp
	  const double mu = get_mu_eta(model);
e05e224fcc7b5ddbe7e17df631493218|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|156|41|v|cpp
	(model)
b9a3a607476021401b0188923cffbf22|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|184|63|v|cpp
	,
	                                                const double *model
11c6ab3d468a6651a5747b965a0dee2f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|236|1|V|cpp
	  const double c = get_c(model);
	  const double n = get_n(model);
	  const double lam = get_lam(model);
5b352f6bf18bcef1c46bcc0783ac9e3b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|39|58|v|cpp
	,
	                        const double *model
d3b2168fc5d593ebba39426fcce24403|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|12|5|v|cpp
	-> std::pair<double, double>
130b99f704d3146dee645e786416e552|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|23|5|V|cpp
	    -> std::pair<double, double> {
3c4ff8ffbf543dab28706f5f1d5949ec|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|64|14|v|cpp
	>= 0.0
08594ff182193f5078efc5aefba631aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|62|3|V|cpp
	  const double tsm_fo = get_tsm_fo(model);
236a4272bad7d338cdac40d17693bede|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|67|28|v|cpp
	get_xi_fo(model);
20f5ac3e5ff0b0cd8d2c8c2f600c9196|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/compute_xi.cpp|67|7|V|cpp
	      const double xifo = xi_fo.value();
589bfdd5d10efca32769a1fd03bb41ed|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|7|36|v|cpp
	onst double *model
97b427461a0285b60d2ef656fe1e32cd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|9|21|v|cpp
	get_xi_cmb(model);
40e12b210c5d017e4f71ffcc10463b2e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|10|25|v|cpp
	 >= 0.0
cc1e93169ae5b807512a7a5592088e3d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|20|21|v|cpp
	get_xi_bbn(model);
dd50249e6afb04d88debeb115f939435|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/dneff.cpp|21|7|v|cpp
	xi >= 0.0
4fa07c458a1cf0791329478838bc0ef1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|20|25|v|cpp
	double *model, int *
e43e6aab9d52f0a352f87bd444f14a68|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|31|27|v|cpp
	get_xi_fo(model) < 0.0
a10132ca505a9f653b34f020d1441698|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|32|5|v|cpp
	set_xi_fo(model, xi);
c20a7bf3406055410b82aa9004e11f4c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|33|5|v|cpp
	set_tsm_fo(model, tsm);
1f1a720650fec2992c91cad67cc4f455|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|62|38|v|cpp
	, double *model, int *
682051bbbd797109e03c8a5735904e35|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|111|3|V|cpp
	  double dx = get_dx(model);
39125b371b254e1fc6f0648b3f159263|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|111|3|V|cpp
	  double d = get_xout(model);
86bd1aacfc15ee1b86f498eef903ca7b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|112|3|V|cpp
	  int i = *ipar;
811c43b9785f80c0d3a4c2fc832cc2da|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|116|5|V|cpp
	    // int len = *ipar;
b829cdb0704957a07098844ca8aac7e1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|111|3|V|cpp
	  double yd[2];
1da1567c78c10dc3c6ad967ba87b04e0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|116|5|v|cpp
	yd[0] =
438ba4cecac386b689bbaa496279e113|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|56|3|v|cpp
	std::optional<
6833aca8bf8d447adf13f52222fe82fd|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|117|5|v|cpp
	yd[1] = 
d88ea4bce65260be7bf8ab510b804a55|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|122|3|V|cpp
	  *ipar = i;
e6a1c8c713bae0b5a290ca9f67f52d1e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|140|15|v|cpp
	get_lam()
2adf6054d82b6d029a52522348c339f1|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|151|18|v|cpp
	get_n(model)
1e27f15925f7cc20e4e659be5dead767|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|153|15|v|cpp
	get_adel(model)
d20eb887ae15bf2b45d66cf2797781e5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|186|3|v|cpp
	model[Dx]
4d235dd6783a00c1cffcffee6a1faf72|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|188|17|v|cpp
	model, &ipar
10b8ab5f55334d9d4c696e706d825567|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|189|38|v|cpp
	, model, &ipar
53209094cedd6532b12816d04270190b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|205|1|V|cpp
	  solution.y[NUM_SOLS-1][0] = y[0];
9b6153b91ef89033b8315f645c1ba920|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|207|1|V|cpp
	  // Save last state
	  set_sol_boltz(DarkSun::NUM_SOLS - 1, log_xfinal, y[0], y[1], model);
7a5fae61599ff060a367bed8ebea418a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|209|5|v|cpp
	set_
4c2cb5000b8350e6b466ffb149a19d2d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|209|11|v|cpp
	(model, 
d2e8f5c966fbde9db130af153164ea7a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/boltzmann.cpp|211|14|v|cpp
	model, 
082eae030e2d7cd3d6a9bf0cc1b56327|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|28|25|v|cpp
	::new_vec
e2ec8d1c37116c2ce825cc432c8a156e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|34|27|v|cpp
	model.data(), 
3246dce74587148293b6c83271d8405b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|46|12|v|cpp
	model[DarkSunIdx::N] << ",";
e6d0933397991610362bf611cc83aeae|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|47|12|v|cpp
	model[DarkSunIdx::Lam]
f864a41dc373a856acbb24ea60f1ffa8|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|48|12|v|cpp
	model[DarkSunIdx::C]
7f642d175d162e4b5fe1c8f1ec38762a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|49|12|v|cpp
	model[DarkSunIdx::Adel]
9502d074d44eb1e60560b68a15b35a5f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|50|12|v|cpp
	model[DarkSunIdx::Lec1]
02bc8a31b4d9d88682f9dce0a3250d42|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|51|12|v|cpp
	model[DarkSunIdx::Lec2]
717937bf79a6ec4c1ee9fa2eb3ed800b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|52|12|v|cpp
	model[DarkSunIdx::MuEta]
d891a4c61307d838f43c70d69aafaa27|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|53|12|v|cpp
	model[DarkSunIdx::MuDel]
b10f10583763c9dbefe54f4582a714e0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|54|12|v|cpp
	model[DarkSunIdx::XiInf]
c3db150744cc5c920b9e8d0aedeb7e57|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|56|12|v|cpp
	model[DarkSunIdx::XiFo]
6e11227a26f20ea80e44325cee228afc|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|57|12|v|cpp
	model[DarkSunIdx::TsmFo]
eb584c14e5c013758bf6ea8d67ac6536|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|58|12|v|cpp
	model[DarkSunIdx::XiCmb]
cc1b5440e69d2642c1a2fc9c503c1ad2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|59|12|v|cpp
	model[DarkSunIdx::XiBbn]
5c17c0dbaddf4b5ebf09a9ad03ec3d7b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|60|12|v|cpp
	model[DarkSunIdx::RdEta]
ab1ac5f93b77144609cc43b2eab3917a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|61|12|v|cpp
	model[DarkSunIdx::RdDel]
0e5f2a9d656843e8e870a18789e9390d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|62|12|v|cpp
	model[DarkSunIdx::DNeffCmb]
3f9bb2fdf4ae504532cadabb06c79532|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|63|12|v|cpp
	model[DarkSunIdx::DNeffBbn]
abcc2ae0bdc9074dc2ecabbc3113fde5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|64|12|v|cpp
	model[DarkSunIdx::EtaSiPerMass]
68d6db565473eb1264b1ee812ad00fd2|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/scan.cpp|65|12|v|cpp
	model[DarkSunIdx::DelSiPerMass]
009f02bac9954e78a5b652650a911019|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/adel_scan.cpp|35|10|v|cpp
	[DarkSunIdx::N]
3f0f2c122dcd02dc106ed087b9a9cdce|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/adel_scan.cpp|36|10|v|cpp
	[DarkSunIdx::Lam]
2f062b8f079e1dc98bccc30ff91a2d1d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/adel_scan.cpp|37|10|v|cpp
	[DarkSunIdx::Adel]
3ed28b9abb7dc37467e39a8e7d02a356|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|10|v|cpp
	[DarkSunIdx::C]
e5117790ed22965912f5a6352b441e9c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/c_scan.cpp|37|10|v|cpp
	 = c;
	
55e6633cc6bbe07a768815b2dc17be17|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/lec1_scan.cpp|37|10|v|cpp
	[DarkSunIdx::Lec1]
e5a62228ea8935186eb0aaa550724875|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/lec1_scan.cpp|55|5|V|cpp
	    auto f = [i](int counter, model) {
70d1b88b01f53e5111d3df98e649dca4|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/lec2_scan.cpp|37|10|v|cpp
	[DarkSunIdx::Lec2]
1fbf2427433ce77578846fafb3fac01c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/mu_del_scan.cpp|38|10|v|cpp
	[DarkSunIdx::MuDel]
7a906460a84b4fc61e00a42650ba8a57|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/mu_eta_scan.cpp|37|10|v|cpp
	vkSunIdx::Lam]
8b38aa868d909d1f7d7380b39a91cb05|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|39|10|v|cpp
	DarkSunIdx::Lam]
7a7d3fa7685ac7eb1a2efde9b40d5d03|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|39|10|v|cpp
	 = pow(10.0, LOG
9bd21e4efab817d1da99ce73480c3a9d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/apps/xi_inf_scan.cpp|40|10|v|cpp
	[DarkSunIdx::XiInf]
01945a075bfe2f277d84800775dfa01f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|10|16|v|cpp
	new_vec
607a7a46c481079f9502a7f2810ff68a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|12|48|v|cpp
	, model.data()
a7d566c1128a2ce41800deef1c91ed56|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|14|63|v|cpp
	model.data()
ea8eb27f475bc8c0894e404ea77db423|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|16|64|v|cpp
	()),
e8f8d0aeda20825f908cca25b8b7449b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|17|44|v|cpp
	model.data())
1457c92a9b3e58ae89374eb34ca62e4d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|38|3|V|cpp
	  model.set_adel(model.data(), 0.0);
0deb3ec3b5ea417dc7cfc5f36ffed28d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|40|3|V|cpp
	  auto sol = model.get_sol_boltz(model.data());
117863865eab96ba1818912740e1c785|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|41|8|v|cpp
	auto &val : sol
6563f89f68a7cd424c6a756dd6baf1f9|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|42|1|V|cpp
	    double x = model.solution.x[i];
c2a78e9cf4b94bb67bf4fccbce656a3c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_model.cpp|47|43|v|cpp
	(model.data())
f6cf815d1d470f524f2af1307f87eea3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|15|18|v|cpp
	model.new_vec
a186f5960baeedb0ead9be5814a6d558|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|16|5|v|cpp
	model.set_lec1(model.data(), 0.1);
2dd4c0c67eaa80509cc32f1f8feba32e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|17|5|v|cpp
	model.set_lec2(model.data(), 1.0);
2e232b9fffcaa11cfb5052c9e96594d3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|22|5|V|cpp
	    auto sol = model.get_sol_boltz(model.data());
a6052d5e7c07d696306c0181a80d80ee|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|24|1|V|cpp
	      double x = model.solution.x[i];
78fcad178ad808453199e437d1d9e323|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|27|37|v|cpp
	sol[i][0], sol[i][1], sol[i][2]);
2c5bc40fc86211f5347d06a92c688050|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|30|41|v|cpp
	(model.data()));
ad8fcc3df02902836712e91b1b867d8e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|32|1|V|cpp
	    fmt::print("xd fo={}\n",
	               model.m_eta() / (model.tsm_fo(model.data()) *
	                                            model.get_xi_fo(model.data())));
6748f1f3cc405c81959922a713e7595d|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|34|1|V|cpp
	    fmt::print("xi cmb={}\n", model.get_xi_cmb(model.data()));
	    fmt::print("xi bbn={}\n", model.get_xi_bbn(model.data()));
	    fmt::print("dneff bbn={}\n", model.get_dneff_bbn(model.data()));
	    fmt::print("dneff cmb={}\n", model.get_dneff_cmb(model.data()));
	    fmt::print("eta si/meta={}\n", model.get_eta_si_per_mass(model.data()));
	    fmt::print("del si/mdel={}\n", model.get_del_si_per_mass(model.data()));
efb11956bb1ea5aa01be646c7c16791c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|13|1|V|cpp
	  auto start1 = std::chrono::high_resolution_clock::now();
	  {
	    auto model = DarkSun(30, 2e-3);
	    model.lec1 = 0.1;
	    model.lec2 = 1.0;
	
	    model.solve_boltzmann(1e-7, 1e-7);
	
	    // Solve the model using c++ Radau
	
	    for (size_t i = 0; i < model.solution.x.size(); i++) {
	      double x = model.solution.x[i];
	      double we = model.solution.y[i][0];
	      double yd = model.solution.y[i][1];
	      fmt::print("[{}, {}, {}],\n", x, we, yd);
	    }
	
	    fmt::print("xi fo={}\n", model.xi_fo.value());
	    fmt::print("tsm fo={}\n", model.tsm_fo.value());
	    fmt::print("rd eta={}\n", model.rd_eta);
	    fmt::print("rd del={}\n", model.rd_del);
	  }
296b3b25dd71126c625440e2cb3fa1b0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/test/test_solve_boltzmann.cpp|42|1|V|cpp
	  std::cout << "\n\n\n\nVERSION 2";
	
	  auto start2 = std::chrono::high_resolution_clock::now();
	  {
	    auto model = model.new_vec(30, 2e-3);
	    model.set_lec1(model.data(), 0.1);
	    model.set_lec2(model.data(), 1.0);
	
	    model.solve_boltzmann2(model.data(), 1e-7, 1e-7);
	
	    // Solve the model using c++ Radau
	    auto sol = model.get_sol_boltz(model.data());
	
	    for (size_t i = 0; i < sol.size(); i++) {
	      fmt::print("[{}, {}, {}],\n", sol[i][0], sol[i][1], sol[i][2]);
	    }
	
	    fmt::print("xi fo={}\n", model.get_xi_fo(model.data()));
	    fmt::print("tsm fo={}\n", model.get_tsm_fo(model.data()));
	    fmt::print("xd fo={}\n",
	               model.m_eta(model.data()) / (model.get_tsm_fo(model.data()) *
	                                            model.get_xi_fo(model.data())));
	    fmt::print("rd eta={}\n", model.get_rd_eta(model.data()));
	    fmt::print("rd del={}\n", model.get_rd_del(model.data()));
	    fmt::print("xi cmb={}\n", model.get_xi_cmb(model.data()));
	    fmt::print("xi bbn={}\n", model.get_xi_bbn(model.data()));
	    fmt::print("dneff bbn={}\n", model.get_dneff_bbn(model.data()));
	    fmt::print("dneff cmb={}\n", model.get_dneff_cmb(model.data()));
	    fmt::print("eta si/meta={}\n", model.get_eta_si_per_mass(model.data()));
	    fmt::print("del si/mdel={}\n", model.get_del_si_per_mass(model.data()));
	  }
	  auto end2 = std::chrono::high_resolution_clock::now();
	  std::cout << std::chrono::duration_cast<std::chrono::microseconds>(end2 -
	                                                                     start2)
	                   .count()
	            << "\n";
5bbae7c32d2c8a7fe40947f37ee2e6c1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|11|9|v|cpp
	int *n, int *ndim, 
056aaf830eea5a7695e5205ab19a8980|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|11|51|v|cpp
	, int *ier
5cf4efb2f372fd8c000c6f432182d8d9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|43|1|V|cpp
	  --ip;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
b3d900c4643b4b7a10646a5e17d452f2|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|51|3|V|cpp
	  i__1 = nm1;
b814d8e4500f7af1e98009ed10c44904|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|54|5|V|cpp
	    i__2 = *n;
5e2f17fb3f08a92628aa1e40e443fadc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|55|23|v|cpp
	+ k * a_dim1
65c3a944cab9ef70178899f0a6b1d1c6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|56|25|v|cpp
	 * a_dim1]
6c514ab0eae0540651b2345dee6f899b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|62|15|v|cpp
	 + k * a_dim1]
1aa6f905c68281cfecbed9d270e80b5f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|76|14|v|cpp
	 * a_dim1] 
22ab0903f022ed6b5c848da9761a19e9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|80|13|v|cpp
	* a_dim1]
d1a90677ab965dfff60205abd9596489|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|85|7|V|cpp
	      i__3 = *n;
d727b72b1dea916bcbe45323098cb102|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|85|26|v|cpp
	i__3
4d5876cc4bd399a5b631b28f4018ff58|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|87|16|v|cpp
	 * a_dim1
0331302902980d22842550b7862be450|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|13|7|v|cpp
	a_dim1
f739c7e7b977c856452e4ebe0cbbbf68|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|13|7|v|cpp
	a_offset
59b5623cf4e89cf228d89a834afdf577|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|13|3|V|cpp
	  int 
2069a050984b80fb4905caa935cb3c34|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|131|3|V|cpp
	  --ip;
b587bb4ccdd44eea51e669a0f96ad56a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|131|3|V|cpp
	  --b;
25dd4003143f65aa937da63e091a387b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|131|1|V|cpp
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
fa8a8ea0719e9944b5a864d5806e75b3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|154|5|V|cpp
	    i__2 = km1;
e50f1c636c40171f9902b0546fc342ad|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|161|13|v|cpp
	a_dim1 + 1
8e005f737c70163011e78313a7f85586|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|162|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE SOL ------------------------- */
6e3d409c2edfd63f4ca0e35006cf3042|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|158|1|V|cpp
	    /* L40: */
00e91a164d69e126723662a29d0eeef5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|155|3|V|cpp
	      /* L30: */
b270797ba452e8d34bb9daae0546166d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|160|3|v|cpp
	/* sol_ */
b800eed9f32fa513cf823ebe0c7b14a9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|165|3|V|cpp
	  int a_dim1, a_offset, i__1, i__2, i__3;
b5946ea32666969a22f4b34730d40765|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|213|5|V|cpp
	    i__2 = na;
a821440ec9c52091a609914a68ccef1d|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|218|7|V|cpp
	      /* L10: */
a6cf66508d0fdb8cc64139de120dc603|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|244|7|V|cpp
	      i__3 = na;
3873360e56529e99cfaf61cbf64bb404|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|245|9|V|cpp
	        /* L40: */
93a2ce70dd8ae3975e279ae0a5a3efed|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|248|9|V|cpp
	        /* L50: */
3a01410d1a0752cdce90edee6e31ba49|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|249|5|V|cpp
	    /* L60: */
6ff3096d33032c9784d406cfc1b450d1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|259|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE DECH ------------------------ */
e81195e883309c3d28b331a63eb71366|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|259|3|v|cpp
	/* dech_ */
c1ff52b8f325559c03ab43f7e2593ce6|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|286|1|V|cpp
	  --ip;
	  --b;
	  a_dim1 = *ndim;
	  a_offset = 1 + a_dim1;
	  a -= a_offset;
7cf04fc5eac48f3aa868a6883ef66c9e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|305|5|V|cpp
	    /* L20: */
ef35ab1084ebdfc3f93b48e6a35c6438|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|319|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE SOLH ------------------------ */
b93a52ccf7caa63bdaca179569c54fd5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|319|3|v|cpp
	/* solh_ */
f685b768ec9a64a5fe07e8dfc635dc0e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|318|13|v|cpp
	a_dim1 
840724198f28b0366e88f20de6c7b841|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|324|7|v|cpp
	ar_dim1, ar_offset, ai_dim1, ai_offset, 
e21b653b3bbf8c4876da15d06a07cbd8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|359|19|V|cpp
	  /* Parameter adjustments */
	  --ip;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
08a912e555af732395c6538d487b1efc|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|371|27|v|cpp
	 * ar_dim1
7caa2a2e0ef218463ff73d6e8712f79f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|372|31|v|cpp
	 * ai_dim1
5478d8b78e9c6c5e24239f577357763c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|412|9|V|cpp
	        i__3 = *n;
f4947d396f562fa015dd3527e8937f50|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|426|19|v|cpp
	 * ar_dim1]
05333759b8d62a12e14a326212a32077|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|426|19|v|cpp
	 * ai_dim1]
7d9343791eb4f04dce5f94613295d22b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|436|9|V|cpp
	        /* L47: */
9043b657a7a62eac9ff8218646c1b678|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|452|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE DECC ------------------------ */
afa6ea68a74c77f581733bbdb640f823|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|452|3|v|cpp
	/* decc_ */
b95871185d0898dfa02f430db4a5b3f8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|325|3|V|cpp
	  int i__1, i__2, i__3;
d4815cc59af34bf7b1ed251ff072a8a9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|477|1|V|cpp
	  /* Parameter adjustments */
	  --ip;
	  --bi;
	  --br;
	  ai_dim1 = *ndim;
	  ai_offset = 1 + ai_dim1;
	  ai -= ai_offset;
	  ar_dim1 = *ndim;
	  ar_offset = 1 + ar_dim1;
	  ar -= ar_offset;
f51e55645d943d04d750c3912a411aa9|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|519|12|v|cpp
	ar_dim1 
62331ae79077082128aa5e7fcec2f143|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|519|33|v|cpp
	ai_dim1 + 1
2ac806f12123346d9f8fc9f3355578d3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|521|40|v|cpp
	ai_dim1 
2ac806f12123346d9f8fc9f3355578d3|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|521|40|v|cpp
	ai_dim1 
f360089295909c972eca5c98fd764e67|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|524|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE SOLC ------------------------ */
93a1cc937636bf329185134447834b1e|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|524|3|v|cpp
	/* solc_ */
f9484a9feea196de76ff44829a01a158|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|456|3|V|cpp
	  int i__1;
d5aef32abc826096f9b671982389e1c4|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|455|1|V|cpp
	  /* System generated locals */
5d586658d27e25482d34dd4e1c87accb|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|524|11|V|cpp
	          int *ier) {
8bc9d0b7f48029d691b014c00b4cd551|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|622|9|V|cpp
	        i__3 = na;
dab5800a85c0d569b83959f1b5da9c71|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|627|11|V|cpp
	          /* L40: */
e13a651bde7809bd22e4289b1c87baaa|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|636|11|V|cpp
	          /* L45: */
8780edf83035f55fad9a463d356dcaa5|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|658|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE DECHC ----------------------- */
391671772f3e988d68c8846735eab978|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|658|3|v|cpp
	/* dechc_ */
704f3270f28ee100d4039a58dc72aa62|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|13|1|V|cpp
	int dech(int *n, int *ndim, double *a, int *lb, int *ip, int *ier);
	
	int solh(int *n, int *ndim, double *a, int *lb, double *b, int *ip);
d255143b553fe87f610d94f442d6a1c3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|17|1|V|cpp
	
	int dechc(int *n, int *ndim, double *ar, double *ai, int *lb, int *ip,
	          int *ier);
	
	int solhc(int *n, int *ndim, double *ar, double *ai, int *lb, double *br,
	          double *bi, int *ip);
	
	int decb(int *n, int *ndim, double *a, int *ml, int *mu, int *ip, int *ier);
	
	int solb(int *n, int *ndim, double *a, int *ml, int *mu, double *b, int *ip);
	
	int decbc(int *n, int *ndim, double *ar, double *ai, int *ml, int *mu, int *ip,
	          int *ier);
	
	int solbc(int *n, int *ndim, double *ar, double *ai, int *ml, int *mu,
	          double *br, double *bi, int *ip);
	
	int elmhes(int *nm, int *n, int *low, int *igh, double *a, int *int__);
caabf032ca10b33ddd4a6f00deadebce|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/vector_matrix.hpp|8|1|V|cpp
	template <class Type, int n = Eigen::Dynamic>
	using Vector = Eigen::Matrix<Type, n, 1>;
	
	template <class Type, int n = Eigen::Dynamic, int m = Eigen::Dynamic>
	using Matrix = Eigen::Matrix<Type, n, m>;
e16b5fb4c041ae878bdffe1eb4d6e169|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|10|1|V|cpp
	template <int ndim, int n>
	int dec(Matrix<double, ndim, n> &a, Vector<int, n> &ip) {
8373cd5302fd2df0a00f792834dc07de|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|10|1|V|cpp
	int dec(double *a, int *ip, int *ier);
6908893d5e2e06321057c227b852dc71|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|106|1|V|cpp
	template <int ndim, int n>
	void sol(const Matrix<double, ndim, n> &a, Vector<double> &b,
	         const Vector<int> &ip) {
2ded07154556cd889eef936fc5811405|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|13|1|V|cpp
	int sol(double *a, double *b, int *ip);
c3efa85b64ec47146460093fcc35a15f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|10|1|V|cpp
	template <int ndim, int n>
	int dec(Matrix<double, ndim, n> &a, Vector<int, n> &ip) {
	  /* System generated locals */
	  double d__1, d__2;
	
	  /* Local variables */
	  int i, j, k, m;
	  double t;
	  int nm1, kp1, ier;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION. */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*     A = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U . */
	  /*     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N). */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	
	  /* Function Body */
	  ier = 0;
	  ip[n] = 1;
	  if (n == 1) {
	    goto L70;
	  }
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= n; ++i) {
	      if ((d__1 = a(i, k), abs(d__1)) > (d__2 = a(m, k), abs(d__2))) {
	        m = i;
	      }
	      /* L10: */
	    }
	    ip[k] = m;
	    t = a(m, k);
	    if (m == k) {
	      goto L20;
	    }
	    ip[n] = -ip[n];
	    a(m, k) = a(k, k);
	    a(k, k) = t;
	  L20:
	    if (t == 0.) {
	      goto L80;
	    }
	    t = 1.0 / t;
	    for (i = kp1; i <= n; ++i) {
	      /* L30: */
	      a(i, k) = -a(i, k) * t;
	    }
	    for (j = kp1; j <= n; ++j) {
	      t = a(m, j);
	      a(m, j) = a(k, j);
	      a(k, j) = t;
	      if (t == 0.) {
	        goto L45;
	      }
	      for (i = kp1; i <= n; ++i) {
	        /* L40: */
	        a(i, j) += a(i, k) * t;
	      }
	    L45:
	        /* L50: */
	        ;
	    }
	    /* L60: */
	  }
	L70:
	  k = n;
	  if (a(n, n) == 0.0) {
	    goto L80;
	  }
	  return ier;
	L80:
	  ier = k;
	  ip[n] = 0;
	  return ier;
	  /* ----------------------- END OF SUBROUTINE DEC ------------------------- */
	} /* dec_ */
	
	template <int ndim, int n>
	void sol(const Matrix<double, ndim, n> &a, Vector<double> &b,
	         const Vector<int> &ip) {
	  /* System generated locals */
	  int a_dim1, a_offset, i__1, i__2;
	
	  /* Local variables */
	  int i, k, m;
	  double t;
	  int kb, km1, nm1, kp1;
	
	  /* VERSION REAL DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAY  A . */
	  /*    A = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    B = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    B = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	  /* Parameter adjustments */
	
	  /* Function Body */
	  if (n == 1) {
	    goto L50;
	  }
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    t = b[m];
	    b[m] = b[k];
	    b[k] = t;
	    for (i = kp1; i <= n; ++i) {
	      /* L10: */
	      b[i] += a[i, k] * t;
	    }
	    /* L20: */
	  }
	  for (kb = 1; kb <= nm1; ++kb) {
	    km1 = n - kb;
	    k = km1 + 1;
	    b[k] /= a[k, k];
	    t = -b[k];
	    for (i = 1; i <= km1; ++i) {
	      b[i] += a[i, k] * t;
	    }
	  }
	L50:
	  b[1] /= a[1, 1];
	}
fe6f27ecb3bf264536f403f2d524afa5|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|10|1|V|cpp
	template <int ndim, int n>
	int dec(Matrix<double, ndim, n> &a, Vector<int, n> &ip);
	
	template <int ndim, int n>
	void sol(const Matrix<double, ndim, n> &a, Vector<double> &b,
	         const Vector<int> &ip) {
b4130709ab5aeeb5389cc684b152659f|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|321|1|V|cpp
	template <int ndim, int n>
	int decc(Matrix<double, ndim, n> &ar, Matrix<double, ndim, n> &ai,
	         Vector<int, n> &ip) {
	  /* System generated locals */
	  double d__1, d__2, d__3, d__4;
	
	  /* Local variables */
	  int i, j, k, m;
	  double ti, tr;
	  int nm1, kp1, ier;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION */
	  /*  ------ MODIFICATION FOR COMPLEX MATRICES -------- */
	  /*  INPUT.. */
	  /*     N = ORDER OF MATRIX. */
	  /*     NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI . */
	  /*     (AR, AI) = MATRIX TO BE TRIANGULARIZED. */
	  /*  OUTPUT.. */
	  /*     AR(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; REAL PART. */
	  /*     AI(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U ; IMAGINARY PART. */
	  /*     AR(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    REAL PART. */
	  /*     AI(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L. */
	  /*                                                    IMAGINARY PART. */
	  /*     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW. */
	  /*     IP(N) = (-1)**(NUMBER OF INTERCHANGES) OR O . */
	  /*     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE */
	  /*           SINGULAR AT STAGE K. */
	  /*  USE  SOL  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
	  /*  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO. */
	
	  /*  REFERENCE.. */
	  /*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
	  /*     C.A.C.M. 15 (1972), P. 274. */
	  /* ----------------------------------------------------------------------- */
	
	  /* Function Body */
	  ier = 0;
	  ip[n] = 1;
	  if (n == 1) {
	    goto L70;
	  }
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; ++k) {
	    kp1 = k + 1;
	    m = k;
	    for (i = kp1; i <= n; ++i) {
	      if ((d__1 = ar[i, k], abs(d__1)) + (d__2 = ai[i, k], abs(d__2)) >
	          (d__3 = ar[m, k], abs(d__3)) + (d__4 = ai[m, k], abs(d__4))) {
	        m = i;
	      }
	    }
	    ip[k] = m;
	    tr = ar[m, k];
	    ti = ai[m, k];
	    if (m == k) {
	      goto L20;
	    }
	    ip[n] = -ip[n];
	    ar[m, k] = ar[k, k];
	    ai[m, k] = ai[k, k];
	    ar[k, k] = tr;
	    ai[k, k] = ti;
	  L20:
	    if (abs(tr) + abs(ti) == 0.) {
	      goto L80;
	    }
	    den = tr * tr + ti * ti;
	    tr /= den;
	    ti = -ti / den;
	    for (i = kp1; i <= n; ++i) {
	      prodr = ar[i, k] * tr - ai[i, k] * ti;
	      prodi = ai[i, k] * tr + ar[i, k] * ti;
	      ar[i, k] = -prodr;
	      ai[i, k] = -prodi;
	    }
	    for (j = kp1; j <= n; ++j) {
	      tr = ar[m, j];
	      ti = ai[m, j];
	      ar[m, j] = ar[k, j];
	      ai[m, j] = ai[k, j];
	      ar[k, j] = tr;
	      ai[k, j] = ti;
	      if (abs(tr) + abs(ti) == 0.0) {
	        goto L48;
	      }
	      if (ti == 0.0) {
	        for (i = kp1; i <= n; ++i) {
	          prodr = ar[i, k] * tr;
	          prodi = ai[i, k] * tr;
	          ar[i, j] += prodr;
	          ai[i, j] += prodi;
	          /* L40: */
	        }
	        goto L48;
	      }
	      if (tr == 0.) {
	        for (i = kp1; i <= n; ++i) {
	          prodr = -ai[i, k] * ti;
	          prodi = ar[i, k] * ti;
	          ar[i, j] += prodr;
	          ai[i, j] += prodi;
	          /* L45: */
	        }
	        goto L48;
	      }
	      for (i = kp1; i <= n; ++i) {
	        prodr = ar[i, k] * tr - ai[i, k] * ti;
	        prodi = ai[i, k] * tr + ar[i, k] * ti;
	        ar[i, j] += prodr;
	        ai[i, j] += prodi;
	      }
	    L48:;
	    }
	  }
	L70:
	  k = n;
	  if ((d__1 = ar[n, n], abs(d__1)) + (d__2 = ai[n, n], abs(d__2)) == 0.0) {
	    goto L80;
	  }
	  return ier;
	L80:
	  ier = k;
	  ip[n] = 0;
	  return ier;
	}
	
	template <int ndim, int n>
	void solc(const Matrix<double, ndim, n> &ar, const Matrix<double, ndim, n> &ai,
	          Vector<double, n> &br, Vector<double, n> &bi,
	          const Vector<int, n> &ip) {
	
	  /* Local variables */
	  int i, k, m, kb;
	  double ti, tr;
	  int km1, nm1, kp1;
	  double den, prodi, prodr;
	
	  /* VERSION COMPLEX DOUBLE PRECISION */
	  /* ----------------------------------------------------------------------- */
	  /*  SOLUTION OF LINEAR SYSTEM, A*X = B . */
	  /*  INPUT.. */
	  /*    N = ORDER OF MATRIX. */
	  /*    NDIM = DECLARED DIMENSION OF ARRAYS  AR AND AI. */
	  /*    (AR,AI) = TRIANGULARIZED MATRIX OBTAINED FROM DEC. */
	  /*    (BR,BI) = RIGHT HAND SIDE VECTOR. */
	  /*    IP = PIVOT VECTOR OBTAINED FROM DEC. */
	  /*  DO NOT USE IF DEC HAS SET IER .NE. 0. */
	  /*  OUTPUT.. */
	  /*    (BR,BI) = SOLUTION VECTOR, X . */
	  /* ----------------------------------------------------------------------- */
	
	  /* Function Body */
	  if (n == 1) {
	    goto L50;
	  }
	  nm1 = n - 1;
	  for (k = 1; k <= nm1; ++k) {
	    kp1 = k + 1;
	    m = ip[k];
	    tr = br[m];
	    ti = bi[m];
	    br[m] = br[k];
	    bi[m] = bi[k];
	    br[k] = tr;
	    bi[k] = ti;
	    for (i = kp1; i <= n; ++i) {
	      prodr = ar[i, k] * tr - ai[i, k] * ti;
	      prodi = ai[i, k] * tr + ar[i, k] * ti;
	      br[i] += prodr;
	      bi[i] += prodi;
	    }
	  }
	  for (kb = 1; kb <= nm1; ++kb) {
	    km1 = n - kb;
	    k = km1 + 1;
	    den = ar[k, k] * ar[k, k] + ai[k, k] * ai[k, k];
	    prodr = br[k] * ar[k, k] + bi[k] * ai[k, k];
	    prodi = bi[k] * ar[k, k] - br[k] * ai[k, k];
	    br[k] = prodr / den;
	    bi[k] = prodi / den;
	    tr = -br[k];
	    ti = -bi[k];
	    for (i = 1; i <= km1; ++i) {
	      prodr = ar[i, k] * tr - ai[i, k] * ti;
	      prodi = ai[i, k] * tr + ar[i, k] * ti;
	      br[i] += prodr;
	      bi[i] += prodi;
	    }
	  }
	L50:
	  den = ar[1, 1] * ar[1, 1] + ai[1, 1] * ai[1, 1];
	  prodr = br[1] * ar[1, 1] + bi[1] * ai[1, 1];
	  prodi = bi[1] * ar[1, 1] - br[1] * ai[1, 1];
	  br[1] = prodr / den;
	  bi[1] = prodi / den;
	}
7d83a4ca591acac3f573415933a6f45b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|162|1|V|cpp
	int decc(double *ar, double *ai, int *ip, int *ier);
	
	int solc(double *ar, double *ai, double *br, double *bi, int *ip);
830f25a6d44d03bd37fdda0485a1478c|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|752|54|v|cpp
	Vector<int,n>&
1c4ec8232daa94869f478fc8f5e5fe17|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|990|11|v|cpp
	int *ier
4f150e0f901b91844f632dda552be578|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1194|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE DECBC ------------------------ */
00ddc5349a4aed51768917b1c71f24e1|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|1194|3|v|cpp
	/* decbc_ */
29d5f8ce9fdcb63639af3ace186cb003|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|736|12|v|cpp
	ar_dim1 + 1
dea3e1b3549b76991ed30a2dd649c406|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|736|33|v|cpp
	i_dim1 
afb8b71bce47a2bc3846d7159dc2e197|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|738|40|v|cpp
	ai_dim1 + 
afb8b71bce47a2bc3846d7159dc2e197|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|738|40|v|cpp
	ai_dim1 + 
d708cc631db83e0ccfa8944e9ed1bb95|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|742|3|V|cpp
	  /* ----------------------- END OF SUBROUTINE SOLHC ----------------------- */
8f7c0446951cd7168884978e994d8df8|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|742|3|v|cpp
	/* solhc_ */
64fafe1fbda20ed1f0c97376818bd33a|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|747|7|v|cpp
	a_dim1, a_offset, 
3428b6304155566d3ded7fcf99282a27|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|799|3|V|cpp
	  i__1 = *n;
e16cac825233a70e7e2bb6680ec58709|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|800|5|V|cpp
	    i__2 = ml;
1c6853e9d9c4dcd9bae3298d5281ab6b|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/include/stiff/decsol.hpp|801|7|V|cpp
	      /* L5: */
b7ef3c66437a5881e467d68924be68ba|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/stiff/decsol.hpp|7|11|v|cpp
	stiff 
a2146051838e4fee887b7373af0c67cf|file:///Users/loganmorrison/Documents/coding/cpp/Libraries/stiff/CMakeLists.txt|10|1|V|cmake
	# configure optimization
	if (CMAKE_BUILD_TYPE STREQUAL "Debug")
	    set(OPTIMIZATION_FLAGS "-O0 -DDEBUG")
	    message("-- Configuring debug build")
	else()
	    set(OPTIMIZATION_FLAGS "-O3 -DNDEBUG")
	    message("-- Configuring release build")
	endif()
f16a6db621aa6653b012b42c6c449639|file:///Users/loganmorrison/Documents/research/DarkSun/code/CMakeLists.txt|16|1|V|cmake
	# configure optimization
	if (CMAKE_BUILD_TYPE STREQUAL "Debug")
	    set(OPTIMIZATION_FLAGS "-O0 -DDEBUG -fsanitize=memory -fsanitize-memory-track-origins -fPIE -pie -fno-omit-frame-pointer")
	    message("-- Configuring debug build")
	else()
	    set(OPTIMIZATION_FLAGS "-O3 -DNDEBUG")
	    message("-- Configuring release build")
	endif()
9cc5d37e04dd8026c137bc74ae2aa063|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|5|1|V|cmake
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
460917f6279956b1caf2ff4a202efde0|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|9|9|v|cmake
	OPTIMIZATION_FLAGS
f43fe477e08f326aca52e84dc72bcf70|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|9|1|V|cmake
	    set(CMAKE_CXX_FLAGS "-O0 -DDEBUG -fsanitize=memory -fsanitize-memory-track-origins -fPIE -pie -fno-omit-frame-pointer")
dd1a15f0725d73ca9c5cc1c3d5be446b|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|11|1|V|cmake
	else()
	    set(OPTIMIZATION_FLAGS "-O3 -DNDEBUG")
	    message("-- Configuring release build")
ab968073517daff00bdb7f5e354a55da|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|9|38|v|cmake
	-fsanitize=memory
bb803296928301702793cdb636697a6c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|9|33|v|cmake
	-DDEBUG
e802a17de50747b153d980632b608088|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/CMakeLists.txt|7|1|V|cmake
	# configure optimization
	if (CMAKE_BUILD_TYPE STREQUAL "Debug")
	    set(CMAKE_CXX_FLAGS "-fsanitize=memory -g -O2  -fsanitize-memory-track-origins -fPIE -pie -fno-omit-frame-pointer")
	    message("-- Configuring debug build")
	endif()
af6ea9200bdbed22e233094520bb658e|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|35|10|v|cpp
	(0.11549230036519878 * g * m * m * xi *
	          gsl_sf_bessel_Kn(2, m / (tsm * xi))) /
	         (tsm * tsm * StandardModel::heff(tsm))
cfd1c9ee4424bdc5ff24bfe8c989b9be|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|55|1|V|cpp
	  return -x + log((0.11549230036519878 * g * m * m * xi *
	                   gsl_sf_bessel_Kn_scaled(2, x)) /
	                  (tsm * tsm * StandardModel::heff(tsm)));
d4224d93eacc9dea936b58b35385113a|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|76|1|V|cpp
	  const double xe = m_eta(model) / td;
	  const double xd = m_del(model) / td;
	  const double g = g_del(model);
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  return pre * (pow<3>(xe) * gsl_sf_bessel_Kn(3, xe) +
	                g * pow<3>(xd) * gsl_sf_bessel_Kn(3, xd));
866b0dd171950748f87f8278d755af12|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|86|1|V|cpp
	  const double xe = m_eta(model) / td;
	  const double xd = m_del(model) / td;
	  const double g = g_del(model);
	  const double pre = 45.0 / (4.0 * pow<4>(M_PI));
	  const double geffe =
	      pow<2>(xe) * (xe * gsl_sf_bessel_K1(xe) + 3.0 * gsl_sf_bessel_Kn(2, xe));
	  const double geffd =
	      g * pow<2>(xd) *
	      (xe * gsl_sf_bessel_K1(xd) + 3.0 * gsl_sf_bessel_Kn(2, xd));
	  return pre * (geffe + geffd);
2642beef2d51e478b5f95877d87b786f|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/thermal_functions.cpp|100|1|V|cpp
	  double gd = dark_geff(tsm * xi, model);
	  double gsm = StandardModel::geff(tsm);
	  return StandardModel::sqrt_gstar(tsm) *
	         sqrt(gsm / (gsm + gd * xi * xi * xi * xi));
aac0fa15f9f112e0b5ba939b64a8f7aa|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/include/darksun/model.hpp|383|1|V|cpp
	  static constexpr double eta_cs_intercept44 = -9.744896762121916;
	  static constexpr double eta_cs_intercept66 = -10.667768576761643;
	  static constexpr double eta_cs_intercept46 = -10.206870194730394;
396476198ee9ac55483e8571e3a566e3|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|116|1|V|cpp
	  const double mu_eta = get_mu_eta(model);
	  const double lam = get_lam(model);
	  const double lec1 = get_lec1(model);
	  const double lec2 = get_lec2(model);
	  const double n = get_n(model);
	
	  // Common prefactors. Constant is (256 pi^4 / 3)^2
	  const double com =
	      6.9093374296577904e7 * pow<14>(mu_eta) / pow<2>(lam) / pow<11>(n);
	  // Coefficients of the A4*A4, A6*A6 and A4*A6 terms
	  const double c44 = com * pow<4>(lec1) / 9.0;
	  const double c66 = com * pow<2>(lec2) / 25.0;
	  const double c46 = -2.0 * com * pow<2>(lec1) * lec2 / 15.0;
	  // Scaled center-of-mass energy
	  const double z = cme / m_eta(model);
	
	  return c44 * scaled_cs_eta_24_44(z) + c66 * scaled_cs_eta_24_66(z) +
	         c46 * scaled_cs_eta_24_46(z);
525caab900691bdfc5d44706e01eda35|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|149|1|V|cpp
	  const double mu = get_mu_eta(model);
	  const double lam = get_lam(model);
	  const double lec1 = get_lec1(model);
	  const double n = get_n(model);
	
	  return 62.012553360599640 * pow<6>(mu) * lec1 * lec1 /
	         (pow<2>(lam) * pow<5>(n));
1ee2616d8b957882ced7dff7564d585c|file:///Users/loganmorrison/Documents/research/DarkSun/code/darksun/src/model/cross_section.cpp|169|1|V|cpp
	  return 4.0 * pow<3>(M_PI) / pow<2>(get_lam(model));
